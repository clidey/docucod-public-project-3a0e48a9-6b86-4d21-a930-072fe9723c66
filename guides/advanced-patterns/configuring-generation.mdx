---
title: "Customizing Generation with genconfig.Config"
description: "Guide to using configuration files and options to tailor code generation: set output paths, control which models/interfaces generate helpers, and map custom field types for advanced domain needs."
---

# Customizing Generation with genconfig.Config

This guide explains how to use the `genconfig.Config` struct to customize and tailor the GORM CLI code generation process through configuration files and options. You will learn how to override output directories, control which models and interfaces generate helpers, and map custom field types to specialized helpers—empowering you to handle advanced domain-specific needs with precision.

---

## Workflow Overview

**Task Description:**
Customize the behavior of GORM CLI’s code generation by defining a package-level configuration using `genconfig.Config`. This allows you to set output paths, filter structures and interfaces, and specify custom field mappings to enhance or alter generated code.

**Prerequisites:**
- A Go package containing your model structs and query interfaces.
- GORM CLI installed and initialized in your environment.
- Basic knowledge of defining Go types and interfaces used in GORM CLI.

**Expected Outcome:**
A configuration file that automatically directs the GORM CLI generator to:
- Output generated files to a custom directory.
- Include or exclude specific interfaces and structs.
- Map specific Go types or struct field tags to custom or enhanced field helpers.

**Time Estimate:** 10–20 minutes

**Difficulty Level:** Intermediate

---

## Step-by-Step Instructions

### 1. Declare a `genconfig.Config` variable in your package

Create or update a Go source file in the same package as your models and interfaces. Declare a package-level variable using `genconfig.Config` to specify your generation customizations.

```go
package examples

import (
    "database/sql"
    "gorm.io/cli/gorm/field"
    "gorm.io/cli/gorm/genconfig"
)

var _ = genconfig.Config{
    // Override the default output directory for generated files in this package
    OutPath: "examples/output",

    // Map Go types to the corresponding field helper types
    FieldTypeMap: map[any]any{
        sql.NullTime{}: field.Time{},
    },

    // Map struct field `gen:"tag"` names to custom field helpers
    FieldNameMap: map[string]any{
        "json": JSON{},  // e.g., map `json` tagged fields to a JSON helper
    },

    // Control generation to apply only to this file (optional)
    FileLevel: false,

    // Whitelist interfaces and structs for generation
    IncludeInterfaces: []any{"Query*", models.Query(nil)},
    ExcludeInterfaces: []any{"*Deprecated*"},

    IncludeStructs: []any{"User", "Account*", models.User{}},
    ExcludeStructs: []any{"*DTO"},
}
```

---

### 2. Customize the Output Path

Set the `OutPath` field in your config to specify the directory where generated code should be placed for this package. This overrides the CLI `-o` flag for the corresponding files.

```go
OutPath: "my/custom/generated",
```

When running `gorm gen`, generated files from this package will appear under `my/custom/generated` instead of the default `./g`.

---

### 3. Map Go Types to Custom Field Helpers

Use `FieldTypeMap` to map Go types or database drivers' types to GORM CLI field helpers, allowing you to extend or customize generated helpers.

Example: Map `sql.NullTime` to the `field.Time` helper:

```go
FieldTypeMap: map[any]any{
    sql.NullTime{}: field.Time{},
},
```

This instructs the generator to treat `sql.NullTime` fields as `field.Time` in generated field helpers, enabling better predicate and setter generation.

---

### 4. Map Struct Field Tags to Helpers with `FieldNameMap`

You can customize fields based on struct tags using `FieldNameMap`. For example, to handle JSON fields specially:

```go
FieldNameMap: map[string]any{
    "json": JSON{},  // Custom JSON field helper
},
```

Model example:

```go
type User struct {
    Profile string `gen:"json"` // Will use custom JSON helper
}
```

You must also implement the custom helper (like `JSON{}`) in your codebase.

---

### 5. Include or Exclude Specific Interfaces and Structs

Refine which interfaces and structs get generated using whitelist (`IncludeInterfaces`, `IncludeStructs`) and blacklist (`ExcludeInterfaces`, `ExcludeStructs`) patterns.

- Use shell-style wildcard patterns (e.g., "Query*", "*DTO").
- Use type literals, e.g., `models.User{}`
- Use interface type conversion syntax, e.g., `models.Query(nil)`

Example:

```go
IncludeInterfaces: []any{"Query*", models.Query(nil)},
ExcludeInterfaces: []any{"*Deprecated*"},

IncludeStructs: []any{"User", "Account*", models.User{}},
ExcludeStructs: []any{"*DTO"},
```

Filtering is applied in priority order: includes first, then excludes.

---

### 6. File-Level Configuration

Set `FileLevel: true` to apply the configuration only to the single file where it’s declared, instead of the whole package. This is useful for granular control when a package contains multiple distinct concerns.

```go
FileLevel: true,
```

---

## Practical Tips and Best Practices

- **Position the config in the same package** as your models/intended generation targets to ensure automatic detection.
- **Use precise filters** to limit generation scope and reduce build times.
- **Validate your mappings** by generating sample code and inspecting if the correct helpers are used.
- **Implement any custom helpers** (like `JSON`) carefully, providing methods needed for SQL expression composition.
- **Combine config with CLI flags (like `-o`) judiciously**; per-package config overrides CLI flags for those packages.

---

## Example: JSON Custom Field Mapping

1. Define configuration:

```go
package examples

import "gorm.io/cli/gorm/genconfig"

var _ = genconfig.Config{
    OutPath: "examples/output",
    FieldNameMap: map[string]any{
        "json": JSON{},
    },
}
```

2. Tag your struct fields:

```go
package models

type User struct {
    Profile string `gen:"json"`
}
```

3. Implement the JSON helper type (simplified example):

```go
type JSON struct{ column clause.Column }

func (j JSON) Equal(path string, value any) clause.Expression {
    // Implementation for database-specific JSON equal predicate
}
```

4. Use it:

```go
res, err := gorm.G[User](db).
    Where(generated.User.Profile.Equal("$.vip", true)).Take(ctx)
```

---

## Troubleshooting

- **Config not applied?**
  - Ensure the `genconfig.Config` variable is in the same Go package as your models/interfaces.
  - Verify that the Go file is included in the code generation input path.

- **Mappings not effective?**
  - Check that types used as keys in `FieldTypeMap` match your actual field types exactly.
  - Confirm that struct tags used with `FieldNameMap` are spelled and cased correctly.

- **Unexpected files generated?**
  - Review your include/exclude filters for inadvertent matches or omissions.
  - Try temporarily simplifying filters to isolate the issue.

---

## Next Steps & Related Content

- After customizing generation with `genconfig.Config`, proceed to:
  - [Running the Generator](https://gorm.io/cli/gorm/getting-started/your-first-generation/running-the-generator) to generate code incorporating your config.
  - [Using Generated APIs](https://gorm.io/cli/gorm/guides/core-workflows/using-generated-apis) to start leveraging generated code.
  - [Writing Models and Interfaces](https://gorm.io/cli/gorm/getting-started/your-first-generation/writing-models-interfaces) if you want to refine input types.
  - [Template-Based SQL Queries](https://gorm.io/cli/gorm/guides/advanced-patterns/template-based-sql) for advanced query scenarios.

- Explore advanced configuration use cases and troubleshooting in:
  - [Basic Configuration Guide](https://gorm.io/cli/gorm/getting-started/configuration-and-troubleshooting/basic-configuration)
  - [Configuration & Extensibility Overview](https://gorm.io/cli/gorm/overview/features-and-workflows/configuring-generation)

---

## Summary

By mastering `genconfig.Config`, you unlock powerful customization hooks for GORM CLI’s static code generation. This enables seamless alignment of generated code with your project structure, domain-specific field behavior, and selective generation strategies—streamlining your development workflow and enhancing maintainability.

---

## Additional Resources

- See the [example configuration files](https://github.com/go-gorm/cli/tree/main/examples) in the official repository for real-world use cases.
- Reference the [type-safe API generation readme](https://github.com/go-gorm/cli#usage) for broader context and examples.

---

_Take control of your GORM CLI generation with `genconfig.Config`, and tailor your data access layer to fit your exact needs._

---