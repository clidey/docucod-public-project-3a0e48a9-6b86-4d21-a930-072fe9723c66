---
title: "Customizing Code Generation & Field Mapping"
description: "Practical strategies for tailoring the code generator using `genconfig.Config`, custom field types, per-field helper mapping, and advanced whitelist/blacklist controls. Includes a real-world JSON field helper extension example."
---

# Customizing Code Generation & Field Mapping

This guide empowers you to tailor GORM CLI's code generation to your project’s unique needs using the `genconfig.Config` configuration. You'll learn how to override output paths, map custom Go field types to specialized helpers, control code inclusion via whitelist/blacklist settings, and extend generation with real-world examples such as JSON field helpers.

---

## 1. Overview

GORM CLI offers built-in defaults for generating type-safe query APIs and field helpers, but projects often require fine-tuning to align generated code with custom model types, folder structures, or selective interface/struct processing. This page shows you how to customize these aspects efficiently using a package-level configuration.

### What You'll Achieve

- Customize output code location per package or file
- Map Go types and struct tags to specific field helper types
- Enable precise control over which interfaces and structs are generated
- Understand file-level versus package-level applicability
- Extend GORM CLI with your own custom field helpers, demonstrated by a JSON example

### Prerequisites

- Basic experience defining Go interfaces and model structs for GORM CLI
- Familiarity with the CLI generation workflow, including running `gorm gen`
- Understanding of model-driven field helpers and query API concepts (see related guides)

### Time Estimate

~15-30 minutes to apply basic customizations

### Difficulty Level

Intermediate - requires knowledge of Go type system and some configuration concepts

---

## 2. Getting Started with `genconfig.Config`

You customize code generation by declaring a `genconfig.Config` variable at the package level in the package where your interfaces and models reside. This optional configuration is automatically picked up by the GORM CLI generator when processing that package.

### Basic Configuration Example

```go
package examples

import (
    "database/sql"
    "gorm.io/cli/gorm/field"
    "gorm.io/cli/gorm/genconfig"
)

var _ = genconfig.Config{
    OutPath: "examples/output",
    FieldTypeMap: map[any]any{
        sql.NullTime{}: field.Time{},
    },
    FieldNameMap: map[string]any{
        "date": field.Time{},
        "json": JSON{},  // Custom field helper example
    },
    IncludeInterfaces: []any{},
}
```

This config snippet:

- Changes the generation output folder to `examples/output`
- Maps the `sql.NullTime` Go type to a `field.Time` helper
- Maps any struct field tagged with `gen:"json"` to a `JSON` custom helper
- Sets up an empty whitelist for interfaces (meaning all interfaces are included by default)

---

## 3. Configuration Fields Explained

### OutPath

- Specifies the directory where generated files will be written for this package or file
- Overrides the CLI `-o` output path when set

### FieldTypeMap

- Maps exact Go types (e.g., `sql.NullTime{}`) to specific field helpers (e.g., `field.Time{}`)
- Useful to treat custom or wrapped types with existing helper implementations

### FieldNameMap

- Maps field names discovered from the `gen` struct tag to field helpers
- Allows you to assign helpers based on domain-specific tags like `json`, `date`, etc.

### IncludeInterfaces and ExcludeInterfaces

- Control which Go interfaces the generator will process
- Implements whitelist/blacklist filtering using shell-style `*` patterns or typed interface literals
- Whitelist (`IncludeInterfaces`) takes precedence over blacklist

### IncludeStructs and ExcludeStructs

- Control which structs the generator processes for model-driven helpers
- Same pattern format and precedence as interfaces

### FileLevel

- When `true`, config applies only to the file it’s declared in
- When `false` (default), applies at the package level, influencing all files under that package

---

## 4. Applying Whitelist and Blacklist Filters

Filtering your interfaces and structs helps avoid generating code for deprecated or unrelated types, improving build times and output clarity.

### Example: Include Only Interfaces Starting with "Query"

```go
package pattern

import "gorm.io/cli/gorm/genconfig"

var _ = genconfig.Config{
    IncludeInterfaces: []any{"Query*"},
}
```

This config filters generation to only interfaces whose names start with `Query`.

### How Filtering Works

- If `IncludeInterfaces` or `IncludeStructs` lists are non-empty, only matching items are generated;
  excludes are ignored.
- If those lists are empty, excludes in `ExcludeInterfaces` or `ExcludeStructs` apply as blacklists.
- Filtering supports string patterns or typed literals (e.g., `models.Query(nil)`).


---

## 5. How to Declare a Config Variable

- Declare a package-level, unexported variable (normally named `_` to avoid unused warnings)
- Assign a `genconfig.Config` composite literal with your desired fields
- Place the config in the same package where your interfaces and models reside

Example:

```go
package yourpackage

import "gorm.io/cli/gorm/genconfig"

var _ = genconfig.Config{
    OutPath: "yourpackage/generated",
    FileLevel: false,
    FieldNameMap: map[string]any{
        "json": JSON{},
    },
    IncludeStructs: []any{"User", "Order*"},
}
```

The config is automatically detected and used by the generator when running `gorm gen`.

---

## 6. Extending with Custom Field Helpers - JSON Example

Sometimes built-in helpers aren't enough. You can create custom field helpers that define how some fields generate SQL predicates dynamically per database dialect.

### JSON Field Helper Walkthrough

#### 6.1 Define JSON Helper Type

```go
package examples

import (
    "encoding/json"
    "gorm.io/gorm"
    "gorm.io/gorm/clause"
)

type JSON struct{ column clause.Column }

func (j JSON) WithColumn(name string) JSON {
    c := j.column
    c.Name = name
    return JSON{column: c}
}

func (j JSON) Equal(path string, value any) clause.Expression {
    return jsonEqualExpr{col: j.column, path: path, val: value}
}

type jsonEqualExpr struct {
    col  clause.Column
    path string
    val  any
}

func (e jsonEqualExpr) Build(builder clause.Builder) {
    if stmt, ok := builder.(*gorm.Statement); ok {
        switch stmt.Dialector.Name() {
        case "mysql":
            v, _ := json.Marshal(e.val)
            clause.Expr{SQL: "JSON_EXTRACT(?, ?) = CAST(? AS JSON)", Vars: []any{e.col, e.path, string(v)}}.Build(builder)
        case "sqlite":
            clause.Expr{SQL: "json_valid(?) AND json_extract(?, ?) = ?", Vars: []any{e.col, e.col, e.path, e.val}}.Build(builder)
        default: // postgres
            clause.Expr{SQL: "jsonb_extract_path_text(?, ?) = ?", Vars: []any{e.col, e.path[2:], e.val}}.Build(builder)
        }
    }
}
```

#### 6.2 Annotate Model Fields

Use the `gen:"json"` struct tag on Go model fields you want to treat as JSON.

```go
package models

type User struct {
    // ... other fields ...
    Profile string `gen:"json"`
}
```

#### 6.3 Reference Custom Helper in Your Config

```go
var _ = genconfig.Config{
    FieldNameMap: map[string]any{
        "json": JSON{},
    },
}
```

#### 6.4 Query Using Custom JSON Helper

```go
// Generates different JSON comparison for MySQL/SQLite/Postgres
res, err := gorm.G[models.User](db).
    Where(generated.User.Profile.Equal("$.vip", true)).
    Take(ctx)
```

This powerful approach lets you generate conditional SQL for custom database features and keeps your code strongly typed.

---

## 7. File-Level vs Package-Level Configuration

- **Package-Level (`FileLevel: false`)** (default): config affects all files in the package tree. Ideal for common settings.
- **File-Level (`FileLevel: true`)**: config applies only to the file where declared. Useful for isolated or special cases.

Set `FileLevel: true` when you want to limit scope to specific files.

---

## 8. Best Practices & Tips

- Define `genconfig.Config` once per package unless you have clear reasons for file-level configs.
- Use whitelist (`Include*`) selectively to speed generation and reduce noise.
- Map custom types and struct tag values consistently to keep generated code intuitive.
- When defining custom field helpers, consider how they interact with different databases.
- Keep folder structure clean so the OutPath override mirrors your desired generated code structure.
- Regularly check your configuration after changing model structures or queries.

---

## 9. Common Pitfalls

<Warning>
- Avoid defining multiple conflicting configs in the same package with overlapping filters.
- Do not assume mapping a Go type applies to variants or pointers unless explicitly mapped.
- Custom field helpers must implement the required interfaces expected by GORM CLI for code generation.
- Excluding all interfaces or structs unintentionally leads to no generated code.
</Warning>

---

## 10. Summary

The `genconfig.Config` provides a flexible way to control code generation behavior, helping you align the GORM CLI output with your project conventions and requirements. With whitelist/blacklist filters, custom field type mapping, and output path control, you maintain fine-tuned generation and effortlessly extend functionality with custom helpers like JSON support.

Explore related guides for deeper understanding:

- [Generating & Using Type-Safe Query APIs](../core-workflows/generating-and-using-query-apis)
- [Model-Driven Field Helper Generation](../core-workflows/model-driven-field-helpers)
- [Working with Associations & Relationships](../advanced-patterns/working-with-associations)

---

## Appendix A: Example Complete Config with JSON Helper

```go
package examples

import (
    "database/sql"
    "gorm.io/cli/gorm/field"
    "gorm.io/cli/gorm/genconfig"
)

var _ = genconfig.Config{
    OutPath: "examples/output",
    FieldTypeMap: map[any]any{
        sql.NullTime{}: field.Time{},
    },
    FieldNameMap: map[string]any{
        "date": field.Time{},
        "json": JSON{},
    },
    IncludeInterfaces: []any{"Query*"},
    IncludeStructs:    []any{"User", "Account*"},
}
```

This configuration ensures generation is scoped to relevant interfaces and structs while providing specialized helpers.
