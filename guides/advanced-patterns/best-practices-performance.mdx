---
title: "Best Practices and Performance Tips"
description: "Recommendations and common pitfalls for building scalable and maintainable query layers with GORM CLI. Discusses performance considerations, patterns for large models/projects, and techniques for minimizing code generation and runtime overhead."
---

# Best Practices and Performance Tips

GORM CLI provides a powerful and type-safe way to generate query APIs and field helpers that integrate seamlessly with GORM. This guide delivers critical recommendations to help you design scalable, maintainable, and high-performance query layers using GORM CLI-generated code. By applying these best practices, you minimize code bloat, maintain clarity in your codebase, and reduce runtime overhead while leveraging the full power of type-safe APIs.

---

## 1. Optimize Code Generation Scope

### Focused Interface and Model Generation

- **Use Inclusion Filters Wisely:** Limit code generation to only the interfaces and structs you actively use by configuring `IncludeInterfaces` and `IncludeStructs` in `genconfig.Config`. This prevents unnecessary code output and keeps your generated packages lean.

- **Exclude Deprecated or Unused Code:** Similarly, use `ExcludeInterfaces` and `ExcludeStructs` to explicitly leave out code that is obsolete or not part of your current workflow.

- **File-Level vs. Package-Level Configuration:** Consider setting `FileLevel` to `true` for packages where you want to generate code only for the current file. This isolates generation to finer-grained units and helps in large projects maintaining modular code.

### Example: Configuring Generation for Only Query Interfaces Starting with "Query"
```go
var _ = genconfig.Config{
  IncludeInterfaces: []any{"Query*"},
  ExcludeInterfaces: []any{"*Deprecated*"},
  IncludeStructs: []any{"User", "Account*"},
  FileLevel: false,
}
```

<Tip>
Applying selective generation reduces compilation time and improves developer navigation by eliminating noise in generated files.
</Tip>

---

## 2. Leverage Model-Driven Field Helpers Efficiently

### Prefer Basic Field Helpers for Simple Filters and Updates

- Use generated field helpers like `generated.User.Name.Eq("alice")` for safe and readable queries.
- Avoid raw SQL strings wherever possible to maintain compile-time type safety and to reduce error-prone code.

### Use Association Helpers for Manipulating Related Data

- Manage association operations (`Create`, `Update`, `Unlink`, `Delete`, `CreateInBatch`) through generated helpers on struct fields.
- For large models with many relations, selectively generate association helpers only for the associations you actively query or modify.

<Tip>
Take advantage of typed setter expressions and predicates to compose expressive and performant updates in a fluent style.
</Tip>

---

## 3. Design Query Interfaces with Performance in Mind

### Avoid Overly Complex SQL Templates

- Keep SQL templates in your interfaces simple and focused; avoid overly complex dynamic SQL blocks that can bloat or slow down generated code.
- For repetitive query patterns, consider abstracting common filters as reusable methods or external query fragments.

### Minimize Use of Heavy Template Constructs

- Extensive use of `{{for}}` and nested `{{if}}` blocks can complicate generated code and increase maintenance burden.
- Prefer parameterized queries and conditional clauses with clear, minimal logic.

### Use Context-Aware Parameter Binding

- Pass `context.Context` explicitly in interface methods (or rely on generator auto-injection) to respect cancellation and deadlines for query execution.

---

## 4. Minimize Runtime Overhead and Maximize Type Safety

### Generated Code Is Efficient but Keep It Lean

- Generated method bodies inline SQL string construction and parameter binding to minimize reflection and runtime interpretation.
- Avoid unnecessary or repeated calls by batching updates and inserts where possible.

### Leverage Generated Type Parameters for Reusability

- Use the generic API interfaces like `Query[T]` or generated helpers with type parameters to unify similar queries for different models, cutting down on redundant code.

### Use Generated Predicates and Setters for Safer Updates

- Examples:
```go
// Increment user's age atomically
gorm.G[User](db).Where(generated.User.ID.Eq(1)).Set(generated.User.Age.Incr(1)).Update(ctx)

// Update multiple fields with zero values safely
gorm.G[User](db).
  Set(
    generated.User.Name.Set("alice"),
    generated.User.IsAdult.Set(false),
  ).
  Create(ctx)
```

<Tip>
Avoid building raw SQL strings manually; the generated predicates and setters ensure correctness, parameterization, and security.
</Tip>

---

## 5. Handle Large Models and Complex Associations Strategically

### Split Large Models

- For models with many fields and associations, consider splitting definitions or selectively generating field helpers to keep compilation times manageable.
- Use the `ExcludeStructs` option to exclude heavyweight structs during iterative development.

### Limit Batch Operations Size

- When using batch `CreateInBatch` for associations, monitor batch sizes to avoid excessive memory and transaction overhead.

### Unlink vs Delete Semantics

- Understand the semantic differences to avoid accidental data loss:
  - `Unlink` removes association links (e.g., clears foreign keys or deletes join rows).
  - `Delete` removes records physically (or join rows in many2many).

---

## 6. Troubleshooting Common Performance Issues

<AccordionGroup title="Troubleshooting Guide">
<Accordion title="Generated Code Size Grows Too Large">
- Review your `genconfig.Config` filters.
- Exclude unused interfaces and structs.
- Enable `FileLevel` config if applicable.
- Avoid overly broad inclusion patterns like `*`.
</Accordion>
<Accordion title="Slow Compilation After Generation">
- Reduce generation scope.
- Run generator incrementally only on changed files.
- Use cache and build tags to limit recompilation.
</Accordion>
<Accordion title="Runtime Queries Are Slow Despite Type Safety">
- Analyze generated SQL for inefficiencies.
- Avoid complex nested template logic in query interfaces.
- Use database indexes matching generated query predicates.
</Accordion>
<Accordion title="Association Operations Fail or Behave Unexpectedly">
- Verify your associations are properly defined in GORM models.
- Confirm semantics: unlink vs delete.
- Check generated code with relation filters.
</Accordion>
</AccordionGroup>

---

## Summary

| Aspect | Recommendation |
|-|-|
| Code Generation | Use config filters to limit generated code |
| Query Interfaces | Keep SQL templates simple and maintainable |
| Field Helpers | Use generated predicates and setters for safer queries |
| Associations | Use helpers thoughtfully, understand unlink vs delete |
| Performance | Batch operations thoughtfully; avoid bloated code |

---

## Next Steps & Further Reading

- Dive into [Quickstart: Generate Type-Safe APIs](/guides/core-workflows/quickstart-generate) for practical workflows.
- Explore advanced query writing in [Template-Based Queries](/guides/advanced-patterns/template-based-queries).
- Learn to customize generation with [Customizing Code Generation with Config](/guides/advanced-patterns/customizing-generation).
- Deepen association handling skills in [Managing Associations Safely](/guides/core-workflows/association-operations).

---

By applying these best practices, you will maintain efficient, manageable, and robust generated query APIs suited for projects of any scale with GORM CLI.


---