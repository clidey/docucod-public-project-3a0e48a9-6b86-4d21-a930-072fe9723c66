---
title: "Customizing Code Generation with genconfig"
description: "How to tailor output paths, selectively include or exclude models/interfaces, and map custom field types using `genconfig.Config`. Provides recipes for advanced project setups and keeping generated code tightly aligned with business requirements."
---

# Customizing Code Generation with genconfig

## Workflow Overview

This guide helps you tailor GORM CLI's code generation process to fit your project's specific requirements using the `genconfig.Config` struct. You will learn how to:

- Customize output directory paths for generated code
- Selectively include or exclude specific query interfaces and model structs
- Map Go struct field types or named fields to custom field helper types

By the end, your generated code will be tightly aligned with your business layer conventions and project structure.

**Prerequisites:**
- A working installation of GORM CLI (Go 1.18+)
- Basic familiarity with writing query interfaces and model structs (see "Preparing Your Models and Interfaces")
- Understanding of running the generator with `gorm gen`

**Expected Outcome:**
- You’ll master fine-grained control of generation output and behavior across packages and files
- Enable advanced use cases such as rewriting paths, filtering generated code, and plugging in custom field helpers

**Time Estimate:** 15-30 minutes

**Difficulty Level:** Intermediate

---

## Step-by-Step Instructions

### 1. Declare a Package-Level `genconfig.Config`

In each Go package or directory where you want to customize code generation, declare a package-level variable of type `genconfig.Config`. This variable is automatically discovered and applied by GORM CLI during generation.

```go
package examples

import (
    "database/sql"
    "gorm.io/cli/gorm/field"
    "gorm.io/cli/gorm/genconfig"
)

var _ = genconfig.Config{
    OutPath: "examples/output", // Redirect generated files

    FieldTypeMap: map[any]any{ // Map Go types to custom field helper types
        sql.NullTime{}: field.Time{},
    },

    FieldNameMap: map[string]any{ // Map fields with specific gen tags
        "date": field.Time{},  // e.g., fields tagged with `gen:"date"`
        "json": JSON{},        // custom JSON field helper
    },

    FileLevel: false, // false means config is package-level, true restricts to file

    IncludeInterfaces: []any{"Query*", models.Query(nil)}, // Whitelist interfaces
    ExcludeInterfaces: []any{"*Deprecated*"},                // Blacklist interfaces

    IncludeStructs: []any{"User", "Account*", models.User{}}, // Whitelist structs
    ExcludeStructs: []any{"*DTO"},                             // Blacklist structs
}
```

> **Note:** You can specify include/exclude patterns using shell-style wildcards or by passing type literals like `models.User{}`.


### 2. Redirect Generated Code Output With `OutPath`

Override the CLI `-o` output directory for files in the config’s package or directory by setting `OutPath`.

```go
var _ = genconfig.Config{
    OutPath: "examples/output",
}
```

When multiple configs apply (e.g., nested directories), the deepest matching config's path takes precedence.


### 3. Use the `Include*` and `Exclude*` Filters to Scope Generation

- **Whitelists (`IncludeInterfaces`, `IncludeStructs`)** take priority and limit generation to exactly those interfaces or structs.
- **Blacklists (`ExcludeInterfaces`, `ExcludeStructs`)** remove matching items unless a whitelist is specified.

```go
var _ = genconfig.Config{
    IncludeInterfaces: []any{"Query*"}, // Only generate interfaces starting with "Query"
    ExcludeStructs:    []any{"*DTO"},   // Exclude structs like "SomethingDTO"
}
```

Patterns and type literals can be mixed. This allows you to generate only parts of your codebase where you want GORM CLI to apply.


### 4. Map Go Types or Named Fields to Custom Field Helpers

By default, GORM CLI detects basic Go types (int, string, time.Time) and associations to generate field helpers. For advanced use cases, override these mappings:

- **`FieldTypeMap`**: Map Go types (e.g., `sql.NullTime{}`) to field helpers like `field.Time{}`
- **`FieldNameMap`**: Map `gen:"<tag>"` names to specific field helpers (e.g., `json` → custom `JSON` type)


**Example mapping JSON fields using a custom `JSON` helper:**

```go
var _ = genconfig.Config{
    OutPath: "examples/output",
    FieldNameMap: map[string]any{
        "json": JSON{}, // Custom JSON field helper for fields tagged `gen:"json"`
    },
}
```

On your model:

```go
type User struct {
    Profile string `gen:"json"` // triggers use of JSON helper
}
```


### 5. Control Config Application Scope with `FileLevel`

- When `FileLevel` is `false` (default), the config applies to the whole package/directory recursively.
- When `true`, the config affects only the file it is defined in.

This helps manage overrides in large codebases with mixed files needing distinct generation behavior.


### 6. Run the Generator to See Changes

After applying your config, run the code generator as usual:

```bash
gorm gen -i ./examples -o ./generated
```

Observe that output files respect your overridden output paths, filtered interfaces/structs, and custom field mappings.


## Examples

### Example 1: Exclude a Specific Interface and Struct in a Nested Package

```go
package nested

import "gorm.io/cli/gorm/genconfig"

var _ = genconfig.Config{
    FileLevel:      false,
    ExcludeInterfaces: []any{"I3"},
    ExcludeStructs: []any{"S3"},
}
```

This configuration excludes the interface `I3` and struct `S3` from code generation in the `nested` directory.


### Example 2: Custom Field Type Mapping for `sql.NullTime`

```go
var _ = genconfig.Config{
    FieldTypeMap: map[any]any{
        sql.NullTime{}: field.Time{},
    },
}
```

This ensures `sql.NullTime` fields are treated as Time helpers in generated model-driven helpers.


### Example 3: Include Only Specific Interfaces and Structs

```go
var _ = genconfig.Config{
    IncludeInterfaces: []any{"Query*", models.Query(nil)},
    IncludeStructs:    []any{"User", "Account*", models.User{}},
}
```

Limits generation to interfaces matching `Query*` or the literal `models.Query(nil)` and structs matching patterns.


## Troubleshooting & Tips

<AccordionGroup title="Common Issues & Solutions">
<Accordion title="Generator Doesn't Apply My Configuration">
- Ensure your `genconfig.Config` is declared at package-level (top-level variable).
- Verify that `FileLevel` is set correctly depending on whether you want file-scoped or package-scoped configuration.
- Check path and package naming: the config applies based on package/directory hierarchies.
</Accordion>
<Accordion title="Patterns Don't Match as Expected">
- Patterns use shell-style matching, e.g., `*DTO` matches any ending with DTO.
- When specifying type literals like `models.User{}`, make sure the package is imported properly.
</Accordion>
<Accordion title="Custom Field Helper Not Used for Named Field">
- Confirm field has the `gen:"tag"` annotation matching the key in `FieldNameMap`.
- Ensure your custom field helper implements the required interfaces and is accessible.
- Check for typo in mapping keys, they must match tag values exactly.
</Accordion>
</AccordionGroup>

<Tip>
Include `Include*` and `Exclude*` filters only when necessary — avoid over-filtering to prevent unexpected omissions.
</Tip>

<Tip>
Use `FileLevel: true` sparingly, as it restricts config action to a single file and may complicate multi-file package generation.
</Tip>


## Next Steps & Related Content

- **Explore:** [Configuring GORM CLI](https://gorm.io/docs/cli/#configuring-generator) for broader configuration options.
- **Understand:** How to write and use SQL template driven interfaces in [Preparing Your Models and Interfaces](../getting-started/first-run-basic-usage/prepare-code).
- **Learn:** How to generate and utilize [Type-Safe Query APIs](../guides/core-workflows/working-with-type-safe-queries) and [Model-Driven Field Helpers](../guides/core-workflows/using-model-field-helpers).
- **Troubleshoot:** Common setup issues in [Troubleshooting Common Setup Issues](../getting-started/configuration-and-troubleshooting/troubleshooting-common-issues).

---

## Summary

This page details how to customize GORM CLI code generation through the `genconfig.Config` struct, enabling control over output paths, selective generation of interfaces and structs, and custom field type mappings. It empowers users to align generated source code precisely with project requirements and maintain clean, organized output.

Main sections include:

- Workflow overview
- Step-by-step configuration guide
- Practical examples
- Troubleshooting common pitfalls
- Suggestions for next exploration steps

Refer to key related guides such as Preparing Your Models and Interfaces, Configuring Generator, and Working with the Generated Code for comprehensive onboarding and advanced usage.

For navigation, this document is part of the 'Advanced Patterns & Use Cases' guide group under 'Customizing Code Generation with genconfig'.

---

**Useful Links:**
- [GORM CLI Overview](../../../overview/product-introduction/what-is-gorm-cli)
- [Configuring GORM CLI Generator](../../../getting-started/configuration-and-troubleshooting/configuring-generator)
- [Preparing Your Models and Interfaces](../../../getting-started/first-run-basic-usage/prepare-code)
- [Running the Generator](../../../getting-started/first-run-basic-usage/run-generator)
- [Using Generated Code](../../../getting-started/first-run-basic-usage/using-generated-code)
- [Troubleshooting Common Setup Issues](../../../getting-started/configuration-and-troubleshooting/troubleshooting-common-issues)

**Next recommended guides:**
- Mastering Advanced Association Management
- Handling JSON Fields with Custom Helpers
- Best Practices and Troubleshooting

---

Feel confident using `genconfig.Config` to craft a GORM CLI code generation workflow that fits your unique project needs and coding standards.