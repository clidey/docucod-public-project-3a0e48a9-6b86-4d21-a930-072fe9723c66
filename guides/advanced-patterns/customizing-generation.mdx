---
title: "Customizing Generation: genconfig and Field Mapping"
description: "Learn how to tailor the generator to your project's requirements with genconfig.Config, including output paths, custom field type maps, includes/excludes, and struct-level overrides. Includes a practical JSON field helper example that demonstrates extensibility and advanced mapping."
---

# Customizing Generation: genconfig and Field Mapping

Customize the GORM CLI code generation process to perfectly fit your project's structure and requirements using `genconfig.Config`. This guide walks you through configuring output paths, defining custom field type mappings, including or excluding specific interfaces or structs, and applying overrides at file or package levels. Additionally, it presents a practical example of extending the generation system with a JSON field helper.

---

## 1. Overview of Generator Customization

Out of the box, GORM CLI generates type-safe query APIs and model-driven field helpers from your Go source code. However, complex projects often demand fine-tuned control over this process. `genconfig.Config` empowers you to tailor generation behavior on a per-package or even per-file basis.

### What You Will Learn

- How to declare a `genconfig.Config` configuration
- How to customize the output directory for generated code
- How to map Go model field types to specific field helper types
- How to include or exclude particular interfaces and structs from generation
- How to perform file-level or package-wide configuration
- How to create and integrate custom field helpers, demonstrated with a JSON helper

### Prerequisites

- A working Go development environment (Go 1.18+)
- Familiarity with GORM CLI project setup and basic usage
- Existing Go model structs and query interfaces

### Expected Outcome

By completing this guide, you will confidently customize GORM CLI generation to match your project needs, leveraging advanced field mappings and filters efficiently.

---

## 2. Understanding genconfig.Config

`genconfig.Config` is a special package-level variable you declare in any package where you want to influence code generation. The generator automatically detects and applies it when running on the package directory or files.

### Declaring a Configuration

Place the following in a Go source file under the package you want to customize, typically named `config.go`:

```go
package examples

import (
    "database/sql"
    "gorm.io/cli/gorm/field"
    "gorm.io/cli/gorm/genconfig"
)

var _ = genconfig.Config{
    OutPath: "examples/output",
    FieldTypeMap: map[any]any{
        sql.NullTime{}: field.Time{},
    },
    FieldNameMap: map[string]any{
        "date": field.Time{},
        "json": JSON{},
    },
    IncludeInterfaces: []any{"Query*"},
    ExcludeInterfaces: []any{"*Deprecated*"},
    IncludeStructs: []any{"User", "Account*"},
    ExcludeStructs: []any{"*DTO"},
    FileLevel: false,
}
```

### Key Configuration Fields

| Field               | Purpose                                                                                               |
|---------------------|-----------------------------------------------------------------------------------------------------|
| `OutPath`           | Directory where the generated code for this package (or file) will be placed. Defaults to `./g`.    |
| `FieldTypeMap`      | Map Go types or named types (e.g., `sql.NullTime{}`) to specific `field` helpers (e.g., `field.Time{}`).|
| `FieldNameMap`      | Map struct field name keys (matching the `gen:"tag"` annotation) to custom field helpers.         |
| `IncludeInterfaces` | Whitelist: generate only interfaces matching these names or patterns (`*` supported).                |
| `ExcludeInterfaces` | Blacklist: exclude interfaces matching these names or patterns if no includes are defined.          |
| `IncludeStructs`    | Whitelist: generate only structs matching these names or patterns.                                  |
| `ExcludeStructs`    | Blacklist: exclude structs matching these names or patterns if no includes are defined.              |
| `FileLevel`         | If `true`, applies config only to the current file, not entire package or directory subtree.        |

<Tip>
The whitelist (`Include*`) takes precedence over the blacklist (`Exclude*`). If any whitelist is set, excludes are ignored for that type.
</Tip>

---

## 3. Customizing Output Directory

Override default generated code placement by setting `OutPath` in your config.

1. Add or update your `genconfig.Config` in the package:

```go
var _ = genconfig.Config{
    OutPath: "internal/gen/generated",
}
```

2. Run the generator with `-i` pointed to the package or directory.

```bash
gorm gen -i ./internal/gen -o ./fallback/output
```

3. Generated files appear under `internal/gen/generated` instead of the CLI’s default `./g` folder.

<Check>
If multiple packages or configs overlap (e.g., parent/child directories), the config closest to the source file applies.
</Check>

---

## 4. Mapping Go Types to Field Helpers

By default, GORM CLI maps common Go types like `string`, `int`, `time.Time`, etc., to field helper types like `field.String`, `field.Number[int]`, `field.Time`.

Use `FieldTypeMap` to override or add mappings, including for named types such as `sql.NullTime` or your custom types.

Example:

```go
var _ = genconfig.Config{
    FieldTypeMap: map[any]any{
        sql.NullTime{}: field.Time{}, // Map sql.NullTime fields to time helpers
        MyCustomType{}: field.String{}, // Map a custom type to string helpers
    },
}
```

### Mapping by Field Name with gen tag

Sometimes Go types are generic or ambiguous. Use struct tags and `FieldNameMap` for precise control:

```go
var _ = genconfig.Config{
    FieldNameMap: map[string]any{
        "json": JSON{}, // Fields tagged `gen:"json"` use a custom JSON helper
        "date": field.Time{},
    },
}
```

On your model struct:

```go
type User struct {
    Profile string `gen:"json"` // Uses JSON helper at generation
    Birthdate time.Time `gen:"date"`
}
```

<Tip>
Use the `gen` tag on struct fields to apply name-based helper mapping only when type-based mapping is insufficient.
</Tip>

---

## 5. Including and Excluding Interfaces and Structs

Control which Go interfaces and structs are included in code generation by specifying include/exclude slices.

### Patterns and Types Supported

- Exact names (e.g., `Query`, `User`)
- Shell-style wildcards (e.g., `Query*`, `*DTO`)
- Go typed values (e.g., `models.Query(nil)` or `models.User{}`) for precise type matching

### Example

```go
var _ = genconfig.Config{
    IncludeInterfaces: []any{"Query*"},    // Only interfaces starting with 'Query'
    ExcludeInterfaces: []any{"*Deprecated*"}, // Exclude deprecated interfaces
    IncludeStructs: []any{"User", "Account*"}, // Include struct User and structs starting with Account
    ExcludeStructs: []any{"*DTO"}, // Exclude any struct ending with DTO
}
```

### File Level vs Package Level

By default, configs apply at the package (directory) level. Use `FileLevel: true` to restrict the config influence only to the file where it is defined.

---

## 6. Practical JSON Field Helper Example

Extend the field helper system with a custom JSON helper that generates dialect-specific SQL expressions when used in queries.

### Step 0: Declare Configuration

```go
package examples

import "gorm.io/cli/gorm/genconfig"

var _ = genconfig.Config{
    OutPath: "examples/output",
    FieldNameMap: map[string]any{
        "json": JSON{}, // Map fields tagged with `gen:"json"` to JSON helper
    },
}
```

### Step 1: Annotate Your Model Fields

```go
package models

type User struct {
    // Other fields...
    Profile string `gen:"json"` // Custom JSON field helper applied
}
```

### Step 2: Define the JSON Helper

```go
package examples

import (
    "encoding/json"
    "gorm.io/gorm"
    "gorm.io/gorm/clause"
)

type JSON struct{ column clause.Column }

func (j JSON) WithColumn(name string) JSON {
    c := j.column
    c.Name = name
    return JSON{column: c}
}

func (j JSON) Equal(path string, value any) clause.Expression {
    return jsonEqualExpr{col: j.column, path: path, val: value}
}

type jsonEqualExpr struct {
    col  clause.Column
    path string
    val  any
}

func (e jsonEqualExpr) Build(builder clause.Builder) {
    if stmt, ok := builder.(*gorm.Statement); ok {
        switch stmt.Dialector.Name() {
        case "mysql":
            v, _ := json.Marshal(e.val)
            clause.Expr{SQL: "JSON_EXTRACT(?, ?) = CAST(? AS JSON)", Vars: []any{e.col, e.path, string(v)}}.Build(builder)
        case "sqlite":
            clause.Expr{SQL: "json_valid(?) AND json_extract(?, ?) = ?", Vars: []any{e.col, e.col, e.path, e.val}}.Build(builder)
        default:
            clause.Expr{SQL: "jsonb_extract_path_text(?, ?) = ?", Vars: []any{e.col, e.path[2:], e.val}}.Build(builder)
        }
    }
}
```

### Step 3: Query Using the JSON Helper

```go
// Generates SQL JSON-specific comparison depending on DB dialect
result, err := gorm.G[models.User](db).
    Where(generated.User.Profile.Equal("$.vip", true)).Take(ctx)
```

<Tip>
This example demonstrates how the generator’s field helper mapping allows you to extend query semantics without modifying the core generator.
</Tip>

---

## 7. Best Practices and Troubleshooting

### Best Practices

- Define configurations at the package level whenever possible for consistency.
- Use `Include*` filters sparingly to avoid accidentally excluding needed types.
- Use `FieldNameMap` only for fields with custom tags to reduce confusion.
- Keep output paths organized by module or package to avoid clutter.
- When creating custom helpers, ensure proper integration with GORM’s clause system.

### Common Issues

<AccordionGroup title="Troubleshooting genconfig Configurations">
<Accordion title="Generated files do not appear in the expected folder">
Verify `OutPath` is correctly set and relative to your module root. Check config scoping with `FileLevel` if multiple configs overlap.
</Accordion>
<Accordion title="Custom field helper not applied to some fields">
Confirm the naming/tag matches the `FieldNameMap` keys exactly. Ensure your model fields use the correct `gen` struct tag.
</Accordion>
<Accordion title="Interfaces or structs not generated as expected">
Check your `Include*` and `Exclude*` patterns for correctness and precedence. If both are set, whitelist takes precedence.
</Accordion>
<Accordion title="Compilation errors after generation related to imports">
Check that your config and model packages import any custom helpers properly. The generator automatically injects imports based on `FieldTypeMap` mappings.
</Accordion>
</AccordionGroup>

---

## 8. Next Steps & Related Documentation

- [Project Configuration](../getting-started/first-steps/project-configuration) — Foundation for setting up your models and configs
- [Generating Code](../getting-started/first-steps/generating-code) — How to run the generator CLI efficiently
- [Model-Driven Field Helpers](../guides/core-workflows/model-driven-field-helpers) — Advanced usage of generated field helpers
- [Working with Associations](../guides/advanced-patterns/working-with-associations) — Deep dive into association operations
- [Troubleshooting Common Issues](../getting-started/troubleshooting/common-issues) — Fast resolution for code generation hiccups

Harness the full power of `genconfig.Config` to tailor GORM CLI perfectly to your existing or new Go project.

---

## Appendix: Example genconfig Config for JSON Custom Helper

```go
package examples

import (
    "database/sql"
    "gorm.io/cli/gorm/field"
    "gorm.io/cli/gorm/genconfig"
)

var _ = genconfig.Config{
    OutPath: "examples/output",
    FieldTypeMap: map[any]any{
        sql.NullTime{}: field.Time{},
    },
    FieldNameMap: map[string]any{
        "json": JSON{},
    },
    IncludeInterfaces: []any{"Query*"},
}
```

This configuration outputs generated code to `examples/output`, maps `sql.NullTime` to `field.Time`, applies the JSON helper to any field tagged `gen:"json"`, and only includes interfaces starting with `Query`.

---