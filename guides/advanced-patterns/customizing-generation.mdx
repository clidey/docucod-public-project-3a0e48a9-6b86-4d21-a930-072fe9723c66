---
title: "Customizing Generation with genconfig"
description: "Detailed instructions on leveraging the genconfig.Config for advanced code generation customization, including output paths, field and type mapping, whitelists/blacklists, and per-file or package settings."
---

# Customizing Generation with genconfig.Config

Customize GORM CLI's code generation process with the powerful `genconfig.Config` struct. This configuration lets you tailor output paths, field type mappings, interface and struct filters, and per-file or package-level settings, empowering you to generate exactly the code you need with precision and flexibility.

---

## Workflow Overview

- **Purpose**: This guide shows you how to leverage `genconfig.Config` to control and customize GORM CLI’s code generation behavior.
- **Prerequisites**: Familiarity with Go project structure, GORM models, and basic GORM CLI usage.
- **Outcome**: Configure output directories, override field helper mappings, filter generated interfaces/structs, and apply scoped configurations for more maintainable and targeted generated code.
- **Time Estimate**: 15–30 minutes to understand and start applying customizations.
- **Difficulty Level**: Intermediate.

---

## Understanding genconfig.Config

The `genconfig.Config` struct declares package-level generation settings within your Go source code. When the generator runs, it detects these configurations and applies them automatically.

### Key Configuration Fields:

| Field               | Description                                                                                                      |
|---------------------|------------------------------------------------------------------------------------------------------------------|
| `OutPath`           | Customizes the base directory where generated files are written.                                                |
| `FieldTypeMap`      | Maps Go field types (e.g., `sql.NullTime{}`) to custom field helper wrappers (e.g., `field.Time{}`).              |
| `FieldNameMap`      | Maps struct field tag keys (e.g., `json`, `date`) to custom field helper types for fine-grained field control.   |
| `FileLevel`         | When set to `true`, applies this configuration only to the current file instead of the entire package subtree.  |
| `IncludeInterfaces` | Whitelist of interface types to generate; only matching interfaces will be processed if non-empty.               |
| `ExcludeInterfaces` | Blacklist of interface types to skip; ignored if whitelist is non-empty.                                        |
| `IncludeStructs`    | Whitelist of struct types to generate field helpers for.                                                        |
| `ExcludeStructs`    | Blacklist of struct types to exclude from generation.                                                           |

---

## Step-by-Step Instructions

### 1. Declare Your genconfig.Config

In one of your Go files within the target package or directory, add a package-level var of type `genconfig.Config`.

```go
package examples

import (
    "database/sql"
    "gorm.io/cli/gorm/field"
    "gorm.io/cli/gorm/genconfig"
)

var _ = genconfig.Config{
    OutPath: "examples/output",  // Customize output directory

    FieldTypeMap: map[any]any{   // Map Go types to field helper wrappers
        sql.NullTime{}: field.Time{},
    },

    FieldNameMap: map[string]any{ // Map struct field gen tags to custom helpers
        "date": field.Time{},
        "json": JSON{}, // Custom JSON helper you define
    },

    IncludeInterfaces: []any{"Query*"},  // Only generate interfaces with names starting with "Query"
    ExcludeInterfaces: []any{"*Deprecated*"}, // Exclude deprecated interfaces

    IncludeStructs: []any{"User", "Account*"},   // Include these structs
    ExcludeStructs: []any{"*DTO"},                 // Exclude DTO structs
}
```

### 2. Understand Filtering Logic

- **Whitelists (`Include*`) override blacklists.** If you specify any `Include*` lists, only those matching types are generated.
- Use shell-style patterns (`*`, `?`) or full type selectors, including package-qualified names.
- You can include types by string patterns or by type-literals, e.g., `models.User{}`.

### 3. Control Output Directory

- Use `OutPath` to direct generated files into a specific folder relative to your module root.
- This helps organize generated code apart from source code or supports generating multiple outputs from multiple packages.

### 4. Custom Field Helper Mappings

- Use `FieldTypeMap` to globally map Go types to desired field helpers.
- Use `FieldNameMap` to map specific field tags (`gen:"tag"`) to custom helpers.

Example:

```go
FieldNameMap: map[string]any{
    "json": JSON{}, // Your custom JSON field helper
},
```

Your structs can then tag fields with `gen:"json"` to apply your custom JSON helper.

### 5. Per-File vs Package-Level Config

- `FileLevel: true` applies the config only to the file where the config var is declared.
- Otherwise (default `false`), the configuration applies recursively to the package directory tree.

### 6. Combining Multiple Configs

- You can declare multiple `genconfig.Config` vars in different files — the generator merges applicable configs based on paths and precedence rules.

---

## Practical Examples

### Example 1: Include Only Interfaces Starting with "Query"

```go
package pattern

import "gorm.io/cli/gorm/genconfig"

var _ = genconfig.Config{
    IncludeInterfaces: []any{"Query*"},
}
```

Generates code only for interfaces whose names begin with `Query`.

### Example 2: Exclude Nested Interfaces and Structs

```go
package twolevel

import (
    s "gorm.io/cli/gorm/examples/filters/twolevel/nested"
    "gorm.io/cli/gorm/genconfig"
)

var _ = genconfig.Config{
    ExcludeInterfaces: []any{s.I2[any](nil), I3[any](nil)},
    ExcludeStructs:    []any{s.S2{}, S3{}},
}
```

This avoids generating certain nested or complex interfaces and structs.

### Example 3: JSON Field Helper Mapping

```go
package examples

import "gorm.io/cli/gorm/genconfig"

var _ = genconfig.Config{
    FieldNameMap: map[string]any{
        "json": JSON{},
    },
}
```

Then in your model:

```go
package models

type User struct {
    Profile string `gen:"json"`
}
```

This wires your `JSON` field helper for the `Profile` field.

---

## Troubleshooting & Tips

- **Config not applied?** Ensure your `genconfig.Config` var is declared at package-level (var _ = ...) and imported correctly.
- **Whitelisting conflicting with includes/excludes?** Remember that any non-empty `IncludeInterfaces` or `IncludeStructs` overrides the excludes.
- **Custom field helper issues?** Make sure your helper types implement the expected interfaces and are imported for generation.
- **Output directory ignored?** Confirm no other config with higher priority or CLI flag overrides your `OutPath`.
- **FileLevel true scope**: Use this carefully to target specific files, especially in mixed directories.

---

## Next Steps & Related Content

- Explore the **[First Code Generation](https://docs.example.com/getting-started/essential-setup/first-code-generation)** guide to see configuration impact on initial generation.
- Learn about **[Working with Field Helpers](https://docs.example.com/guides/core-workflows/working-with-field-helpers)** for advanced field control.
- Dive into **[Template DSL Guide](https://docs.example.com/guides/advanced-patterns/template-dsl-guide)** for custom SQL queries.
- Refer to **[Associations Guide](https://docs.example.com/guides/core-workflows/associations-guide)** to understand how config affects association helpers.

---

## Source

Browse the configuration parsing implementation:

<Source url="https://github.com/go-gorm/cli" paths={[{"path": "internal/gen/generator.go", "range": "100-200"},{"path": "genconfig/config.go", "range": "1-70"}]} branch="main" />

---