---
title: "Writing Template-Driven Queries"
description: "Master the SQL template DSL for dynamic, type-safe method generation from Go interfaces. Includes best practices for leveraging directives, binding parameters, and handling conditional SQL—enabling expressive, safe, and DRY query layer design."
---

# Writing Template-Driven Queries

Master the use of GORM CLI's SQL template DSL to create dynamic, expressive, and type-safe query methods directly from Go interfaces. This guide walks you through leveraging SQL templating directives, binding Go method parameters, and constructing conditionals within your SQL queries to build robust, DRY, and maintainable query layers.

---

## 1. Understanding the Purpose and Workflow

Writing template-driven queries allows you to embed and customize raw SQL snippets within Go interface method comments. GORM CLI processes these templates to generate concrete implementations that are type-safe and integrate seamlessly with your GORM-based application.

### Why Use Template-Driven Queries?
- **Expressive SQL:** Craft precise SQL queries that go beyond what GORM's default ORM chaining supports.
- **Type-Safe Bindings:** Parameters in your SQL are bound directly to Go method parameters with compile-time safety.
- **Dynamic SQL Generation:** Use template directives to conditionally include WHERE clauses, SET updates, iteration, and more, creating flexible queries without boilerplate.
- **DRY & Maintainable:** Encapsulate query logic close to your interface definition, minimizing duplicated code and easing maintenance.

### Typical User Goals
- Define advanced custom queries with dynamic conditions.
- Write update statements that conditionally set fields based on input values.
- Iterate over collections to build complex OR/AND filters.
- Generate implementation code automatically, avoiding manual SQL string building.

---

## 2. How Template-Driven Queries Work in GORM CLI

Users define Go interfaces with methods that include SQL snippets annotated in comments. These annotations use a domain-specific templating syntax:

- Parameters prefixed with `@` bind to Go method parameters.
- Special markers like `@@table` and `@@column` dynamically insert table and column names.
- Template directives like `{{where}}` and `{{set}}` dynamically build SQL clauses.

The generator parses these templates and outputs Go code that compiles SQL safely, manages parameters, and returns typed results.

---

## 3. Using the SQL Template DSL

### Core Template Directives
| Directive   | Purpose                                | Example                                    |
|-------------|----------------------------------------|--------------------------------------------|
| `@@table`   | Inserts the model’s database table name | `SELECT * FROM @@table WHERE id=@id`        |
| `@@column`  | Binds dynamic column names in SQL      | `WHERE @@column=@value`                      |
| `@param`    | Bind Go method parameters safely       | `WHERE name=@user.Name`                      |
| `{{where}}` | Conditionally assemble WHERE clauses   | `{{where}} age > 18 {{end}}`                 |
| `{{set}}`   | Conditionally build UPDATE SET clauses | `{{set}} name=@name {{end}}`                 |
| `{{if}}`    | Conditional SQL fragment inclusion      | `{{if age > 0}} AND age=@age {{end}}`       |
| `{{for}}`   | Iterate over collections for filters    | `{{for _, tag := range tags}} ... {{end}}` |

### Key Concepts
- **Parameter Binding:** Placeholders such as `@id` in the query are automatically bound to Go parameters of the same name.
- **Escaping:** Use `\@` to escape the `@` symbol literally inside your SQL.
- **Conditional Logic:** Use nested `{{if}} ... {{else}} ... {{end}}` for fine-grained control.
- **Collections:** Iterate with `{{for}}` to build OR/AND conditions via repetition.

---

## 4. Step-by-Step Guide to Writing Template Queries

### Step 1: Define Your Go Interface Method

Write a method inside your Go interface with parameters reflecting the data you want to filter or update.

```go
// Fetch a user by ID and name
// SELECT * FROM @@table WHERE id=@id AND name = "\@name"
GetByID(id int) (T, error)
```

### Step 2: Write SQL Template Comments

Annotate the method with a SQL snippet as a raw string comment. Use the DSL for dynamic behaviors.

```go
// Query with conditional WHERE based on User struct fields
// SELECT * FROM @@table
// {{where}}
//   {{if user.ID > 0}}
//       WHERE id=@user.ID
//   {{else if user.Name != ""}}
//       WHERE name=@user.Name
//   {{end}}
QueryWith(user models.User) (T, error)
```

### Step 3: Use Directives for Updates or Sets

For update queries, wrap field updates in `{{set}}` to include only fields meeting conditions.

```go
// UPDATE @@table
// {{set}}
//   {{if user.Name != ""}} name=@user.Name, {{end}}
//   {{if user.Age > 0}} age=@user.Age, {{end}}
//   {{if user.Age >= 18}} is_adult=1 {{else}} is_adult=0 {{end}}
// {{end}}
// WHERE id=@id
UpdateInfo(user models.User, id int) error
```

### Step 4: Handle Iterations for Batch Filters

Build complex WHERE clause filters by iterating over collections.

```go
// SELECT * FROM @@table
// {{where}}
//   {{for _, user := range users}}
//     {{if user.Name != "" && user.Age > 0}}
//       (name = @user.Name AND age=@user.Age AND role LIKE concat("%",@user.Role,"%")) OR
//     {{end}}
//   {{end}}
// {{end}}
Filter(users []models.User) ([]T, error)
```

### Step 5: Run the Generator

Use the CLI to generate implementations.

```bash
gorm gen -i ./examples -o ./generated
```

### Step 6: Use Generated Methods

Invoke the generated methods safely with typed parameters.

```go
user, err := generated.Query[User](db).GetByID(ctx, 123)
```

---

## 5. Practical Examples

### Simple Select Query

```go
// SELECT * FROM @@table WHERE id=@id
GetByID(id int) (T, error)
```

**Result:** Returns a typed single entity matching the id with safe binding.

---

### Dynamic Column Filter

```go
// SELECT * FROM @@table WHERE @@column=@value
FilterWithColumn(column string, value string) (T, error)
```

Allows filtering by dynamic columns using column name from parameter.

---

### Conditional WHERE Clause

```go
// SELECT * FROM @@table
// {{where}}
//   {{if name != ""}} name=@name {{end}}
//   {{if age > 0}} AND age=@age {{end}}
// {{end}}
SearchUsers(name string, age int) ([]T, error)
```

Query parts appear based on non-empty parameters.

---

### Update with Conditional SET

```go
// UPDATE @@table
// {{set}}
//  {{if user.Name != ""}} name=@user.Name, {{end}}
//  {{if user.Email != ""}} email=@user.Email {{end}}
// {{end}}
// WHERE id=@id
UpdateUser(user User, id int) error
```

Only updates columns with defined values.

---

## 6. Best Practices and Tips

- **Use `@@table` for portability:** Always use the `@@table` directive instead of hardcoding table names.
- **Escape literal `@`:** Use `\@` to include literal `@` symbols in your SQL comments.
- **Include `context.Context` in methods:** If omitted, the generator injects it — but it's best to declare explicitly.
- **Avoid overly complex logic:** Keep conditional SQL expressions manageable for readability.
- **Leverage collections carefully:** When iterating, ensure the data passed is valid and non-empty to avoid empty clauses.
- **Test generated code:** Always verify generated code compiles and performs as expected.

---

## 7. Common Pitfalls and Troubleshooting

<AccordionGroup title="Troubleshooting Common Template Issues">
<Accordion title="Unclosed Directive Blocks">
Make sure all `{{if}}`, `{{for}}`, and `{{where}}` blocks have corresponding `{{end}}`. Mismatched directives cause generation failures.
</Accordion>
<Accordion title="Parameter Name Mismatch">
Ensure that all `@param` placeholders in the SQL match method parameter names exactly, including case.
</Accordion>
<Accordion title="Escape Characters Not Applied Correctly">
Use `\@` to escape literal `@` symbols. Forgetting this causes parsing errors or unexpected placeholders.
</Accordion>
<Accordion title="Unexpected Empty WHERE/SET Clauses">
Empty dynamic clauses like `{{where}}` or `{{set}}` do not add SQL fragments, which can cause syntax errors if not handled properly.
Consider adding safe defaults or pre-checks in your application code.
</Accordion>
<Accordion title="Method Return Signature Errors">
Template-driven methods that return data must have appropriate return signatures:
- 1 return value: must be `error` (used for exec-only)
- 2 return values: first is data, second must be `error`
Mismatches cause generation errors.
</Accordion>
</AccordionGroup>

---

## 8. Advanced Patterns and Usage

### Binding Struct Fields
You can bind directly to a struct's exported fields and use conditions.

### Using `{{where}}` with Complex Logic
Trim leading/trailing `AND`/`OR` connectors automatically for clean SQL.

### Combining `{{if}}` and `{{for}}` for Flexible Queries
Iterate over slices of structs to build OR conditions, filtering only valid items.

---

## 9. Summary

Writing template-driven queries in GORM CLI unlocks powerful customization for your Go persistent layers, combining the expressiveness of raw SQL with the safety and ergonomics of Go types. Mastering the SQL template DSL dramatically reduces boilerplate while giving you precise control over query semantics.

---

## 10. Related Documentation and Next Steps

- [Generating Type-Safe APIs and Helpers](https://your-docs-link/guides/core-workflows/quickstart-generate) — How to run the generator and use output code.
- [Defining Models and Query Interfaces](https://your-docs-link/getting-started/core-workflow-quickstart/prepare-models-interfaces) — Organizing your code for generation.
- [Working with Model-Driven Field Helpers](https://your-docs-link/guides/core-workflows/using-field-helpers) — Safely compose queries using generated helpers.
- [Configuring GORM CLI](https://your-docs-link/getting-started/configuration-troubleshooting/basic-configuration) — Customize generation behavior.

---

_For further details on the internal parsing, rendering, and error handling of template-driven queries, see the internal code and tests (in `internal/gen/sqlparser.go` and its test files)._