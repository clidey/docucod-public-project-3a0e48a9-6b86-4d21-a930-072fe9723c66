---
title: "Customizing Field Helpers: Mapping, Predicates, and Setters"
description: "Strategies for customizing field helpers using tags and configuration, including mapping custom Go types (such as JSON), adapting helpers for complex columns, and crafting reusable predicates and setters for your domain."
---

# Customizing Field Helpers: Mapping, Predicates, and Setters

This guide walks you through customizing your model-driven field helpers generated by GORM CLI. It covers how to map custom Go types using tags and configuration, adapt helpers for complex or nested columns like JSON, and craft reusable predicates and setter expressions that fit your domain logic. By mastering these techniques, you'll unlock powerful, type-safe query and update capabilities tailored to your application needs.

---

## 1. Understanding Custom Field Helper Mapping

### What This Guide Helps You Accomplish

You’ll learn how to customize the generated field helpers that GORM CLI creates from your Go models. This allows you to:

- Map custom or complex Go types (e.g., `sql.NullTime`, JSON blobs) to specialized field helpers.
- Customize field helper types on a per-column basis using struct tags.
- Extend or replace default helpers to support database-specific or domain-specific SQL expressions.

### Prerequisites

- You have Go 1.18+ installed.
- You have a GORM project with models defined.
- You understand basic GORM querying and GORM CLI usage.
- You have run the basic code generation flow producing default field helpers.

### Expected Outcome

After following this guide, you’ll be able to define custom mappings for your fields to specialized helpers and write expressive queries and updates with those helpers, adapting to complex data types and domain requirements.

---

## 2. Mapping Custom Go Types to Field Helpers

By default, GORM CLI generates field helpers for basic Go types (`int`, `string`, `time.Time`, etc.). To map your complex or custom types to specific helpers, use the package-level configuration `genconfig.Config`.

### Step 1: Define Your Custom Field Helper Type

For example, to handle JSON columns differently, define a custom helper type. The example below shows a generic JSON field helper:

```go
// JSON is a field helper for JSON columns that generates database-specific SQL.
type JSON struct{ column clause.Column }

func (j JSON) WithColumn(name string) JSON {
    c := j.column
    c.Name = name
    return JSON{column: c}
}

func (j JSON) Equal(path string, value any) clause.Expression {
    return jsonEqualExpr{col: j.column, path: path, val: value}
}

// jsonEqualExpr implements clause.Expression to output dialect-specific JSON equality
// ...implementation omitted for brevity...
```

### Step 2: Configure Field Mapping in `genconfig.Config`

In your package, declare a `genconfig.Config` variable that maps your Go fields to your custom helpers using `FieldNameMap` or `FieldTypeMap`. For example:

```go
package examples

import (
    "database/sql"
    "gorm.io/cli/gorm/genconfig"
    "gorm.io/cli/gorm/field"
)

var _ = genconfig.Config{
    OutPath: "examples/output",
    FieldTypeMap: map[any]any{
        sql.NullTime{}: field.Time{}, // map sql.NullTime to Time helper
    },
    FieldNameMap: map[string]any{
        "json": JSON{},             // map fields tagged with `gen:"json"` to JSON helper
    },
}
```

### Step 3: Tag Model Fields to Use Custom Helpers

Add the `gen` struct tag to your model fields that require custom helpers.

```go
package models

type User struct {
    // ... other fields ...
    Profile string `gen:"json"` // Custom JSON helper applied
}
```

### Step 4: Generate Updated Helpers

Run the CLI with your input path to generate helpers using your config:

```bash
gorm gen -i ./examples -o ./generated
```

The generated code will use your JSON helper for the `Profile` field.

---

## 3. Using Custom Field Helpers in Queries and Updates

Once your helpers are generated, leverage the fluent API to build complex expressions.

### Example: Querying JSON Fields

```go
// Query users whose Profile JSON contains {"vip":true}
got, err := gorm.G[models.User](db).
    Where(generated.User.Profile.Equal("$.vip", true)).
    Take(ctx)
if err != nil {
    // handle error
}
```

> The generated SQL differs based on the underlying database dialect, improving compatibility.

### Best Practice: Use Struct Tags for Clear Intent

Use `gen:"json"` or similar tags consistently in your model structs to keep the intent clear and the mapping explicit.

---

## 4. Adapting Helpers for Complex Columns

### Handling Complex Types Beyond JSON

You can extend or define helpers for:

- Custom types implementing `database/sql.Scanner` and `driver.Valuer` interfaces.
- Nested structs requiring `field.Struct[T]` helpers.
- Slice fields representing `has many` relationships as `field.Slice[T]`.

### How to Apply This

1. Create a helper struct similar to `field.Field[T]` or `field.Struct[T]`.
2. Implement useful predicates (e.g., `Equal`, `Contains`) and setters (`Set`, `SetExpr`).
3. Map these helpers to your types via `genconfig` as above.

This enables writing type-safe and expressive code tailored to your domain.

---

## 5. Crafting Reusable Predicates and Setters

### Common Predicates

Your helpers can provide predicates such as:

- Equality (`Eq(value)`)
- Inequality (`Neq(value)`)
- Null checks (`IsNull()`, `IsNotNull()`)
- Range checks (`Between(min, max)`)
- SQL expressions (`Expr(sql, args...)`)
- Containment (`Contains(val)`) especially for JSON or text

### Setter Methods for Updates

Helpers support setters like:

- `Set(value)` — set field to a literal value
- `SetExpr(expression)` — set field using SQL expressions
- Increment/decrement helpers (e.g., `Incr(amount)`)

### Example: Using Set with Expressions

```go
// Increment age by 1
rows, err := gorm.G[models.User](db).
    Where(generated.User.Name.Eq("bob")).
    Set(generated.User.Age.SetExpr(clause.Expr{SQL: "age + ?", Vars: []any{1}})).
    Update(ctx)
```

### Design Tip

Design your predicates and setters to compose cleanly with GORM's clause expressions for flexible query building.

---

## 6. Practical Tips and Common Pitfalls

<Tip>
Always test your custom helpers with the supported database dialects. JSON functions differ widely; verify SQL generated matches your DB.
</Tip>

<Tip>
Use explicit `gen:"tag"` struct tags rather than implicit name matching to avoid accidental mis-mapping.
</Tip>

<Warning>
Remember to run code generation after changing custom helper mappings or adding new tags; otherwise, helpers won't be updated.
</Warning>

<Note>
When mapping pointer or nullable types, ensure your helper correctly handles zero-value vs. NULL distinctions.
</Note>

---

## 7. Summary and Next Steps

Now that you have learned customizing field helpers:

- **Map** your custom/complex Go types to specialized helpers using config and struct tags.
- **Define** expressive predicates and setters to encapsulate your domain conditions and updates.
- **Adapt** helpers for complex columns and nested types to maintain type safety and fluency.

Advance your mastery by exploring related guides:

- [Working with Associations: Patterns and Examples](/guides/advanced-patterns/association-operations) — managing related entities with generated helpers.
- [Template-based Queries: Building Flexible and Type-safe Queries](/guides/advanced-patterns/template-based-queries) — advanced SQL templating techniques.
- [Tailoring Code Generation with genconfig.Config](/guides/advanced-patterns/configuring-generation) — in-depth configuration customization.

For a refresher on using generated helpers, see [Using the Generated APIs in Your Project](/getting-started/first-steps-usage/using-generated-apis).

---

## Appendix: Example Custom JSON Helper (Summary)

```go
// JSON is a custom field helper for JSON columns
// Customize SQL generation based on DB dialect

type JSON struct{ column clause.Column }

func (j JSON) WithColumn(name string) JSON {
    c := j.column
    c.Name = name
    return JSON{column: c}
}

func (j JSON) Equal(path string, value any) clause.Expression {
    return jsonEqualExpr{col: j.column, path: path, val: value}
}

// jsonEqualExpr implements clause.Expression
func (e jsonEqualExpr) Build(builder clause.Builder) {
    switch stmt := builder.(*gorm.Statement); stmt.Dialector.Name() {
    case "mysql":
        // MySQL JSON_EXTRACT
    case "sqlite":
        // SQLite json_extract
    default:
        // Postgres jsonb_extract_path_text
    }
}
```

This snippet illustrates how your custom predicate can generate dialect-specific JSON query expressions.

---

For full code and deeper examples, refer to the GORM CLI repository and the linked guides in this documentation.


---