---
title: "Advanced: Creating and Using Custom Field Helpers (e.g., for JSON)"
description: "Walks through extending field helpers—like mapping a custom JSON field—with practical code for helper design, generation config, and usage. Explains database-specific SQL generation and integration with model tags."
---

# Advanced: Creating and Using Custom Field Helpers (e.g., for JSON)

## Workflow Overview

This guide walks you through how to extend GORM CLI by creating and integrating custom field helpers to support complex or database-specific data types, such as JSON fields. You'll learn how to:

- Design a custom field helper with database-aware SQL generation
- Configure code generation to recognize and use your custom helper
- Apply the custom helper in your Go models and query code

### Prerequisites

- Familiarity with basic GORM CLI usage, including model definitions and standard field helpers (see [Field Helper Basics](/guides/core-workflows/field-helper-basics))
- A working GORM CLI setup with code generation experience
- Basic understanding of Go generics and interfaces

### Expected Outcome

After completing this guide, you will have a custom field helper integrated into your generated code that:

- Maps a specialized Go field type (e.g., string representing JSON) to a fluent, type-safe field helper
- Generates database-specific SQL expressions seamlessly for different dialects (e.g., MySQL, SQLite, PostgreSQL) when querying JSON content
- Works naturally with the GORM CLI generation system and runtime query building

### Time Estimate

15–30 minutes, depending on familiarity with Go and GORM CLI

### Difficulty Level

Intermediate – Requires custom Go code and an understanding of SQL dialect differences

---

## Step-by-Step Instructions

<Steps>
<Step title="1. Declare Your Custom Field Helper Type">
Create a struct type in your project representing your custom field helper. Include the required method `WithColumn(string) YourType` to specify the database column name.

Example for JSON:

```go
package examples

import (
  "encoding/json"
  "gorm.io/gorm"
  "gorm.io/gorm/clause"
)

// JSON is a field helper for JSON columns with dialect-specific SQL generation.
type JSON struct {
  column clause.Column
}

// WithColumn sets the column name for this JSON field.
func (j JSON) WithColumn(name string) JSON {
  c := j.column
  c.Name = name
  return JSON{column: c}
}
```

This method allows the generator to assign database columns and for your helper to apply SQL clauses against that column.
</Step>

<Step title="2. Implement SQL Expression Methods">
Add methods generating database-specific SQL expressions targeting your field type. Use GORM's `clause.Expression` interface for adaptability.

Example — JSON field supporting equality and containment:

```go
// Equal builds an expression comparing JSON values at a JSON path.
func (j JSON) Equal(path string, value any) clause.Expression {
  return jsonEqualExpr{col: j.column, path: path, val: value}
}

type jsonEqualExpr struct {
  col  clause.Column
  path string
  val  any
}

func (e jsonEqualExpr) Build(builder clause.Builder) {
  if stmt, ok := builder.(*gorm.Statement); ok {
    switch stmt.Dialector.Name() {
    case "mysql":
      v, _ := json.Marshal(e.val)
      clause.Expr{SQL: "JSON_EXTRACT(?, ?) = CAST(? AS JSON)", Vars: []any{e.col, e.path, string(v)}}.Build(builder)
    case "sqlite":
      clause.Expr{SQL: "json_valid(?) AND json_extract(?, ?) = ?", Vars: []any{e.col, e.col, e.path, e.val}}.Build(builder)
    default:  // e.g. postgres
      clause.Expr{SQL: "jsonb_extract_path_text(?, ?) = ?", Vars: []any{e.col, e.path[2:], e.val}}.Build(builder)
    }
  }
}

// Contains checks if JSON column contains the given value (example).
func (j JSON) Contains(value any) clause.Expression {
  return clause.Expr{SQL: "JSON_CONTAINS(?, ?)", Vars: []any{j.column, value}}
}
```

These methods allow you to write expressive filters in your queries that behave correctly across multiple databases.
</Step>

<Step title="3. Configure the Generator to Map Your Field Helper">
Declare a package-level variable of type `genconfig.Config` in your code generation input package to map your custom field helper to fields marked by struct tags or custom Go types.

Example configuration mapping struct fields with the `gen:"json"` tag to your JSON helper:

```go
package examples

import (
  "gorm.io/cli/gorm/genconfig"
)

var _ = genconfig.Config{
  OutPath: "examples/output",
  FieldNameMap: map[string]any{
    "json": JSON{},  // Map fields tagged `gen:"json"` to JSON helper
  },
}
```

This informs GORM CLI to generate your JSON helper code for any struct field annotated with `gen:"json"`.
</Step>

<Step title="4. Annotate Your Model Struct">
Add the appropriate tag to your model struct field to trigger the generation of your custom field helper.

Example:

```go
package models

type User struct {
  ID      uint
  Name    string
  Profile string `gen:"json"` // Use custom JSON helper
}
```

The `gen:"json"` tag signals the generator to replace the default field helper with your custom JSON helper for this field.
</Step>

<Step title="5. Generate the Code">
Run the GORM CLI generator on your package. Your configuration and model will result in generated code including your JSON field helper integrated with the rest of the model fields.

Command example:

```bash
gorm gen -i ./examples -o ./generated
```

Confirm that your generated code contains the JSON helper with methods like `Equal()` and `Contains()`.
</Step>

<Step title="6. Use Your Custom Field Helper in Queries">
Once generated, you can use the new field helper method calls to build expressive, type-safe queries.

Example usage:

```go
ctx := context.Background()

// Find a user with Profile JSON field where $.vip is true
user, err := gorm.G[models.User](db).
  Where(generated.User.Profile.Equal("$.vip", true)).
  Take(ctx)

if err != nil {
  // Handle error
}

fmt.Println("Found VIP user:", user.Name)
```

This query generates the correct JSON SQL according to the current database dialect, abstracting the complexity.
</Step>
</Steps>

## Examples & Code Samples

### Complete JSON Helper Example

From the `examples/json_field.go` source:

```go
package examples

import (
  "encoding/json"
  "gorm.io/gorm"
  "gorm.io/gorm/clause"
)

type JSON struct {
  column clause.Column
}

func (j JSON) WithColumn(name string) JSON {
  c := j.column
  c.Name = name
  return JSON{column: c}
}

func (j JSON) Equal(path string, value any) clause.Expression {
  return jsonEqualExpr{col: j.column, path: path, val: value}
}

type jsonEqualExpr struct {
  col  clause.Column
  path string
  val  any
}

func (e jsonEqualExpr) Build(builder clause.Builder) {
  if stmt, ok := builder.(*gorm.Statement); ok {
    switch stmt.Dialector.Name() {
    case "mysql":
      v, _ := json.Marshal(e.val)
      clause.Expr{SQL: "JSON_EXTRACT(?, ?) = CAST(? AS JSON)", Vars: []any{e.col, e.path, string(v)}}.Build(builder)
    case "sqlite":
      clause.Expr{SQL: "json_valid(?) AND json_extract(?, ?) = ?", Vars: []any{e.col, e.col, e.path, e.val}}.Build(builder)
    default:
      clause.Expr{SQL: "jsonb_extract_path_text(?, ?) = ?", Vars: []any{e.col, e.path[2:], e.val}}.Build(builder)
    }
  }
}

func (j JSON) Contains(value any) clause.Expression {
  return clause.Expr{SQL: "JSON_CONTAINS(?, ?)", Vars: []any{j.column, value}}
}
```

### Code Generation Configuration Example

```go
package examples

import (
  "gorm.io/cli/gorm/genconfig"
)

var _ = genconfig.Config{
  OutPath: "examples/output",
  FieldNameMap: map[string]any{
    "json": JSON{},
  },
}
```

### Model Definition Example

```go
package models

type User struct {
  ID      uint
  Profile string `gen:"json"`
}
```

### Example Query Usage

```go
ctx := context.Background()

user, err := gorm.G[models.User](db).
  Where(generated.User.Profile.Equal("$.vip", true)).
  Take(ctx)

if err != nil {
  panic(err)
}

fmt.Println("VIP user found:", user.Name)
```

## Troubleshooting & Tips

<AccordionGroup title="Troubleshooting & Best Practices">
<Accordion title="Generator does not pick up custom field helper mappings">
Ensure your `genconfig.Config` is declared in the same package or directory where your models are defined and that you run the generator including that package path. The generator automatically detects this config if properly declared.
</Accordion>

<Accordion title="SQL syntax errors related to JSON functions">
Check that your database supports the JSON functions used in your SQL expressions (e.g., `JSON_EXTRACT` on MySQL, `json_extract` on SQLite). Some builds of SQLite require enabling JSON1 extension explicitly.
</Accordion>

<Accordion title="Custom field helper methods are not generated">
Verify that the model struct fields have the corresponding `gen` struct tag with the mapping key matching what you put in `FieldNameMap`.
</Accordion>

<Accordion title="Best Practices for Custom Field Helpers">
- Always implement `WithColumn(string)` method so the generator can assign the correct database column.
- Use GORM’s `clause.Expression` interface to build query fragments that respect SQL dialect differences.
- Test your helper on all target databases to confirm SQL correctness.
- Avoid using unsupported JSON paths or dialect-specific features without fallbacks.
</Accordion>
</AccordionGroup>

## Next Steps & Related Content

- Explore [Field Helper Basics](/guides/core-workflows/field-helper-basics) to master standard generated helpers.
- For advanced query customization, review [Template-Based Queries](/guides/advanced-patterns/template-sql-workflows).
- Customize code generation in detail with [Customizing Generation](/guides/advanced-patterns/customizing-generation).
- Use generated custom helpers in integration workflows as described in [Integrating Generated Code into Your GORM Projects](/guides/core-workflows/integrating-into-projects).


---