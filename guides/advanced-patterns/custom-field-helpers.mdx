---
title: "Defining and Using Custom Field Helpers (e.g., JSON)"
description: "Step through the process of mapping custom Go types, like JSON columns, to your own field helpers. See how to configure, implement, and use these helpers for idiomatic, multi-database-safe access patterns."
---

# Defining and Using Custom Field Helpers (e.g., JSON)

Customize how GORM CLI maps Go struct fields to generated field helpers by defining your own types like JSON. This guide walks you through configuring, implementing, and using custom field helpers so your queries remain idiomatic and multi-database safe.

---

## Workflow Overview

### What This Guide Helps You Accomplish

You will learn how to:

- Configure GORM CLI to recognize custom Go types or struct tags for field helpers.
- Implement a custom field helper that generates database-specific SQL expressions.
- Use these custom helpers in your queries for consistent, type-safe access.

### Prerequisites

- Familiarity with Go and GORM.
- Your project with Go structs modeling your database.
- Basic experience using GORM CLI to generate query APIs and field helpers.

### Expected Outcome

After completing this guide, you will be able to:

- Map a Go struct field (e.g., a JSON column) to a custom helper type.
- Leverage that custom helper to build expressive, database-safe query conditions.

### Time Estimate

About 15-25 minutes, depending on familiarity.

### Difficulty Level

Intermediate â€” involves Go code customization and generator configuration.

---

## Step-by-Step Instructions

### Step 1: Declare Your Generation Configuration

Create or update a package-level `genconfig.Config` variable to inform GORM CLI about your custom mapping.

```go
package examples

import (
    "gorm.io/cli/gorm/genconfig"
)

var _ = genconfig.Config{
    OutPath: "examples/output", // Optional: set output directory

    // Map the struct tag key to your custom JSON helper type
    FieldNameMap: map[string]any{
        "json": JSON{}, // tells generator to use JSON helper for fields tagged `gen:"json"`
    },
}
```

### Step 2: Annotate Your Model Fields

Tell the generator which fields should use your custom helper with struct tags.

```go
package models

// User model example

type User struct {
    ID      uint
    Name    string

    // Use `gen:"json"` to apply the custom JSON field helper
    Profile string `gen:"json"`
}
```

### Step 3: Implement the Custom Field Helper

Define your custom helper type capable of building correct SQL expressions for JSON operations.

Example JSON helper implementation:

```go
package examples

import (
    "encoding/json"
    "gorm.io/gorm/clause"
    "gorm.io/gorm"
)

// JSON is a custom field helper for JSON columns that adapts SQL for various DBs

type JSON struct{
    column clause.Column
}

// WithColumn associates the helper with a column name
func (j JSON) WithColumn(name string) JSON {
    c := j.column
    c.Name = name
    return JSON{column: c}
}

// Equal builds a DB-specific JSON comparison expression
func (j JSON) Equal(path string, value any) clause.Expression {
    return jsonEqualExpr{col: j.column, path: path, val: value}
}

// jsonEqualExpr handles generating the SQL clause per DB dialect

type jsonEqualExpr struct {
    col  clause.Column
    path string
    val  any
}

func (e jsonEqualExpr) Build(builder clause.Builder) {
    if stmt, ok := builder.(*gorm.Statement); ok {
        switch stmt.Dialector.Name() {
        case "mysql":
            v, _ := json.Marshal(e.val)
            clause.Expr{SQL: "JSON_EXTRACT(?, ?) = CAST(? AS JSON)", Vars: []any{e.col, e.path, string(v)}}.Build(builder)
        case "sqlite":
            clause.Expr{SQL: "json_valid(?) AND json_extract(?, ?) = ?", Vars: []any{e.col, e.col, e.path, e.val}}.Build(builder)
        default: // postgres, etc.
            clause.Expr{SQL: "jsonb_extract_path_text(?, ?) = ?", Vars: []any{e.col, e.path[2:], e.val}}.Build(builder)
        }
    }
}
```

### Step 4: Generate Code and Use Your Helper

Run `gorm gen` with your input files and the configuration declared to produce generated code.

Example usage in your application:

```go
import (
    "context"
    "gorm.io/gorm"
    "your/package/generated"
    "your/package/models"
)

func queryJSONValue(db *gorm.DB) error {
    ctx := context.Background()

    // Query users where JSON column 'profile' contains vip=true
    user, err := generated.User(db).
        Where(generated.User.Profile.Equal("$.vip", true)).
        Take(ctx)

    if err != nil {
        return err
    }

    // work with 'user'...
    return nil
}
```

### Step 5: Verify Generated Field Helper Includes Your Custom Type

After generation, inspect the generated field helpers and verify that fields tagged `json` are using your `JSON` helper type with methods like `Equal` available.

---

## Examples & Use Cases

### Mapping JSON Columns for User Profiles

```go
// Model

type User struct {
    ID      uint
    Profile string `gen:"json"` // use JSON helper
}

// Generation config
var _ = genconfig.Config{
    FieldNameMap: map[string]any{
        "json": JSON{},
    },
}

// Query usage
user, err := generated.User(db).
    Where(generated.User.Profile.Equal("$.settings.theme", "dark"))
    .Take(ctx)
```

This example queries users whose JSON `profile` field's `settings.theme` key is 'dark'. The generated SQL adapts to your DB dialect.

---

## Troubleshooting & Tips

<AccordionGroup title="Common Issues and Best Practices">
<Accordion title="GORM CLI does not generate using my custom helper">
Check that your `genconfig.Config` is in the correct package and properly imported. Also ensure the struct tag matches your `FieldNameMap` key exactly (e.g., "json") and re-run the generator.
</Accordion>

<Accordion title="SQL generated for JSON is not valid in my DB">
Make sure your custom helper implements the `clause.Expression` interface correctly adjusting SQL per dialect. Inspect the generated SQL snippets using GORM's logging to diagnose mis-generated queries.
</Accordion>

<Accordion title="Field helper method missing after generation">
Verify the custom helper you mapped has exported methods (e.g., `Equal`). The generator only exposes methods declared on the helper type.
</Accordion>

<Accordion title="Performance Consideration">
Use your JSON helper carefully in WHERE clauses to avoid full table scans. Index computed columns or ensure JSON queries align with your DB's indexing capabilities.
</Accordion>

</AccordionGroup>

<Tip>
Custom field helpers empower you to extend GORM CLI beyond basic types, preserving compile-time safety while accommodating database-specific features like JSON querying. Use them to model complex data patterns transparently in your generated APIs.
</Tip>

---

## Next Steps & Related Content

- Explore [Generating Type-Safe Query APIs](/overview/features-quicktour/query-api-generation) to enhance your query interfaces.
- Learn more about [Model-Driven Field & Association Helpers](/overview/features-quicktour/model-field-helpers) to understand default helper generation.
- See [Advanced Code Generation Configuration](/guides/core-workflows/configuring-generation) for deeper control of the generator.
- For custom SQL templates, refer to [Building Custom Queries with SQL Templates](/guides/advanced-patterns/template-queries).

---

## Summary Diagram of Custom Field Helper Mapping

```mermaid
flowchart TD
  A[Define genconfig.Config] --> B[Map "json" tag to JSON helper]
  B --> C[Annotate struct field with `gen:"json"`]
  C --> D[GORM CLI Generator]
  D --> E[Generate field helper with JSON type]
  E --> F[Use helper in fluent queries: Profile.Equal(path, value)]
  F --> G[Queries produce DB-specific JSON expressions]
```

This flow highlights how configuration and tags lead to generating and leveraging custom helpers.

---

For detailed reference, explore the example JSON helper implementation in the package `examples` and see how the `genconfig.Config` interacts with the generator.

---

*End of guide.*