---
title: "Configuring Code Generation with genconfig"
description: "Teaches how to fine-tune code generation through package-level genconfig.Config, including output directories, type and field mappings, and selective inclusion/exclusion of interfaces or structs. Includes real configuration samples for custom field mapping and interface filtering."
---

# Configuring Code Generation with genconfig

This guide teaches you how to fine-tune your code generation process in GORM CLI using the package-level `genconfig.Config`. You will learn how to customize output directories, define type and field mappings, and control which interfaces or structs get included or excluded during code generation. Real-world configuration examples are included to help you apply custom field mappings and interface filtering effectively.

---

## 1. Why Configure Code Generation?

By default, GORM CLI generates code for all qualifying interfaces and structs in your package, outputting files to a default directory. Configuring the generator with `genconfig.Config` gives you precise control over:

- Where the generated code is saved (`OutPath`)
- How Go types and specific field tags map to generated field helpers (`FieldTypeMap`, `FieldNameMap`)
- Which interfaces and structs are processed or skipped based on inclusion/exclusion filters
- Whether the configuration applies per file or per package (`FileLevel`)

This enables a cleaner, more maintainable generation process tailored to your project's requirements.

---

## 2. Prerequisites

Before using generation configuration:

- You have GORM CLI installed and working in your environment
- Your Go package contains model structs and query interfaces ready for code generation
- You understand basic Go struct and interface syntax
- You are familiar with running GORM CLI's `gen` command

---

## 3. Expected Outcome

After following this guide, you will be able to:

- Declare a `genconfig.Config` value at package level to override default generation behaviors
- Customize where generated code files are placed on disk
- Map custom Go types or struct tags to appropriate field helpers for richer generated code
- Selectively include or exclude specific interfaces and structs from generation
- Control configuration scope at package or file level

---

## 4. Time Estimate

This is an intermediate-level guide and should take approximately 15–30 minutes to fully understand and implement, depending on your familiarity with GORM CLI and your project complexity.

---

## 5. Step-by-Step Instructions

### Step 1: Import `genconfig` in Your Package

To declare configuration, import the `genconfig` package:

```go
import "gorm.io/cli/gorm/genconfig"
```

Also import any relevant packages for your type mappings.

### Step 2: Declare a Package-Level Config Variable

Create a package-level variable using the unnamed blank identifier pattern (`var _ = genconfig.Config{}`) to have the generator automatically pick up your settings.

Example:

```go
var _ = genconfig.Config{
    OutPath: "examples/output",
}
```

This changes the output directory for generated files in the current package to `examples/output`.

### Step 3: Customize Output Directory (`OutPath`)

Set `OutPath` to specify where to place generated files for this package. This path overrides the command line `-o` option for files in this package.

Example:

```go
var _ = genconfig.Config{
    OutPath: "custom/generated",
}
```

Make sure the directory exists or allow the generator to create it.

### Step 4: Map Go Types to Field Helpers (`FieldTypeMap`)

Control how Go types map to field helpers used in generated code. For example, use this to convert `sql.NullTime` fields into `field.Time` helpers.

Example:

```go
import (
    "database/sql"
    "gorm.io/cli/gorm/field"
)

var _ = genconfig.Config{
    FieldTypeMap: map[any]any{
        sql.NullTime{}: field.Time{},
    },
}
```

Here, any field of type `sql.NullTime` in your structs will generate with `field.Time` helpers.

### Step 5: Map Struct Tags to Field Helpers (`FieldNameMap`)

Use `FieldNameMap` to choose field helpers based on struct tags with `gen:"tag"`.

Example for JSON field handling:

```go
var _ = genconfig.Config{
    FieldNameMap: map[string]any{
        "json": JSON{}, // your custom JSON helper type
    },
}
```

Add the `gen:"json"` tag on struct fields to signal the generator to use the `JSON` helper.

### Step 6: Control Filtering of Interfaces and Structs

Use selective inclusion or exclusion lists to refine which interfaces or structs get code-generated.

- **IncludeInterfaces**: If non-empty, only interfaces matching these patterns or types will be generated.
- **ExcludeInterfaces**: After applying `IncludeInterfaces`, exclude any matching interfaces.
- **IncludeStructs** / **ExcludeStructs**: The same filtering applies for structs.

Example: Only generate interfaces starting with `Query`:

```go
var _ = genconfig.Config{
    IncludeInterfaces: []any{"Query*"},
}
```

Example: Include only `I1` interface and `S1` struct:

```go
var _ = genconfig.Config{
    IncludeInterfaces: []any{"I1"},
    IncludeStructs:    []any{"S1"},
}
```

### Step 7: Choose Scope: File-Level vs Package-Level (`FileLevel`)

By default, the configuration applies to the entire package. Set `FileLevel: true` if you want the config to only apply to the single file where the config literal is declared.

```go
var _ = genconfig.Config{
    FileLevel: true,
    OutPath: "file_specific_output",
}
```

### Step 8: Combine Multiple Configuration Options

You can define multiple fields as needed. Here is a comprehensive example:

```go
package examples

import (
    "database/sql"
    "gorm.io/cli/gorm/field"
    "gorm.io/cli/gorm/genconfig"
)

var _ = genconfig.Config{
    OutPath: "examples/output",
    FieldTypeMap: map[any]any{
        sql.NullTime{}: field.Time{},
    },
    FieldNameMap: map[string]any{
        "json": JSON{},
        "date": field.Time{},
    },
    IncludeInterfaces: []any{"Query*", models.Query(nil)},
    ExcludeInterfaces: []any{"*Deprecated*"},
    IncludeStructs:    []any{"User", "Account*", models.User{}},
    ExcludeStructs:    []any{"*DTO"},
}
```

### Step 9: Run the Generator

Invoke the generator in your project root or package:

```bash
gorm gen -i ./path/to/package
```

The generator will detect your `genconfig.Config` and honor the specified options.

### Step 10: Verify Generation

Check that:

- Generated files are placed in the configured `OutPath` directory
- Only the intended interfaces and structs appear in generated code
- Custom field types and tag-based mappings affect field helper types in output

---

## 6. Configuration Examples

### Example 1: Include Only Interfaces Starting with "Query"

File: `examples/filters/pattern/config.go`

```go
package pattern

import "gorm.io/cli/gorm/genconfig"

// Include only interfaces whose names start with "Query"
var _ = genconfig.Config{
    IncludeInterfaces: []any{"Query*"},
}
```

### Example 2: Whitelist Specific Interfaces and Structs

File: `examples/filters/whitelist/config.go`

```go
package whitelist

import (
    "gorm.io/cli/gorm/genconfig"
)

// Only generate I1 and S1
var _ = genconfig.Config{
    IncludeInterfaces: []any{"I1"},
    IncludeStructs:    []any{"S1"},
}
```

### Example 3: Map `sql.NullTime` and `gen:"date"` to `field.Time`

```go
package examples

import (
    "database/sql"
    "gorm.io/cli/gorm/field"
    "gorm.io/cli/gorm/genconfig"
)

var _ = genconfig.Config{
    OutPath: "examples/output",
    FieldTypeMap: map[any]any{
        sql.NullTime{}: field.Time{},
    },
    FieldNameMap: map[string]any{
        "date": field.Time{},
    },
}
```

---

## 7. Troubleshooting & Tips

- **Generator ignores your config file?** Make sure your `genconfig.Config` literal is declared at package scope (not inside a function) and uses the blank identifier (`var _ = genconfig.Config{...}`).

- **Files not generated in expected directory?** Verify that `OutPath` is correct and that directory permissions allow write access.

- **Interfaces or structs still generated unexpectedly?** Double-check your include/exclude patterns. Remember `Include*` takes precedence over `Exclude*`. Use explicit type literals (e.g., `models.User{}`) when needed.

- **Field helpers not applying your custom types?** Confirm the underlying Go types or tags match exactly, and use proper instances (e.g., `sql.NullTime{}` as key).

- **Scope control unexpected?** If you want config per file rather than per package, set `FileLevel: true`. Otherwise, `FileLevel: false` applies to the whole package subtree.

- **Combining multiple configs?** If you have multiple `genconfig.Config` literals at different package levels, the generator merges applicable configs based on path prefix and priority.

- **Check official examples:** GORM CLI’s `examples/filters` directory contains working filter configurations showing include/exclude patterns, type mappings, and file-level controls.

---

## 8. Next Steps & Related Content

- Explore the [Configuring Generation](https://docs.gorm.io/guides/advanced-patterns/generation-config) guide for deeper understanding and advanced techniques.
- Combine configuration with writing [Advanced SQL Templates](https://docs.gorm.io/guides/advanced-patterns/template-dsl) for powerful, dynamic queries.
- Use customized field helpers as explained in [Creating Custom Field Helpers](https://docs.gorm.io/guides/advanced-patterns/custom-field-helper).
- Follow the [Generating Code](https://docs.gorm.io/getting-started/first-run-usage/generating-code) and [Validating Generated Code](https://docs.gorm.io/getting-started/first-run-usage/quick-validation) guides to integrate generation config into your workflow.


---