---
title: "SQL Template DSL: Power and Flexibility"
description: "Hands-on walkthrough of the SQL templating DSL supported by the generator, including all supported directives, dynamic fragments, parameter binding, and conditional logic. Real-world examples help you write expressive, type-safe queries that adapt to your schema and use case."
---

# SQL Template DSL: Power and Flexibility

This guide provides a **hands-on walkthrough** of the SQL templating domain-specific language (DSL) supported by the GORM CLI generator. You'll learn how to leverage all supported directives, dynamic fragments, parameter binding, and conditional logic to write expressive, type-safe SQL queries tailored to your Go models and use cases.

By the end of this guide, you'll be empowered to write powerful SQL templates within your query interfaces that dynamically adapt based on your input data and schema, vastly increasing both expressiveness and safety.

---

## 1. Understanding the SQL Template DSL

The SQL Template DSL allows you to embed SQL fragments with dynamic behaviors right inside Go interface comments. The generator parses these templates and produces type-safe, fluent query APIs.

### Key DSL Directives

| Directive   | Purpose                                | Description & Example                                        |
|-------------|--------------------------------------|-------------------------------------------------------------|
| `@@table`   | Model table name placeholder          | Resolves to the underlying database table name.             |
| `@@column`  | Dynamic column binding                 | Allows column names to be specified dynamically.             |
| `@param`    | Parameter binding                     | Binds Go method parameters safely into the SQL.              |
| `{{where}}` | Conditional WHERE clause builder       | Wraps conditions that are added only if content exists.      |
| `{{set}}`   | Conditional SET clause builder         | Used for dynamically generating UPDATE set clauses.          |
| `{{if}}`    | Conditional SQL fragment               | Enables inline logic based on parameters.                     |
| `{{for}}`   | Iteration over collections             | Loops over slices or maps to dynamically build SQL lists.    |

<Tip>
Use these directives to reduce duplicated SQL code and make your queries adapt dynamically to input, improving safety and maintainability.
</Tip>

---

## 2. How to Write SQL Templates Using the DSL

### Step 1: Use `@@table` for Table Names
Anywhere in your SQL template where you need to refer to your model’s table, use `@@table`. This is resolved automatically to the correct table.

```sql
-- Correct usage
SELECT * FROM @@table WHERE id=@id
```

### Step 2: Bind Parameters with `@param`
Bind your method’s input parameters using `@param` syntax to avoid SQL injection and ensure correct value substitution.

```sql
-- Binds 'id' param safely
SELECT * FROM @@table WHERE id=@id
```

### Step 3: Use Dynamic Column Binding with `@@column`
Use `@@column` when columns can be dynamic strings passed to the method.

```sql
SELECT * FROM @@table WHERE @@column=@value
```

### Step 4: Add Conditional Clauses with `{{where}}`
Wrap optional WHERE conditions inside `{{where}}` blocks. Only if the inner condition yields content will the WHERE keyword be added.

```sql
SELECT * FROM @@table
{{where}}
  {{if name != ""}} name=@name {{end}}
  {{if age > 0}} AND age=@age {{end}}
{{end}}
```

### Step 5: Use `{{set}}` for Dynamic UPDATE SET Clauses
Use `{{set}}` to conditionally build SET clauses for updates.

```sql
UPDATE @@table
{{set}}
  {{if user.Name != ""}} name=@user.Name, {{end}}
  {{if user.Age > 0}} age=@user.Age {{end}}
{{end}}
WHERE id=@id
```

### Step 6: Leverage `{{if}}`, `{{else if}}`, `{{else}}` for Logic
Add simple if-else logic within templates for varied SQL generation.

```sql
SELECT * FROM @@table
  {{if user.ID > 0}}
    WHERE id=@user.ID
  {{else if user.Name != ""}}
    WHERE name=@user.Name
  {{end}}
```

### Step 7: Iterate Collections with `{{for}}`
Loop over slices/arrays to build complex conditions or IN lists.

```sql
SELECT * FROM @@table
{{where}}
  {{for _, tag := range tags}}
    {{if tag != ""}} tags LIKE concat('%',@tag,'%') OR {{end}}
  {{end}}
{{end}}
```

---

## 3. Practical Examples

### Example 1: Simple Parameter Binding
```go
// SELECT * FROM users WHERE id=@id AND status=@status
GetByIDAndStatus(id int, status string) (User, error)
```

### Example 2: Dynamic Column Filter
```go
// SELECT * FROM users WHERE @@column=@value
FilterWithColumn(column string, value string) (User, error)
```

### Example 3: Conditional WHERE Clause
```go
// SELECT * FROM users
// {{where}}
//   {{if name != ""}} name=@name {{end}}
//   {{if age > 0}} AND age=@age {{end}}
// {{end}}
FilterByNameAndAge(name string, age int) ([]User, error)
```

### Example 4: Dynamic UPDATE SET Clause
```go
// UPDATE users
// {{set}}
//   {{if user.Name != ""}} name=@user.Name, {{end}}
//   {{if user.Age > 0}} age=@user.Age {{end}}
// {{end}}
// WHERE id=@id
UpdateUser(user User, id int) error
```

---

## 4. Best Practices and Tips

- Always use `@param` for binding parameters to prevent SQL injection and ensure type safety.
- Wrap optional WHERE clauses inside `{{where}}`, never prepend `WHERE` manually when using conditional filtering.
- Use `{{set}}` for flexible UPDATE statements to avoid setting empty or zero values unintentionally.
- When iterating collections with `{{for}}`, ensure your slice elements are non-empty to avoid malformed SQL.
- Escape literal `@` in comments by using `\@` to avoid confusing the parser.

<Tip>
Start simple with static templates before adding complex conditional logic to prevent errors during code generation.
</Tip>

---

## 5. Common Pitfalls and Troubleshooting

### Problem: Missing WHERE Keyword
If conditions inside `{{where}}` don't output anything, no WHERE clause appears. This is expected; ensure the condition is correct.

### Problem: Unclosed Blocks or Syntax Errors
The SQL DSL parser expects matched `{{end}}` directives. Check all `{{if}}`, `{{for}}`, and function blocks (`{{where}}`, `{{set}}`) are properly closed.

### Problem: Dynamic Column or Table Doesn't Resolve
Only use `@@table` and `@@column` as documented. Other dynamic placeholders are not supported.

### Problem: Escaped `@` Not Recognized
Use `\@` to escape literals `@` characters in your SQL comment templates.

<Tip>
If code generation fails, check your SQL template for unbalanced or malformed constructs first.
</Tip>

---

## 6. How It Integrates Into Your Workflow

- Write your query interface methods with SQL template comments using the DSL.
- Run `gorm gen -i ./yourpackage -o ./generated` to generate the type-safe APIs.
- Use the generated APIs in your code, passing Go parameters mapped to your templates.
- Benefit from compile-time safety, rich dynamic querying, and clean separation of SQL logic and Go code.

---

## 7. Visualizing the SQL Template DSL Workflow

```mermaid
flowchart TD
  A[Define Go Interface with SQL Template Comments] --> B[SQL Template DSL Parsing]
  B --> C[Generate Go Method Code]
  C --> D[Provide Type-Safe Query APIs]
  D --> E[Execute Queries with Bound Parameters]
  E --> F[Database Executes Safe SQL]

  subgraph Parsing Details
    B --> B1[Identify Directives: @@table, @param, {{where}}, {{set}}, {{if}}, {{for}}]
    B --> B2[Build AST Nodes]
    B --> B3[Emit Go Code for SQL String & Params]
  end

  classDef directive fill:#f96,stroke:#333,stroke-width:2px;
  class B1 directive;
```

---

## 8. Related Resources

- [Model-Driven Field Helpers and Updates](../core-workflows/model-driven-field-helpers) — Combine DSL-generated queries with typed field helpers.
- [Working with Associations](../../advanced-patterns/working-with-associations) — Manage relationships alongside your templated queries.
- [Project Configuration](../../getting-started/first-steps/project-configuration) — Customize how DSL and generation behave.
- [Using Type-Safe Query APIs](../core-workflows/using-type-safe-query-apis) — Learn to consume the generated APIs.

---

## 9. Next Steps

- Experiment with adding conditional logic in your query interface comments.
- Use collections and iteration to build complex filters dynamically.
- Combine with model-driven field helpers for enhanced filtering and updates.
- Review generated code to see how templates translate into safe Go code.

<Tip>
Mastering this DSL unlocks the ability to write maintainable, safe, and powerful database queries tailored to any use case.
</Tip>

---

Happy coding with GORM CLI's SQL Template DSL!
