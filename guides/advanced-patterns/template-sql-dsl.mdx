---
title: "Using Template SQL & DSL in Custom Queries"
description: "In-depth exploration of the GORM CLI SQL template DSL for dynamic, type-checked queries. Demonstrates directive usage, placeholders, and conditional/iterative SQL generation for flexible, safe code."
---

# Using Template SQL & DSL in Custom Queries

## Overview

This guide provides an in-depth exploration of how to use GORM CLI's powerful SQL template Domain-Specific Language (DSL) to write dynamic, type-safe custom queries directly within your Go interface method comments. It explains the use of special directives, parameter placeholders, and control structures like conditionals and loops for flexible and safe SQL generation. By mastering this page, you will gain the ability to write expressive raw SQL queries seamlessly integrated with the generated type-safe APIs.

---

## What You Will Achieve

- Write custom SQL queries using the GORM CLI SQL template DSL embedded in Go method comments.
- Utilize placeholders like `@@table`, `@@column`, and `@param` for safe and dynamic SQL binding.
- Apply conditional (`{{if}}`), iterative (`{{for}}`), and block directives (`{{where}}`, `{{set}}`) to generate complex SQL fragments.
- Understand how parameters map to method arguments and models.
- Use examples to write flexible SELECT and UPDATE queries that adapt to input values.

---

## Prerequisites

Before using the SQL template DSL effectively, ensure you have:

- Installed GORM CLI and have a Go development environment with Go 1.18+.
- Defined your Go model structs mapping to your database schema.
- Created Go interfaces containing method signatures with embedded SQL template comments for queries.
- Basic familiarity with SQL, Go generics, and templating syntax.

---

## Understanding the SQL Template DSL

The GORM CLI SQL template DSL allows you to embed SQL statements with templating capabilities inside method comments on your query interfaces. These templates get parsed and generate strongly typed Go code to execute the described queries.

### Key Template Directives and Elements

| Directive / Placeholder | Description | Example Usage |
|-------------------------|-------------|---------------|
| `@@table` | Resolves automatically to the current model's table name. Saves hardcoding table names.| `SELECT * FROM @@table WHERE id=@id` |
| `@@column` | Dynamically resolves a column name based on method parameter strings.| `SELECT * FROM @@table WHERE @@column=@value` |
| `@param` | Binds the Go method parameter or struct field to a SQL parameter safely.| `WHERE name=@user.Name` |
| `{{where}} ... {{end}}` | Wraps conditional WHERE clause components that appear only if inner content is non-empty.|```sql
SELECT * FROM @@table
{{where}}
  {{if condition}} column=@value {{end}}
{{end}}
```|
| `{{set}} ... {{end}}` | Used inside UPDATE queries to conditionally emit SET clause content.|```sql
UPDATE @@table
{{set}}
  {{if user.Name != ""}} name=@user.Name, {{end}}
{{end}}
WHERE id=@id
```|
| `{{if condition}} ... {{else}} ... {{end}}` | Conditional blocks that allow branching in query generation.|```go
{{if user.Age >= 18}} is_adult=1 {{else}} is_adult=0 {{end}}
```|
| `{{for ...}} ... {{end}}` | Iterates over slices to generate repeated SQL fragments.|```sql
{{for _, user := range users}}
  (name=@user.Name AND age=@user.Age) OR
{{end}}
```|

### How Parameters Bind

- Method parameters and struct fields referred to by the `@` placeholder are automatically mapped as SQL parameters.
- Placeholders like `@id` or `@user.Name` pull from the named method parameter or the struct field.
- The generator emits Go code that builds SQL strings and aggregates parameters in order for safe binding.

---

## Step-by-Step: Writing Template SQL Queries

<Steps>
<Step title="1. Define Query Interface Method with SQL Template">
Write the Go interface method with a descriptive signature, and place the SQL template inside the method comment just above the signature. Use placeholders and directives to express your query logic.

```go
// SELECT * FROM @@table WHERE id=@id
GetByID(id int) (T, error)
```

</Step>
<Step title="2. Use @@table and @@column for Dynamic Table/Column Names">
Replace hardcoded table and column names using `@@table` and `@@column` for flexibility, particularly when columns depend on method params.

```go
// SELECT * FROM @@table WHERE @@column = @value
FilterWithColumn(column string, value string) (T, error)
```

</Step>
<Step title="3. Implement Conditional WHERE Clauses with {{where}} and {{if}}">
Wrap optional WHERE conditions inside `{{where}}` blocks; use `{{if}}` to conditionally add filters based on parameter values.

```go
// SELECT * FROM @@table
// {{where}}
//    {{if user.Name != ""}} name=@user.Name {{end}}
//    {{if user.Age > 0}} AND age=@user.Age {{end}}
// {{end}}
QueryWith(user models.User) (T, error)
```

</Step>
<Step title="4. Use {{set}} for Conditional UPDATE SET Clauses">
In update methods, generate only relevant assignments inside `{{set}}` blocks filtering for non-empty or meaningful fields.

```go
// UPDATE @@table
// {{set}}
//    {{if user.Name != ""}} name=@user.Name, {{end}}
//    {{if user.Age > 0}} age=@user.Age, {{end}}
// {{end}}
// WHERE id=@id
UpdateInfo(user User, id int) error
```
</Step>
<Step title="5. Iterate Over Collections with {{for}}">
Loop over slices to build queries dynamically with `{{for ...}}`.

```go
// SELECT * FROM @@table
// {{where}}
//    {{for _, user := range users}}
//      (name=@user.Name AND age=@user.Age) OR
//    {{end}}
// {{end}}
Filter(users []User) ([]T, error)
```
</Step>
</Steps>

---

## Practical Examples

### Example 1: Simple Find by ID

```go
// SELECT * FROM @@table WHERE id=@id
GetByID(id int) (User, error)
```

After generation, calling `GetByID(ctx, 123)` safely binds `123` to `id`.

### Example 2: Dynamic Column Filter

```go
// SELECT * FROM @@table WHERE @@column=@value
FilterWithColumn(column string, value string) (User, error)
```

Use this to filter by any column, e.g., `FilterWithColumn("name", "alice")`.

### Example 3: Conditional Query Based on Struct Fields

```go
// SELECT * FROM @@table
// {{where}}
//  {{if user.ID > 0}} WHERE id=@user.ID {{else if user.Name != ""}} WHERE name=@user.Name {{end}}
QueryWith(user User) ([]User, error)
```

Query adapts based on which field (`ID` or `Name`) is non-zero.

### Example 4: Conditional UPDATE SET Clause

```go
// UPDATE @@table
// {{set}}
//  {{if user.Name != ""}} name=@user.Name, {{end}}
//  {{if user.Age > 0}} age=@user.Age, {{end}}
// {{end}}
// WHERE id=@id
UpdateUser(user User, id int) error
```

Only non-empty fields update columns.

### Example 5: Iteration Over Multiple Users

```go
// SELECT * FROM @@table
// {{where}}
//   {{for _, user := range users}}
//     {{if user.Name != "" && user.Age > 0}}
//       (name=@user.Name AND age=@user.Age) OR
//     {{end}}
//   {{end}}
// {{end}}
Filter(users []User) ([]User, error)
```

Creates a WHERE clause testing multiple user conditions combined with OR.

---

## Tips and Best Practices

- **Always use `@@table` instead of hardcoding table names** to maintain reusability and DRY principles.
- Use parameter placeholders `@param` consistently to ensure proper SQL parameter binding and prevent SQL injection.
- Combine `{{where}}` blocks with `{{if}}` checks to produce clean WHERE clauses that omit empty or zero-value filters.
- When writing UPDATE queries, use `{{set}}` with conditional statements so your SET clauses stay succinct and only update meaningful fields.
- Employ `{{for}}` loops for batch filtering scenarios but ensure filters within iterations properly guard against empty values.
- Indent your template comments for readability, but the generator trims and processes ignoring whitespace.

---

## Troubleshooting Common Issues

<AccordionGroup title="Common Problems with Template SQL">
<Accordion title="Query methods not generating expected SQL">
Check that your SQL template comments are correctly formatted and immediately precede the interface method signature. Ensure placeholders exactly match parameter names. Review that all `{{end}}` directives are balanced.
</Accordion>
<Accordion title="Unbound parameters or incorrectly ordered parameters">
Verify that all placeholders `@param` correspond to method parameters or struct fields. Avoid typos and maintain consistent casing. The generator automatically appends parameters in the order they appear.
</Accordion>
<Accordion title="Empty WHERE or SET clauses generate invalid SQL">
Use the `{{where}}` or `{{set}}` blocks to make clauses conditional on inner content. Wrapping conditionals inside these blocks avoids empty clause emission.
</Accordion>
<Accordion title="Escaping '@' characters in SQL literals">
Use `\@` inside your SQL template to emit a literal '@' symbol. The template processor recognizes this escape to prevent substitution.
</Accordion>
<Accordion title="Complex conditional logic not working as expected">
Ensure your conditions inside `{{if}}` blocks use valid Go expression syntax matching your parameter types. Use `else if` and `else` branches correctly.
</Accordion>
</AccordionGroup>

---

## Next Steps & Related Content

- After mastering template SQL, explore [Generating & Using Type-Safe Query APIs](/guides/core-workflows/generating-and-using-query-apis) to see how your templates translate to usable APIs.
- Learn how to combine these queries with [Model-Driven Field Helper Generation](/guides/core-workflows/model-driven-field-helpers) for powerful expressive queries.
- Deep dive into [Customizing Code Generation & Field Mapping](/guides/advanced-patterns/customizing-code-generation) to refine helper types and generation parameters.
- Understand [Working with Associations & Relationships](/guides/advanced-patterns/working-with-associations) to extend your modeling to related data.

---

## Glossary

| Term | Meaning |
| -------- | -------- |
| `@@table` | Special placeholder replaced with the database table name of the associated model.
| `@@column` | Placeholder for dynamic column names supplied as method parameters.
| `@param` | Binds Go function parameters or struct fields safely into SQL.
| `{{where}}` | Template block wrapping conditional WHERE clauses, emitted only if conditions exist.
| `{{set}}` | Template block wrapping conditional UPDATE SET clauses.
| `{{if}}` / `{{else}}` | Conditional branching inside templates.
| `{{for}}` | Loop construct to repeat SQL fragments for slices or collections.

---

Mastering these concepts empowers you to craft maintainable, flexible, and safe custom queries directly linked to your domain models, while retaining full compile-time type safety using GORM CLI's generated code.
