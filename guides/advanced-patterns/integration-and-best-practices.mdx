---
title: "Integration & Best Practices"
description: "Recommendations for integrating GORM CLI into real projects: directory layout, build pipeline automation, versioning strategies, and performance tips for large models and codebases."
---

# Integration & Best Practices

## Overview
This guide offers practical recommendations for integrating GORM CLI into your Go projects effectively. It focuses on structuring your project directories for clarity, automating your build pipeline with code generation steps, managing versioning strategies for generated code, and optimizing performance when working with large models and extensive codebases.

By following these best practices, you ensure that your use of GORM CLI is maintainable, scalable, and aligned with enterprise development workflows.

---

## 1. Directory Layout

Organizing your code and generated files consistently is foundational to a smooth development experience with GORM CLI.

### Recommended Structure

```
/my-go-project
  /cmd
    /app
      main.go
  /internal
    /models      # Your domain model structs
    /queries     # Query interfaces with SQL templates
  /generated     # Auto-generated code (output directory)
  /scripts       # Build and generation scripts
  go.mod
```

- **Models**: Keep your Go structs representing database tables here. These are the source of your field helpers.
- **Queries**: Define your interfaces with embedded SQL annotations here. GORM CLI generates query API implementations from these.
- **Generated**: Configure your GORM CLI output to place generated code in a dedicated directory â€” keep it separate from hand-written code.

### Configuration Example

Set the `genconfig.Config` in your package to place generated files neatly:

```go
var _ = genconfig.Config{
  OutPath: "../generated",
}
```

This keeps generated code isolated, simplifying version control and clean rebuilds.


<Note>
Maintaining consistent directory structures across teams reduces onboarding friction and eases tooling integration.
</Note>

---

## 2. Build Pipeline Automation

Automate invocation of GORM CLI code generation to keep generated code up to date with your models and queries.

### Integration Steps

1. **Add Generation Command to Your Build Process**

   Use your Makefile, shell script, or task runner to invoke:

   ```bash
gorm gen -i ./internal/queries -o ./generated
```

   - `-i`: Input path to your query interface files
   - `-o`: Output path for generated code

2. **Separate Generation from Compilation**

   Because generated code may depend on your models and interfaces, run generation **before** compiling your application.

3. **Regenerate on Source Changes**

   Integrate file watchers or CI pipeline steps to regenerate the code whenever you change interfaces or models.

4. **Error Handling**

   Fail build or pipeline if generation fails. This ensures safety and consistency.

### Makefile Example

```makefile
.PHONY: gen

gen:
	gorm gen -i ./internal/queries -o ./generated

build: gen
	go build -o bin/app ./cmd/app
```

### CI Pipeline Example

```yaml
steps:
  - name: Generate GORM CLI Code
    run: gorm gen -i ./internal/queries -o ./generated
  - name: Build Application
    run: go build -o bin/app ./cmd/app
```

<Info>
Keep your generation deterministic: ensure `genconfig.Config` files are checked into source control and referenced correctly to avoid surprises.
</Info>

---

## 3. Versioning Strategies

Managing generated code versions ensures maintainability and avoids conflicts.

### Best Practices

- **Commit Generated Code When Necessary**

  - For small or stable projects, commit generated code to source control to simplify builds for team members.
  - For large or CI-driven projects, consider keeping generated code out of VCS and only generate during CI/build.

- **Keep Generator Versions Consistent**

  Pin GORM CLI version in your build files or `go.mod` using:

  ```bash
go install gorm.io/cli/gorm@vX.Y.Z
```

- **Clean Generated Code on Major Changes**

  When upgrading GORM CLI versions or changing generation config, clean (delete) the output folder to force complete regeneration.

- **Use Semantic Version Tags**

  Version your generated packages using module versioning to trace compatibility.

<Warning>
Avoid manual edits in generated code; apply changes to query interfaces or models, then regenerate to avoid conflicts.
</Warning>

---

## 4. Performance Considerations

Large models and complex query interfaces may increase generation time and output size. Keep performance smooth with the following tips.

### Tips to Optimize Generation and Runtime

- **Scope Generation with Config Filters**

  Use `IncludeInterfaces` and `ExcludeInterfaces` or `IncludeStructs` and `ExcludeStructs` in your `genconfig.Config` to limit generation only to interfaces and structs you need.

```go
var _ = genconfig.Config{
  IncludeInterfaces: []any{"Query*"},
  ExcludeInterfaces: []any{"*Deprecated*"},
  IncludeStructs:    []any{"User", "Account*"},
  ExcludeStructs:    []any{"*DTO"},
}
```

- **Generate at File Level**

  Use `FileLevel: true` to apply config per file instead of whole package. This enables more granular control.

- **Avoid Over-Complex SQL Templates**

  Keep SQL templates readable and maintainable. Break queries into smaller, reusable methods if possible.

- **Incremental Generation**

  Changes in one interface or model only trigger partial regeneration, reducing build times.

- **Background Generation**

  For very large schemas, consider running generation asynchronously or off the critical path.

- **Profile Generation Time**

  Enable verbose logs and monitor generation to identify bottlenecks when dealing with thousands of structs or interfaces.

<Info>
Using minimal necessary scope in generation reduces both build times and binary size.
</Info>

---

## Summary
| Area                  | Recommendations                                                                                  |
|-----------------------|------------------------------------------------------------------------------------------------|
| Directory Layout      | Separate models, queries, and generated code clearly; configure output folder via `genconfig`.  |
| Build Automation      | Run `gorm gen` as part of your build pipeline before compilation; fail on generation errors.     |
| Versioning            | Pin generator versions, optionally commit generated code, and avoid manual edits.               |
| Performance           | Scope generation with include/exclude config; use file-level configs; keep SQL templates simple. |

---

## Troubleshooting & Tips

### Common Issues
- **Generated Code Not Updated**

  Ensure you run `gorm gen` after each change to interfaces/models.

- **Incorrect Paths or Output**

  Double-check your `-i` and `-o` command flags and any `OutPath` in `genconfig.Config`.

- **Version Mismatch Errors**

  Confirm GORM CLI version matches the one expected by your project.

### Best Practices
- Keep your `genconfig.Config` files close to the interfaces they configure.
- Document your generation commands in project README or build scripts.
- Regularly run generation locally to catch issues early.

---

## Next Steps & Related Content

- **[Project Setup & Model Definition](../getting-started/configuration/project-setup)**: Organizing models and query interfaces efficiently.
- **[Configuring the Generator](../getting-started/configuration/generator-configuration)**: Customizing generation behavior.
- **[Running the First Code Generation](../getting-started/configuration/generating-code)**: Step-by-step generation instructions.
- **[Building Type-Safe Queries](../guides/core-workflows/type-safe-queries)**: Leveraging generated APIs.
- **[Working with Associations](../guides/advanced-patterns/working-with-associations)**: Managing relationships in generated code.
- **[Troubleshooting Common Issues](../getting-started/validation/troubleshooting)**: Solutions to frequent problems.

---

By adopting these integration and best practice recommendations, your team will maximize the benefits of using GORM CLI, maintain code quality, and streamline database API development.

---