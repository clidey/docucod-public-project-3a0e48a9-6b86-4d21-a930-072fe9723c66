---
title: "Writing Advanced SQL Templates with the Embedded DSL"
description: "Shows how to leverage the GORM CLI template DSL to create highly expressive, type-safe queries directly from Go interfaces. Covers use of directives, dynamic column/field resolution, conditional SQL fragments, and iteration for custom queries."
---

# Writing Advanced SQL Templates with the Embedded DSL

Leverage the power of GORM CLI's embedded SQL template DSL to write flexible, expressive, and type-safe database queries directly in your Go interfaces. This guide demystifies how to harness directives, dynamic placeholders, conditional SQL fragments, and iteration constructs to craft custom, safe queries tailored to your application's logic.

---

## 1. Understanding the Embedded SQL Template DSL

GORM CLI enables you to embed SQL templates into Go interface method comments. These templates use an intuitive DSL that automatically binds Go parameters, handles dynamic table/column resolution, and lets you write conditionals and loops directly in SQL.

### Core Directive Elements

| Directive         | Purpose                                                | Example Usage                                    |
|-------------------|--------------------------------------------------------|-------------------------------------------------|
| `@@table`         | Resolves to the current model's table name             | `SELECT * FROM @@table WHERE id=@id`            |
| `@@column`        | Dynamically bind column names                           | `SELECT * FROM @@table WHERE @@column=@value`   |
| `@param`          | Binds Go method parameters to SQL parameters safely    | `WHERE name=@user.Name AND age=@user.Age`       |
| `{{where}}`       | Wrapper for conditional `WHERE` clauses                | `{{where}} age > 18 {{end}}`                     |
| `{{set}}`         | Wrapper for conditional `SET` clauses in updates       | `{{set}} name=@name, age=@age {{end}}`           |
| `{{if condition}}`| Inserts SQL fragments conditionally                     | `{{if user.Age > 18}} AND is_adult=1 {{end}}`   |
| `{{for ...}}`     | Iterates over collections to generate repetitive SQL   | `{{for _, tag := range tags}} tag=@tag OR {{end}}` |

### Key Advantages

- **Complete Type Safety**: Bindings ensure SQL parameters match Go types.
- **Dynamic SQL Construction**: Compose queries dynamically without hand-coding string concatenations.
- **Expressive Logic**: Embed if/else, loops, and placeholders for flexible queries.
- **Automatic Parameter Handling**: All placeholders convert transparently to positional parameters and Go slices.

<Check>
The embedded DSL abstracts away tedious SQL string manipulation, letting you focus on business logic in your query interfaces.
</Check>

---

## 2. Writing SQL Templates in Go Interfaces: Step-by-Step

Let's walk through how to write advanced SQL templates within your Go interfaces to unlock precise control over query generation.

### Step 1: Define Your Interface and Method

Write a method inside an interface, aiming to build a query with advanced conditional logic or loops.

```go
// Your interface example
type Query[T any] interface {
    // Your method(s) 
}
```

### Step 2: Add SQL Template Comments Using the DSL

In the method comment, embed the SQL template:

- Use `@@table` as a placeholder for the model's table name.
- Use `@param` syntax to bind Go parameters.
- Wrap conditional filters in `{{where}}` blocks.
- Use `{{set}}` blocks for update statements.
- Employ `{{if}}`, `{{else if}}`, `{{else}}`, and `{{end}}` directives for branching logic.
- Use `{{for}}` loop to iterate over slices or arrays in parameters.

Example:

```go
// Query users with optional filters
//
// SELECT * FROM @@table
// {{where}}
//   {{if user.Name != ""}}
//     name=@user.Name
//   {{end}}
//   {{if user.Age > 0}}
//     AND age=@user.Age
//   {{end}}
// {{end}}
SearchUsers(user User) ([]T, error)
```

### Step 3: Handle Dynamic Columns and Parameters

When column names are dynamic based on parameters, use `@@column` and `@param` to safely bind without risking SQL injection.

```go
// SELECT * FROM @@table WHERE @@column=@value
FilterByColumn(column string, value any) (T, error)
```

### Step 4: Use Iteration for Complex Filters

For filters that must loop over a slice:

```go
// SELECT * FROM @@table
// {{where}}
//   {{for _, tag := range tags}}
//     {{if tag != ""}}
//       tags LIKE concat("%",@tag,"%") OR
//     {{end}}
//   {{end}}
// {{end}}
FilterByTags(tags []string) ([]T, error)
```

### Step 5: Compose Update Statements Dynamically

Use the `{{set}}` block with conditions to update only fields that satisfy criteria:

```go
// UPDATE @@table
// {{set}}
//    {{if user.Name != ""}} name=@user.Name, {{end}}
//    {{if user.Age > 0}} age=@user.Age, {{end}}
// {{end}}
// WHERE id=@id
UpdateUser(user User, id int) error
```

---

## 3. Real-World Examples & Patterns

### Example 1: Conditional Filtering

```go
// GetByID fetches an entity by its ID only
//
// SELECT * FROM @@table WHERE id=@id AND name="@name"
GetByID(id int) (T, error)
```

Generated SQL snippet:

```go
var sb strings.Builder
params := make([]any, 0, 2)
sb.WriteString("SELECT * FROM ? WHERE id=? AND name = \"@name\"")
params = append(params, clause.Table{Name: clause.CurrentTable}, id)
```

### Example 2: Iteration with Filtering

```go
// Filter users by name, age, and role patterns
//
// SELECT * FROM @@table
// {{where}}
//   {{for _, user := range users}}
//     {{if user.Name != "" && user.Age > 0}}
//       (name = @user.Name AND age=@user.Age AND role LIKE concat("%",@user.Role,"%")) OR
//     {{end}}
//   {{end}}
// {{end}}
Filter(users []User) ([]T, error)
```

The generator converts this loop into Go iteration appending parameters and conditions.

### Example 3: Update with Conditional Fields

```go
// UpdateInfo updates User info conditionally
//
// UPDATE @@table
// {{set}}
//   {{if user.Name != ""}} name=@user.Name, {{end}}
//   {{if user.Age > 0}} age=@user.Age, {{end}}
//   {{if user.Age >= 18}} is_adult=1 {{else}} is_adult=0 {{end}}
// {{end}}
// WHERE id=@id
UpdateInfo(user User, id int) error
```

The code generator produces a composite set clause string that includes only the provided fields.

---

## 4. Best Practices & Tips

- **Always escape literals with `\@`**: To include literal `@` character in SQL, escape it as `\@`.
- **Use `@@table` to bind the model's table**: Avoid hardcoding table names to maintain flexibility.
- **Keep logic inside `{{if}}` blocks minimal**: Limit logic complexity for better maintainability and generator compatibility.
- **Validate generated Go code**: Use `go fmt` or the CLI tooling's output verification to catch template errors early.
- **Use iteration (`{{for}}`) for slice parameters**: This enables bulk-like queries without repetitive manual SQL.
- **Avoid double quoting placeholders**: The generator injects parameters safely; adding extra quotes can cause errors.
- **Always end control blocks with `{{end}}`**: Proper closure is mandatory to prevent parse errors.

---

## 5. Troubleshooting Common Issues

<AccordionGroup title="Common SQL Template Pitfalls">
<Accordion title="Unclosed Block Errors">
You may see errors like "unclosed block(s) at EOF" if you forget to close `{{if}}`, `{{for}}`, or `{{where}}` blocks with `{{end}}`.

**Solution:** Double-check your comment indentation and ensure every `{{` directive has a matching `{{end}}`.
</Accordion>
<Accordion title="Incorrect Parameter Binding or Compilation Errors">
If your SQL placeholder syntax is incorrect (e.g., missing `@` or unescaped `@`), the generated code may not compile.

**Solution:** Review placeholders, using `@param` for variables, `@@table` for tables, and escape literal '@' as `\@`.
</Accordion>
<Accordion title="Unexpected SQL Output or Extra Commas">
In `{{set}}` blocks especially, trailing commas can produce invalid SQL.

**Solution:** Use the generator's trimming and trimming logic features. Avoid manually ending lines with commas inside blocks when possible.
</Accordion>
</AccordionGroup>

<Tip>
Use the included `internal/gen/sqlparser.go` module as the reference implementation of the DSL parser and generator. It is designed to produce clean, safe Go code from your SQL template comments.
</Tip>

---

## 6. Next Steps & Further Learning

- Explore [Configuring Code Generation with genconfig](/guides/advanced-patterns/generation-config) to customize generation outcomes.
- Learn about [Using Model-Driven Field Helpers](/guides/core-getting-started/field-helper-basics) to complement your custom queries.
- Practice by generating code and inspecting the output for your complex interfaces.
- Dive into [Best Practices for Interface Design and Query Safety](/guides/practices-integration/practices-patterns) for safer API modeling.

---

## 7. Reference Example Snippet (from examples/query.go)

```go
// GetByID query data by id and return it as struct
//
// SELECT * FROM @@table WHERE id=@id AND name = "\@name"
GetByID(id int) (T, error)

// FilterWithColumn filters based on dynamic column
// SELECT * FROM @@table WHERE @@column=@value
FilterWithColumn(column string, value string) (T, error)

// UpdateInfo updates user information conditionally
// UPDATE @@table
//  {{set}}
//    {{if user.Name != ""}} name=@user.Name, {{end}}
//    {{if user.Age > 0}} age=@user.Age, {{end}}
//    {{if user.Age >= 18}} is_adult=1 {{else}} is_adult=0 {{end}}
//  {{end}}
// WHERE id=@id
UpdateInfo(user User, id int) error
```

---

## Diagram: Embedded SQL Template Processing Flow

```mermaid
flowchart TD
  Start([Start SQL Template Parsing]) --> Lexer[Tokenize template lines]
  Lexer --> Parser{Directive?}
  Parser -->|Text| PlainText[Append TextNode]
  Parser -->|{{where}} or {{set}}| FuncNode[Create FuncNode]
  Parser -->|{{for}}| ForNode[Create ForNode with expression]
  Parser -->|{{if}}| IfNode[Create IfNode and first branch]
  Parser -->|{{else if}}| AddBranch[Add if branch]
  Parser -->|{{else}}| ElsePart[Switch to else branch]
  Parser -->|{{end}}| CloseBlock[Close current block]
  PlainText --> Parser
  FuncNode --> Parser
  ForNode --> Parser
  IfNode --> Parser
  CloseBlock --> Parser
  Parser -->|EOF| CodeGen[Generate Go code snippet]
  CodeGen --> End([Return final Go code for method body])
```

This flow illustrates GORM CLI’s parsing and code generation from templates to Go code.

---