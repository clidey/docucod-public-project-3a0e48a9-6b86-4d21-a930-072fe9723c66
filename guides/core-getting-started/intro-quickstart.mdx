---
title: "Quickstart: Generate Your First Query API"
description: "Walk through the foundational process of writing a query interface and GORM model, running the code generator, and consuming the resulting fluent API. This page guides users from zero to a working example with step-by-step command-line instructions and sample code."
---

# Quickstart: Generate Your First Query API

This guide walks you through creating your first type-safe query API using GORM CLI. You will write a query interface with embedded SQL templates, define your GORM model struct, run the code generator from the command line, and use the resulting fluent API in your Go project.

---

## 1. What You'll Accomplish

- Write a Go interface defining query methods with SQL templates
- Associate the interface with your GORM model structs
- Generate concrete, type-safe query APIs and field helpers
- Use the generated API to perform database queries with complete compile-time safety

---

## 2. Prerequisites

Before starting, ensure you have:

- Go 1.18+ installed (required for generics support)
- GORM ORM library installed and set up in your project
- GORM CLI tool installed (`go install gorm.io/cli/gorm@latest`)
- A Go module initialized for your project
- Basic familiarity with Go interfaces and struct definitions


---

## 3. Step-by-Step Quickstart

Follow these sequential steps to go from zero to a working generated query API.

<Steps>

<Step title="Step 1: Define Your GORM Model Struct">
Define a struct representing a database table. This model will be the basis for generated field helpers and query APIs.

```go
package models

import "gorm.io/gorm"

type User struct {
  gorm.Model
  Name string
  Age  int
}
```

This example defines a simple `User` struct with standard fields.
</Step>

<Step title="Step 2: Write a Query Interface with SQL Templates">
In the same package or directory, define an interface embedding raw SQL templates as method comments. Use the GORM CLI DSL placeholders

```go
package examples

import "gorm.io/cli/gorm/examples/models"

type Query[T any] interface {

  // SELECT * FROM @@table WHERE id=@id
  GetByID(id int) (T, error)

  // where("name=@name AND age=@age")
  FilterByNameAndAge(name string, age int)
}
```

Key points:
- `@@table` resolves to your model's database table
- `@param` binds method parameters to SQL parameters
- You must return the model type (`T`) and error as appropriate

</Step>

<Step title="Step 3: Run the Code Generator">
Run the CLI generator to produce concrete implementations and field helpers.

```bash
gorm gen -i ./examples -o ./generated
```

Replace `./examples` with the package/directory containing your model and interface, and `./generated` with your preferred output path.

Expected result:
- Generated Go files in `./generated`
- Type-safe query API implementations
- Model field helpers for fluent filtering and sorting

</Step>

<Step title="Step 4: Use the Generated API in Your Code">
Import and use the generated package to call your newly generated APIs.

```go
package main

import (
    "context"
    "fmt"
    "gorm.io/gorm"
    "your_project/generated"
    "your_project/models"
)

func main() {
  var db *gorm.DB // initialized GORM DB
  ctx := context.Background()

  // Query user by ID
  user, err := generated.Query[models.User](db).GetByID(ctx, 123)
  if err != nil {
    panic(err)
  }
  fmt.Printf("User: %+v\n", user)

  // Filter users by name and age
  builder := generated.Query[models.User](db).FilterByNameAndAge("jinzhu", 25)
  var users []models.User
  err = builder.Find(ctx).Scan(&users)
  if err != nil {
    panic(err)
  }
  fmt.Printf("Filtered Users: %+v\n", users)
}
```

The generated API offers methods corresponding to your interface with fluent chaining and compile-time safety.

</Step>

</Steps>

---

## 4. Detailed Explanation and Best Practices

### Writing Query Interfaces

- Keep interfaces small and focused; one per model or logical query group.
- Use raw SQL comments with valid template placeholders like `@@table`, `@param`, `{{where}}`, `{{set}}`.
- Return model type(s) and errors explicitly, letting the generator enforce correctness.

### Organizing Code

- Place your models and interfaces in the same package or directory to ease code generation.
- Use package-level `genconfig.Config` files for optional configuration (inclusion filters, output paths, type mappings).

### Running the Generator

- Always specify the input directory containing the interfaces (`-i` flag).
- Use the output directory flag (`-o`) to control where generated code goes.
- The tool preserves directory structure and applies configuration rules.

### Using the Generated Fluent API

- Use the generated interface constructor, e.g., `generated.Query[User](db)`.
- Call query methods directly with context and parameters.
- Combine with GORM filtering, ordering, and projection via the field helpers.

<Tip>
Generated code includes field helper structs with methods like `.Eq()`, `.Like()`, and `.Set()`. Use them to write expressive, type-safe queries that integrate seamlessly with GORM.
</Tip>

---

## 5. Troubleshooting

<AccordionGroup title="Common Issues">
<Accordion title="Generator does not find interfaces or structs">
Verify your `-i` input path points exactly to the directory/package containing your model structs and query interfaces. The tool recursively processes Go files.

Also, check for `genconfig.Config` filters that may exclude your types.
</Accordion>

<Accordion title="Method signature errors">
Your interface methods must return either only `error` or `(T, error)` where `T` matches your model type. The last return value must always be `error`.

The generator enforces this strictly.
</Accordion>

<Accordion title="Generated code fails to compile">
Ensure your project dependencies, especially GORM, are up to date matching generics support.

Make sure your environment uses Go 1.18+, and you have run proper `go mod tidy`.
</Accordion>
</AccordionGroup>

---

## 6. Next Steps

- Explore the [Using Model-Driven Field Helpers guide](../field-helper-basics) to leverage generated field helpers for filters and updates.
- Learn advanced SQL templating with the [Embedded DSL guide](../../advanced-patterns/template-dsl) to create complex query interfaces.
- Customize generation with [genconfig](../../advanced-patterns/generation-config) for tailored output.
- Refer to [Validating Generated Code](../../first-run-usage/quick-validation) to integrate and verify generated code quickly.

---

## 7. Reference Example

```go
// Query interface example (examples/query.go)
type Query[T any] interface {
  // SELECT * FROM @@table WHERE id=@id
  GetByID(id int) (T, error)

  // where("name=@name AND age=@age")
  FilterByNameAndAge(name string, age int)
}

// Model example (examples/models/user.go)
type User struct {
  gorm.Model
  Name string
  Age  int
}
```

Command to generate:

```bash
gorm gen -i ./examples -o ./generated
```

Use in your app:

```go
u, err := generated.Query[User](db).GetByID(ctx, 123)
```

---

Congratulations! You have successfully generated and consumed your first GORM CLI query API.

---

<Info>
For more detailed configuration options and advanced usage, see the full documentation at the [GORM CLI Documentation Homepage](https://gorm.io/docs/cli.html).
</Info>
