---
title: "Filtering and Updating Records"
description: "Hands-on walkthrough for constructing advanced filters and executing safe, expressive updates using generated field helpers. Includes composition patterns for predicates, zero-value handling, and update expressions."
---

# Filtering and Updating Records

This guide provides a practical, step-by-step walkthrough on constructing advanced filters and executing safe, expressive update operations using GORM CLI's generated field helpers. You'll learn how to compose predicates for filtering queries, handle zero values correctly in updates, and build update expressions for flexible data manipulation.

---

## 1. Workflow Overview

**Task Description**  
Learn how to construct robust filters and perform updates on your database records leveraging model-driven field helpers generated by GORM CLI. This includes composing conditional predicates, managing zero-value updates safely, and crafting dynamic update expressions.

**Prerequisites**  
- You have generated query APIs and model-driven field helpers using GORM CLI.
- Basic understanding of GORM and Go generics.
- A working GORM DB instance in your Go project.

**Expected Outcome**  
By completing this guide, you'll confidently filter data using composable predicates and update records safely with both static values and dynamic expressions.

**Time Estimate**  
Approximately 15-20 minutes.

**Difficulty Level**  
Intermediate

---

## 2. Filtering Records Using Generated Field Helpers

### Step 1: Using Basic Predicate Helpers

Generated field helpers provide type-safe methods such as `Eq()`, `Gt()`, and `Like()` to build predicates for filtering. For example, filtering users older than 18 with an active role:

```go
users, err := gorm.G[models.User](db).
    Where(generated.User.Age.Gt(18), generated.User.Role.Eq("active")).
    Find(ctx)
```

_Expected result:_  
`users` contains all User records where `age > 18` and `role = 'active'`.

### Step 2: Composing Multiple Conditions

You can chain multiple predicates for complex where clauses. All predicates are combined with AND logic.

```go
// Find users named "jinzhu" with age between 18 and 65
users, err := gorm.G[models.User](db).
    Where(generated.User.Name.Eq("jinzhu"),
          generated.User.Age.Between(18, 65)).
    Find(ctx)
```

### Step 3: Handling Nil and Zero Values in Filters

Avoid filtering with zero values unless intentional. Helpers like `IsNull()` and `IsNotNull()` are available for nullable fields.

```go
// Find users with Score NULL
users, err := gorm.G[models.User](db).
    Where(generated.User.Score.IsNull()).
    Find(ctx)
```

### Step 4: Using Filters with Time Ranges

You can efficiently filter records within time ranges using generated Time field helpers.

```go
start, end := time.Date(2023,1,1,0,0,0,0,time.UTC), time.Now()
users, err := gorm.G[models.User](db).
    Where(generated.User.CreatedAt.Gt(start), generated.User.CreatedAt.Lt(end)).
    Find(ctx)
```

### Step 5: Using Generated Query Interface Methods for Filtering

If you have defined query interfaces with SQL template methods (e.g., `FilterByNameAndAge`), you can invoke those directly to build filtered queries.

```go
query := generated.Query[models.User](db)
filteredQuery := query.FilterByNameAndAge(ctx, "alice", 20)
results, err := filteredQuery.Find(ctx)
```

_Expected result:_ Query returns users named "alice" aged 20.

---

## 3. Updating Records Safely and Expressively

### Step 1: Update Using Direct Set Assignments

Use `Set(...)` with generated field setters followed by `Update(ctx)` to safely update matched records.

```go
rows, err := gorm.G[models.User](db).
    Where(generated.User.Role.Eq("pending")).
    Set(
        generated.User.Role.Set("active"),
    ).
    Update(ctx)
```

_Expected result:_  
All users with role "pending" are updated to "active".

### Step 2: Update With Zero-Value Fields

Generated setters handle zero values explicitly, ensuring fields like boolean and string zeros are correctly persisted.

```go
// Set zero string, zero bool, and NULL for nullable fields
rows, err := gorm.G[models.User](db).
    Where(generated.User.Name.Eq("alice")).
    Set(
        generated.User.Role.Set(""),           // empty string
        generated.User.IsAdult.Set(false),      // false boolean
        generated.User.Score.Set(sql.NullInt64{}), // NULL
    ).
    Update(ctx)
```

### Step 3: Use Increment and Expression Updates

You can apply expressions or increment operations atomically using `SetExpr()` or helper methods like `Incr()`.

```go
// Increment age by 1
rows, err := gorm.G[models.User](db).
    Where(generated.User.Name.Eq("bob")).
    Set(
        generated.User.Age.Incr(1),
    ).
    Update(ctx)

// Use arbitrary SQL expression
rows, err := gorm.G[models.User](db).
    Where(generated.User.Name.Eq("bob")).
    Set(
        generated.User.Age.SetExpr(clause.Expr{SQL: "GREATEST(age, ?)" , Vars: []any{18}}),
    ).
    Update(ctx)
```

_Expected result:_  
Bob's age is incremented or updated to the greater of current age and 18 respectively.

### Step 4: Combine Zero-Value Sets and Expressions

You can mix zero-value field updates with expressions safely.

```go
rows, err := gorm.G[models.User](db).
    Where(generated.User.Name.Eq("cathy")).
    Set(
        generated.User.Role.Set("") ,
        generated.User.IsAdult.Set(false),
        generated.User.Score.Set(sql.NullInt64{}),
        generated.User.Age.SetExpr(clause.Expr{SQL: "age + ?", Vars: []any{2}}),
    ).
    Update(ctx)
```

### Step 5: Update with Template-Driven Query Interfaces

If you generated SQL template interfaces that include update methods with conditional sets, use those for declarative updates.

```go
query := generated.Query[models.User](db)
err := query.UpdateInfo(ctx, models.User{Name: "jinzhu", Age: 20}, 1)
```

This runs an update including conditionals for changing `is_adult` appropriately.

---

## 4. Common Patterns and Tips

- **Compose predicates progressively:** Combine multiple predicates in `Where()` to create expressive filters.
- **Explicit zero-value setting:** Use generated setters to assign zero values to fields to avoid accidental omissions.
- **Use expressions for atomic calculations:** Employ `SetExpr()` and helper methods like `Incr()` for DB-side calculations.
- **Avoid building SQL strings manually:** Use generated field helpers and interfaces to ensure compile-time safety.
- **Handle nullable fields properly:** Use provided predicates like `IsNull()` and setters with zero values (e.g., `sql.NullInt64{}`) to manage nullable columns.

---

## 5. Troubleshooting

### Problem: Updates appear to ignore zero values (e.g., empty strings or false booleans)

**Cause:** Direct assignment without generated field setters can skip zero values because Go's `omitempty`/non-pointer zero values might be ignored.

**Solution:** Always use generated setters such as `generated.User.Role.Set("")` or `generated.User.IsAdult.Set(false)` for zero-value updates.

---

### Problem: Unexpected SQL errors when mixing expressions and plain setters

**Cause:** Expressions require special handling and cannot be mixed improperly with plain assignment.

**Solution:** Use `SetExpr()` for expressions and ensure `Set()` only contains field setters or expressions, not raw strings.

---

## 6. Examples

### Example 1: Filter active users older than 18

```go
users, err := gorm.G[models.User](db).
    Where(generated.User.Role.Eq("active"), generated.User.Age.Gt(18)).
    Find(ctx)
```

### Example 2: Update user role and zero out nullable fields

```go
rows, err := gorm.G[models.User](db).
    Where(generated.User.Name.Eq("alice")).
    Set(
        generated.User.Role.Set(""),
        generated.User.IsAdult.Set(false),
        generated.User.Score.Set(sql.NullInt64{}),
    ).
    Update(ctx)
```

### Example 3: Increment age by 3 where user name is "bob"

```go
rows, err := gorm.G[models.User](db).
    Where(generated.User.Name.Eq("bob")).
    Set(generated.User.Age.Incr(3)).
    Update(ctx)
```

### Example 4: Update user info conditionally using query interface

```go
query := generated.Query[models.User](db)
err := query.UpdateInfo(ctx, models.User{Name: "jim", Age: 21}, 15)
```

---

## 7. Next Steps & Related Content

- Explore [Working with Associations](https://docs.gorm.io/guides/practical-usage-patterns/working-with-associations) to manage related records.
- Learn to write custom SQL templates in [SQL Template DSL in Practice](https://docs.gorm.io/guides/practical-usage-patterns/template-dsl-patterns).
- Customize generation with advanced [Generation Config](https://docs.gorm.io/guides/customization-advanced/generation-config).
- Consult Getting Started guides to set up and generate your own field helpers and query APIs.


---

_For more in-depth understanding and additional examples, see the [Using the Generated APIs](https://docs.gorm.io/getting-started/first-generation/using-generated-code) guide and [Model-driven Field Helpers](https://docs.gorm.io/guides/getting-started/field-helpers-basics)._