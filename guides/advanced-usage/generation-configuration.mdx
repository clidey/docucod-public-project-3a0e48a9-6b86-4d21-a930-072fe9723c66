---
title: "Customizing Code Generation"
description: "Shows how to use genconfig.Config for fine-tuned control over code generation: changing output folders, controlling included/excluded interfaces or structs, and mapping custom field types for specialized use cases."
---

# Customizing Code Generation

This guide shows you how to use the `genconfig.Config` configuration in GORM CLI to fine-tune code generation. You'll learn how to change output folders, selectively include or exclude specific interfaces or structs, and map custom field types for specialized use cases, allowing you to tailor the generated code precisely to your project's needs.

---

## Workflow Overview

- **Task Description**: Customize GORM CLI code generation by defining a package-level `genconfig.Config` variable that controls output paths, filtering of interfaces and structs, and field type mappings.
- **Prerequisites**: You should have Go models and interfaces written with GORM CLI raw SQL annotations and basic understanding of GORM CLI code generation concepts.
- **Expected Outcome**: Controlled and customized generation of code files in specific output folders, including only interfaces and structs you want, and supporting custom field helper types.
- **Time Estimate**: 10–20 minutes to set up and test configuration.
- **Difficulty Level**: Intermediate - assumes familiarity with Go packages and GORM CLI usage.

---

## How to Customize Code Generation Using `genconfig.Config`

You customize code generation by declaring a **package-level** variable of type `genconfig.Config` in the same package as your source interfaces and models. The GORM CLI generator automatically detects and applies this configuration when generating code.

### Step 1: Declare the Configuration

In a Go file within your package, import `gorm.io/cli/gorm/genconfig` and optionally other dependencies needed for your mappings. Then declare a variable named `_` (to avoid unused variable errors) of type `genconfig.Config`.

```go
package yourpackage

import (
    "database/sql"
    "gorm.io/cli/gorm/field"
    "gorm.io/cli/gorm/genconfig"
)

var _ = genconfig.Config{
    OutPath: "generated/code",  // Custom output directory relative to your module root

    FieldTypeMap: map[any]any{
        sql.NullTime{}: field.Time{}, // Map sql.NullTime fields to time helpers
    },

    FieldNameMap: map[string]any{
        "date": field.Time{},  // Map fields tagged `gen:"date"` to Time helper
        "json": JSON{},        // Use custom JSON field helper for `gen:"json"`
    },

    FileLevel: false, // Apply config to whole package (true for single-file scope)

    IncludeInterfaces: []any{"Query*", models.Query(nil)}, // Whitelist interfaces by pattern or type
    ExcludeInterfaces: []any{"*Deprecated*"},               // Blacklist certain interfaces

    IncludeStructs: []any{"User", "Account*", models.User{}}, // Whitelist structs
    ExcludeStructs: []any{"*DTO"},                               // Blacklist structs by pattern
}
```

### Step 2: Configure Output Directory

- Use `OutPath` to specify where the generated files will be written for the current package.
- This overrides the global CLI `-o` flag for files in this package.

Example:

```go
OutPath: "examples/output",
```

This places all generated code inside the `examples/output` directory, keeping your source files separate.

### Step 3: Include or Exclude Interfaces and Structs

Fine-tune your generation by specifying exactly which interfaces and structs get code generated.

- `IncludeInterfaces` and `IncludeStructs` act as whitelists. If non-empty, only those matching these lists are generated.
- `ExcludeInterfaces` and `ExcludeStructs` act as blacklists applied after whitelisting.

Selectors can be:

- String patterns (shell-style), e.g. "Query*", "IRepo", "pkg.Query"
- Type literals, e.g. `models.User{}`
- Type conversions, e.g. `models.Query(nil)`

Example:

```go
IncludeInterfaces: []any{"Query*", models.Query(nil)},
ExcludeInterfaces: []any{"*Deprecated*"},
IncludeStructs: []any{"User", "Account*", models.User{}},
ExcludeStructs: []any{"*DTO"},
```

This configuration ensures only interfaces starting with "Query" or matching `models.Query` are included, excluding deprecated ones, and including only certain structs.

### Step 4: Map Custom Field Types

You can customize how struct fields are translated into field helpers by configuring:

- `FieldTypeMap` which maps Go types (instances) to field helper instances.
- `FieldNameMap` which maps struct field tag names (values from `gen:"tag"` struct tags) to field helpers.

Example for JSON fields:

```go
FieldNameMap: map[string]any{
    "json": JSON{},  // Map fields tagged with `gen:"json"` to custom JSON helper
},
```

Check your custom field helper types follow the interface expectations of the code generator.

---

## Real-World Example: JSON Field Mapping

Suppose your project has JSON data stored in string fields, and you want to generate specific helpers with database-specific SQL for JSON comparison.

1. Declare `genconfig.Config` with field name mapping:

```go
var _ = genconfig.Config{
    OutPath: "examples/output",
    FieldNameMap: map[string]any{
        "json": JSON{},
    },
}
```

2. Annotate your struct field with the `gen:"json"` tag:

```go
type User struct {
    Profile string `gen:"json"`
    // other fields
}
```

3. Define your `JSON` field helper type implementing comparison expressions.

4. Use the generated helper in queries, e.g.: 

```go
users, err := gorm.G[User](db).
    Where(generated.User.Profile.Equal("$.vip", true)).Take(ctx)
```

GORM CLI will generate correct SQL according to the database dialect.

---

## Tips & Best Practices

- **Place `genconfig.Config` in the same package** as your interfaces/models so the generator can detect it.
- **Use shell-style wildcard patterns for flexible inclusion/exclusion.**
- **Set `FileLevel` to `true` for file-scoped configs** if you want to affect only one file instead of the whole package.
- **Prioritize `FieldNameMap` over `FieldTypeMap`** to target fields by `gen` tag.
- **Keep your output directories separate** to avoid mixing generated code with handwritten sources.
- **Combine inclusion/exclusion filters carefully** to avoid removing needed interfaces or structs unintentionally.

---

## Common Pitfalls & Troubleshooting

<AccordionGroup title="Common Issues and Solutions">
<Accordion title="Configuration Not Detected">

- Ensure the config variable is declared at the package-level (not inside a function).
- The variable must be named `_` or exported.
- The config must be in a Go source file in the input directory.

</Accordion>
<Accordion title="Too Many or No Interfaces Generated">

- Check filters `IncludeInterfaces` and `ExcludeInterfaces`.
- Use patterns carefully; for example, `Query*` matches all interfaces starting with "Query".
- Remember exclude filters apply after include filters.

</Accordion>
<Accordion title="Custom Field Helpers Not Applied">

- Confirm your type mappings are correct and use type instances, e.g., `sql.NullTime{}`.
- Make sure your `FieldNameMap` key matches exactly the `gen` struct field tag value.
- Double-check your custom helper types implement required methods if generating complex SQL.

</Accordion>
</AccordionGroup>

---

## Summary

Customizing code generation with `genconfig.Config` lets you control exactly what code is generated, where, and how field types are handled—empowering you to maintain clean, manageable codebases suited to your project's complexity.

---

## Further Reading & Related Topics

- [Generating Code](https://docs.gorm.io/getting-started/first-use-configuration/generating-code) — Learn how to run the generator with and without config overrides.
- [Writing Your First Query Interface and Model](https://docs.gorm.io/getting-started/first-use-configuration/writing-query-interfaces-and-models) — Start building your definitions.
- [Mapping JSON and Custom Field Types](https://docs.gorm.io/guides/advanced-usage/mapping-json-and-custom-fields) — Details on custom helpers.
- [Basic Configuration (Optional)](https://docs.gorm.io/getting-started/first-use-configuration/configuration-basics) — More on config options.

---

## References

- Full API reference for `genconfig.Config` is in the package source.
- Example config declarations:
  - [filters/whitelist](https://github.com/go-gorm/cli/blob/main/examples/filters/whitelist/config.go)
  - [filters/twolevel](https://github.com/go-gorm/cli/blob/main/examples/filters/twolevel/config.go)
  - [filters/pattern](https://github.com/go-gorm/cli/blob/main/examples/filters/pattern/config.go)


---

## Troubleshooting Quick Guide

<AccordionGroup title="Troubleshooting: Common Questions">
<Accordion title="How do I specify a custom output folder?">
Simply set `OutPath` in your `genconfig.Config`. This overrides the CLI `-o` option for that package.
</Accordion>
<Accordion title="Can I generate code only for some interfaces?">
Yes, define `IncludeInterfaces` with shell-style patterns or exact types. Excluded interfaces will not be generated.
</Accordion>
<Accordion title="How to map a field with a custom tag to a helper?">
Use `FieldNameMap` with the tag name as key and the field helper instance as value.
</Accordion>
<Accordion title="Why is my struct not generating code?">
Check if it is excluded by filters or if it lacks exported fields. Also confirm the config applies to its package/directory.
</Accordion>
</AccordionGroup>

---

## Example Config Snippets

```go
// Only generate interfaces whose names start with "Query"
var _ = genconfig.Config{
    IncludeInterfaces: []any{"Query*"},
}
```

```go
// Exclude nested interfaces and structs across all files in subtree
var _ = genconfig.Config{
    ExcludeInterfaces: []any{"NestedI3"},
    ExcludeStructs:    []any{"NestedS3"},
}
```

---

This completes your configuration to customize GORM CLI code generation, making it precise, maintainable, and fully integrated into your Go project structure.

---
