---
title: "Customizing Code Generation with Config"
description: "A practical guide to using `genconfig.Config` for advanced generation scenarios: customizing output paths, field type mappings, inclusion/exclusion rules, and project-specific field helpers (such as JSON fields). Illustrated with real configuration and Go examples."
---

# Customizing Code Generation with Config

A practical guide to using `genconfig.Config` for advanced generation scenarios: customizing output paths, field type mappings, inclusion/exclusion rules, and project-specific field helpers (such as JSON fields). Illustrated with real configuration and Go examples.

---

## Overview

This page guides you through customizing GORM CLI's code generation process by defining package-level `genconfig.Config` values. You will learn how to tailor generation output directories, map Go types or field names to specialized field helpers, and include or exclude specific interfaces and structs based on your project's needs.

By the end of this guide, you will confidently configure your project for precise and maintainable generated code tailored to complex or domain-specific scenarios.

#### Prerequisites

- Familiarity with GORM CLI basics and running the generator.
- Go 1.18+ installed.
- Basic understanding of Go interfaces and struct types.
- A project with Go interfaces annotated for SQL templates and model structs.

#### Expected Outcome

You'll create and apply generation configurations that:

- Redirect generated code to specific directories.
- Override default field helper mappings for types and named fields.
- Filter which interfaces and structs are included or excluded during generation.

#### Time Estimate

10–20 minutes, depending on setup complexity.

#### Difficulty Level

Intermediate

---

## Why Customize Generation With Config?

While GORM CLI works out-of-the-box with default settings, real-world applications benefit greatly from controlling generation behavior for:

- **Project organization:** Output generated code into dedicated directories.
- **Type mapping:** Use custom or domain-specific field helpers for specialized data types (e.g., JSON fields).
- **Selective generation:** Only target relevant interfaces and structs, improving generation speed and output clarity.

This approach reduces clutter, enhances type safety with custom helpers, and aligns code generation tightly with your codebase.

---

## Step-by-Step Instructions

<Steps>
<Step title="Create Your Configuration File">
Begin by declaring a package-level `genconfig.Config` variable in one of your Go source files within the package being generated.

Example:

```go
package examples

import (
    "database/sql"
    "gorm.io/cli/gorm/field"
    "gorm.io/cli/gorm/genconfig"
)

var _ = genconfig.Config{
    OutPath: "examples/output",
    FieldTypeMap: map[any]any{
        sql.NullTime{}: field.Time{},
    },
    FieldNameMap: map[string]any{
        "date": field.Time{},  // map fields tagged with `gen:"date"` to Time helper
        "json": JSON{},       // map fields tagged with `gen:"json"` to custom JSON helper
    },
    IncludeInterfaces: []any{"Query*"},        // include all interfaces starting with 'Query'
    ExcludeInterfaces: []any{"*Deprecated*"}, // exclude deprecated interfaces
    IncludeStructs: []any{"User", "Account*"},
    ExcludeStructs: []any{"*DTO"},
    FileLevel: false, // apply configuration at package level
}
```

This variable will be automatically detected and used during code generation.

<Check>
Make sure the config file is in the same package as your query interfaces and models or in a parent package directory that is part of your input path.
</Check>
</Step>

<Step title="Understand Key Config Fields">

- **OutPath** – The output directory for generated code. Overrides the CLI `-o` flag for the package.

- **FieldTypeMap** – Maps specific Go types (by example value, e.g., `sql.NullTime{}`) to field helper types.

- **FieldNameMap** – Maps field tag names (the `gen:"name"` tag on struct fields) to custom field helpers.

- **IncludeInterfaces/ExcludeInterfaces** – Filters interfaces to include or exclude by exact names or Unix shell-style wildcard patterns (e.g., `Query*`).

- **IncludeStructs/ExcludeStructs** – Same as above but for structs.

- **FileLevel** – When true, config applies only to the file it is declared in; when false, it applies package-wide.

Use these fields to precisely tune what gets generated and how fields are treated.

</Step>

<Step title="Map JSON Fields to a Custom Helper">

If you want to generate special behavior for certain fields (such as JSON), create a custom field helper type and map it via `FieldNameMap`.

Example JSON helper definition:

```go
package examples

import (
    "encoding/json"
    "gorm.io/gorm/clause"
    "gorm.io/cli/gorm/field"
)

// JSON is a field helper for JSON columns with database-specific SQL generation
// Use gen:"json" tag on fields you want to map

type JSON struct{ column clause.Column }

func (j JSON) WithColumn(name string) JSON {
    c := j.column
    c.Name = name
    return JSON{column: c}
}

// Equal builds a SQL expression adapted to the current database's JSON functions
func (j JSON) Equal(path string, value any) clause.Expression {
    return jsonEqualExpr{col: j.column, path: path, val: value}
}

type jsonEqualExpr struct {
    col  clause.Column
    path string
    val  any
}

func (e jsonEqualExpr) Build(builder clause.Builder) {
    if stmt, ok := builder.(*gorm.Statement); ok {
        switch stmt.Dialector.Name() {
        case "mysql":
            v, _ := json.Marshal(e.val)
            clause.Expr{SQL: "JSON_EXTRACT(?, ?) = CAST(? AS JSON)", Vars: []any{e.col, e.path, string(v)}}.Build(builder)
        case "sqlite":
            clause.Expr{SQL: "json_valid(?) AND json_extract(?, ?) = ?", Vars: []any{e.col, e.col, e.path, e.val}}.Build(builder)
        default:
            clause.Expr{SQL: "jsonb_extract_path_text(?, ?) = ?", Vars: []any{e.col, e.path[2:], e.val}}.Build(builder)
        }
    }
}
```

Define this helper in your project and include it via `FieldNameMap`:

```go
FieldNameMap: map[string]any{
    "json": JSON{},
},
```

Your model fields can then declare `gen:"json"` tags to opt into this behavior.

</Step>

<Step title="Control Output Directory Per Package or File">

By setting `OutPath` in your config, you redirect all generated files from a package or file into a custom directory.

Example:

```go
var _ = genconfig.Config{
    OutPath: "examples/output",
    FileLevel: false, // applies to entire package
}
```

If `FileLevel` is true, the output directory override applies only to the exact file containing this config.

<Warning>
Setting `FileLevel` to true reduces package-wide config scope and may require duplicating config for multiple files.
</Warning>

</Step>

<Step title="Filter Interfaces and Structs for Generation">

Use `Include*` and `Exclude*` fields to whitelist or blacklist interface and struct names using patterns or concrete types.

Examples:

- Include only interfaces whose names start with `Query`:

```go
IncludeInterfaces: []any{"Query*"},
```

- Exclude deprecated interfaces:

```go
ExcludeInterfaces: []any{"*Deprecated*"},
```

- Include specific structs and patterns:

```go
IncludeStructs: []any{"User", "Account*", models.User{}},
ExcludeStructs: []any{"*DTO"},
```

The generator matches patterns against fully qualified names (package + type).

<Note>
If `Include*` is non-empty, only those matching elements are generated, ignoring the exclude lists.
</Note>

</Step>

<Step title="Run the Generator with Your Config">

Once your config is in place and committed, run the GORM CLI generator normally:

```bash
gorm gen -i ./examples -o ./generated
```

The generator automatically discovers your `genconfig.Config` declarations and applies them when processing files under the input path.

<Check>
Verify generated files appear in the configured `OutPath` directories.
Check logs for file processing and generation confirmation.
</Check>

</Step>

</Steps>

---

## Examples

### Example Config File with JSON Field Mapping

```go
package examples

import (
    "database/sql"
    "gorm.io/cli/gorm/field"
    "gorm.io/cli/gorm/genconfig"
)

var _ = genconfig.Config{
    OutPath: "examples/output",
    FieldTypeMap: map[any]any{
        sql.NullTime{}: field.Time{},
    },
    FieldNameMap: map[string]any{
        "date": field.Time{},
        "json": JSON{},
    },
    IncludeInterfaces: []any{"Query*"},
    ExcludeInterfaces: []any{"*Deprecated*"},
    IncludeStructs: []any{"User", "Account*"},
    ExcludeStructs: []any{"*DTO"},
}
```

### Using Config With a JSON Field in Model

```go
package models

type User struct {
    ID      uint
    Name    string
    Profile string `gen:"json"` // tells generator to use JSON helper
}
```

### Querying JSON Fields Using Generated Code

```go
// The JSON helper supports database-specific JSON queries
ctx := context.Background()

// Query users where profile's $.vip is true
users, err := gorm.G[models.User](db).
    Where(generated.User.Profile.Equal("$.vip", true)).
    Find(ctx)
```

---

## Troubleshooting & Tips

- **Config Not Applied?**
  - Ensure the `genconfig.Config` is declared as a package-level variable named `_` (anonymous) or any variable.
  - The config file must be in the input directory or packages the generator processes.

- **Pattern Matching Confusion?**
  - Patterns are shell-style (e.g., `Query*` matches any interface starting with `Query`).
  - Use concrete type literals for explicit inclusion (e.g., `models.Query(nil)`).

- **Custom Field Helper Issues?**
  - Confirm your custom helper implements required methods (e.g., `WithColumn(string)`).
  - Test queries to verify correct SQL is generated per database dialect.

- **Output Path Not Changing?**
  - The CLI `-o` flag is overridden by package-level `OutPath` if config applies to the given package.
  - Use `FileLevel: true` for fine-grained per-file control.

---

## Best Practices

- Keep your config declarations in logical package locations for easy maintenance.
- Use `Include*` lists to limit generation scope rather than broad excludes.
- Map fields with semantic meaning (e.g., timestamps, JSON) to specialized helpers for cleaner queries.
- Document custom field helpers and their expected SQL behavior for team awareness.

---

## Next Steps & Related Content

- Explore [Type-Safe Queries with Interfaces](/guides/core-workflows/type-safe-queries) to build powerful querying APIs.
- Learn more about [Model-Driven Field Helpers](/guides/core-workflows/model-field-helpers) to unlock rich update and association operations.
- Delve into [Performance & Best Practices](/guides/advanced-usage/performance-patterns) for optimizing generation workflows.
- Review [First Code Generation Walkthrough](/guides/getting-started/first-code-generation) to bootstrap your project.

---

## Additional Resources

- GORM CLI GitHub: https://github.com/go-gorm/cli
- Official Documentation Home: /overview/intro-and-value/product-overview
- Configuration Reference: /concepts/configuration-and-extensibility/generation-config

---