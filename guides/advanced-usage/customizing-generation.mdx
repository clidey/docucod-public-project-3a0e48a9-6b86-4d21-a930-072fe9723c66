---
title: "Customizing Code Generation"
description: "Configure and extend the code generator to fit your project’s needs. This page explains the genconfig.Config options, field mapping, and file output customization. Includes examples for advanced scenarios such as custom JSON field helpers."
---

# Customizing Code Generation

Configure and extend the GORM CLI code generator to precisely fit your project’s needs. This guide covers how to use the `genconfig.Config` options, customize field mappings, and control file output behavior. It also includes examples for advanced scenarios such as creating custom JSON field helpers.

---

## 1. Understanding the Configuration Workflow

### What You Will Accomplish
This guide helps you fine-tune how GORM CLI generates code by allowing precise control over output paths, field helper type mappings, and selective inclusion or exclusion of types and interfaces. You will learn how to:
- Override default output directories per package
- Map custom Go types and struct tags to specialized field helpers
- Filter code generation by interface and struct patterns
- Implement custom field helper types, such as JSON support

### Prerequisites
- Basic familiarity with GORM CLI and its generation process
- A working project with models and query interfaces
- Go knowledge to write package-level configuration and custom helpers

### Expected Outcome
After following this guide, you will be able to shape GORM CLI's code output to align with your project conventions, optimize generated helper types for your domain, and extend functionality with your own custom field helpers.

### Time Estimate
10-20 minutes to read and apply configurations; longer if implementing advanced custom helpers.

### Difficulty Level
Intermediate—requires understanding of Go types, package structure, and GORM CLI's generation behavior.

---

## 2. Configuring Generation with `genconfig.Config`

### Where to Declare Configuration
Place your configuration as a **package-level variable** named `genconfig.Config` inside any Go source file within the package you want to configure. The generator will automatically discover and apply it.

```go
package examples

import (
  "database/sql"
  "gorm.io/cli/gorm/field"
  "gorm.io/cli/gorm/genconfig"
)

var _ = genconfig.Config{
  OutPath: "examples/output",
  FieldTypeMap: map[any]any{
    sql.NullTime{}: field.Time{},
  },
  FieldNameMap: map[string]any{
    "date": field.Time{},
  },
  FileLevel: false,          // Apply config package-wide (false) or file-only (true)
  IncludeInterfaces: []any{"Query*"},
  ExcludeInterfaces: []any{"*Deprecated*"},
}
```

### Configuration Fields Explained

| Field               | Description                                                                                                    |
|---------------------|----------------------------------------------------------------------------------------------------------------|
| **OutPath**         | Overrides the default output directory for this package’s generated code.                                      |
| **FieldTypeMap**    | Maps Go type instances (e.g., `sql.NullTime{}`) to field helper instances (`field.Time{}`), customizing helper types by Go type.
|
| **FieldNameMap**    | Maps struct tag names (extracted from `gen:"tagname"`) to field helper instances, e.g., custom JSON field helpers.
|
| **FileLevel**       | Boolean indicating if the config applies only to the current file (`true`) or the entire package (`false`).    |
|
| **IncludeInterfaces** | Whitelist of interfaces to generate based on glob patterns or explicit types.
|
| **ExcludeInterfaces** | Blacklist of interfaces to exclude (applied after include).                                                  |
|
| **IncludeStructs**  | Whitelist of struct types to generate helpers for, supporting patterns and explicit literals.                   |
|
| **ExcludeStructs**  | Blacklist of struct types to exclude (applied after include).                                                  |

### Filtering Notes
- **Whitelists** (`Include*`) take priority over blacklists.
- Pattern matching uses shell-style patterns (e.g., `Query*`, `*DTO`).

---

## 3. Controlling Code Output Locations

By default, generated code is output to `./g` unless overridden by `-o` in the CLI or the `OutPath` in your `genconfig.Config`.

**Example:** To output generated code to a custom directory for the package `examples`:

```go
var _ = genconfig.Config{
  OutPath: "examples/output",
}
```

You can also use `FileLevel: true` to limit this output override to the current file only, allowing multiple configs in the same package for flexible control.

---

## 4. Custom Field Helper Mappings

### Why Customize Field Helpers?
GORM CLI generates field helpers for your model's fields to provide type-safe filter and update methods. In some cases, you may want to:
- Use special helpers for types like `sql.NullTime` or custom structs
- Adjust helpers based on struct tags (e.g., treat `gen:"json"` fields differently)
- Extend with your own custom field helpers beyond built-in types

### Using `FieldTypeMap` for Go Types
Provide a mapping from a Go type instance (key) to a field helper type instance (value). The generator uses this to wrap field types accordingly.

```go
var _ = genconfig.Config{
  FieldTypeMap: map[any]any{
    sql.NullTime{}: field.Time{},  // Use field.Time helper for sql.NullTime fields
  },
}
```

### Using `FieldNameMap` for Tag-Based Mapping
Map a field tag name (`gen:"tagname"`) to a helper type.

Example: Assign fields tagged `gen:"json"` to your custom JSON field helper.

```go
var _ = genconfig.Config{
  FieldNameMap: map[string]any{
    "json": JSON{},  // Use custom JSON helper
  },
}
```

### How to Use Field Tags
In your model structs, tag fields with `gen:"tagname"` to trigger the mapping:

```go
type User struct {
  // Use the custom JSON helper for Profile field
  Profile string `gen:"json"`
}
```

---

## 5. Creating a Custom JSON Field Helper

For JSON fields, standard SQL might vary by database. Here’s how to implement a custom JSON helper that generates correct SQL expressions per dialect.

### Step 1: Declare FieldNameMap
```go
var _ = genconfig.Config{
  OutPath: "examples/output",
  FieldNameMap: map[string]any{
    "json": JSON{},
  },
}
```

### Step 2: Use `gen:"json"` Tag in Model
```go
type User struct {
  Profile string `gen:"json"`
}
```

### Step 3: Implement JSON Helper Type
```go
package examples

import (
  "encoding/json"
  "gorm.io/gorm"
  "gorm.io/gorm/clause"
  "gorm.io/cli/gorm/field"
)

// JSON is a custom field helper for JSON columns, generating dialect-specific SQL.
type JSON struct { column clause.Column }

// WithColumn returns a new JSON helper with the specified column name.
func (j JSON) WithColumn(name string) JSON {
  c := j.column
  c.Name = name
  return JSON{column: c}
}

// Equal builds an expression to compare JSON path values correctly for each database.
func (j JSON) Equal(path string, value any) clause.Expression {
  return jsonEqualExpr{col: j.column, path: path, val: value}
}

type jsonEqualExpr struct {
  col  clause.Column
  path string
  val  any
}

func (e jsonEqualExpr) Build(builder clause.Builder) {
  if stmt, ok := builder.(*gorm.Statement); ok {
    switch stmt.Dialector.Name() {
    case "mysql":
      v, _ := json.Marshal(e.val)
      clause.Expr{SQL: "JSON_EXTRACT(?, ?) = CAST(? AS JSON)", Vars: []any{e.col, e.path, string(v)}}.Build(builder)
    case "sqlite":
      clause.Expr{SQL: "json_valid(?) AND json_extract(?, ?) = ?", Vars: []any{e.col, e.col, e.path, e.val}}.Build(builder)
    default: // postgres and others
      clause.Expr{SQL: "jsonb_extract_path_text(?, ?) = ?", Vars: []any{e.col, e.path[2:], e.val}}.Build(builder)
    }
  }
}
```

### Step 4: Use Custom JSON Helper in Queries
```go
result, err := gorm.G[models.User](db).
  Where(generated.User.Profile.Equal("$.vip", true)).
  Take(ctx)
```

This generates appropriate JSON SQL expressions for MySQL, SQLite, or Postgres depending on your database driver.

---

## 6. Selective Code Generation Using Includes and Excludes

### Controlling Interface and Struct Generation
Use `IncludeInterfaces` and `ExcludeInterfaces` to whitelist or blacklist interfaces for generation.
Use `IncludeStructs` and `ExcludeStructs` similarly for structs.

```go
var _ = genconfig.Config{
  IncludeInterfaces: []any{"Query*", models.Query(nil)},
  ExcludeInterfaces: []any{"*Deprecated*"},
  IncludeStructs: []any{"User", "Account*", models.User{}},
  ExcludeStructs: []any{"*DTO"},
}
```

### Priority Rules
- If any `Include*` is set and not empty, only matching patterns are included; excludes ignored.
- If no `Include*` is specified but `Exclude*` is set, excludes remove matches after loading all.

---

## 7. Best Practices and Tips

- **Centralize your config** in one or a few package files to keep it manageable.
- Use **include** filters to narrow down generation to important interfaces and structs, avoiding unwanted code.
- For **custom helpers**, always ensure you provide the necessary SQL generation logic compatible with all target databases.
- When overriding **OutPath**, keep directory structure consistent with your Go modules to ease imports.
- Verify generation by running the CLI and inspecting outputs; use the standard logs for clues.

---

## 8. Troubleshooting Common Issues

### Config Not Applied or Ignored
- Check `FileLevel` setting: if you intend to have package-level config, ensure `FileLevel` is `false`.
- Confirm your config variable is declared at package level, named exactly `genconfig.Config`.
- Ensure the package containing config is included in your generator’s input path.

### Custom Field Helper Not Applied
- Confirm the struct tag matches the key in `FieldNameMap` exactly.
- Make sure your field helper has proper method receivers and complies with field helper interface conventions.
- Validate import paths and package names are consistent to avoid loading errors.

### Filtering Does Not Respect Patterns
- Use shell-style wildcards (`*`), but avoid incorrect patterns.
- Patterns match fully qualified names (e.g., `models.User`), so include package prefixes as needed.

---

## 9. Next Steps & Related Content

- Explore the [Writing Templated Queries Guide](/guides/advanced-usage/template-dsl-guide) to enhance your SQL templates.
- Learn advanced [Association Management](/guides/advanced-usage/advanced-associations) using generated helpers.
- Review [Using Generated APIs](/guides/getting-started/using-generated-apis) for practical application examples.
- Consult [Troubleshooting Common Issues](/getting-started/troubleshooting-validation/troubleshooting) for deeper problem solving.

---

# Additional Reference: Sample Minimal Config

```go
package examples

import (
  "database/sql"
  "gorm.io/cli/gorm/field"
  "gorm.io/cli/gorm/genconfig"
)

var _ = genconfig.Config{
  OutPath: "examples/output",
  FieldTypeMap: map[any]any{
    sql.NullTime{}: field.Time{},
  },
  FieldNameMap: map[string]any{
    "json": JSON{},
  },
  IncludeInterfaces: []any{"Query*"},
}
```

Use this as a starting point and extend according to your project’s specific mapping and inclusion requirements.
