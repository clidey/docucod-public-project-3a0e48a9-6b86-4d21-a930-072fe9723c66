---
title: "Writing Templated Queries"
description: "Master the template-based DSL for generating custom SQL from Go interfaces. This guide walks through the available directives, conditional fragments, and parameter mapping, allowing you to develop expressive, type-safe queries."
---

# Writing Templated Queries

Harness the power of GORM CLI's template-based Domain-Specific Language (DSL) to define custom, expressive, and type-safe SQL queries directly within your Go interfaces. This guide walks you through how to write effective templated queries using SQL annotations and template directives embedded in interface method comments. Mastering this will enable you to build dynamic queries with parameter binding, conditional logic, and iteration for powerful, compile-time-safe data access.

---

## Workflow Overview

- **Task Description**: Learn how to write templated SQL queries in Go interface method comments using GORM CLI's template DSL. Customize query behavior with directives, conditionals, and parameter mappings to generate type-safe query implementations.

- **Prerequisites**: 
  - A Go interface with methods representing the queries you want to implement.
  - Basic understanding of Go syntax and method signatures.
  - Familiarity with your data model struct fields and their types.

- **Expected Outcome**: 
  - Your Go interfaces contain SQL templates that GORM CLI uses to generate implementations.
  - Generated code supporting dynamic, type-safe query construction.

- **Time Estimate**: 20–30 minutes for initial templated query writing and understanding the DSL.

- **Difficulty Level**: Intermediate — requires knowledge of Go, SQL, and templating concepts.

---

## Understanding the Template DSL

The heart of templated queries lies in annotating Go interface methods with specialized SQL comments incorporating directives and Go-like templating logic.

### Key Concepts

- **Annotations Come from Comments**: Method comments directly preceding the interface method declarations contain the SQL templates.
- **Parameters Bind Automatically**: Placeholders in the template, such as `@param`, bind to method parameters.
- **Template Directives Enable Control Flow**: Conditional and iterative constructs allow dynamic SQL generation.
- **Special Placeholders** replace model/table information automatically.

### Core DSL Directives

| Directive   | Purpose                         | Example                                      |
| ----------- | ------------------------------- | -------------------------------------------- |
| `@@table`   | Resolves to the model's table name | `SELECT * FROM @@table WHERE id=@id`         |
| `@@column`  | Dynamically binds column name    | `WHERE @@column=@value`                      |
| `@param`    | Binds Go method parameters to SQL | `WHERE name=@user.Name`                      |
| `{{where}}` | Conditional WHERE clause section | `{{where}} age > 18 {{end}}`                 |
| `{{set}}`   | Conditional SET clause for UPDATE | `{{set}} name=@name {{end}}`                 |
| `{{if}}`    | Conditional SQL fragment          | `{{if age > 0}} AND age=@age {{end}}`        |
| `{{for}}`   | Iterate over collections          | `{{for _, t := range tags}} ... {{end}}`     |

### Example Template

```go
// SELECT * FROM @@table WHERE id=@id AND name = "@name"
GetByID(id int) (T, error)
```

This method retrieves a record by ID, automatically binding the method parameter `id` to the SQL.

---

## Step-by-Step Guide to Writing Templated Queries

### 1. Define Your Interface Method Signature

Start by writing the interface method representing the query you want, including method parameters matching your SQL needs.

```go
// interface with generic type T
type Query[T any] interface {
  // Your method signatures here
}
```

### 2. Annotate with SQL Template Comments

Write SQL statements and template directives as Go doc comments immediately above the method declaration.

- Use single-line or multi-line comments.
- Embed SQL with `@@table` and other placeholders.
- Use Go-like template syntax for advanced conditions.

Example:

```go
// SELECT * FROM @@table WHERE id=@id
GetByID(id int) (T, error)

// SELECT * FROM @@table
// {{where}}
//   {{if user.Name != ""}} name=@user.Name {{end}}
//   {{if user.Age > 0}} AND age=@user.Age {{end}}
// {{end}}
SearchUsers(user User) ([]T, error)
```

### 3. Use Placeholders to Bind Parameters

- `@param` maps to method parameters or their fields.
- `@@table` automatically resolves to the current model’s database table.
- `@@column` can be used to dynamically specify column names.

### 4. Add Conditional Blocks

Control the presence of SQL fragments using `{{if CONDITION}} ... {{end}}`. This dynamically includes or excludes SQL based on runtime data.

Example:

```sql
{{where}}
  {{if user.ID > 0}}
    WHERE id=@user.ID
  {{else if user.Name != ""}}
    WHERE name=@user.Name
  {{end}}
{{end}}
```

### 5. Employ Iteration for Collections

For queries involving slices or multiple values, use `{{for}}` loops to generate repeated SQL fragments for each element.

```sql
{{where}}
  {{for _, user := range users}}
    {{if user.Name != "" && user.Age > 0}}
      (name = @user.Name AND age = @user.Age) OR
    {{end}}
  {{end}}
{{end}}
```

### 6. Use SET Blocks for UPDATE Statements

The `{{set}}` directive helps conditionally build the SET clause in UPDATE statements.

```sql
UPDATE @@table
{{set}}
  {{if user.Name != ""}} name=@user.Name, {{end}}
  {{if user.Age > 0}} age=@user.Age, {{end}}
{{end}}
WHERE id=@id
```

### 7. Escape `@` When Needed

To include a literal `@` symbol in SQL (e.g., email addresses), escape it as `\@`.

```sql
-- name = "\@name" will output literal '@name' in SQL
SELECT * FROM @@table WHERE name = "\@name"
```


---

## Complete Example Interface

```go
// Query interface with various templated queries
type Query[T any] interface {

  // Get data by ID
  // SELECT * FROM @@table WHERE id=@id
  GetByID(id int) (T, error)

  // Dynamic column filter
  // SELECT * FROM @@table WHERE @@column=@value
  FilterWithColumn(column string, value string) (T, error)

  // Conditional query with user filter
  // SELECT * FROM @@table
  // {{where}}
  //   {{if user.ID > 0}}
  //     WHERE id=@user.ID
  //   {{else if user.Name != ""}}
  //     WHERE name=@user.Name
  //   {{end}}
  // {{end}}
  QueryWith(user User) (T, error)

  // Update user info with conditionally set fields
  // UPDATE @@table
  // {{set}}
  //   {{if user.Name != ""}} name=@user.Name, {{end}}
  //   {{if user.Age > 0}} age=@user.Age, {{end}}
  //   {{if user.Age >= 18}} is_adult=1 {{else}} is_adult=0 {{end}}
  // {{end}}
  // WHERE id=@id
  UpdateInfo(user User, id int) error

  // Multi-item filter with iteration
  // SELECT * FROM @@table
  // {{where}}
  //   {{for _, user := range users}}
  //     {{if user.Name != "" && user.Age > 0}}
  //       (name = @user.Name AND age=@user.Age AND role LIKE concat("%",@user.Role,"%")) OR
  //     {{end}}
  //   {{end}}
  // {{end}}
  Filter(users []User) ([]T, error)

  // Simple parameter-based filter without return error
  // where("name=@name AND age=@age")
  FilterByNameAndAge(name string, age int)

  // Time range filter with conditional WHERE
  // SELECT * FROM @@table
  // {{where}}
  //   {{if !start.IsZero()}}
  //     created_at > @start
  //   {{end}}
  //   {{if !end.IsZero()}}
  //     AND created_at < @end
  //   {{end}}
  // {{end}}
  FilterWithTime(start, end time.Time) ([]T, error)
}
```

---

## Tips and Best Practices

- **Always Use Placeholders for Safety**: Use `@param` placeholders to ensure parameters are safely bound, preventing SQL injection.
- **Use `@@table` for Portability**: Rely on the `@@table` directive to reference the model table dynamically.
- **Validate Conditions Carefully**: Ensure conditions in `{{if}}` evaluate fields or parameters correctly to avoid empty or malformed SQL.
- **Keep SQL Sections Concise**: Write clear, focused SQL in comments; complex logic should use Go conditionals within templates.
- **Escape `@` When Needed**: Use `\@` to include literal `@` symbols.
- **Test Generated Queries**: After generating code, test queries for correctness and expected SQL output.

---

## Common Pitfalls

<AccordionGroup title="Common Issues When Writing Templated Queries">
<Accordion title="Incorrect Parameter Mapping">
Ensure parameter names in SQL templates exactly match method parameter names or their struct field names. Mismatched names cause generation errors or runtime failures.
</Accordion>
<Accordion title="Unclosed Template Blocks">
Forgotten `{{end}}` in `{{if}}`, `{{for}}`, or `{{where}}` blocks leads to generation failure. Always pair opening and closing directives.
</Accordion>
<Accordion title="Using Unsupported Directives">
Only directives `{{where}}`, `{{set}}`, `{{if}}`, `{{else if}}`, `{{else}}`, `{{for}}`, and `{{end}}` are supported. Using others causes errors.
</Accordion>
<Accordion title="Literal `@` Not Escaped">
Failing to escape literal `@` as `\@` can break parsing or cause incorrect SQL.
</Accordion>
<Accordion title="Method Return Signature Mismatch">
Templated methods with raw SQL must return data and error (e.g., `(T, error)`). Methods without SQL may return interface for chaining.
</Accordion>
</AccordionGroup>

---

## Troubleshooting

<Tip>
If you encounter errors during code generation:
- Verify your template syntax carefully.
- Check for matching `{{end}}` statements.
- Confirm all parameter placeholders exist in method signatures.
- Use `FilterByNameAndAge(name string, age int)` style methods without SQL when chaining.
- Review the generated Go code where available for clues.
</Tip>

---

## Next Steps

- Explore the [Template DSL Guide](/guides/advanced-usage/template-dsl-guide) for deeper understanding of the template directives and syntax.
- Continue to [Creating Models & Query Interfaces](/getting-started/first-code-gen/writing-models-interfaces) to learn how to structure your Go code for generation.
- Use the [Running the Generator](/getting-started/first-code-gen/running-generator) guide to integrate your templated queries into your codebase.
- Refer to [Using Generated APIs](/guides/getting-started/using-generated-apis) to leverage the generated methods effectively.

---

## Visual Workflow

```mermaid
flowchart TD
  Start([Write Go Interface with SQL Templates]) --> AddComments[Add SQL Template Annotations]
  AddComments --> UseDirectives[Use DSL Directives (@param, @@table, {{if}}, {{for}}, etc.)]
  UseDirectives --> ValidateSyntax[Validate Template Syntax & Param Bindings]
  ValidateSyntax --> RunGenerator[Run GORM CLI to Generate Code]
  RunGenerator --> TestCode[Test Generated Type-Safe Query Methods]
  TestCode --> Success{Is Output as Expected?}
  Success -->|Yes| UseInApp[Use Generated Queries in Application]
  Success -->|No| DebugTemplates[Correct Template Syntax or Param Issues]
  DebugTemplates --> RunGenerator
```

This flowchart details your journey from writing Go interfaces with embedded SQL templates to using the generated query methods in your application.

---

## References

- [SQL Template DSL Principles](/concepts/data-modeling-and-templates/template-dsl-principles)
- [Writing Models & Query Interfaces](/getting-started/first-code-gen/writing-models-interfaces)
- [Running the Generator](/getting-started/first-code-gen/running-generator)
- [Using Generated APIs](/guides/getting-started/using-generated-apis)
- [Troubleshooting and Best Practices](/guides/advanced-usage/troubleshooting-and-patterns)

---

With this guide, you can now author templated queries within your Go interfaces confidently, unlocking the full potential of GORM CLI’s dynamic, type-safe SQL generation. Start shaping precise data queries that cater exactly to your application's needs with clarity and compile-time guarantees.