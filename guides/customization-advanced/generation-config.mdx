---
title: "Customizing Generation with Config"
description: "Comprehensive how-to for using `genconfig.Config` to customize output paths, whitelist/blacklist targets, remap field types, and fine-tune which files/interfaces participate in generation. Discusses per-package and per-file controls."
---

# Customizing Generation with Config

This guide provides a complete, practical walkthrough for using the `genconfig.Config` struct to customize your GORM CLI generation process. You'll learn how to control output directories, precisely select interfaces and structs for generation, and adapt field helper mappings to your needs. This page focuses specifically on generation configuration options that influence file outputs and content tailoring on a per-package or per-file basis.

---

## Workflow Overview

### What this guide helps you accomplish

Customize the GORM CLI code generation behavior on a granular level by declaring `genconfig.Config` literals in your source files. You will learn to:

- Override default output paths per package or per file.
- Whitelist or blacklist specific interfaces and structs to control what gets generated.
- Remap Go field types or `gen`-tagged field names to specialized field helper types.
- Adjust whether configurations apply to the entire package or just individual files.

### Prerequisites

- Familiarity with running the `gorm gen` command and the basic code generation workflow.
- A Go project with interfaces and model structs prepared for generation.
- Understanding of generated field helpers and interfaces usage.

### Expected Outcome

By following the steps in this guide, you will have precise control over which source files, interfaces, structs, and fields participate in generation, how your generated files are organized on disk, and how field helpers map to your custom types.

### Time Estimate

10-15 minutes to read and apply configuration examples.

### Difficulty Level

Intermediate, best suited for users comfortable with Go source structure and basic GORM CLI usage.

---

## Key Concepts of `genconfig.Config`

`genconfig.Config` is a struct you instantiate as a package-level variable in your Go source files. The GORM CLI generator automatically detects this and applies configuration settings found in these files during generation.

You primarily use `genconfig.Config` for:

- **Output path customization:** `OutPath`
- **Field helper remapping:** `FieldTypeMap` and `FieldNameMap`
- **Selective generation:** `IncludeInterfaces`, `ExcludeInterfaces`, `IncludeStructs`, `ExcludeStructs`
- **Scope of configuration:** `FileLevel`

### How to declare this configuration

You declare Config literals in any Go file in the package you want to customize. The generator reads these automatically during AST analysis.

```go
package example

import (
  "database/sql"
  "gorm.io/cli/gorm/genconfig"
  "gorm.io/cli/gorm/field"
)

var _ = genconfig.Config{
  OutPath: "examples/output", // Set output directory for generated files in this package
  FieldTypeMap: map[any]any{
    sql.NullTime{}: field.Time{}, // Map sql.NullTime fields to field.Time helpers
  },
  FieldNameMap: map[string]any{
    "date": field.Time{}, // For fields tagged with gen:"date"
  },
  IncludeInterfaces: []any{"Query*"}, // Include all interfaces with names starting with "Query"
  ExcludeStructs: []any{"*DTO"}, // Exclude structs whose names end with DTO
  FileLevel: false, // Apply config to package (false) or file level (true)
}
```

---

## Step-by-Step: Customizing Code Generation

<Steps>
<Step title="Declare `genconfig.Config` in your package source files">
Create a Go source file inside the package or directory that you want to customize. Import `gorm.io/cli/gorm/genconfig` and declare a global variable of type `genconfig.Config`.

```go
import "gorm.io/cli/gorm/genconfig"

var _ = genconfig.Config{
  // Config options here
}
```

This declaration is automatically recognized during generation.

</Step>

<Step title="Set output path with `OutPath`">
Use the `OutPath` field to specify a custom directory where generated files for this package will be placed. This overrides the default CLI `-o` flag for files in the same package.

Example:

```go
OutPath: "generated/output",
```

This control helps maintain a clear project structure.

</Step>

<Step title="Remap field types with `FieldTypeMap` and `FieldNameMap`">
You can map Go types or field tag names to custom field helper implementations.

- `FieldTypeMap`: keys are Go type instances (e.g., `sql.NullTime{}`), values are field wrapper instances (e.g., `field.Time{}`).
- `FieldNameMap`: keys are strings matching `gen` struct tag values, which override `FieldTypeMap`.

Example:

```go
FieldTypeMap: map[any]any{
  sql.NullTime{}: field.Time{},
},
FieldNameMap: map[string]any{
  "json": JSON{}, // Use custom JSON field helper (assumed defined)
},
```

This ensures proper SQL generation and fluent APIs for custom types.

</Step>

<Step title="Fine-tune which interfaces and structs are generated">
You can whitelist or blacklist interface and struct types.

- **Whitelists** (`IncludeInterfaces`, `IncludeStructs`) take priority: if set, only listed items generate.
- **Blacklists** (`ExcludeInterfaces`, `ExcludeStructs`) exclude listed items after inclusion checks.

Supported selectors:

- Shell-style patterns (`"Query*"`, `"*Repo"`)
- Fully qualified package/type literals (e.g., `models.User{}`)

Example:

```go
IncludeInterfaces: []any{"Query*", models.Query(nil)},
ExcludeInterfaces: []any{"*Deprecated*"},
IncludeStructs: []any{"User", "Account*", models.User{}},
ExcludeStructs: []any{"*DTO"},
```

Use these lists to focus generation on relevant parts of your codebase.

</Step>

<Step title="Control scope with `FileLevel`">
By default (`FileLevel: false`), the config applies to the entire package (all files in the package).

Setting `FileLevel: true` restricts the config to only apply to the file where it is declared.

Example:

```go
FileLevel: true,
```

This is useful for fine-grained control when multiple config files exist in the same package.

</Step>
</Steps>

---

## Practical Examples

### Example 1: Simple package-level configuration

```go
package examples

import (
  "database/sql"
  "gorm.io/cli/gorm/field"
  "gorm.io/cli/gorm/genconfig"
)

var _ = genconfig.Config{
  OutPath: "examples/output",
  FieldTypeMap: map[any]any{
    sql.NullTime{}: field.Time{},
  },
  IncludeInterfaces: []any{"Query*"},
  ExcludeStructs: []any{"*DTO"},
}
```

*Effect:* Files in the `examples` package will generate under `examples/output`. Only interfaces starting with "Query" are included. Structs ending with "DTO" will be excluded.


### Example 2: Per-file exclusion of interfaces

```go
package whitelist

import "gorm.io/cli/gorm/genconfig"

var _ = genconfig.Config{
  FileLevel: true,
  ExcludeInterfaces: []any{"I3", "*Deprecated*"},
}
```

*Effect:* This file-level config skips interfaces named "I3" and any interface matching "*Deprecated*" only in the current file.


### Example 3: Custom field name mapping for JSON columns

```go
package models

import (
  "gorm.io/cli/gorm/genconfig"
)

var _ = genconfig.Config{
  FieldNameMap: map[string]any{
    "json": JSON{},
  },
}
```

In your model:

```go
type User struct {
  Profile string `gen:"json"`
}
```

This instructs the generator to use the `JSON` field helper for the `Profile` column.

---

## Tips and Best Practices

- **Use whitelists over blacklists whenever possible** to avoid accidental omissions.
- When declaring `FieldTypeMap`, use zero-value instances (e.g., `sql.NullTime{}`) to allow the generator to infer import paths and exact types.
- Leverage `FieldNameMap` for field tag-based mappings for more semantic control.
- Use `FileLevel` cautiously — ensure that file-level configs do not conflict across files in the same package.
- Keep your output paths organized to clearly separate generated and handwritten code.

---

## Common Pitfalls & Troubleshooting

- **Config not taking effect**: Ensure your `genconfig.Config` variable is a package-level variable (declared with `var _ = genconfig.Config{}`) and properly imported.
- **Unexpected interfaces or structs generating**: Double-check your whitelist/blacklist patterns and their priorities.
- **Output path ignored**: Confirm that your config's `OutPath` is set correctly and that the config is within the package of the generated files.
- **Conflicting multiple configs in a package**: When multiple configs might apply, the output path and filters merge, but conflicts can cause unexpected results. Prefer a single source of truth per package or use `FileLevel` to isolate.

---

## What Next?

After configuring generation:

- Run the `gorm gen` command with your input path. Your configuration settings are automatically applied.
- Explore the [Generating Query APIs from Interfaces guide](https://gorm.io/docs/generating-query-apis.html) to see how generated code works with filtered interfaces.
- Consult the [Mapping and Handling Custom Field Types](https://gorm.io/docs/json-field-mapping.html) guide for advanced field helper customization.
- For troubleshooting, see the [Troubleshooting & Common Issues guide](https://gorm.io/docs/troubleshooting.html).

---

## References

- [`genconfig.Config` Go Source](https://github.com/go-gorm/cli/blob/main/genconfig/config.go)
- [Running First Code Generation](https://gorm.io/docs/first-generation-command.html)
- [Model-driven Field Helpers](https://gorm.io/docs/field-helpers-basics.html)
- [Working With Associations](https://gorm.io/docs/working-with-associations.html)

---

By mastering `genconfig.Config`, you gain precise and scalable control over your GORM CLI generation pipeline—empowering you to produce lean, maintainable, and accurately tailored query APIs and model helpers.