---
title: "Integrating Generated Code into Your GORM Project"
description: "Stepwise integration guide for bringing generated code into your repository, managing updates, and coding against the new APIs. Focuses on best practices for scalability, separation of concerns, and future-proofing your codebase."
---

# Integrating Generated Code into Your GORM Project

Integrating code generated by GORM CLI into your existing Go project is a crucial step that enables you to harness the power of type-safe queries and robust model-driven APIs. This guide walks you through practical, stepwise integration strategies to seamlessly adopt generated APIs while maintaining clarity, scalability, and ease of maintenance.

---

## 1. Integration Workflow Overview

### What this guide helps you accomplish
- Effectively incorporate generated query interfaces and field helpers into your project structure.
- Understand best practices for organizing generated and handwritten code.
- Manage updates and regenerate source code without disrupting your workflow.
- Adopt idiomatic usage patterns that maximize productivity and type safety.

### Prerequisites
- You have run the `gorm gen` command and have generated query API and field helper code available.
- Your project uses GORM as the ORM library, with version compatible with the generated code.
- Basic familiarity with Go project structure and GORM usage.

### Expected Outcome
- Your project successfully compiles using generated code.
- You are able to write queries, updates, and association operations using the generated fluent APIs.
- You have an organized project layout that cleanly separates generated code from handwritten logic.
- You have strategies in place for updating your generated code as models or interfaces evolve.

### Time Estimate
30 minutes to 1 hour for initial integration, dependent on project complexity.

### Difficulty Level
Intermediate Go and GORM project management skill.

---

## 2. Step-by-Step Integration Instructions

### Step 1: Organize Generated Code in Your Project

- **Place generated files in a dedicated package or directory.**

  Typically, set the output folder during generation via the `-o` flag (e.g., `./generated` or `gormgen`).

- **Keep generated code separate from handwritten code.**

  This separation minimizes merge conflicts and allows easier regeneration without overwriting manual changes.

- **Verify the package imports and dependencies.**

  Generated code usually imports your model package and `gorm.io/gorm`. Ensure correct import paths if you rename or move directories.

---

### Step 2: Import and Use Generated APIs in Your Application

- **Import your generated package alongside your model package.**

  ```go
  import (
      "context"
      "your_project/models"
      "your_project/generated"
      "gorm.io/gorm"
  )
  ```

- **Establish or pass your GORM `*gorm.DB` instance where needed.**

- **Invoke generated query interfaces with the generic constructors.**

  ```go
  func GetUserByID(ctx context.Context, db *gorm.DB, id int) (models.User, error) {
      userQuery := generated.Query[models.User](db)
      return userQuery.GetByID(ctx, id)
  }
  ```

- **Leverage generated field helpers for crafting filters and updates.**

  ```go
  users, err := gorm.G[models.User](db).
      Where(generated.User.Age.Gt(18)).
      Find(ctx)
  ```

- **Use association helpers for create, update, unlink, and delete operations on related data.**

  See the [Association Management Guide](/guides/core-workflows/associations-management) for detailed patterns.

---

### Step 3: Manage Code Regeneration and Updates

- **Regenerate code whenever models or query interfaces change.**

  Run your generation command (`gorm gen -i <input> -o <output>`) with the updated sources.

- **Avoid editing generated files manually.**

  Instead, implement custom logic in separate files or packages.

- **Automate regeneration as part of your build process or CI pipeline if appropriate.**

  This keeps generated APIs up to date with model changes and enforces synchronization.

- **Use configuration (`genconfig.Config`) to customize generation behavior.**

  For example, controlling output directories, field mappings, or filtering interfaces.

---

### Step 4: Adopt Idiomatic Usage in Your Application Code

- **Write context-aware queries using the generated interfaces, which embed `gorm.Interface`.**

- **Compose filters fluently with the typed field helpers for compile-time safety and discoverability.**

- **Perform batch operations and association management with the type-safe helpers.**

- **Use generated APIs as the foundation for building repository or service layers.**

- **Test database operations using helper functions and mock the generated interfaces where needed.**

---

### Step 5: Maintain Separation of Concerns

- **Keep generated code focused on direct data access.**

- **Implement business logic, validation, and error handling in separate application layers.**

- **Document any customized code that interacts with generated APIs for clarity.**

---

## 3. Practical Examples

### Example: Querying a User by ID

```go
func FindActiveUserByID(ctx context.Context, db *gorm.DB, id int) (models.User, error) {
    query := generated.Query[models.User](db)
    user, err := query.GetByID(ctx, id)
    if err != nil {
        return models.User{}, err
    }
    if user.Role != "active" {
        return models.User{}, fmt.Errorf("user not active")
    }
    return user, nil
}
```

### Example: Creating a User with Pets

```go
err := gorm.G[models.User](db).
    Set(
      generated.User.Name.Set("alice"),
      generated.User.Age.Set(28),
      generated.User.Pets.Create(generated.Pet.Name.Set("fido")),
    ).
    Create(ctx)
if err != nil {
    log.Fatalf("failed to create user and pet: %v", err)
}
```

### Example: Updating User Role and Unlinking Pets

```go
err := gorm.G[models.User](db).
    Where(generated.User.ID.Eq(10)).
    Set(
      generated.User.Role.Set("inactive"),
      generated.User.Pets.Unlink(),
    ).
    Update(ctx)
if err != nil {
    log.Fatalf("failed to update user: %v", err)
}
```

---

## 4. Troubleshooting & Tips

### Common Issues

- **Generated code does not compile due to import path conflicts.**
  - Verify generated package paths and fix import references.

- **Changes to models not reflected in generated code.**
  - Ensure you rerun generation after any model/interface update.

- **Methods missing or mismatched after regeneration.**
  - Check your query interfaces for correct SQL template annotations and method signatures.

- **Runtime panics or unexpected SQL errors.**
  - Validate parameter bindings and correctness of SQL templates.

### Best Practices

- Use descriptive package names for generated code (e.g., `generated`, `gormgen`).
- Automate code generation in your build pipeline but gate check-ins on passing tests.
- Write wrappers or adapters over generated APIs for finer domain control.
- Embrace the type-safe predicates and setters to avoid SQL injection risks.

### Performance Considerations

- Generated code calls GORM methods directly; keep your DB connection and pooling configured optimally.
- Efficiently batch create or update associations using the batch helpers.

### Alternative Approaches

- For simple projects or prototypes, you can place generated code in the same package as your models.
- For larger applications, consider generating code into its own module or service layer.

---

## 5. Next Steps & Related Documentation

- **Mastering Type-Safe Queries:** Learn advanced query patterns for complex filters and joins.
  - Link: [/guides/core-workflows/type-safe-queries](https://docs.example.com/guides/core-workflows/type-safe-queries)

- **Associations Management:** Deep dive into association helpers including create, update, unlink, and delete.
  - Link: [/guides/core-workflows/associations-management](https://docs.example.com/guides/core-workflows/associations-management)

- **Customizing Generation:** Use `genconfig.Config` to fine-tune your generation setup.
  - Link: [/guides/core-workflows/customizing-generation](https://docs.example.com/guides/core-workflows/customizing-generation)

- **Validation and Testing:** Verify your integration with generated code using provided test helpers.
  - Reference: [examples/output/test_helpers_test.go]

- **Sample Projects and Usage:** Review example usages under the `examples` directory.

---

Integrating generated code is the gateway to unlocking safer, more maintainable database operations. By following this guide, you establish a foundation for scalable, clear, and efficient application development with GORM CLI-generated APIs.
