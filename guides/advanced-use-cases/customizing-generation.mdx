---
title: "Customizing Code Generation with genconfig"
description: "Guide to advanced configuration for generation: mapping custom field types, controlling output paths, whitelisting/blacklisting targets, and leveraging file- or package-level configs. Includes real-world recipes for JSON, time, and custom type handling."
---

# Customizing Code Generation with genconfig

Unlock advanced customization of GORM CLI’s code generation workflow using package-level configuration with `genconfig.Config`. This guide walks you through tailoring output directories, mapping custom Go types to field helpers, selectively including or excluding interfaces and structs, and controlling generation scope at file or package granularity. Equipped with practical recipes such as JSON and time field mapping, you’ll gain mastery of flexible generation tailored to your project.

---

## 1. Overview of Generator Configuration

### What This Guide Covers
Customize how GORM CLI generates code from your Go interfaces and models by declaring a `genconfig.Config` value in your package. This configuration enables:

- **Output Path Control:** Customize where generated files are placed per package or file.
- **Field Type Mapping:** Associate Go types or `gen` struct tags with special field helper types.
- **Inclusion and Exclusion Filters:** Whitelist or blacklist interfaces and structs to generate.
- **Scope Control:** Decide whether configuration applies at the package or file level.

### Prerequisites
- Go 1.18 or later project with GORM CLI installed.
- Basic understanding of Go interfaces and struct definitions.
- Familiarity with GORM CLI’s generation workflow and output structure.

### Expected Outcome
After applying these configuration techniques, your generated code will:
- Include only interfaces and structs you explicitly want.
- Map custom field types (like JSON or time) to appropriate helpers.
- Place generated code in organized output folders.
- Behave predictably with complex filtering setups.

### Time Estimate
10-20 minutes to apply configuration and generate code adjusted to your needs.

---

## 2. Declaring Configuration with genconfig.Config

Place a package-level variable of type `genconfig.Config` in any source `.go` file within the package whose code you want to customize. The generator automatically picks it up.

```go
package examples

import (
    "database/sql"
    "gorm.io/cli/gorm/field"
    "gorm.io/cli/gorm/genconfig"
)

var _ = genconfig.Config{
    // Customize output directory for generated code from this package
    OutPath: "examples/output",

    // Map Go types to field helpers directly
    FieldTypeMap: map[any]any{
        sql.NullTime{}: field.Time{},
    },

    // Map struct field gen tags to custom field helpers
    FieldNameMap: map[string]any{
        "json": JSON{}, // a custom JSON field helper
    },

    // Limit generation to specific interfaces and struct types
    IncludeInterfaces: []any{"Query*"},
    IncludeStructs:    []any{"User", "Account*"},

    // Apply only to this file if true; otherwise package-wide
    FileLevel: false,
}
```

<Note>
Declaring `var _ = genconfig.Config{}` ensures the variable is global in your package without affecting runtime.
</Note>

---

## 3. Configuration Options in Detail

### OutPath: Control Output Location
- Overrides the CLI `-o` flag **per package** or **per file**, if `FileLevel` is true.
- Enables organizing generated code logically by domain or functionality.

```go
OutPath: "generated/models",
```

### FileLevel: Scope of Configuration
- `false` (default): Config applies **to all files in the package**.
- `true`: Config applies **only to the source file in which it is declared**.

Use `FileLevel: true` for fine-grained per-file overrides.

### FieldTypeMap: Map Go Types to Field Helpers
- Associates Go type literals (e.g., `sql.NullTime{}`) with custom field helper types (`field.Time{}`).
- Useful to customize behavior, like treating nullable SQL times as time fields in generated code.

Example mapping:

```go
FieldTypeMap: map[any]any{
    sql.NullTime{}: field.Time{},
},
```

### FieldNameMap: Map gen Tag Names to Field Helpers
- Targets struct fields tagged with `gen:"tagname"`.
- Maps the tag string to a field helper type.

Example with a JSON helper:

```go
FieldNameMap: map[string]any{
    "json": JSON{},
},
```

This causes any struct field with `gen:"json"` to use the `JSON` helper type.

### IncludeInterfaces and ExcludeInterfaces: Filtering Interfaces
- Control which interfaces are generated by including or excluding them.
- Supports shell-style glob patterns (`"Query*"`, `"*Repo"`) or direct type conversions (`models.Query(nil)`).

Rules:
- If `IncludeInterfaces` is non-empty, **only** matching interfaces are generated.
- Otherwise, all interfaces except those matching `ExcludeInterfaces` are generated.

Example:

```go
IncludeInterfaces: []any{"Query*", models.Query(nil)},
ExcludeInterfaces: []any{"*Deprecated*"},
```

### IncludeStructs and ExcludeStructs: Filtering Structs
- Similar filtering but for struct types.
- Supports patterns like `"User"`, `"Account*"` or concrete type literals.

Example:

```go
IncludeStructs: []any{"User", "Account*"},
ExcludeStructs: []any{"*DTO"},
```

---

## 4. Practical Recipes and Examples

### Recipe 1: Map sql.NullTime to Field.Time and Custom JSON Helper

```go
package models

import (
    "database/sql"
    "gorm.io/cli/gorm/field"
    "gorm.io/cli/gorm/genconfig"
)

var _ = genconfig.Config{
    OutPath: "models/generated",
    FieldTypeMap: map[any]any{
        sql.NullTime{}: field.Time{},
    },
    FieldNameMap: map[string]any{
        "json": JSON{},
    },
}
```

Then in your model struct:

```go
type User struct {
    ID        int
    CreatedAt sql.NullTime
    Profile   string `gen:"json"`
}
```

The generator will use `field.Time` for `CreatedAt` and the custom JSON helper for `Profile`.

### Recipe 2: Whitelist Query Interfaces Starting with "Query"

```go
package queries

import "gorm.io/cli/gorm/genconfig"

var _ = genconfig.Config{
    IncludeInterfaces: []any{"Query*"},
}
```

Only interfaces named like `QueryUser`, `QueryAccount` etc. will be generated.

### Recipe 3: Exclude Deprecated Interfaces Globally

```go
package data

import "gorm.io/cli/gorm/genconfig"

var _ = genconfig.Config{
    ExcludeInterfaces: []any{"*Deprecated*"},
}
```

Avoids generating code for any interface name containing "Deprecated".

### Recipe 4: Generate Per File Output Directory

Place in a specific file:

```go
var _ = genconfig.Config{
    OutPath:   "generated/special",
    FileLevel: true,
}
```

Overrides output directory only for that single file, allowing mixed per-package and per-file generation.

---

## 5. Best Practices and Tips

- **Use include filters to prevent accidental generation** of unwanted interfaces or structs.
- **Prefer `FieldNameMap` for tag-based mappings** when you want to control specific fields via struct tags.
- **Declare configuration variables early in source files** to keep clarity on generation settings.
- **Apply `FileLevel=true` sparingly** to avoid fragmented output unless truly necessary.
- **Keep output paths consistent with Go module layout** to simplify imports and usability.

<Warning>
Incorrect or conflicting include/exclude patterns may cause no code to be generated or unexpected omissions. Validate your patterns carefully.
</Warning>

---

## 6. Troubleshooting Common GenConfig Issues

### No Code Generated
- Verify your include patterns aren’t overly restrictive.
- Check that `FileLevel` setting matches your file arrangement.

### Custom Field Helpers Not Applied
- Confirm the key type in `FieldTypeMap` is an instance literal (e.g., `sql.NullTime{}` not `sql.NullTime`).
- Ensure `FieldNameMap` keys match the exact `gen` tag string.

### Output Directory Not Changing
- Confirm your `OutPath` is not overridden by CLI flags.
- Use `FileLevel: true` for file-specific overrides if necessary.

### Conflicts Between Multiple Configs
- GORM CLI merges configurations from all files in a package.
- Ordering and priority favors the CLI flag, then configs in lexicographical file order.

---

## 7. Next Steps & Additional Resources

- Explore the [Generation Config Concept](https://docs.gorm.io/concepts/extensibility-integration/generation-config) for deeper architecture understanding.
- Combine genconfig customization with [Defining Models and Query Interfaces](https://docs.gorm.io/getting-started/first-code-generation/defining-models-and-interfaces) to optimize your input.
- Use the [Running the Generator Guide](https://docs.gorm.io/getting-started/first-code-generation/running-gorm-cli-gen) to verify configuration effects.
- Consult the [JSON Field Mapping Example](https://docs.gorm.io/overview/introduction_value/value_prop_use_cases#json-mapping) for advanced scenarios.

---