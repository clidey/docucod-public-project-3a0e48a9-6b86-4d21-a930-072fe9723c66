---
title: "Writing Powerful Queries with the Template SQL DSL"
description: "Best practices for authoring complex SQL in interface comments using GORM CLI's template DSL. Learn conditional clauses, dynamic columns, parameter mapping, and iteration for flexible, maintainable query logic."
---

# Writing Powerful Queries with the Template SQL DSL

Explore best practices for authoring complex SQL queries inside interface method comments using GORM CLI's Template SQL DSL. This guide empowers you to craft flexible, maintainable query logic with conditional clauses, dynamic columns, parameter mapping, and iteration—all within your Go code's query interfaces.

---

## Workflow Overview

### Task Description
Learn how to write advanced SQL queries directly in Go interface comments using GORM CLI's templating capabilities, enabling generation of type-safe, fluent query APIs that adapt dynamically based on input.

### Prerequisites
- Familiarity with Go interfaces and method declarations.
- Basic understanding of SQL syntax.
- GORM CLI installed and set up for your project.
- Models and query interfaces defined in Go with appropriate imports.

### Expected Outcome
By following this guide, you will be able to:
- Embed SQL templates with dynamic and conditional logic inside interface comments.
- Use placeholders and directives to bind Go parameters safely.
- Create adaptable query methods that conditionally include parts of SQL.
- Iterate over collections for complex query construction.

### Time Estimate
10–20 minutes, depending on familiarity with templating concepts.

### Difficulty Level
Intermediate

---

## Step-by-Step Instructions

### 1. Define Interface Methods With SQL Templates in Comments

Inside your Go query interface, annotate methods with SQL queries as comments. Use the template DSL directives to build dynamic queries.

Example:

```go
// QueryWith fetches a record by ID or Name depending on input
//
// SELECT * FROM users
//   {{if user.ID > 0}}
//       WHERE id=@user.ID
//   {{else if user.Name != ""}}
//       WHERE name=@user.Name
//   {{end}}
QueryWith(user User) (User, error)
```

**What happens here:**
- `{{if}}` and `{{else if}}` control conditional SQL generation.
- `@user.ID` and `@user.Name` map Go method parameters into safe SQL placeholders.


### 2. Use the Built-In Template DSL Keywords and Placeholders

Leverage specific DSL directives for common SQL parts:

| Directive  | Purpose                             | Example Usage                                         |
|------------|-----------------------------------|-----------------------------------------------------|
| `@@table`  | Model's table name replacement    | `SELECT * FROM @@table WHERE id=@id`                 |
| `@@column` | Dynamic column replacement         | `WHERE @@column=@value`                              |
| `@param`   | Maps Go parameter to SQL placeholder | `WHERE name=@user.Name`                              |
| `{{where}}`| Generates conditional WHERE clause | `{{where}} age > 18 {{end}}`                         |
| `{{set}}`  | Generates conditional SET clause   | `{{set}} name=@name {{end}}`                         |
| `{{if}}`   | Conditional SQL fragments          | `{{if age > 0}} AND age=@age {{end}}`                |
| `{{for}}`  | Iterates over collections          | `{{for _, tag := range tags}} ... {{end}}`          |


### 3. Build Conditional WHERE and SET Clauses

Use `{{where}}` and `{{set}}` blocks to assemble SQL segments that appear only when certain conditions are met.

Example for `{{where}}`:

```sql
SELECT * FROM @@table
{{where}}
  {{if name != ""}} name=@name {{end}}
  {{if age > 0}} AND age=@age {{end}}
{{end}}
```

Example for `{{set}}`:

```sql
UPDATE @@table
{{set}}
  {{if user.Name != ""}} name=@user.Name, {{end}}
  {{if user.Age > 0}} age=@user.Age, {{end}}
{{end}}
WHERE id=@id
```

These blocks automatically trim leading/trailing connectors (`AND`, `OR`, commas), ensuring clean SQL generation.

### 4. Write Nested Conditionals and Use `else` Branches

Enable complex logic inside your SQL templates with nested `{{if}}`, `{{else if}}`, and `{{else}}`:

```sql
{{if user.Age >= 18}}
  is_adult = 1
{{else}}
  is_adult = 0
{{end}}
```

This lets you generate mutually exclusive parts of a query depending on parameter values.

### 5. Iterate Over Collections for Repeated Conditions

Use `{{for}}` to loop over slices or arrays passed as parameters for queries that need OR filters or IN clauses.

Example:

```sql
SELECT * FROM @@table
{{where}}
  {{for _, user := range users}}
    {{if user.Name != "" && user.Age > 0}}
      (name = @user.Name AND age=@user.Age) OR
    {{end}}
  {{end}}
{{end}}
```

The generated SQL will concatenate conditions for each user in the slice.

### 6. Escape Special Literals When Needed

To include a literal `@` symbol (such as in a plain string value), escape it with a backslash (`\@`).

Example:

```sql
SELECT * FROM @@table WHERE name = "\@name"
```

This ensures the literal '@name' appears in the SQL rather than being interpreted as a parameter.

### 7. Map Go Parameters to SQL Parameters Automatically

GORM CLI automatically converts parameter references prefixed by `@` into safe SQL placeholders, with binding of actual Go values. You simply refer to parameters as `@param`, `@user.Name`, or even `@@column` for dynamic columns.

This prevents SQL injection and provides type safety.

### 8. Generate Code and Use Generated APIs

After your interface has annotated SQL comments, run:

```bash
gorm gen -i ./path/to/interfaces -o ./generated
```

Then use the generated APIs:

```go
user, err := generated.Query[User](db).GetByID(ctx, 123)
users, err := generated.Query[User](db).FilterByNameAndAge("alice", 30).Find(ctx)
```

---

## Examples

### Safe Parameter Binding

```go
// SELECT * FROM @@table WHERE id=@id AND status=@status
GetByIDAndStatus(id int, status string) (User, error)
```
This generates a query with `id` and `status` safely bound.

### Dynamic Columns

```go
// SELECT * FROM @@table WHERE @@column=@value
FilterWithColumn(column string, value string) (User, error)
```
Dynamically binds which column to filter.

### Conditional WHERE Clause

```sql
SELECT * FROM @@table
{{where}}
  {{if name != ""}} name=@name {{end}}
  {{if age > 0}} AND age=@age {{end}}
{{end}}
```
Generates WHERE clause only including those conditions where parameters have values.

### Dynamic UPDATE

```sql
UPDATE @@table
{{set}}
  {{if user.Name != ""}} name=@user.Name, {{end}}
  {{if user.Email != ""}} email=@user.Email {{end}}
{{end}}
WHERE id=@id
```
Updates select fields based on conditions.

### Iteration Example

```sql
SELECT * FROM @@table
{{where}}
  {{for _, tag := range tags}}
    {{if tag != ""}} tags LIKE concat("%",@tag,"%") OR {{end}}
  {{end}}
{{end}}
```
Constructs multiple OR conditions based on a list of tags.

---

## Troubleshooting & Tips

<AccordionGroup title="Common Issues and Solutions">
<Accordion title="Empty WHERE or SET Clauses">
If your `{{where}}` or `{{set}}` block results in empty SQL and causes errors, verify that conditional expressions inside `{{if}}` blocks evaluate as expected. For example, ensure parameters are properly named and passed.
</Accordion>
<Accordion title="Incorrect Parameter Binding">
Verify that all `@param` placeholders correspond exactly to method parameters. Misspellings or inconsistent naming cause generation errors or invalid queries.
</Accordion>
<Accordion title="Escaping @ Symbols"
>
Remember to use `\@` to escape literal `@` signs in SQL strings to avoid them being treated as parameter placeholders.
</Accordion>
<Accordion title="Managing Commas in SET Blocks">
Always write commas inside the `{{if}}` block (like `name=@user.Name,`) except for the last field, or use trimming as the DSL handles trailing commas gracefully.
</Accordion>
</AccordionGroup>

### Best Practices

- Use `@@table` consistently to refer to the model's table name.
- Prefer using `{{where}}` and `{{set}}` blocks to conditionally generate SQL sections.
- Indent SQL in comments for readability, but actual indentation is not required for generation.
- Use `{{for}}` for slicing and dynamic OR clauses instead of manual concatenation.
- Check SQL comments for syntax carefully before generating.

### Performance Considerations

Keep dynamically generated SQL concise to maintain query optimizer efficiency. Avoid complex nested loops or redundant conditions inside templates.

### Alternative Approaches

If your query logic is too complex for in-comment templating, consider implementing it programmatically with GORM after generating field helpers, or split logic into smaller methods.

---

## Next Steps & Related Content

- Proceed to [Working with Associations: Patterns & Best Practices](/guides/advanced-use-cases/associations-best-practices) to extend your DSL queries to association manipulations.
- Learn about [Customizing Code Generation with genconfig](/guides/advanced-use-cases/customizing-generation) to fine-tune generation behavior.
- Review [Defining Models and Query Interfaces](/getting-started/first-code-generation/defining-models-and-interfaces) to prepare clean interface definitions.
- Use [Generating Type-Safe Query APIs](/guides/core-workflows/generating-query-apis) for a holistic view on generating and using typed query methods.

---

## Visual Diagram: Query Method Processing Flow

```mermaid
flowchart TD
  A[Start: Write Interface Method with SQL Template] --> B[Parse SQL Template Comment]
  B --> C{Identify Directives}

  C -->|@@table, @@column| D[Replace with Table/Column Placeholders]
  C -->|@param| E[Bind Parameters from Method Signature]
  C -->|{{where}}/{{set}}| F[Generate Conditional Clause]
  C -->|{{if}}/{{else if}}/{{else}}| G[Generate Conditional Fragments]
  C -->|{{for}}| H[Generate Iteration Logic]

  D --> I[Build SQL String with Placeholders]
  E --> I
  F --> I
  G --> I
  H --> I

  I --> J[Generate Go Code Method Body]
  J --> K[Compile-Time Safe API]
  K --> L[User Calls Generated Method with Params]
  L --> M[Runtime Executes Safe Param-Bound SQL]
  M --> N[Return Query Result or Error]

  style A fill:#e0f3ff,stroke:#333,stroke-width:2px
  style N fill:#d4efdf,stroke:#333,stroke-width:2px
```

---

<Tip>
Use clear and descriptive parameter names in your method signature; this ensures your `@param` placeholders map correctly and the generated queries are intuitive.
</Tip>

<Note>
The template DSL is designed for safety and clarity; avoid injecting raw SQL outside the supported directives to maintain security and type safety.
</Note>