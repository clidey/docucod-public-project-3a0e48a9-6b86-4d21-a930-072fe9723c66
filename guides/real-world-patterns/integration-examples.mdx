---
title: "Integrating Generated Code into Your Project"
description: "Best practices for organizing, importing, and evolving generated code within complex or growing Go applications. Includes examples for keeping custom and generated code maintainable, and leveraging GORM CLI alongside other tools."
---

# Integrating Generated Code into Your Project

This guide helps you effectively organize, import, and maintain the code generated by GORM CLI within real-world Go applications. As your project grows in complexity, following these best practices ensures your custom and generated code remain clean, maintainable, and scalable while leveraging GORM CLI's powerful features.

---

## 1. Why This Matters

Generated code can rapidly become a critical part of your application. To keep your projects manageable:

- **Separate concerns** clearly between your handwritten logic and GORM CLIâ€“generated files.
- **Avoid manual edits** to generated code to prevent overwrites and inconsistencies.
- Use configuration and tooling to **control where and how code is generated**.
- Understand how to **evolve your schemas and queries** without breaking existing code.

These practices save time and headaches, especially when onboarding new team members or refactoring.

---

## 2. Preparing Your Project Structure for Generated Code

A consistent and clear project layout sets the foundation:

### Recommended Layout

```
/myapp
  /models            # Your Go structs (model definitions)
  /queries           # Your query interfaces with SQL templates
  /generated         # The output folder for CLI-generated code
    models.go        # Generated model field helpers
    iface.go         # Generated Query interface implementations
```

**Why?**

- Keeps source and generated code separate,
- Enables clean imports,
- Simplifies code reviews and tooling.

### Organizing by Package

- Place interfaces and your model structs in logically grouped packages, e.g., `/queries` and `/models`.
- Configure `genconfig.Config` to generate output specifically in `/generated` for those packages, avoiding clutter.

<Tip>
Configure `genconfig.Config.OutPath` in your packages to direct where generated code is saved. This prevents scattered files.
</Tip>

Example:
```go
var _ = genconfig.Config{
    OutPath: "./generated",
}
```

---

## 3. Importing and Using Generated Code

Once generated, import the generated packages cleanly to use fluent APIs and helpers.

```go
import (
    "myapp/generated"
    "gorm.io/gorm"
)

func FindUserByID(db *gorm.DB, ctx context.Context, id int) (generated.User, error) {
    return generated.Query[generated.User](db).GetByID(ctx, id)
}
```

### Key Tips

- **Avoid cyclic dependencies:** Your model package should not import `generated`. Keep generated code independent.
- Use type aliases or wrapper functions when needed to decouple layers.

---

## 4. Keeping Generated and Custom Code Maintainable

Avoid touching generated files directly. Instead:

- Change your source interface or model definitions to update generation.
- Use meaningful interface names and group models to maintain clarity.
- Use `genconfig.Config` filters (`IncludeInterfaces`, `ExcludeInterfaces`, `IncludeStructs`, `ExcludeStructs`) to control what gets generated.

### Practical Example: Filtering Generation
```go
var _ = genconfig.Config{
    IncludeInterfaces: []any{"Query*"}, // Only generate interfaces starting with 'Query'
    ExcludeStructs: []any{"Internal*"}, // Exclude structs with prefix 'Internal'
}
```

---

## 5. Leveraging GORM CLI Alongside Other Tools

If your project uses other code generation tools or ORM extensions:

- Standardize output to dedicated folders per tool to avoid collisions.
- Use Go module replace or alias if needed to import generated code cleanly.
- Document conventions clearly for your team to avoid confusion.

<Tip>
Integrate generation into your CI pipelines to always keep generated code fresh and consistent.
</Tip>

---

## 6. Evolving Generated Code As Your Project Grows

### Update Interfaces and Models
- Modify or add new methods in your query interfaces.
- Update struct fields or association relationships.
- Run the CLI generator again to reflect changes.

### Handle Breaking Changes
- Use careful interface versioning or differently named interfaces if needed.
- Selectively generate code to keep backward compatibility.

### Example Control via CLI
```bash
gorm gen -i ./queries -o ./generated
```

This regenerates code in the specified output directory reflecting your latest changes.

---

## 7. Best Practices & Common Pitfalls

<AccordionGroup title="Best Practices & Common Pitfalls">
<Accordion title="Separate Source and Generated Code">
Always keep your handwritten models and query interfaces in separate packages or folders from the generated code to easily manage edits and prevent accidental changes.
</Accordion>
<Accordion title="Avoid Manual Edits to Generated Files">
Never manually edit generated code. Doing so will lead to conflicts and overwritten changes when you regenerate.
</Accordion>
<Accordion title="Use Config Filters to Limit Generation Scope">
Use `IncludeInterfaces` and `ExcludeInterfaces` to precisely generate only what you need, improving compile times and reducing clutter.
</Accordion>
<Accordion title="Manage Imports Carefully to Avoid Cyclic Dependencies">
Structure your imports so generated packages do not import your core model packages back, preventing cyclic import errors.
</Accordion>
<Accordion title="Regenerate After Every Change to Interfaces or Models">
Make regenerating code a regular habit, triggered manually or in your build pipeline, to keep all generated APIs in sync with your source.
</Accordion>
</AccordionGroup>

---

## 8. Troubleshooting Integration Issues

### Common Scenarios

- **Generated code not found on import**:
  - Verify `OutPath` matches import path.
  - Ensure Go module setup includes generated folder.

- **Conflicts or cyclic imports**:
  - Check and restructure packages.
  - Use interfaces or type aliases to break cycles.

- **Generation misses expected interfaces or models**:
  - Confirm inclusion and exclusion config settings.
  - Check naming patterns and interface signatures.

<Tip>
Run `go mod tidy` and build after generating code to detect integration issues early.
</Tip>

---

## 9. Next Steps & Additional Resources

- **Learn how to customize generation configurations:** Explore [Customizing Code Generation](/guides/advanced-generation/generation-configuration)
- **Understand template-based queries:** See [Building Template-Based Query Interfaces](/guides/advanced-generation/template-sql-workflows)
- **Master advanced field helpers and associations:** Check out [Advanced Field and Association Helpers](/guides/advanced-generation/advanced-model-helpers)
- **Troubleshooting:** For pitfalls and fixes, visit [Troubleshooting and Common Pitfalls](/guides/real-world-patterns/troubleshooting-common-issues)

Integrate these principles for a robust, maintainable, and scalable codebase using GORM CLI.

---

## References

- [GORM CLI README](https://github.com/go-gorm/cli)
- [Generating Code](https://docs.gorm.io/guides/getting-started-first-codegen-project-generate-code.html)
- [Using Generated APIs](https://docs.gorm.io/guides/getting-started-first-codegen-project-quickstart-usage.html)

---

Start by structuring your codebase for clean separation, then incrementally introduce generated query APIs and helpers following this guide to gain maximum productivity and maintainability.