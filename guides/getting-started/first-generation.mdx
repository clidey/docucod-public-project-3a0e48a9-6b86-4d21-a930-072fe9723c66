---
title: "Generating Your First Code"
description: "Learn how to define a model, create a query interface with SQL templates, and run the code generator to create type-safe APIs. This step-by-step tutorial demonstrates the end-to-end workflow from model design to generated code usage."
---

# Generating Your First Code

Master the essential workflow to define your data models and query interfaces, then generate fully type-safe APIs in Go using GORM CLI. This guide walks you through creating your first model, embedding SQL templates, and running the `gen` command to produce fluent, compile-time safe code that seamlessly integrates with your GORM-based project.

---

## 1. Workflow Overview

### What You'll Achieve
This guide enables you to:
- Define your Go data models structuring database entities.
- Create query interfaces with embedded SQL templates for data access.
- Use the GORM CLI code generator to produce type-safe APIs.
- Understand how to use generated code for robust database operations.

### Prerequisites
- Go development environment (Go 1.18+).
- GORM CLI installed (`go install gorm.io/cli/gorm@latest`).
- Basic familiarity with Go structs and interfaces.
- A GORM-compatible database setup (optional, for using generated code).

### Expected Outcome
You will have generated source code files providing:
- Typed query interfaces matching your SQL-defined methods.
- Model field helpers for constructing filters, updates, and associations.
- Ready-to-use APIs that improve safety and reduce boilerplate.

### Time Estimate
- 20 to 40 minutes, depending on familiarity with Go and SQL.

### Difficulty Level
- Beginner to Intermediate.

---

## 2. Step-by-Step Instructions

### Step 1: Define Your Go Model Struct

Create a Go struct representing your database entity with standard GORM fields.

```go
// models/user.go
package models

import "gorm.io/gorm"

type User struct {
    gorm.Model
    Name  string
    Age   int
}
```

- Ensure exported fields are properly tagged if needed.
- The generator uses these structs to create field helpers for filtering and updates.

### Step 2: Write a Query Interface with SQL Templates

Define a Go interface with methods annotated via comments containing SQL templates.

```go
// examples/query.go
package examples

type Query[T any] interface {
  // SELECT * FROM @@table WHERE id=@id
  GetByID(id int) (T, error)

  // where("name=@name AND age=@age")
  FilterByNameAndAge(name string, age int) Query[T]
}
```

- Use `@@table` to refer to the model's table name dynamically.
- Use `@param` placeholders to safely map method parameters to SQL.
- Return error as the last result, data types match your model.
- Methods returning the interface type enable chaining.

### Step 3: Run the GORM CLI Generator

Invoke the generator, specifying your source path and output directory.

```bash
gorm gen -i ./examples -o ./generated
```

- `-i`: The input directory or file containing your models and interfaces.
- `-o`: The output directory where the generated code will be placed.
- The CLI scans your source files, parses SQL templates, and outputs typed APIs and field helpers.

### Step 4: Verify Generated Files

Inspect the generated code in the output directory:
- Typed query interface implementations.
- Field helpers for your models with predicates and updater methods.

The generators follow these patterns:
- Interface-driven query APIs for database reads and writes.
- Model-driven field helpers to compose SQL clauses safely.

### Step 5: Use Generated APIs in Your Code

Import and use the generated query interfaces and helpers to perform database operations.

```go
package main

import (
  "context"
  "gorm.io/gorm"
  "your_module/generated"
  "your_module/models"
)

func main() {
  var db *gorm.DB // initialized GORM DB
  ctx := context.Background()

  // Query user by ID
  user, err := generated.Query[models.User](db).GetByID(ctx, 123)
  if err != nil {
    panic(err)
  }
  fmt.Println(user.Name)

  // Filter users by name and age
  users, err := generated.Query[models.User](db).
    FilterByNameAndAge("Alice", 30).
    Find(ctx)
  if err != nil {
    panic(err)
  }
  fmt.Println(users)
}
```

- The generated APIs are fully type-safe, ensuring compile-time correctness.
- Use field helpers to build complex queries seamlessly.

---

## 3. Real-World Examples & SQL Templates

### Example Interface with SQL Templates

```go
package examples

type Query[T any] interface {
  // SELECT * FROM @@table WHERE id=@id
  GetByID(id int) (T, error)

  // SELECT * FROM @@table WHERE @@column=@value
  FilterWithColumn(column string, value string) (T, error)

  // UPDATE @@table
  // {{set}}
  //   {{if user.Name != ""}} name=@user.Name, {{end}}
  //   {{if user.Age > 0}} age=@user.Age {{end}}
  // {{end}}
  // WHERE id=@id
  UpdateUser(user T, id int) error
}
```

### SQL Template Syntax Highlights

| Directive  | Description                       | Example                                       |
|------------|---------------------------------|-----------------------------------------------|
| `@@table`  | Substitutes model's table name   | `SELECT * FROM @@table WHERE id=@id`           |
| `@@column` | Dynamic column name binding      | `WHERE @@column=@value`                        |
| `@param`   | Maps Go parameter values safely  | `WHERE name=@user.Name`                        |
| `{{where}}`| Conditionally composes WHERE     | `{{where}} age > 18 {{end}}`                   |
| `{{set}}`  | Conditionally composes SET clause| `{{set}} name=@name {{end}}`                   |
| `{{if}}`   | Adds conditional SQL fragments   | `{{if age > 0}} AND age=@age {{end}}`          |
| `{{for}}`  | Iterates over collections        | `{{for _, tag := range tags}} ... {{end}}`     |

These features let you write expressive SQL queries embedded directly in your Go interface comments for generation into safe methods. 

---

## 4. Troubleshooting & Tips

### Common Pitfalls
- **Missing context parameter**: The generator automatically injects `ctx context.Context` if omitted, but specifying explicitly avoids confusion.
- **No return error**: Query methods must return an error as the last return value.
- **Mismatched SQL and parameters**: Ensure parameters in SQL templates correspond exactly to method argument names.
- **Unsupported SQL directives**: Use only supported directives and avoid raw SQL not supported by the template DSL.

### Best Practices
- Keep models and interfaces in the same Go package or directory for straightforward generation.
- Use descriptive method names reflecting the actual query intent.
- Embed small, focused SQL templates for clarity and maintainability.
- Use the generator's output as a foundation and extend your business logic on top.

### Performance Considerations
- Minimize complex joins or nested queries in SQL templates to keep generated code performant.
- Use field helpers for filtering rather than heavy dynamic SQL generation when possible.

### Alternative Approaches
- Customize generation via `genconfig.Config` for advanced scenarios (e.g., separate output paths, mappings).
- Extend interfaces with template SQL for advanced query logic without modifying models.

---

## 5. Next Steps & Related Content

- Proceed to [Using the Generated APIs](/guides/getting-started/using-generated-apis) to learn how to integrate these APIs in your application.
- Explore [Project Setup & Model Definition](/getting-started/first-codegen-project/project-setup) for detailed guidance on preparing your source code.
- Check [Basic Generator Configuration](/getting-started/troubleshooting-configuration/basic-configuration) for custom generation tuning.
- Review [Troubleshooting Common Setup Issues](/getting-started/troubleshooting-configuration/cli-troubleshooting) if you encounter errors during generation.
- Deepen your understanding of core features in [Feature Overview](/overview/core-concepts-basics/feature-overview).

---

## Appendix: Example Full CLI Generation Command

```bash
gorm gen -i ./examples -o ./generated
```

This command processes all your model and interface definitions under `./examples` and writes generated code into `./generated`.


<Tip>
Keep your model structs and query interfaces well-organized and well-documented. Clear SQL templates lead to straightforward generated code and robust APIs.
</Tip>

<Note>
The code generator automatically injects `context.Context` into method signatures if missing, ensuring consistency.
</Note>

<Warning>
Avoid editing generated files manually. Instead, adjust your models or interfaces and rerun the generator.
</Warning>

---

Happy coding with GORM CLI!
