---
title: "Quickstart: Generate Your First Type-Safe API"
description: "A hands-on walkthrough: define your models, create query interfaces with SQL templates, and generate strongly typed APIs using GORM CLI. Understand the end-to-end flow from initial Go code to working queries, including key tips for a smooth first run."
---

# Quickstart: Generate Your First Type-Safe API

Welcome to your hands-on walkthrough for generating your first type-safe API using GORM CLI. This guide will walk you through the essential steps: defining your Go models, creating query interfaces with embedded SQL templates, running the GORM CLI generator, and finally integrating the generated APIs with your application. By following these steps, you’ll build confidence capturing the end-to-end flow from your initial Go code to working, type-safe database queries.

---

## 1. What You Will Accomplish

This guide helps you:

- Define your data models with Go structs.
- Write query interfaces using SQL templates in Go interface comments.
- Generate strongly typed, interface-driven CRUD & query methods using GORM CLI.
- Understand how to use the generated code effectively.

This is your first step to safe, productive database interactions with compiler-verified SQL mappings.


### Prerequisites
- Go 1.18+ installed with module support.
- Basic familiarity with Go structs and interfaces.
- GORM CLI installed (see [Installing GORM CLI](../../getting-started/setup-requirements-installation/installing-gorm-cli) for instructions).
- A database driver set up with GORM (e.g., SQLite, MySQL).


### Expected Outcome
After completing this guide, you will have:
- Defined a sample model and query interface.
- Generated matching Go code with strongly typed query methods.
- Executed your first queries using the generated API.


### Estimated Time
15-30 minutes, depending on your Go setup and familiarity.


---

## 2. Step-By-Step Instructions

<Steps>
<Step title="Define Your Data Model(s) as Go Structs">
Start by creating your Go model structs to represent database tables.

```go
// models/user.go
package models

import "gorm.io/gorm"

type User struct {
  gorm.Model
  Name    string
  Age     int
  Role    string
  IsAdult bool
}
```

**What you should see:** a Go struct file ready to use as a GORM model.

This struct defines fields that correspond to your DB columns, and GORM auto-manages primary key and timestamps.
</Step>

<Step title="Create a Query Interface with SQL Templates">
Define an interface where each method has a Go comment with embedded SQL template.

Example:

```go
// examples/query.go
package examples

type Query[T any] interface {
  // SELECT * FROM @@table WHERE id=@id
  GetByID(id int) (T, error)

  // SELECT * FROM @@table WHERE @@column=@value
  FilterWithColumn(column string, value string) (T, error)

  // UPDATE @@table
  // {{set}}
  //   {{if user.Name != ""}} name=@user.Name, {{end}}
  //   {{if user.Age > 0}} age=@user.Age, {{end}}
  // {{end}}
  // WHERE id=@id
  UpdateInfo(user User, id int) error
}
```

**Notes:**
- `@@table` resolves to the table for the generic type.
- `@param` represents Go method parameters injected safely.
- Use `{{where}}` / `{{set}}` blocks for dynamic SQL.

**What you should see:** a Go interface file with SQL comments defining query logic.

</Step>

<Step title="Optionally Define Generation Configuration">
You can configure code generation with a package-level `genconfig.Config` variable, e.g.: 

```go
package examples

import (
  "gorm.io/cli/gorm/genconfig"
  "gorm.io/cli/gorm/field"
  "database/sql"
)

var _ = genconfig.Config{
  OutPath: "examples/output",
  FieldTypeMap: map[any]any{
    sql.NullTime{}: field.Time{},
  },
  IncludeInterfaces: []any{"Query*"},
}
```

**Tips:**
- This controls where generated files go.
- You can whitelist or blacklist interfaces and structs.

If you skip this, default settings apply.

</Step>

<Step title="Run the GORM CLI Generator">
Run this command in your terminal to generate the code:

```bash
gorm gen -i ./examples -o ./generated
```

Parameters:
- `-i`, `--input`: path to your Go files with interfaces and models.
- `-o`, `--output`: directory to place generated code.

**Expected output:**
- GORM CLI processes your input files,
- Extracts interface and struct info,
- Produces generated Go code with type-safe methods in the output folder.

Watch for console messages confirming files generated without error.

</Step>

<Step title="Verify Generated Code and Import It">
Check the generated files in your output directory, commonly containing:

- Interface implementations with method bodies.
- Model helpers for fields and associations.

Then import your generated package in your app code:

```go
import "your/module/generated"
```

You can now invoke generated queries as methods:

```go
user, err := generated.Query[models.User](db).GetByID(ctx, 123)
```

This call executes the query defined in your interface’s SQL comment with full type safety and matches your model.

</Step>

<Step title="Run Example Queries and Iterate">
Try running queries using the generated API:

```go
users, err := generated.Query[models.User](db).FilterWithColumn(ctx, "role", "active")
if err != nil {
  log.Fatal(err)
}
for _, u := range users {
  fmt.Println(u.Name, u.Age)
}
```

Build on this foundation by adding more methods in interfaces and regenerating.

Repeat the cycle: edit interfaces → run generator → use generated APIs.

</Step>
</Steps>

---

## 3. Real-World Examples

### Minimal Query Interface Example

```go
package examples

type Query[T any] interface {
  // SELECT * FROM @@table WHERE id=@id
  GetByID(id int) (T, error)

  // UPDATE @@table
  // {{set}}
  //   {{if user.Name != ""}} name=@user.Name, {{end}}
  //   {{if user.Age > 0}} age=@user.Age, {{end}}
  // {{end}}
  // WHERE id=@id
  UpdateInfo(user User, id int) error
}
```

This represents a typical scenario where you retrieve or update a user by ID, while allowing conditions in SQL.

### Generated Method Usage

```go
db, _ := gorm.Open(sqlite.Open("test.db"), &gorm.Config{})

query := generated.Query[models.User](db)

user, err := query.GetByID(ctx, 42)
if err != nil {
  log.Fatal(err)
}
fmt.Println("User Name:", user.Name)

err = query.UpdateInfo(ctx, models.User{Name: "Alice", Age: 30}, 42)
if err != nil {
  log.Fatal(err)
}
```

---

## 4. Tips, Best Practices & Common Pitfalls

<AccordionGroup title="Helpful Tips & Recommendations">
<Accordion title="Use Consistent Naming">
Maintain consistent interface names like `Query[T any]` and prefix methods with verbs describing intent (e.g., Get, Filter, Update).
</Accordion>

<Accordion title="Leverage SQL Template DSL Fully">
Master the GORM CLI template directives (`@@table`, `@param`, `{{where}}`, `{{set}}`) to write flexible, dynamic queries.
</Accordion>

<Accordion title="Configure Generation Thoughtfully">
Use `genconfig.Config` to customize output paths and precisely control which interfaces and structs generate code to avoid overhead or irrelevant code.
</Accordion>

<Accordion title="Watch Out for Return Types">
All query methods returning data must end with an `error` return value to correctly handle database errors.
</Accordion>

<Accordion title="Context Injection">
If you omit `ctx context.Context` in method params, the generator automatically adds it, ensuring your methods support cancellation and deadlines.
</Accordion>

<Accordion title="Verify Generated Imports">
After generation, confirm imports are properly resolved, especially if models or interfaces are spread across multiple packages.
</Accordion>
</AccordionGroup>

---

## 5. Troubleshooting

<AccordionGroup title="Common Issues and Solutions">
<Accordion title="Generator Fails with 'No Interfaces Found'">
- Check your interface files for matching names or package placement.
- Use `IncludeInterfaces` in `genconfig.Config` to restrict generation scope.
- Ensure interface methods have proper SQL template comments.
</Accordion>

<Accordion title="Code Generation Creates No Methods">
- Verify your interface declares methods with return types.
- Ensure SQL directives in comments are well-formed.
</Accordion>

<Accordion title="Build Errors After Generation">
- Run `go mod tidy` to ensure dependencies are correct.
- Check for naming collisions or missing imports.
- Confirm that generated files are in the Go module path.
</Accordion>

<Accordion title="Queries Return Unexpected Results">
- Double-check SQL template logic.
- Use debug logging in GORM with `.Debug()` while running queries.
</Accordion>

<Accordion title="Cannot Find Generated Package">
- Confirm `-o` output path.
- Ensure package imports match generated location.
</Accordion>

</AccordionGroup>

---

## 6. Next Steps & Related Documentation

- Explore [Basic Configuration](../../getting-started/initial-configuration-and-first-use/basic-configuration) to customize the generator.
- Learn about [Interface-Driven Queries](../query-and-model-helpers/interface-driven-queries) to master SQL templating.
- Dive into [Model Field Helpers](../query-and-model-helpers/model-driven-field-helpers) for fluent filters, updates, and association handling.
- Review the [Template DSL Tutorial](../query-and-model-helpers/template-dsl-tutorial) to extend your queries dynamically.
- If you encounter issues, consult [Troubleshooting Installation & Validation](../../getting-started/troubleshooting-and-common-issues/troubleshooting-install-validate).

---

## 7. Diagram: Overview of Generation Flow

```mermaid
flowchart TD
  Start([Write Go Interfaces & Models]) --> DefineModels[Define Data Models (Go Structs)]
  DefineModels --> DefineInterfaces[Create SQL-Templated Query Interfaces]
  DefineInterfaces --> RunGenerator[Run GORM CLI `gorm gen`]
  RunGenerator --> ParseAST[Parse Go Files & Extract Metadata]
  ParseAST --> GenerateCode[Generate Strongly Typed APIs & Helpers]
  GenerateCode --> UseCode[Import & Use Generated Code in App]
  UseCode --> RunQueries[Run Type-Safe Database Queries]
  RunQueries --> End([Success])

  classDef startend fill:#f96,stroke:#333,stroke-width:2px;font-weight:bold
  class Start,End startend
```

---

## Summary

You have now learned how to take your Go models and templated interfaces and turn them into fully typed, safe query APIs using GORM CLI. Armed with this workflow, you can scale to complex queries with confidence and integrate tightly with GORM’s ORM capabilities.

Configurations let you tune generation for your project layout. The SQL template DSL combined with generics based APIs deliver clear, composable, and maintainable database code.

Continue your journey by exploring more advanced query patterns, field helpers, and association management in the related guides.

---

## Key Code References:

- Sample config: [`examples/query.go`](./examples/query.go)
- Config struct: [`genconfig.Config`](./examples/query.go)
- Generator command interface: [`internal/gen/gen.go`](./internal/gen/gen.go)
- Template engine: [`internal/gen/template.go`](./internal/gen/template.go)


---

## Helpful Links

- [Installing GORM CLI](../../getting-started/setup-requirements-installation/installing-gorm-cli)
- [Basic Configuration](../../getting-started/initial-configuration-and-first-use/basic-configuration)
- [Interface-Driven Query APIs](../query-and-model-helpers/interface-driven-queries)
- [Model Field Helpers](../query-and-model-helpers/model-driven-field-helpers)
- [Template DSL Tutorial](../query-and-model-helpers/template-dsl-tutorial)
- [Troubleshooting & Validation](../../getting-started/troubleshooting-and-common-issues/troubleshooting-install-validate)
- [Quickstart Workflow (Overview)](../../overview/quickstart-features/quickstart-workflow)

---

You are now fully equipped to generate your first type-safe API with GORM CLI. Happy coding!
