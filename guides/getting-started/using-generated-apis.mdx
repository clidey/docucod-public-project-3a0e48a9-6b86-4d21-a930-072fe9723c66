---
title: "Using the Generated APIs"
description: "Explore how to consume the generated fluent APIs in your application code. Includes practical code samples for fetching, updating, and creating records, and integrating with GORM's core database operations."
---

# Using the Generated APIs

Explore how to seamlessly consume the generated fluent APIs in your application code to efficiently fetch, update, create records, and integrate deeply with GORM's core database operations. This guide provides practical, ready-to-use code samples and workflows to help you realize the full potential of the generated code.

---

## Workflow Overview

**What you'll accomplish:**
- Use generated interfaces for type-safe queries and commands.
- Leverage model-driven field helpers for predicates and setters.
- Manage associations intuitively with generated helpers.
- Execute template-based SQL queries with strong typing.

**Prerequisites:**
- You have run the GORM CLI generator successfully to produce code.
- You have imported the generated package in your project.
- A `*gorm.DB` instance is initialized and connected.

**Expected outcome:**
- Quickly write clean, type-safe database queries.
- Simplify CRUD operations with fluent APIs.
- Harness association helpers for related entity operations.

**Estimated time:** 15–25 minutes for initial familiarization and practice.

**Difficulty:** Intermediate – basic familiarity with GORM and Go generics recommended.

---

## Step-by-Step Instructions

### 1. Accessing Generated Query Interfaces

Use the generated interface constructor functions, typically named after your interfaces, to start fluent query builds.

```go
import "generated" // replace with your generated package path

// Obtain a query interface for User model
userQuery := generated.Query[models.User](db)
```

**Outcome:** `userQuery` provides typed methods like `GetByID`, `FilterByNameAndAge`, and more.

---

### 2. Performing Basic Query Operations

#### Fetching a Single Record by ID

```go
user, err := userQuery.GetByID(ctx, 123)
if err != nil {
    // handle error
}
// use user
```

This calls the generated SQL template, safely binding parameters.

---

#### Filtering Using Template Methods

```go
user, err := userQuery.FilterWithColumn(ctx, "name", "alice")
```

This dynamically generates:

```sql
SELECT * FROM users WHERE name = "alice"
```

---

### 3. Using Model-Driven Field Helpers for Predicates and Setters

The generated `User` (or other model) struct provides strongly typed field helpers to build predicates and updates fluently:

```go
// Filtering users by age with a predicate
users, err := gorm.G[models.User](db).Where(generated.User.Age.Gt(18)).Find(ctx)

// Updating fields fluently
err = gorm.G[models.User](db).
  Where(generated.User.ID.Eq(1)).
  Set(
    generated.User.Name.Set("alice"),
    generated.User.Age.Incr(1),
  ).
  Update(ctx)
```

**Outcome:** type-safe, expressive queries and updates without manual SQL strings.

---

### 4. Creating Records with Setters

Create new records by setting fields using generated setters.

```go
err := gorm.G[models.User](db).
  Set(
    generated.User.Name.Set("bob"),
    generated.User.Age.Set(30),
  ).
  Create(ctx)
```

This creates a new `User` record with specified fields.

---

### 5. Managing Associations with Generated Helpers

Use association helpers to create, update, unlink, or delete related entities. These helpers are strongly typed based on your model associations.

```go
// Create a user with a new pet (has many association)
err := gorm.G[models.User](db).
  Set(
    generated.User.Name.Set("carol"),
    generated.User.Pets.Create(generated.Pet.Name.Set("fido")),
  ).
  Create(ctx)

// Update a user's pet name
err = gorm.G[models.User](db).
  Where(generated.User.ID.Eq(1)).
  Set(generated.User.Pets.Where(generated.Pet.Name.Eq("fido")).
    Update(generated.Pet.Name.Set("rex")),
  ).
  Update(ctx)

// Unlink a pet from a user
err = gorm.G[models.User](db).
  Where(generated.User.ID.Eq(1)).
  Set(generated.User.Pets.Unlink()).
  Update(ctx)

// Delete associated pets
err = gorm.G[models.User](db).
  Where(generated.User.ID.Eq(1)).
  Set(generated.User.Pets.Delete()).
  Update(ctx)
```

**Behavior details:**
- *Unlink* clears foreign key references or join rows, preserving related rows.
- *Delete* removes related rows or join rows depending on the association type.

---

### 6. Executing Template-Based Queries

For interfaces with SQL templates, call methods directly for complex queries.

```go
// Query with conditional template
user, err := userQuery.QueryWith(ctx, models.User{ID: 123})

// Update using conditional SET template
err := userQuery.UpdateInfo(ctx, models.User{Name: "Updated", Age: 25}, 123)
```

The generated code safely compiles templates, binds parameters, and returns typed results.

---

## Examples

### Example: Fetch User by ID

```go
user, err := generated.Query[models.User](db).GetByID(ctx, 1)
if err != nil {
    log.Fatal(err)
}
fmt.Printf("User: %+v\n", user)
```

### Example: Update User's Age and Status

```go
err := gorm.G[models.User](db).
  Where(generated.User.ID.Eq(1)).
  Set(
    generated.User.Age.Set(35),
    generated.User.Status.Set("active"),
  ).
  Update(ctx)
if err != nil {
    log.Fatal(err)
}
```

### Example: Create User with Multiple Languages (Many2Many)

```go
err := gorm.G[models.User](db).
  Set(
    generated.User.Name.Set("polyglot"),
    generated.User.Languages.CreateInBatch([]models.Language{{Code: "EN"}, {Code: "FR"}}),
  ).
  Create(ctx)
```

### Example: Filter Users by Age Range

```go
users, err := gorm.G[models.User](db).
  Where(generated.User.Age.Between(18, 30)).
  Find(ctx)
```

---

## Troubleshooting & Tips

<AccordionGroup title="Common Issues and Solutions">
<Accordion title="Generated Methods Not Found">
Check that you imported the correct generated package and your interface naming matches your generator configuration filters.
</Accordion>
<Accordion title="Type Errors with Generated Code">
Ensure Go 1.18+ is used. Generated code relies on generics extensively. Also, verify that your models have appropriate exported fields.
</Accordion>
<Accordion title="Association Operations Have No Effect">
Confirm you correctly use `Set()` followed by `Create()` or `Update()` calls on `gorm.G[T](db)`. Remember `Unlink()` and `Delete()` have different impacts depending on association type.
</Accordion>
<Accordion title="Template Query Execution Fails">
Verify that your SQL templates in interface comments are correctly formatted and correspond to the method signature. Also, confirm method parameters align with template placeholders.
</Accordion>
</AccordionGroup>

### Best Practices

- Use the generated field helpers for composing predicates instead of raw strings.
- Always check returned errors and handle `ErrRecordNotFound` where appropriate.
- Leverage batch create and update methods for performance with many associations.
- Prefer template-based query methods for complex, conditional SQL that cannot be expressed with GORM chaining.

### Performance Considerations

- Chain conditions before calling `Find` or `Scan` to leverage SQL indexes.
- When updating associations, filter precisely to avoid unnecessary database churn.

### Alternative Approaches

- You can combine generated APIs with manual GORM queries when necessary but prefer the generated types for safety.
- Use custom SQL in template interfaces for queries with complex joins or database-specific features.

---

## Next Steps & Related Content

- **Explore Advanced Generation Workflows:** Learn to customize your code generation with configuration files and advanced templates.
- **Read About Advanced Field and Association Helpers:** Deep dive into leveraging more complex association operations.
- **Consult Troubleshooting Common Issues:** Resolve common hiccups encountered during integration.
- **See Integration Examples:** Practical usage scenarios demonstrating integration with real-world apps.

You can find all these and more in the [Guides section](/guides).

---

Happy coding with the power of fluent, type-safe database APIs!
