---
title: "Using Generated APIs in Your Application"
description: "See how to leverage the generated query APIs and field helpers for common database operations. Walk through reading, filtering, updating, and creating records with type safety and fluent APIs, illustrated by concrete examples."
---

# Using Generated APIs in Your Application

Discover how to harness the power of the generated query APIs and field helpers produced by GORM CLI to perform common database operations efficiently, safely, and with type safety. This guide walks you through reading, filtering, updating, and creating records using the fluent and expressive APIs generated from your query interfaces and models.

---

## Workflow Overview

### What You Will Achieve
This guide helps you integrate and use the generated APIs in your Go application with GORM. You'll learn how to:
- Query data by IDs and custom filters using generated query interfaces
- Use field helpers for constructing expressive and type-safe predicates
- Perform updates and creations with fluent `Set` clauses
- Manipulate associations using generated helpers

### Prerequisites
Before proceeding, ensure you have:
- Generated the code from your Go interfaces and models using the GORM CLI generator
- Imported the generated package(s) into your Go project
- A working GORM `*gorm.DB` instance and a valid context (`context.Context`)

### Expected Outcome
Once completed, you will be able to perform database operations using the generated, type-safe API methods with confidence that your queries are well-typed, parameterized, and idiomatic.

### Time Estimate
Around 15-30 minutes depending on familiarity with GORM and Go generics.

### Difficulty Level
Intermediate (understanding basic GORM querying plus Go generics)

---

## Step-by-Step Usage Instructions

<Steps>
<Step title="1. Import the Generated Package and Initialize the Generated Query API">
Import your generated package where the CLI generator output lives, then instantiate the generated query API for your model type.

```go
import (
  "context"
  "gorm.io/gorm"
  "your_project/generated" // replace with your generated package path
  "your_project/models"   // your models package
)

func example(db *gorm.DB, ctx context.Context) error {
	queryAPI := generated.Query[models.User](db)
	// Ready to invoke generated query methods
	return nil
}
```

<Check>
Ensure `generated.Query[T]` matches your model struct `models.User` type.
</Check>
</Step>

<Step title="2. Use Generated Query Methods to Read Data">
Call generated methods like `GetByID`, `FilterWithColumn`, or custom ones defined in your query interface to perform safe queries.

```go
// Get user by ID
user, err := queryAPI.GetByID(ctx, 123)
if err != nil {
  return err
}

// Filter with dynamic column
userByName, err := queryAPI.FilterWithColumn(ctx, "name", "alice")
if err != nil {
  return err
}
```

<Info>
These methods are generated based on your interface definitions with SQL templates, ensuring type safety and proper parameter binding.
</Info>

<Check>
Check returned error to handle not found or query issues.
</Check>
</Step>

<Step title="3. Apply Fluent Filtering Using Field Helpers">
The generated model-based field helpers enable you to build predicate expressions fluently and type-safely.

```go
import "generated" // your generated package

// Query users older than 18
users := []models.User{}
err := gorm.G[models.User](db).
  Where(generated.User.Age.Gt(18)).
  Find(ctx, &users)
if err != nil {
  return err
}
```

<Tip>
Field helpers include methods like `.Eq()`, `.Gt()`, `.Like()`, `.Between()`, and more to construct conditions without writing raw SQL.
</Tip>
</Step>

<Step title="4. Update Records Using Generated Query APIs and Setters">
Use the generated query interfaces along with `Set` expressions from field helpers to update records.

```go
// Update a user's name and age where ID matches
err := queryAPI.UpdateInfo(ctx, models.User{Name: "newname", Age: 30}, 123)
if err != nil {
  return err
}
```

Or using field helpers directly:

```go
err := gorm.G[models.User](db).
  Where(generated.User.ID.Eq(123)).
  Set(
    generated.User.Name.Set("newname"),
    generated.User.Age.Set(30),
  ).
  Update(ctx)
if err != nil {
  return err
}
```

<Note>
Using `Set()` with field helpers ensures that your updates are explicit, well-typed, and avoid SQL injection.
</Note>
</Step>

<Step title="5. Create New Records With Fluent APIs and Field Helpers">
You can create new records with `Create(ctx)` using the fluent setters.

```go
err := gorm.G[models.User](db).
  Set(
    generated.User.Name.Set("alice"),
    generated.User.Age.Set(25),
  ).
  Create(ctx)
if err != nil {
  return err
}
```

<Tip>
Setters allow zero-value fields to be set explicitly during creation, improving clarity.
</Tip>
</Step>

<Step title="6. Manipulate Associations With Generated Helpers">
Manage related entities using association helpers generated on your models (like `Pets`, `Languages`).

```go
// Create a user with one pet
err := gorm.G[models.User](db).
  Set(
    generated.User.Name.Set("alice"),
    generated.User.Pets.Create(generated.Pet.Name.Set("fido")),
  ).
  Create(ctx)

// Update associated pets
err = gorm.G[models.User](db).
  Where(generated.User.ID.Eq(1)).
  Set(
    generated.User.Pets.Where(generated.Pet.Name.Eq("fido")).
      Update(generated.Pet.Name.Set("rex")),
  ).
  Update(ctx)

// Unlink associated pets
err = gorm.G[models.User](db).
  Where(generated.User.ID.Eq(1)).
  Set(generated.User.Pets.Unlink()).
  Update(ctx)
```

<Info>
Available association operations include `Create`, `CreateInBatch`, `Update`, `Unlink`, and `Delete`. Behavior varies by association type (belongs-to, has-many, many-to-many).
</Info>
</Step>
</Steps>

---

## Practical Examples

### Querying by ID
```go
u, err := generated.Query[models.User](db).GetByID(ctx, 123)
if err != nil {
  // handle error
}
fmt.Println("User:", u)
```

### Filtering with Column
```go
user, err := generated.Query[models.User](db).FilterWithColumn(ctx, "email", "alice@example.com")
if err != nil {
  // handle error
}
```

### Using Field Helpers for Filtering
```go
users := []models.User{}
err := gorm.G[models.User](db).
  Where(generated.User.Age.Gt(18)).
  Find(ctx, &users)
```

### Updating a Record
```go
err := generated.Query[models.User](db).UpdateInfo(ctx, models.User{Name: "Bob", Age: 40}, 123)
```

### Creating a Record
```go
err := gorm.G[models.User](db).
  Set(
    generated.User.Name.Set("Carol"),
    generated.User.Age.Set(22),
  ).
  Create(ctx)
```

### Managing Associations
```go
err := gorm.G[models.User](db).
  Set(
    generated.User.Name.Set("Dave"),
    generated.User.Pets.Create(generated.Pet.Name.Set("Buddy")),
  ).
  Create(ctx)
```

---

## Troubleshooting & Tips

<AccordionGroup title="Common Issues When Using Generated APIs">
<Accordion title="Method Not Found or Unrecognized">
Ensure your code generation includes the interface declaring the method.
Run the CLI generator again with the correct input path.
</Accordion>

<Accordion title="Errors on Type Mismatches">
Confirm that your model types match between your definitions and generated code.
Regenerate after model changes.
</Accordion>

<Accordion title="Context Parameter Missing">
If your interface method does not include `ctx context.Context`, the generator automatically injects it.
Use the generated method signature as is.
</Accordion>

<Accordion title="Updates Not Reflecting in Database">
Check that you are calling `.Update(ctx)` or `.Create(ctx)` explicitly.
Use `.Set()` to specify fields before calling these methods.
</Accordion>

<Accordion title="Association Operations Not Working">
Make sure associations are properly defined in your models.
Use generated association helpers (`field.Struct` or `field.Slice`) to operate safely.
</Accordion>
</AccordionGroup>

<Tip>
Keep your input query interfaces and models synchronized with generated code by re-running the CLI generator after any changes.
</Tip>

---

## Best Practices

- **Use Generated Query Interfaces:** Always invoke methods from generated query interfaces rather than writing raw SQL.
- **Leverage Field Helpers:** Use the fluent, typed field helpers for filtering and updating to ensure type safety and readability.
- **Explicitly Handle Errors:** Every database call returns errors to handle; do not ignore them.
- **Regenerate After Changes:** Update your interfaces and model definitions, then regenerate to keep generated code current.
- **Use Context in Calls:** Pass context from your app to support cancellation and timeouts.

---

## Next Steps & Related Content

- [Define Models & Query Interfaces](../../getting-started/first-generation/define-models-interfaces) to author your data and query specs.
- [Run the Code Generator](../../getting-started/first-generation/run-code-generator) to produce generated APIs.
- [Validate Generated APIs](../../getting-started/first-generation/validate-generated-apis) to confirm correctness.
- [Managing Associations: Patterns and Examples](../generation-patterns/association-operations-guide) for advanced usage.
- [Customizing Generation with genconfig.Config](../customization-integration/genconfig-config-guide) to tailor generated output.

---

## Summary
This guide empowers you to effectively use the APIs generated by GORM CLI in your application code. By following concrete, actionable steps, you gain the ability to query, filter, update, create, and manage associations type-safely and fluently, helping you build robust, maintainable database interactions.

---

<Source url="https://github.com/go-gorm/cli" paths={[{"path": "examples/query.go", "range": "1-63"},{"path": "README.md", "range": "30-210"}]} />
