---
title: "Using the Generated APIs in Your Project"
description: "Demonstrates how to use the generated query methods and field helpers in real application code. Shows setup, querying, updating, creating, and working with associations for a complete workflow from model to production code."
---

# Using the Generated APIs in Your Project

This guide will help you integrate and leverage the query methods and field helpers generated by GORM CLI in your Go application code. You will learn how to perform typical database operations such as querying, inserting, updating, and working safely with associations using the generated APIs. This page focuses exclusively on practical application scenarios—ensuring you write clear, type-safe, efficient code from model definitions to production interactions.

---

## 1. Why Use Generated APIs?

GORM CLI generates two complementary APIs:

- **Query APIs**: Interface-driven, type-safe methods allowing you to write concise, expressive, and compile-time safe raw SQL queries through Go interfaces annotated with SQL templates.
- **Field Helpers**: Model-driven helpers that enable fluent, discoverable, and type-safe construction of filters, updates, and association operations based on your struct fields.

Together, these APIs eliminate boilerplate, reduce runtime errors, and empower you to write maintainable data access layers confidently.

---

## 2. Setting Up the Generated APIs in Your Project

### Step 1: Import the Generated Package

After running the code generation with GORM CLI, import your generated package into your application code.

```go
import (
  "context"
  "gorm.io/gorm"
  "your_project/generated" // Adjust according to your actual output path
)
```

### Step 2: Initialize Query and Model Helpers

Use the generated query interface constructor and the model field helpers for your entities. For example, with a `User` model:

```go
// Initialize Query interface with a gorm.DB instance
userQuery := generated.Query[User](db)

// Access field helpers for filters and updates
userFields := generated.User
```

<Tip>
`db` here is your *gorm.DB instance connected to your database. The generated APIs strongly type queries based on your models and interfaces.
</Tip>

---

## 3. Performing Query Operations

### Fetching by ID

Use the generated query method to fetch a user by ID safely:

```go
ctx := context.Background()
user, err := userQuery.GetByID(ctx, 123)
if err != nil {
  // Handle error
}
// Use user struct
```

This generates SQL equivalent to:

```sql
SELECT * FROM users WHERE id=123
```

### Filtering Results

Use field helpers to build conditions fluently. For example, fetch users with age above 18:

```go
users := []User{}
err := gorm.G[User](db).
  Where(generated.User.Age.Gt(18)).
  Find(ctx, &users)

if err != nil {
  // Handle error
}
```

Or use generated query interface filters:

```go
users, err := userQuery.FilterByNameAndAge(ctx, "jinzhu", 25).Find(ctx)
```

### Advanced Query with SQL Templates

Leverage methods implementing templated SQL to encode conditional logic:

```go
users, err := userQuery.QueryWith(ctx, someUser).Find(ctx)
```

Where `someUser` might have fields that dynamically alter the executed WHERE clause.

---

## 4. Creating and Updating Records

### Creating New Records

Use generated field helpers with `Set()` to specify values and `Create(ctx)` to insert.

```go
dir := gorm.G[User](db)
err := dir.Set(
  generated.User.Name.Set("alice"),
  generated.User.Age.Set(30),
).Create(ctx)
if err != nil {
  // Handle error
}
```

### Updating Existing Records

Use `Where()` with filters and `Set()` with field helpers, finishing with `Update(ctx)`.

```go
err := gorm.G[User](db).
  Where(generated.User.ID.Eq(123)).
  Set(
    generated.User.Name.Set("alice_updated"),
    generated.User.Age.Incr(1),
  ).
  Update(ctx)
if err != nil {
  // Handle error
}
```

Alternatively, if using generated query method with SQL template:

```go
err := userQuery.UpdateInfo(ctx, User{Name: "alice", Age: 20}, 123)
if err != nil {
  // Handle error
}
```

---

## 5. Working with Associations

GORM CLI generates helpers for associations such as `has one`, `has many`, `belongs to`, and `many2many`. These provide powerful, type-safe methods to create, update, unlink, delete, or batch create associated records.

### Creating and Linking Associations

```go
// Create User with a new Pet
err := gorm.G[User](db).
  Set(
    generated.User.Name.Set("alice"),
    generated.User.Pets.Create(generated.Pet.Name.Set("fido")),
  ).
  Create(ctx)
```

### Updating Associated Records

```go
// Update Pets of user with ID 1 where pet name = 'fido'
err := gorm.G[User](db).
  Where(generated.User.ID.Eq(1)).
  Set(
    generated.User.Pets.Where(generated.Pet.Name.Eq("fido")).Update(generated.Pet.Name.Set("rex")),
  ).
  Update(ctx)
```

### Unlinking Associations

This removes the foreign key link without deleting the associated record.

```go
err := gorm.G[User](db).
  Where(generated.User.ID.Eq(1)).
  Set(generated.User.Pets.Unlink()).
  Update(ctx)
```

### Deleting Associated Records

```go
err := gorm.G[User](db).
  Where(generated.User.ID.Eq(1)).
  Set(generated.User.Pets.Delete()).
  Update(ctx)
```

<Tip>
- `Unlink()` and `Delete()` can be combined with `.Where()` to conditionally impact association records.
- Understand the semantic differences per association type (`belongs to`, `has many`, `many2many`) especially for unlinking and deleting.
</Tip>

---

## 6. Full Example: End-to-End Query and Update

```go
ctx := context.Background()

// Fetch user by ID
user, err := generated.Query[User](db).GetByID(ctx, 10)
if err != nil {
  panic(err)
}

// Update user details
err = generated.Query[User](db).UpdateInfo(ctx, User{Name: "new_name", Age: 25}, 10)
if err != nil {
  panic(err)
}

// Create a new user with associated pets
err = gorm.G[User](db).
  Set(
    generated.User.Name.Set("bob"),
    generated.User.Pets.CreateInBatch([]Pet{{Name: "fido"}, {Name: "spot"}}),
  ).
  Create(ctx)
if err != nil {
  panic(err)
}
```

---

## 7. Best Practices and Tips

- Always use `context.Context` to control request lifetimes and cancellations.
- Use generated field helpers instead of raw strings for column names to avoid typos and ensure compile-time safety.
- When updating, prefer incremental or expression setters (`Incr`, `SetExpr`) to optimize SQL operations.
- Structure your model associations clearly in your structs to maximize the benefits of generated helpers.
- Leverage SQL templating in query interfaces for advanced queries while retaining type safety.

---

## 8. Troubleshooting Common Issues

<AccordionGroup title="Common Pitfalls and Solutions">
<Accordion title="Queries return no results unexpectedly">
Ensure your database connection (`*gorm.DB`) is correct and that the IDs or conditions match actual data. Verify generated SQL by enabling GORM logging with `db = db.Debug()`.
</Accordion>
<Accordion title="Association operations don't link or unlink as expected">
Check association definitions on models. Remember that unlinking only nulifies foreign keys or deletes join rows without deleting data unless using `Delete()`. Confirm association types (`has one` vs `belongs to`).
</Accordion>
<Accordion title="Generated methods are missing or inaccessible">
Confirm your source interface methods are properly annotated with SQL templates. Refresh your generation manually to pick up recent interface changes.
</Accordion>
</AccordionGroup>

---

## 9. Next Steps & Related Resources

- [Quickstart: Generate Type-Safe APIs](../getting-started/quickstart-generate-apis) — Start from defining models and interfaces.
- [Running Code Generation CLI Commands](../../getting-started/project-configuration-run/generation-cli-commands) — How to generate and manage output.
- [Working with Associations Safely](../advanced-usage-patterns/working-with-associations) — Deep dive into association operations.
- [Validating Generated APIs](../../getting-started/project-configuration-run/validating-generated-code) — Verify your generated code is functional.

---

For detailed syntax and additional examples of field helpers and SQL templates, refer to the [GORM CLI README examples](https://github.com/go-gorm/cli/blob/main/README.md#features).


<Check>
Using generated APIs correctly unlocks safer, faster development with GORM. This guide moves you from code generation to mastery in your application.
</Check>
