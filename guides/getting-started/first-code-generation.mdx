---
title: "First Code Generation Walkthrough"
description: "Walk through generating your first query APIs and field helpers from sample models and interfaces. Understand the CLI usage and immediate next steps after generation, with explanations of the generated outputs."
---

# First Code Generation Walkthrough

Walk through generating your first query APIs and field helpers from sample models and interfaces. Understand the CLI usage and immediate next steps after generation, with explanations of the generated outputs.

---

## 1. Overview of the Code Generation Workflow

### What This Guide Helps You Achieve

This guide leads you step-by-step through generating your first type-safe query APIs and model-driven field helpers using the GORM CLI. You'll understand how to start from your Go interfaces and structs, run the generator, and interpret the generated code to confidently integrate it into your GORM projects.

### Prerequisites

- Have Go 1.18 or newer installed
- A project with defined **model structs** and **query interfaces** annotated with SQL templates
- GORM CLI installed (`go install gorm.io/cli/gorm@latest`)
- Basic understanding of Go generics and context usage

### Expected Outcome

By completing this walkthrough, you will:
- Run the GORM CLI generator against your interface input
- Generate type-safe query API implementations and model-driven field helpers
- Understand the structure and purpose of generated files
- Learn immediate next steps to start using the generated code effectively

### Estimated Time Commitment

Approximately 15–30 minutes, depending on familiarity with Go tooling and GORM.

### Difficulty Level

Beginner to Intermediate — no advanced customization needed.

---

## 2. Step-by-Step First Code Generation

<Steps>
<Step title="Prepare Your Models and Query Interfaces">
Ensure your Go project contains your model structs, e.g., `User`, with fields properly defined. Alongside, define query interfaces with SQL templates in method comments.

**Example Query Interface:**
```go
// Query defines generic query methods using SQL templates
type Query[T any] interface {
  // SELECT * FROM @@table WHERE id=@id
  GetByID(id int) (T, error)

  // more methods with templated queries...
}
```

**Model Example:**
```go
// User model struct
type User struct {
  ID   uint
  Name string
  Age  int
}
```

<Check>
You should have both models and interfaces declared within the same package or adjacent directory for generator discovery.
</Check>
</Step>

<Step title="Run the GORM CLI Generation Command">
Execute the CLI generator, specifying the input directory or file path and the output directory for generated code:

```bash
gorm gen -i ./examples -o ./generated
```

- `-i` points to your input file or directory with the Go interfaces and models
- `-o` specifies where generated files will be placed (defaults to `./g` if omitted)

<Note>
You must specify the input path using `-i`. The output path defaults but is often best set explicitly.
</Note>

<Check>
The CLI will print out messages like "Generating file ..." indicating successful generation.
</Check>
</Step>

<Step title="Review the Generated Code">
Navigate to the output directory you specified. You will find:

- **Interface implementations:** Concrete structs implementing your query interfaces with type-safe methods
- **Field helpers:** Generated variables for your model fields, enabling fluent, compile-time-safe query predicates and update helpers

Example of generated interface usage:
```go
user, err := generated.Query[User](db).GetByID(ctx, 123)
```

Example field helper usage:
```go
users, err := gorm.G[User](db).Where(generated.User.Age.Gt(18)).Find(ctx)
```

<Info>
Generated code includes all model fields and SQL template methods from interfaces defined in your input.
</Info>
</Step>

<Step title="Understand the CLI Output Structure">
The generated code is modular:

- For each interface, a generic Go struct implementing its methods is generated with injected SQL templates from comments.
- For each model struct, a struct variable with strongly typed field helpers (like `generated.User.Name`, `generated.User.ID`) is created.

These helpers allow you to write expressive, type-safe queries with GORM beyond plain SQL strings.

<Warning>
Do not manually edit generated files as they will be overwritten on each run.
Use configuration files (`genconfig.Config`) to customize generation.
</Warning>
</Step>

<Step title="Next Steps After Generation">
Start integrating the generated code into your application:

- Import the generated package
- Use the query interfaces to invoke your templated queries with compile-time safety
- Using the model field helpers, build predicates for filters, updates, and joins

Explore related guides to deepen your use:
- [Using the Generated Code](/getting-started/initial-usage/use-generated-code)
- [Type-Safe Queries with Interfaces](/guides/core-workflows/type-safe-queries)
- [Working with Model-Driven Field Helpers](/guides/core-workflows/model-field-helpers)

</Step>
</Steps>

---

## 3. Understanding the Generated Outputs

### Query Interface Implementations

For each interface like `Query[T]`, the generator creates:

- An interface type `QueryInterface[T]` embedding `gorm.Interface[T]`, including your SQL method signatures.
- A struct `QueryImpl[T]` implementing these methods by constructing SQL from your templates and invoking GORM.

**Method generation highlights:**
- Context parameters are auto-injected if missing
- SQL templates with placeholders (`@@table`, `@param`) are dynamically rendered as query builders
- Methods returning data return concrete typed results

### Model Field Helpers

For each model struct, a variable holding a struct with fields matching model fields is generated.

Each field is typed as a helper such as:
- `field.String` for strings
- `field.Number[int]` for ints
- `field.Struct[RelatedType]` or `field.Slice[RelatedType]` for associations

These helpers provide:
- Predicate methods like `.Eq()`, `.Gt()`, `.Between()`, `.IsNull()` to build fluent filters
- Update methods like `.Set()`, `.Incr()`, `.SetExpr()` for atomic updates
- Association operations like `.Create()`, `.Update()`, `.Unlink()`, `.Delete()`, `.CreateInBatch()` for managing related rows

```go
// Usage example:
gorm.G[User](db).
  Where(generated.User.Name.Eq("alice"), generated.User.Age.Gt(18)).
  Find(ctx)
```

---

## 4. Troubleshooting & Best Practices

### Common Issues

- **No output generated:** Ensure input path points to Go files with interfaces/models.
- **Invalid syntax in generated code:** Confirm all SQL templates and method signatures follow examples.
- **Methods missing `context.Context`:** GORM CLI inserts it automatically if omitted.
- **File structure mismatches:** Keep interfaces and models close in the codebase to avoid missed dependencies.

### Best Practices

- Declare any custom generation configs in Go files with `genconfig.Config` exports near your interfaces to control output paths and mappings.
- Use the `genconfig.FieldTypeMap` and `FieldNameMap` to map custom types or tags to field helpers.
- Place your Query interfaces and models consistently with clear package boundaries.
- Write clear, simple SQL templates and leverage the GORM CLI template DSL directives for dynamic queries.

### Performance Considerations

- Keep your input files focused to avoid huge single generation runs.
- Use the CLI `--output` flag to separate generated code organizationally.

### Alternative Approaches

For advanced customization:
- Override generation with `genconfig.Config` including whitelist/blacklist of interfaces and structs.
- Customize template processing with advanced SQL templates for conditional dynamic queries.

---

## 5. Next Steps & Related Guides

- Explore how to **[use the generated code](../getting-started/initial-usage/use-generated-code.mdx)** with live examples.
- Learn about **[type-safe queries with interfaces](../guides/core-workflows/type-safe-queries.mdx)** to build powerful queries.
- Understand **[model-driven field helpers](../guides/core-workflows/model-field-helpers.mdx)** for expressive filters and updates.
- Customize generation via **[generation config](../concepts/configuration-and-extensibility/generation-config.mdx)** for your project.


---

## Appendix: Sample Command Reference

```bash
gorm gen -i ./examples -o ./generated
```
- Run the CLI generator to process interfaces/models in `./examples`
- Place generated code files into `./generated`

---

## Visual Workflow Diagram

```mermaid
flowchart TD

  StartGen["Start: Prepare interfaces & models"] --> RunCLI["Run `gorm gen` CLI with -i & -o"]
  RunCLI --> ParseAST["Parse Go AST for interfaces & structs"]
  ParseAST --> ExtractSQL["Extract SQL templates & interface methods"]
  ParseAST --> ExtractFields["Extract model struct fields & tags"]
  ExtractSQL & ExtractFields --> GenerateCode["Generate Go code with:
- Query interface implementations
- Model field helpers"]
  GenerateCode --> WriteFiles["Write generated files to output directory"]
  WriteFiles --> UseCode["Import & use generated code
in your GORM project"]
  UseCode --> End["End: Type-safe DB access"]

  %% Styling
  classDef startend fill:#28a745,stroke:#333,stroke-width:2px,color:#fff;
  class StartGen,End startend;
  class RunCLI,ParseAST,ExtractSQL,ExtractFields,GenerateCode,WriteFiles,UseCode fill:#17a2b8,stroke:#333,stroke-width:1.5px,color:#fff;
```
