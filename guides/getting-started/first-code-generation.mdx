---
title: "Your First Code Generation"
description: "A concise walkthrough for running your first code generation with GORM CLI. Learn how to define a simple query interface and model, invoke the generator, and inspect the generated APIs for type-safe queries and field helpers."
---

# Your First Code Generation with GORM CLI

## Introduction

This guide provides a concise, practical walkthrough for running your first code generation using the **GORM CLI** tool. You will learn how to define a simple query interface and model, execute the generator, and inspect the generated code for type-safe queries and handy field helpers. This step-by-step process empowers you to immediately start using generated, compile-time-safe GORM APIs to improve your development experience.

---

## 1. Workflow Overview

### Task Description
Generate type-safe query APIs and model-driven field helpers from your Go interfaces defining SQL templates and model structs.

### Prerequisites
- Go 1.18+ installed and your project set up with basic Go modules.
- Basic familiarity with defining Go structs and interfaces.
- Your model structs and query interfaces defined in your project directory.
- GORM CLI installed (`go install gorm.io/cli/gorm@latest`).

### Expected Outcome
- A new folder containing generated Go code with type-safe query interfaces.
- Access to fluent, discoverable APIs for querying and updating your database using GORM.
- Helper structs for fields in your models for filters and updates.

### Time Estimate
Approximately 10-15 minutes for a basic setup and initial code generation.

### Difficulty Level
Beginner to Intermediate

---

## 2. Step-by-Step Instructions

### Step 1: Define Your Model Struct(s)
Create standard Go structs representing your database entities. For example:

```go
package models

import "gorm.io/gorm"

type User struct {
  gorm.Model
  Name string
  Age  int
}
```

Ensure your models are accessible within the package or directory you plan to scan.

---

### Step 2: Define a Query Interface With SQL Templates
Create a Go interface with methods annotated by SQL templates in method comments. The generator uses these to produce type-safe query methods.

```go
package examples

type Query[T any] interface {
  // SELECT * FROM @@table WHERE id=@id
  GetByID(id int) (T, error)

  // where("name=@name AND age=@age")
  FilterByNameAndAge(name string, age int)
}
```

- Use `@@table` as a placeholder for the model's table name.
- Use `@param` to bind method parameters.
- You can include more complex templating (e.g., `{{where}}` blocks) as needed.

---

### Step 3: Run the GORM CLI Generator
Use the `gorm gen` command to process your interfaces and models and generate code.

```bash
gorm gen -i ./examples -o ./generated
```

Flags:
- `-i` specifies the path to the Go interface file or directory.
- `-o` specifies the output directory for generated code (default is `./g`).

Ensure the input path points to the directory/file containing your query interfaces and model structs.

---

### Step 4: Verify the Generated Files

- Navigate to the output directory.
- You should find Go source files with generated APIs.
- The code includes:
  - Type-safe query interface implementations.
  - Structs with field helpers for filters and updates.

Sample output usage might look like:

```go
u, err := generated.Query[User](db).GetByID(ctx, 1)
```

This code is fully type-safe and integrates directly with GORM.

---

### Step 5: Use the Generated APIs in Your Project

- Import the generated package and use the fluent query interfaces.
- Use generated fields for filtering, updating, and working with model associations.

Example:

```go
users, err := gorm.G[User](db).Where(generated.User.Age.Gt(18)).Find(ctx)
```

You are now fully equipped to use compile-time-safe, template-driven queries and updates.

---

## 3. Practical Example

### Example Layout

```
examples/
  models/user.go
  query.go
generated/
  query.go  # generated output
```

### `models/user.go`

```go
package models

import "gorm.io/gorm"

type User struct {
  gorm.Model
  Name string
  Age  int
}
```

### `examples/query.go`

```go
package examples

type Query[T any] interface {
  // SELECT * FROM @@table WHERE id=@id
  GetByID(id int) (T, error)

  // where("name=@name AND age=@age")
  FilterByNameAndAge(name string, age int)
}
```

### Command to Generate Code:

```bash
gorm gen -i ./examples -o ./generated
```

This generates typed query APIs:

```go
u, err := generated.Query[models.User](db).GetByID(ctx, 123)
```

---

## 4. Tips & Best Practices

- **Keep your query interfaces focused and minimal.** Define only the queries your application will use.
- **Use Go generics to maintain type safety** across different models.
- **Leverage the SQL template DSL** for dynamic WHERE/SET clauses with `{{where}}` and `{{set}}` blocks.
- **Use package-level `genconfig.Config` for advanced customization** like output paths and field mappings.
- **Always include `ctx context.Context` in method parameters** or rely on automatic injection by the generator.

---

## 5. Troubleshooting

<AccordionGroup title="Common Issues and Resolutions">
<Accordion title="Generator Fails to Run - Check Input Path">
Verify the `-i` path correctly points to the directory or Go file containing your interfaces and models.
</Accordion>
<Accordion title="No Code Generated">
- Check that interface methods have valid SQL templates in comments.
- Ensure methods follow the required signature conventions with error return types.
- Confirm you haven't excluded relevant interfaces or structs via config files.
</Accordion>
<Accordion title="Compilation Errors in Generated Code">
- Generated code relies on valid Go syntax and types. Check that your model types are defined correctly.
- Verify compatibility of Go version (1.18+ for generics).
</Accordion>
<Accordion title="Cannot Find Generated Package in Import">
Make sure your IDE and Go module paths include the output directory.
Run `go mod tidy` after generation.
</Accordion>
</AccordionGroup>

---

## 6. Next Steps & Related Information

- **Learn to Customize Generation:** Explore `genconfig.Config` for mapping types, controlling output paths, and filtering generation.
- **Define Advanced SQL Templates:** Check the SQL Template DSL cookbook for patterns like iterations, conditionals, and complex queries.
- **Use Generated Field Helpers:** See guides on filtering, updates, and association helpers with generated structs.
- **Validate and Use Generated Code:** Follow validation steps to build and test your generated queries in your application.

---

## Reference Links

- [GORM CLI Installation & Setup](https://github.com/go-gorm/cli/blob/main/docs/guides/getting-started/installation-setup.md)
- [Defining Query Interfaces & SQL Templates](https://github.com/go-gorm/cli/blob/main/docs/guides/core-workflows/query-apis-and-templates.md)
- [Using Generated Field Helpers](https://github.com/go-gorm/cli/blob/main/docs/guides/core-workflows/using-generated-field-helpers.md)
- [Configuring Generation](https://github.com/go-gorm/cli/blob/main/docs/guides/advanced-usage/configuring-generation.md)
- [SQL Template DSL Cookbook](https://github.com/go-gorm/cli/blob/main/docs/guides/advanced-usage/template-dsl-cookbook.md)

---

With this straightforward approach, you will quickly generate customized, type-safe code that integrates naturally into your GORM-powered Go projects.

---