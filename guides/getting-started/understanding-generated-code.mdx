---
title: "Understanding the Generated Code"
description: "Explore what gets generated—field helpers and query APIs—by reviewing real output examples. Learn how to navigate and use the new APIs, and understand the basics of how your input transforms into strongly typed, fluent Go code."
---

# Understanding the Generated Code

Explore what gets generated by GORM CLI—model-driven field helpers and interface-driven query APIs—through real output examples. This guide illuminates how your Go interfaces and structs transform into strongly typed, fluent Go code via the generator.

---

## 1. Overview of Generated Code

When you use GORM CLI to generate code, two primary outputs are created:

- **Query APIs from interfaces**: These are type-safe methods based on your interface declarations containing SQL templates.
- **Field helpers from model structs**: Typed helpers for fields and associations that simplify building queries, updates, and association operations with compile-time safety.

Together, these generated codes make your interactions with GORM models more discoverable, concise, and type safe.

### What You’ll See

- Generated **interface implementations** with methods that run raw SQL or return query chains.
- Typed **field helpers** organized in structs mapping to your model’s fields, supporting predicates and setters.

---

## 2. Anatomy of Generated Query APIs

### User Intent & Workflow
You define raw SQL queries and templates in interface method comments. The generator produces concrete implementations that manage SQL construction, parameter binding, and GORM integration.

### How It Looks in Code
For each interface method, GORM CLI generates:

- A method with a context parameter added if missing.
- Concrete implementations that build SQL strings dynamically per your template directives.
- Return types matching your interface method signature.

Example from a generated interface implementation:

```go
func (e _QueryInterface[T]) GetByID(ctx context.Context, id int) (T, error) {
    var result T
    sb := strings.Builder{}
    params := make([]any, 0)
    sb.WriteString("SELECT * FROM ? WHERE id=?")
    params = append(params, clause.Table{Name: clause.CurrentTable}, id)
    err := e.Raw(sb.String(), params...).Scan(ctx, &result)
    return result, err
}
```

- It uses SQL templates parsed from your interface comments.
- Parameters are safely bound, ensuring type correctness.
- Methods either return data and error or chain queries.

### Fluent Method Chains
Some methods return a query interface allowing method chaining. For example:

```go
func (e _QueryInterface[T]) FilterByNameAndAge(ctx context.Context, name string, age int) _QueryInterface[T] {
    sb := strings.Builder{}
    params := []any{name, age}
    sb.WriteString("name=? AND age=?")
    e.Where(sb.String(), params...)
    return e
}
```

You can chain these for complex queries before fetching results.

---

## 3. Model-Driven Field Helpers Explained

### Purpose
Field helpers generated from your model structs represent your database columns as strongly typed objects. These help you build predicates (e.g., `Eq`, `Like`, `Between`) and setters (`Set`, `Incr`) fluently and safely.

### How They Are Structured
For every model struct, a corresponding generated variable holds a struct with fields:

```go
var User = struct {
    ID field.Number[uint]
    Name field.String
    Age field.Number[int]
    Pets field.Slice[Pet]
    // ... other fields
}{
    ID:   field.Number[uint]{}.WithColumn("id"),
    Name: field.String{}.WithColumn("name"),
    Age:  field.Number[int]{}.WithColumn("age"),
    Pets: field.Slice[Pet]{}.WithName("Pets"),
}
```

### Usage Examples

- **Predicates:**

```go
generated.User.ID.Eq(1)                 // id = 1
generated.User.Name.Like("%jinzhu%")  // name LIKE '%jinzhu%'
generated.User.Age.Between(18, 65)      // age BETWEEN 18 AND 65
```

- **Updates:**

```go
gorm.G[User](db).
    Where(generated.User.Name.Eq("alice")).
    Set(
        generated.User.Age.Incr(1),
        generated.User.Status.Set("active"),
    ).
    Update(ctx)
```

- **Create with Associations:**

```go
gorm.G[User](db).
    Set(
        generated.User.Name.Set("alice"),
        generated.User.Pets.Create(generated.Pet.Name.Set("fido")),
    ).
    Create(ctx)
```

### Relation Field Helpers
Associations are generated as specialized helpers (`field.Struct[T]` or `field.Slice[T]`), with methods like `Create`, `Update`, `Unlink`, and `Delete` for managing related records.

---

## 4. Understanding the Template-Based Query DSL

### SQL Template Features
Your interface methods include raw SQL with templating directives:

- `@@table`, `@@column` for dynamic table and column names
- `@param` binds Go method params to SQL safely
- `{{where}}`, `{{set}}`, `{{if}}`, `{{for}}` for conditional and iterative SQL fragments

Example template from interface method comment:

```go
// SELECT * FROM @@table
// {{where}}
//   {{if user.Name != ""}} name=@user.Name {{end}}
//   {{if user.Age > 0}} AND age=@user.Age {{end}}
// {{end}}
SearchUsers(user User) ([]T, error)
```

### Transformation
The generator reads this template, creates Go code building the SQL string with appropriate clauses and parameters.

### Generated Method Example

```go
func (e _QueryInterface[T]) SearchUsers(ctx context.Context, user models.User) ([]T, error) {
    var results []T
    var sb strings.Builder
    var params []any
    sb.WriteString("SELECT * FROM ?")
    params = append(params, clause.Table{Name: clause.CurrentTable})
    var whereClauses []string
    if user.Name != "" {
        whereClauses = append(whereClauses, "name=?")
        params = append(params, user.Name)
    }
    if user.Age > 0 {
        whereClauses = append(whereClauses, "age=?")
        params = append(params, user.Age)
    }
    if len(whereClauses) > 0 {
        sb.WriteString(" WHERE ")
        sb.WriteString(strings.Join(whereClauses, " AND "))
    }
    err := e.Raw(sb.String(), params...).Scan(ctx, &results)
    return results, err
}
```

---

## 5. Practical Tips & Best Practices

- **Always specify clear SQL templates in interface comments.** This is the source for generated methods.
- **Use generics `[T any]` for maximum flexibility and reuse** with any model while maintaining type safety.
- **Include the `context.Context` parameter explicitly or rely on the generator auto-injection** for consistent cancellation and timeout handling.
- **Customize field mapping using `genconfig.Config` to fine-tune helper types** such as JSON or time fields (see JSON Fields guide for examples).
- **Leverage generated field helpers for expressive and robust query conditions.** Avoid crafting raw strings directly when possible.

---

## 6. Common Pitfalls & Troubleshooting

<AccordionGroup title="Troubleshooting Generated Code Issues">
<Accordion title="Generated Methods Not Returning Expected Types">
Check your interface method return signatures. Methods returning data must return either `(T, error)` or `(T, error)` pairs, with the last return value always being `error`. Single return `error` is valid only for void data methods (e.g., updates).
</Accordion>
<Accordion title="Missing Context Parameter in Method Signature">
The generator automatically inserts `ctx context.Context` as the first parameter if it's not declared. If your code fails with context errors, verify your interface declarations and try explicitly adding it.
</Accordion>
<Accordion title="Field Helpers Not Matching Expected Types">
Field helper types are inferred from Go types and your `genconfig.Config` mappings. Ensure your mappings are correct and your structs properly tagged for custom helpers.
</Accordion>
<Accordion title="Generated Query Methods Not Found or Not Discoverable">
Make sure your generator input path includes the interface files, and your CLI generation command runs correctly. Pay attention to include/exclude filters in your config and CLI flags.
</Accordion>
</AccordionGroup>

---

## 7. Understanding Template Generation & File Structure

The generated files combine all interfaces and structs from your input files (filtered by configs) into Go source files placed in the output directory. Each file contains:

- Package declaration
- Imports (e.g., GORM, clause, generated field helpers)
- Interface implementations with method bodies generated from SQL templates
- Struct field helper declarations as package-level variables

Example snippet of generated file start:

```go
// Code generated by 'gorm.io/cli/gorm'. DO NOT EDIT.

package generated

import (
    "gorm.io/gorm"
    "gorm.io/gorm/clause"
    "gorm.io/cli/gorm/field"
)

var User = struct {
    ID field.Number[uint]
    Name field.String
    Age field.Number[int]
}{
    ID:   field.Number[uint]{}.WithColumn("id"),
    Name: field.String{}.WithColumn("name"),
    Age:  field.Number[int]{}.WithColumn("age"),
}

// Interface _QueryInterface implementation for Query[T]
```

---

## 8. Next Steps & Further Exploration

- Explore [Working with Field Helpers and Predicates](/guides/core-workflows/field-helpers-and-predicates) for in-depth usage of generated helpers.
- Dive into [Building Template-Based Query APIs](/guides/core-workflows/template-based-queries) to master writing SQL templates.
- Configure generation options with [Customizing Generation with genconfig](/guides/advanced-usage/customizing-generation) for tailored output.
- Learn to handle JSON and other special fields with [Handling JSON Columns and Custom Helpers](/guides/advanced-usage/working-with-json-fields).


---

## 9. Reference & Related Documentation

- [GORM CLI Product Introduction](https://github.com/go-gorm/cli#readme)
- [Getting Started / First Generation Workflow](../guides/getting-started/first-generation-workflow)
- [Validating Generated APIs](../getting-started/first-run-validation/validating-generated-apis)
- [Troubleshooting Common Issues](../getting-started/first-run-validation/troubleshooting-common-issues)
- [Generation Configuration Reference](../guides/advanced-usage/customizing-generation)

---

With this guide, you now have a grounded understanding of what GORM CLI generates, how to navigate and use its output, and how your interface and struct inputs map directly to the fluent, type-safe Go code you rely upon every day.

Happy coding!
