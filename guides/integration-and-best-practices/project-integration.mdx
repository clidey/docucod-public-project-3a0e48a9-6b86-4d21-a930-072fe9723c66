---
title: "Integrating Generated Code into Your Project"
description: "A practical guide on organizing and importing generated APIs, managing version control, and updating code as your models and interfaces change. Covers real-world integration examples and common pitfalls to avoid."
---

# Integrating Generated Code into Your Project

A practical guide on organizing and importing generated APIs, managing version control, and updating code as your models and interfaces evolve. This guide helps you seamlessly integrate GORM CLI-generated code into your existing Go projects, ensuring maintainability and efficient workflows.

---

## 1. Overview

### What You'll Accomplish
- Learn how to organize your generated code for clarity and modularity.
- Understand how to import and reference generated packages in your Go projects.
- Manage version control for generated files effectively to avoid conflicts.
- Update and regenerate code gracefully as models and query interfaces change.

### Prerequisites
- You have run GORM CLI `gen` command and generated code files.
- Your Go project compiles and imports are correctly configured.
- Familiarity with Go modules and basic version control workflows.

### Expected Outcome
- Your project uses generated APIs and field helpers with clean imports.
- You manage the lifecycle of generated code without disrupting your development.
- You avoid common pitfalls related to code regeneration and versioning.

### Time Estimate
Approximately 15–25 minutes to arrange your project structure and update code as models or interfaces evolve.

### Difficulty Level
Intermediate — assumes familiarity with Go project layout and module/version management.

---

## 2. Organizing Generated Code

### Choose an Output Directory
When running the GORM CLI generator, use the `-o` (or `--output`) flag to specify a clear directory for generated output. Common practices:
- Use a dedicated `generated` or `gen` folder inside your project root.
- Mirror your source package structure inside the output directory.

Example:

```bash
gorm gen -i ./examples -o ./generated
```

The generator preserves your source directory structure inside the output path, helping keep files organized.

### Best Practices
- **Keep generated code separate from handwritten code.** This prevents accidental edits and allows easy regeneration.
- **Use package paths that match your import paths.** For example, if your source files are in `github.com/youruser/project/models`, generated code in `generated/github.com/youruser/project/models` fits neatly for import.
- **Avoid mixing generated and manual code to reduce complexity and merge conflicts.**

<Tip>
Keep your generated folder under your module root so Go modules handle imports seamlessly.
</Tip>

---

## 3. Importing Generated APIs

Once generated, your codebase can import the generated packages and use the APIs with minimal boilerplate.

### Importing Generated Packages
Ensure your import paths reflect the output directory's module path.

Example:

```go
import (
  "context"
  "gorm.io/gorm"

  "your_module/generated/examples" // Replace with your actual module path + output
)
```

### Using Generated Query Interfaces
Assuming your generated code package is imported as `generated_examples`, you can instantiate and use generated query APIs:

```go
ctx := context.Background()
db := // your gorm.DB instance

// Instantiate generated query interface for User
query := generated_examples.Query[models.User](db)

// Call generated methods
user, err := query.GetByID(ctx, 123)
if err != nil {
    // Handle error
}
```

The generated code provides strongly-typed, compile-time safe methods that align with your initial models and query interface definitions.

---

## 4. Managing Generated Code in Version Control

### To Commit or Not to Commit?
- **Recommended:** Commit generated code to version control if your team wants consistent builds and easy onboarding without requiring generation on every build.
- **Alternative:** Add generated folders to `.gitignore` if you prefer generating code automatically in CI or developer machines.

### Tips for Versioning
- Keep generated code in a dedicated folder (e.g., `/generated`) to simplify `.gitignore` rules.
- Use commit messages specifying the regeneration event, e.g., `Regenerated GORM CLI code after model update`.
- Avoid manual edits in generated files to prevent merge conflicts.

### Handling Regeneration
If your models or query interfaces change, always regenerate code using the `gorm gen` command with the correct parameters:

```bash
gorm gen -i ./examples -o ./generated
```

Verify any build or test failures after regeneration to catch breaking API changes.

<Warning>
Do not edit generated files manually. Changes will be overwritten on next generation.
</Warning>

---

## 5. Updating Generated Code As Your Models and Interfaces Change

### Workflow When Models or Interfaces Change
1. **Update your Go model structs or query interfaces** with new fields, methods, or SQL templates.
2. **Run the generator command** again with the same input and output paths to overwrite previous generated code.
3. **Import and update your code using the new generated APIs.** Newly added fields or queries become immediately available.
4. **Build and run tests** to confirm your changes.

### Tips When Updating
- Keep the input source directory organized so generator picks up all relevant files automatically.
- Use configuration files (`genconfig.Config`) to control selective generation, field mapping, or output directories.
- When removing or renaming interfaces or structs, confirm that they are excluded or updated in your configuration to avoid generation errors.

### Handling Breaking Changes
- Pay attention to changes in method signatures or returned types after regeneration.
- Refactor your usage accordingly to match the updated generated APIs.

---

## 6. Real-World Example: Importing and Using Generated Code

Assuming you generated code for package `examples` into folder `generated/examples`:

```go
package main

import (
  "context"
  "fmt"

  "gorm.io/driver/sqlite"
  "gorm.io/gorm"

  "your_module/generated/examples"
  "your_module/models"
)

func main() {
  db, err := gorm.Open(sqlite.Open("test.db"), &gorm.Config{})
  if err != nil {
    panic(err)
  }

  ctx := context.Background()

  // Use generated query interface
  query := examples.Query[models.User](db)

  // Get user by ID
  user, err := query.GetByID(ctx, 1)
  if err != nil {
    fmt.Println("Query error:", err)
    return
  }

  fmt.Printf("User: %+v\n", user)
}
```

This example demonstrates direct usage of generated APIs after organizing and importing your generated project code.

---

## 7. Common Pitfalls & Troubleshooting

<AccordionGroup title="Common Issues When Integrating Generated Code">
<Accordion title="1. Import Path Errors or Unresolved Packages">
Verify your module path and output directory structure. Your Go import statements must match the filesystem location of generated code relative to your module root.
</Accordion>
<Accordion title="2. Generated Code Missing After Regeneration">
Ensure you specify the correct `-i` input and `-o` output paths to the generator. Check logs for file write errors.
</Accordion>
<Accordion title="3. Conflicts from Manual Edits in Generated Files">
Never edit generated code manually. Use source model/interface files for changes and regenerate code.
</Accordion>
<Accordion title="4. Build Fails Due to API Changes After Regeneration">
Review your updated query interfaces and method signatures. Adjust your codebase to conform to new generated APIs.
</Accordion>
<Accordion title="5. Version Control Noise or Conflicts from Generated Code">
Separate generated code in dedicated folders and use `.gitignore` selectively if preferred. Commit generated code consistently if team prefers.
</Accordion>
</AccordionGroup>

---

## 8. Best Practices

- Always **generate code from the authoritative interfaces and models** to ensure synchronization.
- Use **configuration files (`genconfig.Config`)** to customize generation behavior, e.g., selectively include/exclude interfaces or structs.
- Maintain **clear folder convention** for generated code to simplify imports and version control.
- Use **automated scripts or `Makefile` targets** to generate code consistently during build or CI processes.
- Regularly **run tests after regeneration** to detect integration issues early.

---

## 9. Next Steps & Related Content

- Explore [Using Generated Field Helpers](https://your-docs-domain/guides/getting-started-workflows/using-field-helpers) to safely build queries and updates with generated models.
- Learn about [Customizing Generation with Configurations](https://your-docs-domain/guides/advanced-usage-patterns/customizing-generation) for advanced control over your generated code output.
- Review [Troubleshooting Common Issues](https://your-docs-domain/getting-started/configuration-troubleshooting/troubleshooting-common-issues) for common setup and generation problems.
- Understand [Integration with GORM & Your Codebase](https://your-docs-domain/overview/concepts-architecture-flow/integration-points) for a broader view of how generated code fits in application architecture.

---

## 10. Summary

This guide gave you a complete, practical workflow for integrating, organizing, and updating GORM CLI-generated code within your Go projects. By following these steps and best practices, you ensure a smooth, maintainable development experience with type-safe, generated APIs.

---

## References
- [GORM CLI README](https://github.com/go-gorm/cli#readme)
- [Generate Type-Safe Code](https://your-docs-domain/getting-started/first-steps/generate-code)
- [Validate Your Setup](https://your-docs-domain/getting-started/first-steps/validate-your-setup)
- [Configuration & Troubleshooting](https://your-docs-domain/getting-started/configuration-troubleshooting/basic-configuration)

---