---
title: "Using the Generated APIs in Your Application"
description: "Learn how to leverage your generated query and model APIs for reads, writes, and updates. This guide shows how to make practical use of generated methods and field helpers in real-world application code."
---

# Using the Generated APIs in Your Application

Learn how to leverage your generated query and model APIs for reads, writes, and updates. This guide shows how to make practical use of generated methods and field helpers in real-world application code to build safer, more maintainable database interactions.

---

## 1. Understanding Your Generated APIs

When you run the GORM CLI generator against your Go interfaces and model structs, it produces two key types of code:

- **Query APIs**: Interface-driven, type-safe query methods that implement your SQL template comments.
- **Field Helpers**: Model-driven, strongly-typed field helpers for composing filters, updates, and associations.

This synergy gives you compile-time safety and easier-to-read data access code.

---

## 2. Prerequisites

Before using the generated APIs, make sure you have:

- Generated code via the CLI using your annotated Go interfaces and models (e.g., `gorm gen -i ./examples -o ./generated`).
- Imported the generated package where your generated APIs live (e.g., `generated`).
- A `*gorm.DB` instance connected to your database.
- Your context (`context.Context`) available for passing to API calls.

<Check>
Ensure you run `gorm gen` after any changes to your models or interface comments to keep generated code up to date.
</Check>

---

## 3. Using Generated Query APIs: A Walkthrough

The generated query APIs implement your defined interfaces, providing methods for your custom SQL queries.

### 3.1 Creating a Query Instance

Each query interface has a factory function:

```go
q := generated.Query[models.User](db)
```

This creates a typed query instance for `User` with your custom query methods.

### 3.2 Calling Query Methods

Methods are injectable with your `context.Context` (added automatically if not declared). Example usages:

```go
// Fetch a user by ID
user, err := q.GetByID(ctx, 123)
if err != nil {
    // handle error
}

// Filter users by name and age
users, err := q.FilterByNameAndAge(ctx, "jinzhu", 25).Find(ctx)
if err != nil {
    // handle error
}

// Update a user’s info by ID
err = q.UpdateUser(ctx, models.User{Name: "jinzhu", Age: 20}, 1)
if err != nil {
    // handle error
}
```

### 3.3 Composing Filters and Chaining

Some generated methods return a query builder interface allowing further chaining:

```go
// Chain where conditions
users, err := q.FilterByNameAndAge("jinzhu", 25).
            Where(generated.User.Status.Eq("active")).
            Find(ctx)

if err != nil {
    // handle error
}
```

### 3.4 Context Propagation

You don’t need to manually add `context.Context` to interface methods - the generator adds it.

### 3.5 Common Method Types

- **Get (single result)**: Return a single struct and an error.
- **Find (multiple results)**: Return a slice of structs and an error.
- **Update/Delete (void or error)**: Return only error to indicate success.

---

## 4. Using Model-Driven Field Helpers

Field helpers provide strongly-typed predicates and setters for your model fields. They enable you to write fluent queries and updates that are type-safe and expressive.

### 4.1 Accessing Field Helpers

You use generated structs named after your model, e.g., `generated.User`:

```go
import "generated"

// Access a field predicate
cond := generated.User.Age.Gt(18)
```

### 4.2 Common Field Helper Methods

- `.Eq(value)`: `=` equality
- `.Gt(value)`: Greater than
- `.Lt(value)`: Less than
- `.Like(pattern)`: SQL LIKE operation
- `.Between(start, end)`: Between two values
- `.IsNull()`: IS NULL check

### 4.3 Using Field Helpers in Queries

Combine conditions fluently:

```go
users, err := gorm.G[models.User](db).
    Where(generated.User.Status.Eq("active"), generated.User.Age.Gt(18)).
    Find(ctx)
```

### 4.4 Using Field Helpers in Updates

Update fields safely with `.Set` and expressions:

```go
gorm.G[models.User](db).
  Where(generated.User.ID.Eq(1)).
  Set(
    generated.User.Name.Set("alice"),
    generated.User.Age.Incr(1), // increments age by 1
  ).
  Update(ctx)
```

### 4.5 Working With Zero Values

The `.Set` helper handles zero values like `0`, `false`, or empty string correctly and won’t omit fields unexpectedly.

---

## 5. Managing Associations with Helpers

Association helpers let you create, update, unlink, or delete related records with compile-time safety.

### 5.1 Accessing Associations

Associations are available as fields with types like `field.Struct[T]` or `field.Slice[T]`:

```go
generated.User.Pets // has many `Pet`
generated.User.Account // has one `Account`
generated.User.Languages // many2many `Language`
```

### 5.2 Common Association Operations

Compose operations as args to `.Set(...)` in create or update chains:

- **Create**: Create and link a related record
- **CreateInBatch**: Create multiple related records
- **Update**: Update the associated rows
- **Unlink**: Remove the association (e.g., clear foreign key)
- **Delete**: Delete associated rows

### 5.3 Examples

```go
// Create user and one pet
err := gorm.G[models.User](db).
    Set(
      generated.User.Name.Set("alice"),
      generated.User.Pets.Create(generated.Pet.Name.Set("fido")),
    ).Create(ctx)

// Update pet name for matched user
err := gorm.G[models.User](db).
    Where(generated.User.ID.Eq(1)).
    Set(
      generated.User.Pets.Where(generated.Pet.Name.Eq("fido")).Update(generated.Pet.Name.Set("rex")),
    ).Update(ctx)

// Unlink pets belonging to user
err := gorm.G[models.User](db).
    Where(generated.User.ID.Eq(1)).
    Set(generated.User.Pets.Unlink()).
    Update(ctx)
```

### 5.4 Semantics by Association Type

| Type        | Unlink Effect                        | Delete Effect                  |
|-------------|------------------------------------|-------------------------------|
| Belongs To  | Sets FK to NULL on child            | Deletes associated rows       |
| Has One/Many| Sets FK to NULL on child            | Deletes child rows            |
| Many2Many   | Removes join table rows only        | Deletes join table rows only  |

---

## 6. Working with Template-based Queries

You can write flexible SQL templates in your interface methods as comments. The generated code interprets these to run SQL queries safely.

### 6.1 Template DSL Highlights

- `@@table`: Resolves to your model table name.
- `@@column`: Dynamic column placeholder.
- `@param`: Maps Go method params to SQL parameters.
- `{{where}}` / `{{set}}`: Conditional WHERE/SET SQL blocks.
- `{{if}}`, `{{for}}`: Control flow for building statements.

### 6.2 Example Interface Method

```go
// SELECT * FROM @@table WHERE id=@id
GetByID(id int) (T, error)

// UPDATE @@table
// {{set}}
//   {{if user.Name != ""}} name=@user.Name, {{end}}
//   {{if user.Age > 0}} age=@user.Age, {{end}}
// {{end}}
// WHERE id=@id
UpdateUser(user User, id int) error
```

### 6.3 Using Generated Template Query Methods

```go
user, err := generated.Query[User](db).GetByID(ctx, 123)
err := generated.Query[User](db).UpdateUser(ctx, User{Name: "jinzhu"}, 123)
```

---

## 7. Practical Tips & Best Practices

- **Regenerate Often**: Run `gorm gen` after code or schema changes to keep APIs in sync.
- **Always Pass Context**: Use `context.Context` in all DB calls to manage timeouts and cancellations.
- **Use Field Helpers**: Prefer predicates and setter helpers over raw strings for type safety and SQL correctness.
- **Read Generated Code**: Explore generated source in your output directory to understand implementations.
- **Handle Errors Explicitly**: Always check errors returned from CRUD and query operations.

<Warning>
Avoid modifying generated files directly - changes will be overwritten on the next generation.
</Warning>

---

## 8. Troubleshooting Common Issues

<AccordionGroup title="Common Pitfalls & Solutions">
<Accordion title="Generated Methods Not Found">
- Confirm you generated code with `-i` pointing to the correct input.
- Check your interface method comments for correct SQL templates.
- Verify package imports and generated code paths.
</Accordion>

<Accordion title="Unexpected SQL Errors at Runtime">
- Validate your SQL templates syntax and parameters.
- Ensure your DB schema matches the models.
- Use field helpers to avoid injection or mismatches.
</Accordion>

<Accordion title="Associations Not Linking Properly">
- Confirm association definitions on your GORM models.
- Use association helpers (`Create`, `Unlink`, `Delete`) correctly.
- Examine foreign key constraints in the DB.
</Accordion>

<Accordion title="Code Generation Filters Not Working">
- Check `genconfig.Config` files in your packages.
- Validate Include/Exclude Interfaces and Structs patterns.
- Remember Whitelist (`Include*`) takes precedence over Blacklist.
</Accordion>
</AccordionGroup>

---

## 9. Next Steps and Related Topics

- Learn to **Write and Use SQL Templates** for custom queries (see [Template DSL Guide](../advanced-usage/template-dsl-guide)).
- Customize generation with **`genconfig.Config`** for fine control (see [Customizing Code Generation](../advanced-usage/customizing-generation)).
- Extend field helpers with custom types like JSON (see [Adding JSON Field Helpers](../advanced-usage/json-field-helpers)).
- Deep dive into **Associations Handling** and complex workflows (see [Handling Associations with Helpers](../core-workflows/association-guides)).
- Explore example projects in the CLI repo for real-world usage patterns.

---

## Appendix: Sample Code Snippet

```go
package main

import (
    "context"
    "fmt"
    "gorm.io/driver/sqlite"
    "gorm.io/gorm"
    "generated" // Replace with your actual generated package path
)

func main() {
    ctx := context.Background()
    db, err := gorm.Open(sqlite.Open("test.db"), &gorm.Config{})
    if err != nil {
        panic(err)
    }

    q := generated.Query[models.User](db)

    // Query by ID
    user, err := q.GetByID(ctx, 1)
    if err != nil {
        fmt.Println("Error fetching user:", err)
    } else {
        fmt.Println("User:", user)
    }

    // Update user name
    err = q.UpdateUser(ctx, models.User{Name: "newname"}, 1)
    if err != nil {
        fmt.Println("Error updating user:", err)
    }

    // Using field helpers for complex where
    users, err := gorm.G[models.User](db).
        Where(generated.User.Age.Gt(18), generated.User.Status.Eq("active")).
        Find(ctx)
    if err != nil {
        fmt.Println("Error fetching users:", err)
    } else {
        fmt.Printf("Found %d users\n", len(users))
    }
}
```

---

*This guide transforms your generated APIs into practical building blocks, empowering you to write robust, type-safe database code integrated with GORM effortlessly.*
