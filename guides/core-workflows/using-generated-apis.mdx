---
title: "Using the Generated APIs"
description: "Understand how to interact with the generated code, apply method wrappers for queries, and use fluent APIs for retrieving and manipulating data. Includes practical usage patterns for reads, writes, and querying."
---

# Using the Generated APIs

Understand how to interact with the generated code, apply method wrappers for queries, and use fluent APIs for retrieving and manipulating data. Includes practical usage patterns for reads, writes, and querying.

---

## 1. Workflow Overview

### Task Description
This guide helps you effectively use the APIs generated by GORM CLI from your Go interfaces and model structs. Learn how to perform common read and write operations, work with method wrappers created from SQL templates, and leverage powerful fluent APIs for data access.

### Prerequisites
- Generated code from your interfaces and models using the `gorm gen` command.
- A running GORM `*gorm.DB` database connection.
- Basic familiarity with Go generics and context usage.

### Expected Outcome
By following this guide, you will confidently:
- Invoke generated type-safe methods for queries and updates.
- Compose dynamic filters using generated model-driven fields.
- Perform CRUD operations fluently with association management.

### Time Estimate
15 to 30 minutes depending on your familiarity with Go and GORM.

### Difficulty Level
Intermediate

---

## 2. Interacting with Generated APIs

### 2.1 Accessing Generated Query Interfaces

The core entry point for using the generated APIs is via the function named after your interface. For example, if you have a `Query[T any]` interface:

```go
userQuery := generated.Query[User](db)
```

This produces a type-safe API bound to the `User` model.

### 2.2 Using Method Wrappers for Queries

Each method you defined with the SQL template DSL in your interface comments has a generated implementation with:
- Automatic SQL construction from your SQL template.
- Safe parameter binding with Go values.
- Return types matching your method signature (e.g., `(T, error)`, `(error)`, or fluent interface).

Example:

```go
// SELECT * FROM users WHERE id=@id
user, err := generated.Query[User](db).GetByID(ctx, 123)
if err != nil {
    log.Fatal(err)
}
fmt.Println(user.Name)
```

This invokes the generated `GetByID` method safely with your parameter `id=123`.

### 2.3 Composing Fluent Queries

The generated APIs often integrate with GORM's fluent chaining. Some methods return an interface that allows further query refinement before execution:

```go
// Start by filtering users by name and age
filteredQuery := generated.Query[User](db).FilterByNameAndAge("alice", 30)

// Add further conditions or execute query
users, err := filteredQuery.Find(ctx)
```

If a method is designed as a query builder (without immediate execution), use fluent calls like `.Find(ctx)`, `.First(ctx)`, `.Take(ctx)` to execute.

### 2.4 Using Generated Field Helpers

Alongside query interfaces, you get strongly typed field helpers on your models for building filter expressions explicitly:

```go
// Import generated package
import "generated"

// Use field helpers to build filters
users, err := gorm.G[User](db).
  Where(generated.User.Age.Gt(18)).
  Where(generated.User.Name.Like("%Smith%"))
  .Find(ctx)
```

This provides expressive, type-safe condition building without manual string concatenation.

---

## 3. Practical Usage Patterns

### 3.1 Basic Read Operations

**Query by ID:**

```go
user, err := generated.Query[User](db).GetByID(ctx, 123)
if err != nil {
    // handle error
}
```

**Filter with dynamic column:**

```go
user, err := generated.Query[User](db).FilterWithColumn(ctx, "email", "alice@example.com")
```

**Complex filtered query using structs:**

```go
searchUser := models.User{Name: "alice", Age: 25}
users, err := generated.Query[User](db).QueryWith(ctx, searchUser)
```

### 3.2 Update Operations

Updates typically use methods with conditional `{{set}}` blocks in SQL templates:

```go
userUpdate := models.User{Name: "NewName", Age: 30}
err := generated.Query[User](db).UpdateInfo(ctx, userUpdate, 123) // Update user with id=123
if err != nil {
    // handle error
}
```

### 3.3 Filtering Multiple Records

You can filter collections with dynamic where clauses:

```go
usersToFilter := []models.User{
    {Name: "alice", Age: 25},
    {Name: "bob", Age: 30},
}
filteredUsers, err := generated.Query[User](db).Filter(ctx, usersToFilter)
```

### 3.4 Working with Time Ranges

Filter records between time intervals:

```go
start := time.Date(2022, 1, 1, 0, 0, 0, 0, time.UTC)
end := time.Now()
users, err := generated.Query[User](db).FilterWithTime(ctx, start, end)
```

---

## 4. Using Fluent APIs & Association Management

### 4.1 Fluent Filters & Chaining
You can chain conditions with the standard GORM interface returned by query builders:

```go
users, err := generated.Query[User](db).
    FilterByNameAndAge(ctx, "alice", 25).
    Where(generated.User.IsAdult.Eq(true)).
    Find(ctx)
```

### 4.2 Creating and Updating with Field Helpers

The generated model-driven field helpers allow you to *Set* field values for inserts and updates fluently:

```go
gorm.G[User](db).
  Set(generated.User.Name.Set("alice"), generated.User.Age.Set(22)).
  Create(ctx)

// Update with increment
gorm.G[User](db).
  Set(generated.User.Age.Incr(1)).
  Where(generated.User.ID.Eq(123)).
  Update(ctx)
```

### 4.3 Managing Associations

Generated helpers for associations like `field.Struct[T]` and `field.Slice[T]` enable operations on related data:

```go
// Create with new pet association
err := gorm.G[User](db).
  Set(generated.User.Name.Set("alice"),
      generated.User.Pets.Create(generated.Pet.Name.Set("fido")),
  ).Create(ctx)

// Update a pet's name
err = gorm.G[User](db).
  Where(generated.User.ID.Eq(1)).
  Set(generated.User.Pets.Where(generated.Pet.Name.Eq("fido")).
      Update(generated.Pet.Name.Set("rex")),
  ).Update(ctx)
```

**Unlink and Delete operations** are available with these association helpers as well:

```go
// Unlink pets
err := gorm.G[User](db).
  Where(generated.User.ID.Eq(1)).
  Set(generated.User.Pets.Unlink()).
  Update(ctx)

// Delete pets where name is 'old'
err = gorm.G[User](db).
  Where(generated.User.ID.Eq(1)).
  Set(generated.User.Pets.Where(generated.Pet.Name.Eq("old")).Delete()).
  Update(ctx)
```

---

## 5. Common Troubleshooting & Tips

### Common Issues
- **Missing Method in Generated Code:** Ensure your interface method has proper SQL template comments and your input file is correctly specified during generation.
- **Invalid SQL Template Rendering:** Verify your SQL template syntax, particularly conditional blocks (`{{if}}`, `{{where}}`, `{{set}}`).
- **Type Mismatches:** Check your model types and method parameter types align with those expected by the generator.

### Best Practices
- Keep your SQL templates simple and well-structured.
- Use the `@@table` and `@@column` placeholders to avoid hardcoding table/column names.
- Inject `ctx context.Context` in method parameters for seamless cancellation and tracing.
- Use `generated.<Model>.<Field>` helpers for safer, clearer predicate and update expressions.

### Performance Considerations
- Generated code uses prepared statements and efficient parameter binding.
- Minimize complex raw SQL in template comments when possible; leverage generated filters and chaining.

### Alternative Approaches
- For complex queries, consider writing raw SQL with GORM's `Raw` method alongside generated helpers.
- Customize field helpers by mapping Go types in `genconfig.Config`.

---

## 6. Next Steps & Related Content

- **Run the Generator:** Learn how to run `gorm gen` and specify input and output paths [Running the Generator](https://docs.example.com/getting-started/your-first-generation/running-the-generator).
- **Define Your Models and Query Interfaces:** Best practices for writing your interfaces and models [Writing Models and Interfaces](https://docs.example.com/getting-started/your-first-generation/writing-models-interfaces).
- **Model-Driven Field Helpers:** Deep dive into the generated field helper usage [Field Helpers Basics](https://docs.example.com/guides/core-workflows/field-helpers-basics).
- **Working with Associations:** Managing related data with association helpers [Working With Associations](https://docs.example.com/guides/advanced-patterns/working-with-associations).
- **Template-Based SQL:** Advanced SQL templating for flexible queries [Template-Based SQL](https://docs.example.com/guides/advanced-patterns/template-based-sql).

---

## Appendix: Example Code Snippet
```go
// Generated Query interface usage
user, err := generated.Query[User](db).GetByID(ctx, 123)
if err != nil {
  log.Fatalf("failed to get user: %v", err)
}

// Using fluent API with field helpers
users, err := gorm.G[User](db).
  Where(generated.User.Name.Like("%smith%"), generated.User.Age.Gt(21)).
  Find(ctx)

// Update user's age
err = generated.Query[User](db).UpdateInfo(ctx, models.User{Age: 30}, 123)

// Create user with associated pets
err = gorm.G[User](db).
  Set(
    generated.User.Name.Set("alice"),
    generated.User.Pets.Create(generated.Pet.Name.Set("fido")),
  ).
  Create(ctx)
```

---

For additional help, consult the Troubleshooting & Configuration documentation or reach out to the community.
