---
title: "Using Generated APIs in Your Application"
description: "Step-by-step usage of the generated query interfaces and field helpers, covering common read and write patterns, integrating with a real GORM database connection, and verifying compile-time safety in your codebase."
---

# Using Generated APIs in Your Application

This guide walks you through using the generated query interfaces and field helpers produced by GORM CLI in your Go application. You will learn common read and write patterns, how to integrate with a real GORM database connection, and verify compile-time safety in your codebase. The focus is on practical usage of the generated APIs to confidently build robust database interactions.

---

## Workflow Overview

### What This Guide Helps You Accomplish

You will learn to:
- Use generated interfaces for querying your database with type-safe methods.
- Perform common CRUD operations using generated read and write helpers.
- Interact fluently with GORM’s database connection while maintaining compile-time safety.
- Handle query parameters, dynamic filtering, and updates via generated methods.

### Prerequisites

Before starting, ensure:
- You have run the GORM CLI generator (`gorm gen`) on your interfaces and models.
- Your generated code is available in your project imports.
- You have a working `*gorm.DB` database connection.
- Basic understanding of Go’s generics and context usage.

### Expected Outcome

By the end, you will:
- Confidently call generated query methods with proper parameters.
- Seamlessly chain generated field helpers with GORM’s fluent API.
- Safely perform inserts, updates, deletes, and associations.
- Write clear, maintainable, and type-checked database code.

### Time Estimate

This guide can be completed within 20-30 minutes assuming the generator has run and your project is setup.

### Difficulty Level

Intermediate — familiarity with Go, GORM, and context is assumed.

---

## Step-by-Step Instructions

<Steps>
<Step title="Import and Initialize Generated Code">
Start by importing your generated package and your model types. Then, obtain a `*gorm.DB` connection to your database, and ensure you have a `context.Context`.

```go
import (
  "context"
  "gorm.io/gorm"
  "yourproject/generated" // replace with your generated package path
  "yourproject/models"     // your model package
)

ctx := context.Background()
db, err := gorm.Open(...)
if err != nil {
  // handle error
}
```

<Check>
Your generated code package should be imported correctly, and the `db` variable must be a live connection.
</Check>
</Step>

<Step title="Run Generated Query Methods">
Use the generated query interfaces to perform basic reads. For example, to get a user by ID:

```go
user, err := generated.Query[models.User](db).GetByID(ctx, 123)
if err != nil {
  // handle error
}
fmt.Println(user.Name)
```

This invokes the generated `GetByID` method, executing the templated SQL automatically with binding and safety.

<Note>
Methods auto-inject context if not present in the interface. Passing `ctx` is mandatory.
</Note>

<Check>
After calling, you should receive fully populated struct `user` and no compilation errors.
</Check>
</Step>

<Step title="Perform Filtered Queries Using Dynamic Parameters">
Use query methods supporting dynamic SQL with parameters. For example:

```go
users, err := generated.Query[models.User](db).
  FilterWithColumn(ctx, "age", "25")

if err != nil {
  // handle error
}
for _, u := range users {
  fmt.Println(u.Name, u.Age)
}
```

The method implements flexible queries, allowing you to specify columns and values dynamically.

<Tip>
Use generated methods that accept slices or structs for filter criteria to build complex queries safely.
</Tip>
</Step>

<Step title="Use Template-Based Queries for Complex Conditions">
Generated methods can include SQL templates with conditional `{{if}}` and loops. Use them by passing appropriately populated parameters.

Example:

```go
userFilter := models.User{Name: "jinzhu", Age: 30}
result, err := generated.Query[models.User](db).QueryWith(ctx, userFilter)
if err != nil {
  // handle error
}
```

The generated SQL applies conditions based on which fields in `userFilter` are non-empty.

<Note>
This enables powerful, flexible queries without string concatenation and risk of SQL injection.
</Note>
</Step>

<Step title="Update Records Using Generated Setters">
You can update records via generated methods that accept data structs and parameters. For example, updating a user's info:

```go
updateUser := models.User{Name: "newname", Age: 35}
err := generated.Query[models.User](db).UpdateInfo(ctx, updateUser, 123)
if err != nil {
  // handle error
}
```

The method handles dynamic SET SQL clauses including conditionally omitted fields.

<Tip>
Generated setters distinguish zero-values from unset fields to prevent unintended overwrites.
</Tip>
</Step>

<Step title="Leverage Generated Field Helpers for Fluent Queries">
For more dynamic queries using the fluent GORM builder, use generated field helpers.

Example:

```go
import "generated"

// Find users older than 18
users, err := gorm.G[models.User](db).
  Where(generated.User.Age.Gt(18)).
  Find(ctx)

if err != nil {
  // handle error
}
```

Generated fields like `generated.User.Age` provide type-safe predicates like `.Eq()`, `.Gt()`, `.Between()`, etc.

<Check>
Verify each condition call passes compiler checks for type correctness.
</Check>
</Step>

<Step title="Handle Associations Using Generated Helpers">
Association fields are generated as `field.Struct[T]` or `field.Slice[T]` allowing operations like Create, Update, Unlink, and Delete.

Example creating a user with pets:

```go
err := gorm.G[models.User](db).
  Set(
    generated.User.Name.Set("alice"),
    generated.User.Pets.Create(generated.Pet.Name.Set("fido")),
  ).
  Create(ctx)
if err != nil {
  // handle error
}
```

This automatically creates and associates pets with the user.

<Tip>
Use association helpers inside `Set()` calls combined with `Create(ctx)` or `Update(ctx)` on the parent.
</Tip>
</Step>

<Step title="Verify Compile-Time Safety and Build Your Application">
Since generated APIs use Go generics and typed methods, your IDE and compiler catch most mistakes early.

- Running `go build` confirms all generated method signatures match expected types.
- IDEs provide auto-completion for methods and fields.

<Tip>
Regularly regenerate code as you evolve your interfaces and models to avoid drift.
</Tip>
</Step>
</Steps>

---

## Examples & Code Samples

### Query Interface Usage Example

```go
// Get user by ID
user, err := generated.Query[models.User](db).GetByID(ctx, 1)
if err != nil {
  panic(err)
}

// Filter users dynamically
filteredUsers, err := generated.Query[models.User](db).FilterWithColumn(ctx, "role", "admin")

// Update a user’s name
err = generated.Query[models.User](db).UpdateInfo(ctx, models.User{Name: "newname"}, 1)
```

### Fluent Field Query Example

```go
// Find users where Age > 18 and role = "active"
users, err := gorm.G[models.User](db).
  Where(generated.User.Age.Gt(18), generated.User.Role.Eq("active")).
  Find(ctx)
```

### Association Creation Example

```go
// Create user with two languages (many2many)
gorm.G[models.User](db).
  Set(
    generated.User.Name.Set("polyglot"),
    generated.User.Languages.CreateInBatch([]models.Language{{Code: "EN"}, {Code: "FR"}}),
  ).
  Create(ctx)
```

---

## Troubleshooting & Tips

### Common Issues

- **Generated methods not found or compile errors:** Ensure you imported the generated package and regenerated after any interface/model change.
- **Missing context parameter:** Generated methods add `ctx` as the first argument if absent; always provide a valid `context.Context`.
- **Field type mismatches:** Use `genconfig.Config` to map custom types to field helpers.
- **Database connection errors:** Verify your `*gorm.DB` instance is correctly initialized.

### Best Practices

- Regenerate code each time interfaces or models change.
- Use `context.Context` consistently to manage request lifetimes.
- Leverage generated conditional templates for flexible queries.
- Use field helpers over raw SQL strings for predicates and updates.
- Handle association updates via generated methods to maintain relational integrity.

### Performance Considerations

- The generated APIs internally compose GORM statements efficiently.
- Avoid invoking multiple queries unnecessarily; utilize batch operations when supported.

### Alternative Approaches

- You can write raw SQL or raw GORM queries, but this sacrifices compile-time safety.
- Configure generation filters in `genconfig.Config` to include/exclude interfaces or structs as needed.

---

## Next Steps & Related Content

- Explore the [Field Helper Customization guide](/guides/advanced-patterns/field-helper-customization) to tailor field mappings.
- Learn more about [Template-Based Queries](/guides/advanced-patterns/template-based-queries) for advanced SQL templating.
- Consult [Working with Associations](/guides/advanced-patterns/association-operations) for deep dive into relation handling.
- Review [Avoiding Common Pitfalls and Troubleshooting](/guides/core-workflows/common-pitfalls) for comprehensive problem-solving.
- For setup details, see [First Steps and Usage](/getting-started/first-steps-usage/writing-models-interfaces) and [Generating Code with GORM CLI](/getting-started/first-steps-usage/generating-code).

<Tip>
Keep your generated code in version control and automate regeneration in your build pipeline.
</Tip>
