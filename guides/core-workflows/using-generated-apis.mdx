---
title: "Working with Generated APIs in Your Project"
description: "Walk through practical examples of using generated query methods and field helpers. See how to build robust, compile-time-safe read and write operations, leveraging the generated code for fast and reliable data access."
---

# Working with Generated APIs in Your Project

Explore how to use the type-safe query APIs and model-driven field helpers generated by GORM CLI in your Go project. This guide provides practical, step-by-step examples showcasing reading and writing data safely and efficiently with the generated code, helping you translate interface definitions and SQL templates into robust data operations.

---

## Workflow Overview

- **Task Description:** Learn how to integrate and work with GORM CLI's generated query methods and field helpers in your Go application to build reliable and type-safe database interactions.
- **Prerequisites:** 
  - Completed the generation step using GORM CLI to produce query APIs and field helpers.
  - Familiarity with your model structs and corresponding generated code.
  - A GORM database connection (`*gorm.DB`) ready for use.
- **Expected Outcome:** You will confidently use generated methods to perform complex queries, filtered reads, conditional updates, and manipulate associations with compile-time safety.
- **Time Estimate:** 15-30 minutes
- **Difficulty Level:** Intermediate (basic knowledge of Go and GORM assumed)

---

## Step-by-Step Instructions

### 1. Using Generated Query Interfaces for Reads

The generated query interfaces provide strongly typed methods derived from your interface definitions and SQL template annotations.

<Steps>
<Step title="Invoke a Basic Query Method">
Use a generated method to fetch data by a simple key.

```go
// SELECT * FROM users WHERE id=123
user, err := generated.Query[User](db).GetByID(ctx, 123)
if err != nil {
  // handle error
}
fmt.Println(user)
```

This executes the SQL defined in your interface comment with parameter binding managed automatically.
</Step>

<Step title="Apply Dynamic Filters with Generated Methods">
Use methods with dynamically templated WHERE clauses.

```go
users, err := generated.Query[User](db).FilterByNameAndAge("jinzhu", 25)
if err != nil {
  // handle error
}
for _, u := range users {
  fmt.Printf("User: %+v\n", u)
}
```

These calls leverage the generated SQL templates incorporating conditional SQL logic.
</Step>

<Step title="Use Complex Query Methods">
Pass full struct parameters to perform conditionally assembled queries.

```go
queryUser := models.User{Name: "jinzhu"}
uList, err := generated.Query[User](db).QueryWith(ctx, queryUser)
if err != nil {
  // handle error
}
// uList contains all users matching query conditions
```
</Step>
</Steps>

### 2. Leveraging Generated Field Helpers for Fluent Filters

Generated field helpers enable expressive, type-safe construction of predicates.

```go
result, err := gorm.G[User](db).
  Where(
    generated.User.Age.Gt(18),
    generated.User.Name.Like("%jinzhu%"),
  ).
  Find(ctx)
if err != nil {
  // handle error
}
```

This fluently composes WHERE clauses with predicates like `Gt` (greater than) and `Like`.

### 3. Performing Updates with Generated Helpers

Field helpers allow setting values, expressions, and zero values safely.

```go
err := gorm.G[User](db).
  Where(generated.User.ID.Eq(1)).
  Set(
    generated.User.Name.Set("newname"),
    generated.User.Age.Incr(1),
    generated.User.IsAdult.Set(true),
  ).
  Update(ctx)

if err != nil {
  // handle error
}
```

You can also combine setting fields and association operations (see Associations section).

### 4. Working with Generated Template-Based Query Methods

For SQL template-driven methods that include conditions and iterations, just call the generated method normally. The CLI-generated code compiles the SQL templates into safe, runtime-ready SQL.

Example: Filtering with a list of users

```go
users := []models.User{
  {Name: "jinzhu", Age: 25, Role: "admin"},
  {Name: "alice", Age: 30, Role: "user"},
}
filteredUsers, err := generated.Query[User](db).Filter(ctx, users)
if err != nil {
  // handle error
}
```

The method will generate the corresponding dynamic WHERE clause with proper clause splitting and parameter binding.

### 5. Handling Update Queries with Conditional SET Clause

Use generated methods that represent update operations with conditionally built SET clauses.

```go
userUpdate := models.User{Name: "newName", Age: 21}
err := generated.Query[User](db).UpdateInfo(ctx, userUpdate, 1)
if err != nil {
  // handle error
}
```

This approach ensures only non-empty fields modify the database, optimizing update statements.

---

## Examples & Code Samples

### Basic Generated Query Usage

```go
// Fetch a user by ID
user, err := generated.Query[User](db).GetByID(ctx, 5)
if err != nil {
  log.Fatal(err)
}
fmt.Printf("User: %+v\n", user)
```

### Using Field Helpers for Filters

```go
// Find all users older than 18
var adults []User
err := gorm.G[User](db).
  Where(generated.User.Age.Gt(18)).
  Find(ctx, &adults)
if err != nil {
  log.Fatal(err)
}
```

### Complex Template Query with Slice Parameter

```go
users := []models.User{{Name: "bob", Age: 22}, {Name: "carol", Age: 35}}
result, err := generated.Query[User](db).Filter(ctx, users)
if err != nil {
  log.Fatal(err)
}
// result contains matching users based on dynamic OR conditions
```

### Conditional Update Using Template Method

```go
updateUser := models.User{Name: "updated", Age: 28}
err := generated.Query[User](db).UpdateInfo(ctx, updateUser, 12)
if err != nil {
  log.Fatal(err)
}
```

### Using Where Field Helper with Set Update

```go
err := gorm.G[User](db).
  Where(generated.User.ID.Eq(10)).
  Set(generated.User.Name.Set("newname")).
  Update(ctx)
if err != nil {
  log.Fatal(err)
}
```

---

## Troubleshooting & Best Practices

<AccordionGroup title="Common Issues and Solutions">
<Accordion title="Generated Method Not Found">
Ensure you have run the generator with the correct input file including your interfaces and that the output directory is up to date. Re-run `gorm gen -i <input> -o <output>` and verify generated files.
</Accordion>
<Accordion title="SQL Syntax Errors in Generated Queries">
Verify the correctness of the SQL templates in interface comments. Pay attention to escaping and parameter binding syntax (`@param`, `@@table`). Use the CLI’s error output to locate issues.
</Accordion>
<Accordion title="Empty Results or Unexpected Data">
Confirm that your `Where` clause predicates or method parameters correctly reflect the intended query. Use generated field helpers for consistent predicate construction.
</Accordion>
<Accordion title="Associations Not Updating as Expected">
Review association helper usage patterns—unlike normal fields, associations require explicit `Create`, `Update`, `Unlink`, or `Delete` calls through generated helpers.
</Accordion>
</AccordionGroup>

<Tip>
Always use the generated query interfaces and field helpers as they enforce compile-time type safety and help prevent SQL injection vulnerabilities through safe parameter binding.
</Tip>

## Next Steps & Related Content

- **Explore Working with Associations:** Use [`Managing Associations with Field Helpers`](/guides/advanced-patterns/associations) to handle complex relationships.
- **Deepen SQL Template Knowledge:** Visit [`Building Custom Queries with SQL Templates`](/guides/advanced-patterns/template-queries) for extending your query interfaces.
- **Customize Field Helpers:** Learn about [`Defining and Using Custom Field Helpers (e.g., JSON)`](/guides/advanced-patterns/custom-field-helpers).
- **Advanced Generation Configuration:** Apply fine-grained control with [`Advanced Code Generation Configuration`](/guides/core-workflows/configuring-generation).

---

Embark on your journey integrating the generated code into your application by experimenting with the examples above, enabling fast, compile-safe, and robust data access.
