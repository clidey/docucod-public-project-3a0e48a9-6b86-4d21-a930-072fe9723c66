---
title: "Using the Generated APIs in Real Projects"
description: "Explore how to use the fluent, type-safe APIs generated by the CLI for querying, updating, and creating records. Learn usage patterns in real-world project contexts, with detailed examples mapping generated APIs to database operations."
---

# Using the Generated APIs in Real Projects

Explore how to use the fluent, type-safe APIs generated by the CLI for querying, updating, and creating records. This guide walks you through practical usage patterns in real-world project contexts, illustrating how to map generated APIs directly to your database operations with detailed examples.

---

## 1. Workflow Overview

### What This Guide Helps You Accomplish
- Understand how to leverage the generated type-safe query APIs and model-driven field helpers in your Go projects.
- Learn to perform common CRUD (Create, Read, Update, Delete) operations using fluent, error-proof constructs.
- Master association operations including create, update, unlink, and delete for related records.
- Apply SQL template-based query interfaces for dynamic, type-safe SQL queries.

### Prerequisites
- You have generated the API code using the `gorm gen` CLI with your Go interfaces and model structs.
- Familiarity with Go, GORM, and basic database concepts.
- Basic understanding of SQL and the code generation approach (see guides on interface creation and running the generator).

### Expected Outcome
After completing this guide, you will confidently use the generated APIs to:
- Write complex queries with type-safe methods.
- Manage relational data and associations with concise and clear operations.
- Integrate dynamically templated SQL queries into your application smoothly.

### Time Estimate
Approximately 15-25 minutes to fully grasp the examples and workflows.

### Difficulty Level
Intermediate â€“ assumes familiarity with Go and GORM but new users of the generated API will find guidance to ramp up quickly.

---

## 2. Using Generated APIs: Step-by-Step

### Step 1: Querying Data with Type-Safe Methods

You can retrieve records using generated interfaces that match your defined SQL templates.

```go
// Retrieve a user by ID
user, err := generated.Query[User](db).GetByID(ctx, 123)
if err != nil {
    // handle error
}
```

**Expected Result:** `user` is a typed `User` struct fetched from the database.

---

### Step 2: Filtering and Finding Multiple Records

Use generated methods to compose query predicates fluently.

```go
// Find users named JinZhu aged 25
users, err := generated.Query[User](db).
    FilterByNameAndAge("jinzhu", 25).
    Find(ctx)

if err != nil {
    // handle error
}
```

**Expected Result:** `users` is a slice of `User` structs matching the filter criteria.

---

### Step 3: Creating Records with Field Helpers

Build insertion statements using generated field helpers to set columns safely.

```go
err := gorm.G[User](db).
    Set(
        generated.User.Name.Set("alice"),
        generated.User.Age.Set(0),
        generated.User.IsAdult.Set(false),
        generated.User.Role.Set("active"),
    ).
    Create(ctx)

if err != nil {
    // handle error
}
```

**Expected Result:** A new user record is inserted with specified fields.

---

### Step 4: Updating Records with Conditional Sets

Update existing records, optionally using expressions and zero-value sets.

```go
err := gorm.G[User](db).
    Where(generated.User.Name.Eq("alice")).
    Set(
        generated.User.Name.Set("jinzhu"),
        generated.User.IsAdult.Set(false),
        generated.User.Score.Set(sql.NullInt64{}),
        generated.User.Age.Incr(1),
        generated.User.Age.SetExpr(clause.Expr{SQL: "GREATEST(?, ?)", Vars: []any{clause.Column{Name: "age"}, 18}}),
    ).
    Update(ctx)

if err != nil {
    // handle error
}
```

**Expected Result:** User records matching the `Where` condition are updated accordingly.

---

### Step 5: Working with Associations

The generated field helpers for associations let you create, update, unlink, or delete related data concisely.

- **Create and link a related record:**

```go
gorm.G[User](db).
    Set(
        generated.User.Name.Set("alice"),
        generated.User.Pets.Create(generated.Pet.Name.Set("fido")),
    ).
    Create(ctx)
```

- **Update an associated pet's name:**

```go
gorm.G[User](db).
    Where(generated.User.ID.Eq(1)).
    Set(
        generated.User.Pets.Where(generated.Pet.Name.Eq("fido")).
            Update(generated.Pet.Name.Set("rex")),
    ).
    Update(ctx)
```

- **Unlink associations (remove FK links but do not delete rows):**

```go
gorm.G[User](db).
    Where(generated.User.ID.Eq(1)).
    Set(generated.User.Pets.Unlink()).
    Update(ctx)
```

- **Delete associated rows (including join table rows for many2many):**

```go
gorm.G[User](db).
    Where(generated.User.ID.Eq(1)).
    Set(generated.User.Pets.Delete()).
    Update(ctx)
```

**Expected Result:** Association operations reflect the expected changes in the database.

---

### Step 6: Leveraging Template-Based Queries for Dynamic SQL

Interfaces annotated with SQL templates allow powerful dynamic and reusable queries.

Example interface method:

```go
type Query[T any] interface {
  // SELECT * FROM @@table WHERE id=@id
  GetByID(id int) (T, error)

  // SELECT * FROM @@table
  // {{where}}
  //   {{if @user.Name }} name=@user.Name {{end}}
  //   {{if @user.Age > 0}} AND age=@user.Age {{end}}
  // {{end}}
  SearchUsers(user User) ([]T, error)
}
```

Usage:

```go
users, err := generated.Query[User](db).SearchUsers(ctx, User{Name: "jinzhu", Age: 25})
if err != nil {
    // handle error
}
```

**Expected Result:** Users filtered dynamically according to conditions expressed in the template.

---

## 3. Real-World Examples

### Example: Get a User by ID

```go
user, err := generated.Query[User](db).GetByID(ctx, 123)
if err != nil {
    log.Fatal(err)
}
fmt.Println("User name:", user.Name)
```

### Example: Create User With Pets

```go
err := gorm.G[User](db).
    Set(
        generated.User.Name.Set("alice"),
        generated.User.Pets.Create(generated.Pet.Name.Set("fido")),
    ).
    Create(ctx)
if err != nil {
    log.Fatal(err)
}
```

### Example: Update User Age and Mark Adult

```go
err := generated.Query[User](db).
    UpdateInfo(ctx, User{Name: "jinzhu", Age: 20}, 1)
if err != nil {
    log.Fatal(err)
}
```

## 4. Troubleshooting & Tips

### Common Issues

- **Generated code compilation errors:** Check that your interfaces and models comply with expected signatures and annotations. Return types in interface methods must include `error` as the last value.
- **Missing expected generated APIs:** Verify your `genconfig.Config` inclusion/exclusion rules. Ensure your interfaces and structs are not accidentally filtered out.
- **Association operations have no effect:** Confirm that the relations are correctly defined on your structs and that you use `Set(...).Create(ctx)` or `Set(...).Update(ctx)` to trigger operations.

### Best Practices

- Specify SQL templates pragmatically in interface comments to keep queries readable and maintainable.
- Use field helpers for all read and write operations to benefit from type safety and fluent API.
- Carefully manage `Include` and `Exclude` filters in `genconfig.Config` to limit generation scope and speed up your workflow.

### Performance Considerations

- Use generated APIs to avoid runtime SQL string construction and errors.
- Leverage batch association operations like `CreateInBatch` for bulk inserts and linking.

### Alternative Approaches

- For complex SQL not easily expressed in templates, fallback to raw GORM usage or define new query interface methods.
- Extend generation by defining custom field helpers for special types like JSON.

---

## 5. Next Steps & Related Content

- Explore [Writing Template-based Queries](https://docs.example.com/guides/core-workflows/template-queries-quickstart) to master the templating DSL.
- Extend your API customization with [Customizing Generation with genconfig.Config](https://docs.example.com/guides/advanced-features-patterns/customizing-generation-config).
- Use [Best Practices for Working with Associations](https://docs.example.com/guides/advanced-features-patterns/association-operations) to deepen your association management skills.
- Learn about adding custom field helpers like JSON in [Extending GORM CLI with Custom Field Helpers](https://docs.example.com/guides/advanced-features-patterns/extending-with-custom-helpers).

---

## References

- [GORM CLI GitHub Repository](https://github.com/go-gorm/cli)
- [First Query Interface Guide](https://docs.example.com/getting-started/project-initialization/first-query-interface)
- [Run Generator Guide](https://docs.example.com/getting-started/project-initialization/run-generator)
- [Basic Generator Configuration](https://docs.example.com/getting-started/project-initialization/basic-configuration)
- [Quick Feature Overview](https://docs.example.com/overview/architecture-concepts/quick-feature-overview)

---

Embrace these generated APIs to streamline your Go database programming with assured type safety, expressive code, and reduced runtime errors.