---
title: "Using the Generated Query APIs and Field Helpers"
description: "Demonstrates how to use the generated query functions and field helpers in real application code: building type-safe queries, filters, and updates with fluent, discoverable APIs. Highlights compile-time safety and best usage patterns."
---

# Using the Generated Query APIs and Field Helpers

This guide demonstrates how to use the generated query functions and model-driven field helpers created by GORM CLI. You'll learn how to construct type-safe, fluent queries, filters, and updates in Go application code using the generated APIs. The guide highlights patterns that maximize compile-time safety and outlines best practices for working with generated query methods and association helpers.

---

## Workflow Overview

- **What this guide helps you do:**
  Understand how to use the generated type-safe query interfaces and model-driven field helpers from your Go models and SQL-annotated interfaces.
- **Prerequisites:**
  - GORM CLI-generated code is present (via `gorm gen` command).
  - Familiarity with your Go models and the query interfaces you defined.
  - A configured and initialized GORM database `db` instance.
- **Expected Outcome:**
  - Write fluent, discoverable Go queries that integrate generated helpers.
  - Perform safe filters, updates, inserts, and association operations with compile-time verification.
- **Estimated Time:** 15-30 minutes
- **Skill Level:** Intermediate Go developer with basic knowledge of GORM and code generation.

---

## Step-by-Step Instructions

### 1. Access Generated Query APIs

After generating code, each interface you defined produces a type-safe query implementation accessed like this:

```go
u, err := generated.Query[User](db).GetByID(ctx, 123)
```

- **What happens here:** `generated.Query[User](db)` returns a typed query interface instance for the `User` model.
- **Best practice:** Always pass the current `context.Context` as the first argument.

### 2. Using Model-Driven Field Helpers for Filtering

Model fields have corresponding helpers for building predicates:

```go
// Find users with age greater than 18
users, err := gorm.G[User](db).
  Where(generated.User.Age.Gt(18)).
  Find(ctx)
```

- Here, `generated.User.Age.Gt(18)` represents the SQL predicate `age > 18`.
- This pattern is safe, preventing typos and invalid SQL.

### 3. Combining Filters and Fluent API

You can chain multiple predicates and combine with standard GORM clauses:

```go
users, err := gorm.G[User](db).
  Where(generated.User.Age.Gt(18), generated.User.Name.Like("%John%"))
  .Order(generated.User.CreatedAt.Desc())
  .Limit(10).
  Find(ctx)
```

- Use `.Where` to combine filters.
- Use field helpers like `.Like()`, `.Eq()`, `.Between()` to build expressive conditions.

### 4. Performing Updates and Inserts with Field Helpers

Set new values with `.Set()` using the generated field setters to prepare data for `Update()` or `Create()`:

```go
// Update user's name and increment age
err := gorm.G[User](db).
  Where(generated.User.ID.Eq(1)).
  Set(
    generated.User.Name.Set("Alice"),
    generated.User.Age.Incr(1),
  ).
  Update(ctx)

// Create a new user
err = gorm.G[User](db).
  Set(
    generated.User.Name.Set("Bob"),
    generated.User.Age.Set(30),
  ).
  Create(ctx)
```

- `.Set()` accepts one or more setters reflecting fields to be modified.
- For zero-values, use `.Set()` explicitly; `.Incr()` adds increment expressions.

### 5. Working with Associations

The generated helpers support associations such as `has many`, `belongs to`, and `many2many`:

```go
// Create user and associate one pet
err := gorm.G[User](db).
  Set(
    generated.User.Name.Set("alice"),
    generated.User.Pets.Create(generated.Pet.Name.Set("fido")),
  ).
  Create(ctx)

// Update an associated pet where name = 'fido'
gorm.G[User](db).
  Where(generated.User.ID.Eq(1)).
  Set(generated.User.Pets.Where(generated.Pet.Name.Eq("fido")).
    Update(generated.Pet.Name.Set("rex")),
  ).
  Update(ctx)

// Unlink pets association (removes the link without deleting pets)
gorm.G[User](db).
  Where(generated.User.ID.Eq(1)).
  Set(generated.User.Pets.Unlink()).
  Update(ctx)

// Delete pets associated with user
err = gorm.G[User](db).
  Where(generated.User.ID.Eq(1)).
  Set(generated.User.Pets.Delete()).
  Update(ctx)

// Batch create linked languages for a user
err = gorm.G[User](db).
  Where(generated.User.ID.Eq(1)).
  Set(generated.User.Languages.CreateInBatch([]models.Language{{Code: "EN"}, {Code: "FR"}})).
  Update(ctx)
```

- Association operations (`Create`, `Update`, `Unlink`, `Delete`, `CreateInBatch`) are used inside `.Set()`.
- Use `.Where()` on association helpers to filter related rows.

### 6. Using Template-Based SQL Query Methods

Interfaces with SQL templates generate methods you can call with Go parameters:

```go
user, err := generated.Query[User](db).GetByID(ctx, 123)
users, err := generated.Query[User](db).FilterByNameAndAge(ctx, "john", 25).Find(ctx)
err := generated.Query[User](db).UpdateInfo(ctx, User{Name: "jinzhu", Age: 20}, 1)
```

- These methods encapsulate SQL logic defined in comments.
- Parameters bind safely to placeholders, avoiding injection.

### 7. Verifying Successful Usage

- Methods return typed data and errors.
- On success, queries return model instances or slices.
- On failure, inspect the error returned.

---

## Examples & Code Samples

### Filtering Users Older Than 30 With Name Containing "Jane"

```go
users, err := gorm.G[User](db).
  Where(generated.User.Age.Gt(30), generated.User.Name.Like("%Jane%"))
  .Find(ctx)
if err != nil {
  log.Fatalf("Query failed: %v", err)
}
```

### Updating a User's Email and Status

```go
err := gorm.G[User](db).
  Where(generated.User.ID.Eq(42)).
  Set(
    generated.User.Email.Set("newemail@example.com"),
    generated.User.Status.Set("active"),
  ).Update(ctx)
```

### Creating a User With Multiple Pets

```go
err := gorm.G[User](db).
  Set(
    generated.User.Name.Set("alex"),
    generated.User.Pets.CreateInBatch([]models.Pet{{Name: "spot"}, {Name: "fluffy"}}),
  ).Create(ctx)
```

### Using a Custom Template Query Method

```go
user, err := generated.Query[User](db).QueryWith(ctx, models.User{ID: 5})
if err != nil {
  log.Fatal(err)
}
fmt.Println(user.Name)
```

---

## Troubleshooting & Tips

### Common Issues

- **Error:** _method not found on generated interface_
  - Ensure you ran `gorm gen` after defining new interfaces.
  - Check your `IncludeInterfaces` settings if filtering generation.

- **Error:** _SQL execution error or unexpected results_
  - Review SQL templates for syntax errors.
  - Verify parameter types and values passed.

- **Associations not linking as expected**
  - Confirm correct use of `.Create()`, `.Update()`, `.Unlink()`, or `.Delete()` semantics.
  - Verify foreign key constraints in your model.

### Best Practices

- Always include `ctx context.Context` in your method calls.
- Use generated field helpers to prevent SQL injection and typos.
- Use `.Set()` exclusively to build updates and creationsâ€”avoid raw SQL string concatenation.
- Combine conditions fluently using `.Where` with field helpers.
- Use `.CreateInBatch` for high-performance batch inserts.

### Performance Considerations

- Use `.Limit()` and `.Order()` with your queries to reduce load.
- Batch association operations instead of looping single inserts where possible.

### Alternative Approaches

- While you can use standard GORM queries, leveraging generated field helpers improves type safety and discoverability.

---

## Next Steps & Related Content

- After mastering query and field helper usage, explore **Working with Associations: Linked Data Made Easy** to deepen association handling.
- For advanced templating capabilities, see **Template-Based SQL with Interfaces**.
- Consult **Customizing Code Generation** to tailor generated helpers to your project.
- Review **Using Generated APIs** for an extended set of usage patterns.

---

## Summary

This guide equips you to confidently use the code generated by GORM CLI, producing type-safe, fluent queries and updates. By combining interface-driven query methods with robust model field helpers, your application gains compile-time verification and cleaner database interaction.

Explore related guides to expand functionality, from association management to advanced templating and configuration.

---