---
title: "Using the Generated Code"
description: "Guide to working with generated query APIs, field helpers, and associations in your application code—covering common CRUD operations, filtering, and composing expressions. Includes real usage samples."
---

# Using the Generated Code

This guide explains how you can effectively leverage the **generated query APIs**, **field helpers**, and **association helpers** produced by GORM CLI in your Go application code. You will learn to execute common **CRUD operations**, compose rich **filters**, and manage **associations** using the type-safe, fluent APIs generated from your models and SQL-annotated interfaces.

---

## 1. Workflow Overview

### Task Description
Learn how to interact with generated APIs that simplify database operations by providing compile‑time safety and expressive query building. This guide helps you unlock the full capabilities of generated query methods, field helpers, and association manipulators.

### Prerequisites
- You must have run the GORM CLI generator (**`gorm gen`**) on your Go codebase, producing the query interfaces and field helpers.
- Your Go project should import the generated package where these APIs reside.
- Familiarity with basic GORM concepts: `*gorm.DB`, query building, context usage.

### Expected Outcome
- Execute type-safe queries using generated query interface methods.
- Use field helpers to construct expressive CRUD operations.
- Perform association operations such as create, update, unlink, and delete with fluent syntax.

### Time Estimate
Approximately 20–30 minutes to grasp and try the provided examples.

### Difficulty Level
Intermediate: Requires working knowledge of Go, GORM, and basic code generation concepts.

---

## 2. Using Generated Query Interface Methods

Generated query interfaces provide methods defined in your annotated Go interfaces. These methods encapsulate raw SQL templates into convenient, type-safe Go functions.

### Executing Basic Queries
```go
// Query a single record by ID
user, err := generated.Query[models.User](db).GetByID(ctx, 123)
if err != nil {
    // handle error
}

// Retrieve users filtered by name and age
users, err := generated.Query[models.User](db).FilterByNameAndAge("alice", 30).Find(ctx)

// Dynamic filtering using a slice
filteredUsers, err := generated.Query[models.User](db).Filter([]models.User{
    {Name: "alice", Age: 30},
    {Name: "bob", Age: 25},
}).Find(ctx)
```

### Using SQL Template DSL Features
Generated methods support advanced templating features such as conditional SQL (`{{if}}`), iterations (`{{for}}`), and dynamic WHERE or SET clauses.

```go
// Update user record by ID using templated UpdateInfo method
err = generated.Query[models.User](db).UpdateInfo(ctx, models.User{Name: "newname", Age: 35}, 123)
```

<Tip>
Generated methods automatically inject `context.Context` if not provided, ensuring idiomatic Go usage.
</Tip>

---

## 3. Working With Field Helpers

Field helpers correspond to your model's fields and enable building expressive, type-safe query conditions and update sets.

### Building Filters With Field Helpers
```go
import "gorm.io/gorm"

// Retrieve users older than 18
var users []models.User
err := gorm.G[models.User](db).
  Where(generated.User.Age.Gt(18)).
  Find(ctx, &users)

// Find users where name LIKE '%smith%'
err = gorm.G[models.User](db).
  Where(generated.User.Name.Like("%smith%")).
  Find(ctx, &users)

// Filter on nullable field Score being NULL
err = gorm.G[models.User](db).
  Where(generated.User.Score.IsNull()).
  Find(ctx, &users)
```

### Setting Fields for Create and Update Operations
```go
// Create a new user with specific fields
err := gorm.G[models.User](db).
  Set(
    generated.User.Name.Set("alice"),
    generated.User.Age.Set(22),
    generated.User.IsAdult.Set(true),
  ).
  Create(ctx)

// Update user's age and role
err = gorm.G[models.User](db).
  Where(generated.User.ID.Eq(123)).
  Set(
    generated.User.Age.Set(23),
    generated.User.Role.Set("admin"),
  ).
  Update(ctx)
```

<Tip>
You can also use update expressions, such as incrementing a number field:

```go
generated.User.Age.Incr(1) // Increment age by 1
```
</Tip>

---

## 4. Managing Associations

Associations like `has one`, `has many`, `belongs to`, and `many2many` are represented as association helpers on your model fields. These helpers allow you to **create**, **update**, **unlink**, and **delete** related records in a type-safe manner.

### Creating and Linking Associations
```go
// Create a new user with one pet
err := gorm.G[models.User](db).
  Set(
    generated.User.Name.Set("alice"),
    generated.User.Pets.Create(generated.Pet.Name.Set("fido")),
  ).
  Create(ctx)

// Create a user and link languages (many2many)
err = gorm.G[models.User](db).
  Set(
    generated.User.Name.Set("polyglot"),
    generated.User.Languages.CreateInBatch([]models.Language{{Code: "EN"}, {Code: "FR"}}),
  ).
  Create(ctx)
```

### Updating Associations
```go
// Update a user's pet's name where pet name is 'fido'
err = gorm.G[models.User](db).
  Where(generated.User.ID.Eq(1)).
  Set(generated.User.Pets.Where(generated.Pet.Name.Eq("fido")).
    Update(generated.Pet.Name.Set("rex")),
  ).
  Update(ctx)
```

### Unlinking Associations
```go
// Unlink pets from user (clears foreign keys or join rows)
err = gorm.G[models.User](db).
  Where(generated.User.ID.Eq(1)).
  Set(generated.User.Pets.Unlink()).
  Update(ctx)
```

### Deleting Associations
```go
// Delete all pets associated with a user
err = gorm.G[models.User](db).
  Where(generated.User.ID.Eq(1)).
  Set(generated.User.Pets.Delete()).
  Update(ctx)
```

<Tip>
- **Unlink** clears associations without deleting related records.
- **Delete** removes related records (in many2many, only join table rows are deleted).
- You can add filters before unlink/delete to target specific related records.
</Tip>

---

## 5. Composing Complex Expressions and Filters

You can combine multiple field helpers and filters with logical operators to build rich queries.

```go
// Find users aged between 18 and 30 and whose name starts with "A"
err := gorm.G[models.User](db).
  Where(
    generated.User.Age.Between(18, 30),
    generated.User.Name.Like("A%"),
  ).
  Find(ctx, &users)

// Filter using JSON field helper with custom JSON expression
err = gorm.G[models.User](db).
  Where(generated.User.Profile.Equal("$.vip", true)).
  Take(ctx, &user)
```

---

## 6. Realistic Usage Example

```go
func UpdateUserWithPets(ctx context.Context, db *gorm.DB, userID uint) error {
  return gorm.G[models.User](db).
    Where(generated.User.ID.Eq(userID)).
    Set(
      generated.User.Name.Set("updatedName"),
      generated.User.Pets.Where(generated.Pet.Name.Eq("fido")).
        Update(generated.Pet.Name.Set("rex")),
      generated.User.Pets.Where(generated.Pet.Name.Eq("old")).Delete(),
    ).
    Update(ctx)
}
```

This example updates the user's name, updates one pet's name, and deletes other pets conditionally—all in a single operation.

---

## 7. Troubleshooting & Tips

### Common Issues
- **Unresolved dependencies**: Ensure your generated code import paths are correctly set.
- **Method not found**: Confirm your interface method is implemented in generated code by re-running generation.
- **Context not accepted**: Generated methods automatically add `context.Context` even if omitted.

### Best Practices
- Always use **generated field helpers** for filter and update conditions to maximize type safety.
- Use **association helpers** to manage relations instead of manual FK manipulation.
- Use batch operations (`CreateInBatch`) for efficient insertion of multiple related rows.

### Performance Considerations
- Use filtering on associations before update/unlink/delete to avoid unintended mass updates.
- Combine multiple field predicates in `Where` conditions for efficient querying.

### Alternative Approaches
- For simple queries, generated field helpers can be combined directly inside GORM’s `Where` or `Set` without using full query interface methods.

---

## 8. Next Steps & Related Content

- Explore **Working with Associations** guide to master association helper operations.
- Study the **Mastering the SQL Template DSL** guide to write powerful query interface annotations.
- Customize field helpers with **Custom Field Helpers and JSON Mapping** for complex field types.
- Review the [README on GitHub](https://github.com/go-gorm/cli#readme) for more detailed examples and best practices.

---

## Summary
This page provided practical, step-by-step guidance to use the generated type-safe query methods, field helpers, and association helpers from GORM CLI into your Go code. By following the examples and best practices here, you gain full control over CRUD and complex data manipulations with compile-time safety and clear API ergonomics.


---

# Appendix: Important Generated Types Sample (From models/user.go)

```go
var User = struct {
  ID        field.Number[uint]
  Name      field.String
  Age       field.Number[int]
  Pets      field.Slice[models.Pet]
  Account   field.Struct[models.Account]
  // ... other fields and associations
}{
  ID:        field.Number[uint]{}.WithColumn("id"),
  Name:      field.String{}.WithColumn("name"),
  Age:       field.Number[int]{}.WithColumn("age"),
  Pets:      field.Slice[models.Pet]{}.WithName("Pets"),
  Account:   field.Struct[models.Account]{}.WithName("Account"),
}
```

This structure enables fluent access such as `generated.User.Name.Eq("alice")` or `generated.User.Pets.Create(...)` in code.

---

# References & Links
- [GORM CLI README](https://github.com/go-gorm/cli#readme)
- [Working with Associations Guide](/guides/advanced-patterns/association-helpers)
- [Mastering SQL Template DSL Guide](/guides/advanced-patterns/templating-dsl)
- [Custom Field Helpers and JSON Mapping](/guides/advanced-patterns/custom-fields)
- [First Code Generation Workflow](/getting-started/first-codegen-workflow/generate-code)
- [Using the Generated Code - Overview](/getting-started/first-codegen-workflow/using-generated-code)


---

