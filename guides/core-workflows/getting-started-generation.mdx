---
title: "Getting Started: Generate Your First Helpers"
description: "A step-by-step walkthrough for bootstrapping a new project with GORM CLI: writing your first model and interface, invoking the generator, and inspecting the output. Provides a foundational workflow for all new users."
---

# Getting Started: Generate Your First Helpers

Welcome to your first hands-on introduction to GORM CLI. This guide takes you through bootstrapping a new project by writing your initial Go model and query interface, running the generator, and exploring the generated code. By the end, you'll have a solid foundation for working with GORM CLI to create type-safe, fluent APIs for your database operations.

---

## 1. What You Will Achieve

- Define a simple Go struct to represent your data model.
- Write a type-safe query interface using SQL templates.
- Run the GORM CLI code generator to produce helpers.
- Understand the structure and usage of the generated code.


## 2. Prerequisites

Before you start, make sure you have:

- Go 1.18 or higher installed and properly set up.
- GORM CLI installed using `go install gorm.io/cli/gorm@latest`.
- Basic knowledge of Go models and interfaces.
- Your project workspace initialized with your Go models and interfaces.


## 3. Step-by-Step Guide

### Step 1: Write Your Model Struct

Create a Go file for your model. For example, define a `User` struct with typical fields:

```go
package models

import "time"

type User struct {
    ID        uint
    Name      string
    Email     string
    Age       int
    Status    string
    CreatedAt time.Time
}
```

*Outcome:* A basic User model representing your data.

---

### Step 2: Define a Query Interface with SQL Templates

Next, write an interface that declares method signatures paired with SQL queries or templates in the comments. Here is an example interface with type parameter and templated SQL:

```go
package examples

import ( 
    "time"
    "gorm.io/cli/gorm/examples/models"
)

type Query[T any] interface {
    // SELECT * FROM @@table WHERE id=@id
    GetByID(id int) (T, error)

    // SELECT * FROM @@table WHERE @@column=@value
    FilterWithColumn(column string, value string) (T, error)

    // SELECT * FROM @@table
    // {{where}}
    //   {{if !start.IsZero()}}
    //     created_at > @start
    //   {{end}}
    //   {{if !end.IsZero()}}
    //     AND created_at < @end
    //   {{end}}
    // {{end}}
    FilterWithTime(start, end time.Time) ([]T, error)
}
```

*Outcome:* An interface providing type-safe query methods annotated with SQL templates.

---

### Step 3: (Optional) Add a Generation Configuration

You can optionally customize generation with a `genconfig.Config` in the same package. For example, map Go types like `sql.NullTime` to a custom field helper.

```go
package examples

import (
    "database/sql"
    "gorm.io/cli/gorm/field"
    "gorm.io/cli/gorm/genconfig"
)

var _ = genconfig.Config{
    OutPath: "examples/output",
    FieldTypeMap: map[any]any{
        sql.NullTime{}: field.Time{},
    },
    FieldNameMap: map[string]any{
        "date": field.Time{},
        "json": JSON{}, // if you have defined JSON helper
    },
    // You can also filter included/excluded structs or interfaces here
}
```

*Outcome:* Customized generation behavior for your package.

---

### Step 4: Run the GORM CLI Generator

Run the code generator from your project root or appropriate directory:

```bash
gorm gen -i ./examples -o ./generated
```

- `-i` specifies the path to your Go interface file or directory containing your models and interfaces.
- `-o` is the output directory for the generated code.

*Expected Outcome:* Files generated with type-safe query APIs and field helpers in `./generated`.

---

### Step 5: Inspect the Generated Code

Open the generated files. You will find:

- Query API implementations implementing your interfaces with concrete SQL calls.
- Field helper structs for each model struct to build predicates (e.g., `generated.User.Name.Eq("alice")`).

Example snippet:

```go
var User = struct {
    ID     field.Number[uint]
    Name   field.String
    Email  field.String
    Age    field.Number[int]
    Status field.String
    CreatedAt field.Time
}{
    ID: field.Number[uint]{}.WithColumn("id"),
    Name: field.String{}.WithColumn("name"),
    // ...
}
```

---

### Step 6: Use Generated Helpers in Your Code

You can now perform database queries and operations with type safety and discoverability:

```go
// Use generated query interface
u, err := generated.Query[models.User](db).GetByID(ctx, 123)

// Use field helpers in GORM queries
users, err := gorm.G[models.User](db).
    Where(generated.User.Age.Gt(18)).
    Find(ctx)
```

*Outcome:* Fluent, compile-safe database operations.

---

## 4. Practical Tips and Best Practices

- **Use consistent package structure:** Place models, interfaces, and config files in logically separated packages or directories.
- **Map custom field types:** Leverage `genconfig.Config` to map `sql.NullTime` or your JSON types to appropriate helpers.
- **Filter generation selectively:** Use `IncludeInterfaces/IncludeStructs` in `genconfig.Config` to avoid generating unwanted code.
- **Leverage SQL template directives:** Utilize `@@table`, `{{where}}`, `{{set}}` and other DSL features in your interfaces for dynamic queries.
- **Keep generated files separate:** Use the `-o` flag to direct generated code to its own folder, preventing mix-up with source files.

## 5. Common Pitfalls and Troubleshooting

<AccordionGroup title="Troubleshooting Common Issues">
<Accordion title="No Files Generated After Running gen">
Ensure your input path (`-i` flag) correctly points to files containing interfaces or models. Confirm that any include/exclude filters in your config do not exclude all items.
</Accordion>
<Accordion title="Generated Code Fails to Compile">
Run `go fmt` and `go mod tidy`. Confirm your model and interface definitions are valid Go code. Check for any missing import dependencies for your mapped field types.
</Accordion>
<Accordion title="Generator Ignores Custom Field Mappings">
Verify your `genconfig.Config` is declared at the package level where the generator can detect it. Check that the types in your `FieldTypeMap` or `FieldNameMap` are correct and instantiate the correct field helper.
</Accordion>
<Accordion title="Error Parsing SQL Templates in Interfaces">
Confirm that your SQL comments conform to GORM CLIâ€™s DSL and parameter conventions. Avoid escaping `@` as `\@` except to quote literal `@`.
</Accordion>
</AccordionGroup>

## 6. What to Do Next

- Explore [Using Generated APIs](../core-workflows/using-generated-apis) for detailed usage patterns.
- Learn how to write [Template-Based SQL](../advanced-usage/writing-sql-templates) for complex queries.
- Understand advanced [Configuration Options](../advanced-usage/generation-configuration) to tailor generation.
- Review real-world [Association Handling](../core-workflows/working-with-associations) techniques.

---

## Appendix: Summary Mermaid Diagram of Workflow

```mermaid
flowchart TD
    A[Write Model Structs] --> B[Write Query Interfaces with SQL Templates]
    B --> C[Declare Optional genconfig.Config for Custom Mappings]
    C --> D[Run GORM CLI Generator (gorm gen)]
    D --> E[Inspect Generated Query APIs & Field Helpers]
    E --> F[Use Generated APIs in Your Application Code]
    F --> G[Perform Type-Safe Database Queries & Mutations]
```

---

For detailed exploration and advanced topics, consult the other guides and documentation referenced throughout this guide. Your journey to safe, efficient, and expressive GORM queries starts here!
