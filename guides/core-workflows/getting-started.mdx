---
title: "Getting Started: Your First Type-Safe API"
description: "Learn how to set up GORM CLI, define your first model and query interface, and generate type-safe query APIs. Walk through a simple example to reinforce understanding and ensure quick success."
---

# Getting Started: Your First Type-Safe API

Learn to set up GORM CLI by defining your initial model and query interface, then generate robust, type-safe query APIs through a practical example.

---

## 1. What You Will Achieve

This guide takes you through creating your very first type-safe API using GORM CLI. By following it, you will:

- Define a Go struct model representing a database table.
- Write a query interface with SQL templates embedded in method comments.
- Run the GORM CLI generator to auto-generate type-safe query code.
- Use the generated API to perform database queries with compile-time safety.

Estimated time: 15-20 minutes
Skill Level: Beginner

---

## 2. Prerequisites

Before you begin, ensure you have:

- Installed Go 1.18 or later
- Installed the GORM CLI package (`go install gorm.io/cli/gorm@latest`)
- A working GORM setup with your database connection ready
- Basic familiarity with Go interfaces, structs, and context
- A project directory where you can place your models and query interfaces

For installation details, see [Installation Guide](/getting-started/prerequisites-installation/installation-guide).

---

## 3. Step-by-Step Workflow

### Step 1: Define Your Model Struct

Create a Go file (e.g., `models/user.go`) and define a struct that maps your database table columns.

```go
package models

import "gorm.io/gorm"

// User represents a user record in the database
// The struct fields map to table columns.
type User struct {
  gorm.Model
  Name string
  Age  int
}
```

> This struct will be scanned by GORM CLI to generate type-safe field helpers.

### Step 2: Write a Query Interface with SQL Templates

Create another Go file (e.g., `query.go`) in the same package or directory. Define an interface with methods representing SQL queries and updates. Use comments to embed SQL templates.

```go
package models

// Query[T any] defines the queries for the User model
// Use SQL templates in comments to specify the query logic.
type Query[T any] interface {
  // SELECT * FROM @@table WHERE id=@id
  GetByID(id int) (T, error)

  // SELECT * FROM @@table WHERE name=@name AND age=@age
  FilterByNameAndAge(name string, age int) ([]T, error)

  // UPDATE @@table
  // {{set}}
  //   {{if user.Name != ""}} name=@user.Name, {{end}}
  //   {{if user.Age > 0}} age=@user.Age {{end}}
  // {{end}}
  // WHERE id=@id
  UpdateUser(user User, id int) error
}
```

> Notes:
> - `@@table` automatically resolves to the User table.
> - `@param` binds method parameters to SQL parameters.
> - SQL templates support conditional clauses with `{{if}}` and `{{set}}`.

### Step 3: Run GORM CLI Generator

Use the CLI to generate your query code. Run this command from your project root:

```bash
gorm gen -i ./models -o ./generated
```

- `-i` points to the directory containing your interfaces and models.
- `-o` specifies where to place the generated code (default is `./g`).

This process will:

- Parse your model structs and query interfaces.
- Generate type-safe query APIs named after your interfaces.
- Create model-driven field helpers for fluent querying and updating.

You will see output like:

```
Generating file generated/query.go from models/query.go...
```

### Step 4: Use the Generated Type-Safe APIs

Import the generated package and use the fluent, type-safe APIs.

```go
package main

import (
  "context"
  "fmt"
  "gorm.io/driver/sqlite"
  "gorm.io/gorm"
  "yourmodule/generated"
  "yourmodule/models"
)

func main() {
  db, err := gorm.Open(sqlite.Open("test.db"), &gorm.Config{})
  if err != nil {
    panic(err)
  }

  ctx := context.Background()

  // Use the generated Query API for User
  userQuery := generated.Query[models.User](db)

  // Query user by ID
  user, err := userQuery.GetByID(ctx, 1)
  if err != nil {
    fmt.Println("Error fetching user:", err)
    return
  }

  fmt.Println("User:", user)

  // Update user example
  err = userQuery.UpdateUser(ctx, models.User{Name: "Alice", Age: 30}, 1)
  if err != nil {
    fmt.Println("Error updating user:", err)
  }
}
```

This usage ensures compile-time safety of SQL queries and parameters.

---

## 4. Tips & Best Practices

- **Keep models and query interfaces close:** Place related interfaces and models in the same package or directory for seamless generation.
- **Use meaningful SQL templates:** Use placeholders like `@@table` and `@param` for flexibility and safety.
- **Leverage conditional templates:** Use `{{if}}`, `{{where}}`, and `{{set}}` to build dynamic queries.
- **Verify generated code:** Review generated files and test queries in your application.
- **Add context.Context explicitly or rely on auto-injection:** If your method does not take a context, the generator will add it automatically.
- **Use the generated field helpers for complex filters and updates:** They give more safety and readability.

---

## 5. Common Issues & Troubleshooting

<AccordionGroup title="Troubleshooting Common Problems">
<Accordion title="No Generated Files"
>
- Ensure your input path `-i` points to the directory containing Go files with interfaces and models.
- Verify your interface methods have proper SQL template comments.
- Check for compiler errors in your source files that block generation.
- Confirm you invoked `gorm gen` correctly.
</Accordion>
<Accordion title="SQL Template Parsing Errors">
- Carefully review SQL template syntax in comments.
- Avoid unsupported constructs; the DSL supports basic conditional, iteration, and placeholders.
- Check for missing or incorrect parameter names in your SQL templates.
</Accordion>
<Accordion title="Context Missing in Method Signature">
- The generator automatically adds a `ctx context.Context` parameter if itâ€™s missing.
- If you want explicit control, declare it in your interface methods.
</Accordion>
</AccordionGroup>

---

## 6. Next Steps

- Explore defining more advanced query interfaces with conditional logic.
- Learn how to customize generation using `genconfig.Config` ([Configuration & Extensibility](/overview/features-and-workflows/configuring-generation)).
- Use the generated APIs for association handling and batch operations.
- Review the example projects in the GORM CLI repository for real-world scenarios.

---

## 7. Additional Resources

- [Feature Overview](https://gorm.io/cli/gorm/overview/features-and-workflows/feature-overview)
- [Running the Generator](https://gorm.io/cli/gorm/getting-started/your-first-generation/running-the-generator)
- [Using Generated APIs](https://gorm.io/cli/gorm/getting-started/your-first-generation/using-generated-apis)
- [Template-Based SQL](https://gorm.io/cli/gorm/guides/advanced-patterns/template-based-sql)
- [Installation Guide](https://gorm.io/cli/gorm/getting-started/prerequisites-installation/installation-guide)

---

By completing these steps, you have mastered creating your first type-safe query API using GORM CLI, unlocking safer and more productive database operations in Go.

---