---
title: "Managing Associations and Relationships"
description: "Step-by-step coverage of association helpers, including creating, updating, unlinking, and deleting related records. Explains the distinctions between association types and demonstrates how to compose operations in common real-world scenarios."
---

# Managing Associations and Relationships

Manage associated records effectively with GORM CLI's generated association helpers. This guide walks you through creating, updating, unlinking, and deleting related records while clarifying distinctions between association types like `has one`, `has many`, `belongs to`, `many to many`, and polymorphic associations. You'll learn how to compose these operations naturally in your Go code to reflect real-world relationship workflows.

---

## Workflow Overview

- **What You'll Achieve:** Confidently manage and modify associated records using GORM CLI-generated association helpers, including creating new related rows, updating linked records conditionally, unlinking associations without deletion, and deleting related data as needed.
- **Prerequisites:**
  - Familiarity with GORM ORM basics and your Go models defining associations.
  - Successful GORM CLI code generation producing model-driven association helpers.
  - Basic knowledge of Go generics and context usage.
- **Expected Outcome:**
  - Write clean, type-safe code to manage various association types.
  - Understand precise operations and side effects for each association method.
  - Avoid common pitfalls such as unintended deletions or broken links.
- **Estimated Time:** 15–25 minutes
- **Difficulty:** Intermediate

---

## Understanding Association Types

GORM CLI generates association helpers accessible as `field.Struct[T]` for single associations and `field.Slice[T]` for multiple associations on your generated model helpers. Each corresponds to your GORM struct definitions.

| Association Type  | Cardinality   | Helper Type          | Typical FK Location  |
|-------------------|---------------|---------------------|---------------------|
| Has One           | One-to-One    | `Struct[T]`          | FK in child         |
| Belongs To        | One-to-One    | `Struct[T]`          | FK in parent        |
| Has Many          | One-to-Many   | `Slice[T]`           | FK in child         |
| Many to Many      | Many-to-Many  | `Slice[T]`           | Join table           |
| Polymorphic       | Varies        | `Struct[T]` or `Slice[T]` | FK with OwnerType  |

---

## Step-by-Step Instructions

### 1. Creating Associated Records

Create operations insert new associated rows and link them to matched parent records.

- Use `.Create(assignments...)` for single associations (`has one`, `belongs to`).
- Use `.Create(assignments...)` to create one associated record per matched parent in batch.
- Use `.CreateInBatch(records)` to batch-create multiple associated records per matched parent for `has many` or `many2many`.

**Example: Create one pet when creating a user:**

```go
gorm.G[models.User](db).
  Set(
    generated.User.Name.Set("alice"),
    generated.User.Pets.Create(
      generated.Pet.Name.Set("fido"),
    ),
  ).
  Create(ctx)
```

**Create multiple languages (many2many) when creating a user:**

```go
gorm.G[models.User](db).
  Set(
    generated.User.Name.Set("polyglot"),
    generated.User.Languages.CreateInBatch([]models.Language{{Code: "EN"}, {Code: "FR"}}),
  ).
  Create(ctx)
```

### 2. Updating Associated Records

Update operations modify existing associated rows matching optional conditions.

- Use `.Update(assignments...)` with optional `.Where(...)` to target specific associated records.
- Run with `.Set(...).Update(ctx)` on the parent query.

**Update pet name conditionally:**

```go
gorm.G[models.User](db).
  Where(generated.User.ID.Eq(1)).
  Set(
    generated.User.Pets.Where(generated.Pet.Name.Eq("fido")).
      Update(generated.Pet.Name.Set("rex")),
  ).
  Update(ctx)
```

### 3. Unlinking Associations

Unlink operations remove the association link but retain the associated records.

**Semantics:**
- `belongs to`: sets foreign key in parent to `NULL`.
- `has one` / `has many`: sets foreign key in child to `NULL`.
- `many2many`: deletes rows in the join table but keeps related entities.

**Example: Unlink all pets from user:**

```go
gorm.G[models.User](db).
  Where(generated.User.ID.Eq(1)).
  Set(generated.User.Pets.Unlink()).
  Update(ctx)
```

### 4. Deleting Associated Records

Delete operations remove the associated records themselves.

- For `many2many`, this deletes only the join rows, not the related entities.
- Use with optional conditions via `.Where(...)`.

**Example: Delete pets named 'old' for a user:**

```go
gorm.G[models.User](db).
  Where(generated.User.ID.Eq(1)).
  Set(
    generated.User.Pets.Where(generated.Pet.Name.Eq("old")).Delete(),
  ).
  Update(ctx)
```

### 5. Composing Multiple Association Operations

You can combine multiple association operations in the `.Set(...)` call to perform complex updates in one database operation.

**Example: Create a new pet and unlink all toys:**

```go
gorm.G[models.User](db).
  Where(generated.User.ID.Eq(1)).
  Set(
    generated.User.Pets.Create(generated.Pet.Name.Set("buddy")),
    generated.User.Toys.Unlink(),
  ).
  Update(ctx)
```

### 6. Key Notes on Parent Side Operations

- `.Create(ctx)` on parent inserts new parent rows then performs associated creates.
- `.Update(ctx)` on parent updates selected parents then performs associated updates/unlinks/deletes.

---

## Practical Examples

```go
// Create a user with one pet and multiple languages
err := gorm.G[models.User](db).
  Set(
    generated.User.Name.Set("charlie"),
    generated.User.Pets.Create(generated.Pet.Name.Set("max")),
    generated.User.Languages.CreateInBatch([]models.Language{{Code: "DE"}, {Code: "ES"}}),
  ).
  Create(ctx)

// Update a user's company name (belongs to association)
_, err = gorm.G[models.User](db).
  Where(generated.User.ID.Eq(42)).
  Set(
    generated.User.Company.Where(generated.Company.Name.Eq("Acme")).
      Update(generated.Company.Name.Set("Acme Corp")),
  ).
  Update(ctx)

// Unlink user's manager (belongs to single-table)
_, err = gorm.G[models.User](db).
  Where(generated.User.ID.Eq(10)).
  Set(generated.User.Manager.Unlink()).
  Update(ctx)

// Delete a specific friend from user's friends (many2many single-table)
_, err = gorm.G[models.User](db).
  Where(generated.User.ID.Eq(userID)).
  Set(generated.User.Friends.Where(generated.User.Name.Eq("mike")).Delete()).
  Update(ctx)

// Batch link pets to a user
pets := []models.Pet{{Name: "pet1"}, {Name: "pet2"}}
_, err = gorm.G[models.User](db).
  Where(generated.User.ID.Eq(userID)).
  Set(generated.User.Pets.CreateInBatch(pets)).
  Update(ctx)
```

---

## Troubleshooting & Tips

- **Unintended deletes:** Verify that `.Delete()` is only used when you intend to remove data; use `.Unlink()` to remove associations without deleting records.
- **Foreign key nil after unlink:** This behavior is expected; unlinking sets FK to `NULL` rather than deleting the record.
- **Batch creates for large slices:** Use `.CreateInBatch()` for efficient insertion of multiple related records.
- **Polymorphic associations:** Ensure the polymorphic `OwnerType` and `OwnerID` are correctly set by GORM CLI association helpers; unlinking zeroes these fields but keeps records.
- **Association conditions:** Use `.Where(...)` on association helpers to target a subset of related records precisely.
- **Check errors:** Always check `error` results to catch any constraint or relational integrity issues.

---

## Next Steps & Related Content

- After mastering association management, explore **[Type-Safe Queries with Interfaces](/guides/core-workflows/type-safe-queries)** to extend your querying capabilities.
- For complex scenarios, see how to **[Customize Code Generation with Config](/guides/advanced-usage/customizing-generation)** to tailor helpers.
- Review **[Using the Generated Code](/getting-started/initial-usage/use-generated-code)** for syntax and usage patterns combining queries and associations.

---

This guide empowers you to harness GORM CLI’s association helpers fully, ensuring clean, maintainable, type-safe relationship management within your Go and GORM applications.
