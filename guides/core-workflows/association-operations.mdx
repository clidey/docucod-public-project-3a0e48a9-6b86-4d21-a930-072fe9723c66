---
title: "Managing Associations with Helpers"
description: "Work with related data by managing has-one, has-many, belongs-to, and many2many associations using generated helpers. Covers create, update, unlink, and delete operations with real-world mapping to GORM behavior."
---

# Managing Associations with Helpers

Efficiently managing related data through associations is crucial when working with GORM models. This guide focuses exclusively on how to leverage the **generated association helpers** for `has-one`, `has-many`, `belongs-to`, and `many2many` relationships. You'll learn how to perform create, update, unlink, and delete operations on related records in a way that mirrors GORM's semantics—but with type safety and fluent APIs.

---

## 1. Workflow Overview

### What This Guide Helps You Accomplish
- Understand the generated association helpers on your model structs.
- Perform safe and fluent CRUD operations on associated data.
- Apply conditions to association operations.
- Handle different association types according to their semantics.

### Prerequisites
- You have generated your models and field helpers using GORM CLI.
- Familiarity with GORM associations and basic CRUD operations.
- A Go project setup with GORM and generated code integrated.

### Expected Outcome
By following this guide, you will confidently manage associated records through the generated helpers—creating associated records along with parents, updating related entities with conditions, unlinking associations without deleting data, and deleting associated rows as needed.

### Time Estimate
15–30 minutes to understand and implement the core association operations.

### Difficulty Level
Intermediate — assumes you understand basic GORM concepts and Go generics.

---

## 2. How Association Helpers Work

Every association on your model struct, whether single (`has one`, `belongs to`) or multiple (`has many`, `many2many`), is represented by a generated helper of type:

- `field.Struct[T]` for single relations
- `field.Slice[T]` for multi-relations

These helpers provide methods for the following operations:

| Operation    | Purpose                                           | Usage Pattern                             |
|--------------|---------------------------------------------------|------------------------------------------|
| `Create`     | Create and link a new associated record           | `Set(Helper.Create(assignments...))`    |
| `CreateInBatch` | Batch create/link multiple associated records  | `Set(Helper.CreateInBatch(records))`     |
| `Update`     | Update associated records with optional filtering | `Set(Helper.Where(condition).Update(assignments...))` |
| `Unlink`     | Remove association link but keep records          | `Set(Helper.Where(condition).Unlink())`  |
| `Delete`     | Remove associated records (or join rows for m2m) | `Set(Helper.Where(condition).Delete())`  |

These operations are used in combination with `Set(...)` chained to `Create(ctx)` or `Update(ctx)`, controlling the parent record's lifecycle along with its associations.


## 3. Step-by-Step Instructions

### 3.1 Creating Associations

- **Goal**: Create a parent record along with associated children or linked records.

```go
// Creates a new user with a single pet
gorm.G[User](db).
  Set(
    generated.User.Name.Set("alice"),
    generated.User.Pets.Create(generated.Pet.Name.Set("fido")),
  ).
  Create(ctx)
```

- **Batch Create**: For multiple associated records, use `CreateInBatch`.

```go
// Link multiple languages to a user
gorm.G[User](db).
  Set(
    generated.User.Name.Set("polyglot"),
    generated.User.Languages.CreateInBatch([]models.Language{{Code: "EN"}, {Code: "FR"}}),
  ).
  Create(ctx)
```

- **Create for multiple matched parents**: Use an update with a filter to create one or more associated records per existing matched parent.

```go
// For users with ID in 1 or 2, create a pet named 'multi-pet'
gorm.G[User](db).
  Where(generated.User.ID.In(1, 2)).
  Set(
    generated.User.Pets.Create(generated.Pet.Name.Set("multi-pet")),
  ).
  Update(ctx)
```

### Expected Result
- New associated records are created and linked based on foreign key or join tables.

---

### 3.2 Updating Associations with Conditions

- Apply conditions to narrow down which associated records to update.

```go
// Update pet name of a user's pet where name is 'old'
gorm.G[User](db).
  Where(generated.User.ID.Eq(1)).
  Set(
    generated.User.Pets.Where(generated.Pet.Name.Eq("old")).Update(generated.Pet.Name.Set("new")),
  ).
  Update(ctx)
```

- Conditions help target only specific associated records without affecting others.

### Expected Result
- Only associated rows matching the condition are updated.

---

### 3.3 Unlinking Associations

- Unlink removes the association but **does not delete** the associated records.
- Semantics vary by association type:
  - *belongs to*: Parent foreign key set to `NULL`.
  - *has one/has many*: Child foreign key set to `NULL`.
  - *many2many*: Join table rows deleted only.

```go
// Unlink all pets from user with ID=1
gorm.G[User](db).
  Where(generated.User.ID.Eq(1)).
  Set(generated.User.Pets.Unlink()).
  Update(ctx)
```

- Adding conditions limits unlink to specified associated rows.

### Expected Result
- Association is cleared but records are preserved.

---

### 3.4 Deleting Associations

- Deletes associated rows or join table rows as per type.
- Join rows removed but target entity remains for many2many.

```go
// Delete pet named 'a' for user 1
gorm.G[User](db).
  Where(generated.User.ID.Eq(1)).
  Set(generated.User.Pets.Where(generated.Pet.Name.Eq("a")).Delete()).
  Update(ctx)
```

### Expected Result
- Associated records matching conditions are deleted from DB.

---

## 4. Examples & Common Usage Patterns

### 4.1 Has One Association (User -> Account)

```go
// Create user with account
gorm.G[User](db).
  Set(
    generated.User.Name.Set("user1"),
    generated.User.Account.Create(generated.Account.Number.Set("A-001")),
  ).
  Create(ctx)

// Update account where number equals 'A-001'
gorm.G[User](db).
  Where(generated.User.ID.Eq(1)).
  Set(
    generated.User.Account.Where(generated.Account.Number.Eq("A-001")).Update(
      generated.Account.Number.Set("A-002"),
    ),
  ).
  Update(ctx)

// Unlink account (set UserID foreign key NULL)
gorm.G[User](db).
  Where(generated.User.ID.Eq(1)).
  Set(generated.User.Account.Unlink()).
  Update(ctx)

// Delete account
gorm.G[User](db).
  Where(generated.User.ID.Eq(1)).
  Set(generated.User.Account.Delete()).
  Update(ctx)
```

### 4.2 Belongs To Association (User -> Company)

```go
// Update company name for user's company
gorm.G[User](db).
  Where(generated.User.ID.Eq(1)).
  Set(
    generated.User.Company.Where(generated.Company.Name.Eq("Acme")).Update(generated.Company.Name.Set("NewCo")),
  ).
  Update(ctx)

// Unlink company (set CompanyID column NULL)
gorm.G[User](db).
  Where(generated.User.ID.Eq(1)).
  Set(generated.User.Company.Unlink()).
  Update(ctx)
```

### 4.3 Has Many Association (User -> Pets)

```go
// Create one pet for each matched user
gorm.G[User](db).
  Where(generated.User.ID.Eq(1)).
  Set(
    generated.User.Pets.Create(generated.Pet.Name.Set("fido")),
  ).
  Update(ctx)

// Unlink all pets from user
gorm.G[User](db).
  Where(generated.User.ID.Eq(1)).
  Set(generated.User.Pets.Unlink()).
  Update(ctx)

// Delete a pet named "a"
gorm.G[User](db).
  Where(generated.User.ID.Eq(1)).
  Set(generated.User.Pets.Where(generated.Pet.Name.Eq("a")).Delete()).
  Update(ctx)
```

### 4.4 Many2Many Association (User -> Languages)

```go
// Create and link a language record
gorm.G[User](db).
  Where(generated.User.ID.Eq(1)).
  Set(
    generated.User.Languages.Create(
      generated.Language.Code.Set("EN"),
      generated.Language.Name.Set("English"),
    ),
  ).
  Update(ctx)

// Unlink language association (removes join rows only)
gorm.G[User](db).
  Where(generated.User.ID.Eq(1)).
  Set(generated.User.Languages.Where(generated.Language.Code.Eq("EN")).Unlink()).
  Update(ctx)

// Delete the join rows (language record remains)
gorm.G[User](db).
  Where(generated.User.ID.Eq(1)).
  Set(generated.User.Languages.Where(generated.Language.Code.Eq("EN")).Delete()).
  Update(ctx)
```

### 4.5 Polymorphic Associations (Pet -> Toy)

```go
// Update pet's toy name
gorm.G[Pet](db).
  Where(generated.Pet.ID.Eq(petID)).
  Set(generated.Pet.Toy.Where(generated.Toy.Name.Eq("ball")).Update(generated.Toy.Name.Set("cube"))).
  Update(ctx)

// Unlink toy (set foreign keys in Toy to zero-values, record remains)
gorm.G[Pet](db).
  Where(generated.Pet.ID.Eq(petID)).
  Set(generated.Pet.Toy.Unlink()).
  Update(ctx)

// Delete toy
gorm.G[Pet](db).
  Where(generated.Pet.ID.Eq(petID)).
  Set(generated.Pet.Toy.Delete()).
  Update(ctx)
```

---

## 5. Troubleshooting & Best Practices

### Common Issues

- **Association not created or linked:** Ensure you use `Set(...).Create(ctx)` or `Set(...).Update(ctx)` properly; just calling `Create` or `Update` on main doesn't trigger associations unless included.
- **Unlink not clearing foreign keys:** Confirm association types and semantics; unlink on `belongs to` clears parent's FK, on `has many` clears child's FK.
- **Batch creation failures:** `CreateInBatch` requires slice input; ensure records are properly initialized and relevant parent records matched.
- **Filtering associations:** Use `Where` with strongly typed predicates to avoid incorrect updates/deletes.

### Best Practices

- Always use the generated helpers from your model to maintain type safety.
- Prefer conditions inside `.Where()` to target subgroups in associations.
- Use `Unlink()` when you want to keep associated records but remove links.
- Use `Delete()` cautiously; it removes data, not just links.
- For polymorphic associations, understand owner type and keys in use.

### Performance Considerations

- Batch creating associations improves speed compared to looping single creates.
- Minimize updates by filtering associations precisely.

### Alternative Approaches

- Combine association operations with parent updates in one fluent call.
- Use Raw SQL or GORM associations if you need functionality beyond generated helpers, but lose type safety.

---

## 6. Additional Resources and Next Steps

- [Using Field Helpers for Filters & Updates](/guides/core-workflows/using-field-helpers) — learn filtering basics and setters.
- [Writing Type-Safe Queries from Interfaces](/guides/core-workflows/writing-type-safe-queries) — see how to generate query APIs.
- [Template DSL for Dynamic Queries](/guides/advanced-usage-patterns/template-dsl) — take your queries further with dynamic templates.
- [Integration with GORM and Go Projects](/overview/architecture-concepts/integration-overview) — learn full project integration steps.

---

Harnessing GORM CLI's generated association helpers empowers you with a fluent, type-safe way to manage complex related data, while following GORM conventions exactly. Start managing your associations confidently and see immediate improvements in code clarity and reliability.


---