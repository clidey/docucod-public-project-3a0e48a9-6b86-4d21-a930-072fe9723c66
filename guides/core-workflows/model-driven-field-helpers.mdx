---
title: "Model-Driven Field Helpers and Updates"
description: "A comprehensive guide to leveraging field helpers generated from your models for building filters, updates, associations, and predicates. Discover practical patterns for common CRUD operations and understand the value of compile-time safety in daily application development."
---

# Model-Driven Field Helpers and Updates

Unlock the full power of GORM CLI's field helpers generated from your Go model structs. This guide walks you through using these helpers to build precise query filters, perform safe updates, manage associations, and craft expressive predicates—all while benefiting from compile-time type safety and intuitive APIs.

---

## Workflow Overview

### Objective
Learn how to leverage the model-driven field helpers generated by GORM CLI to efficiently build SQL filters, perform updates with zero-values or expressions, and manage complex associations within your Go application.

### Prerequisites
- Your project must have Go 1.18+ with generics enabled.
- Use GORM as the ORM layer.
- Run GORM CLI to generate field helpers from your model structs (see [Generating Code](../getting-started/first-steps/generating-code)).
- Basic familiarity with generated code structure (check [Core Concepts & Terminology](../overview/concepts-architecture/core-concepts-terminology)).

### Expected Outcome
By the end of this guide, you will be able to:
- Construct type-safe query predicates for filtering data.
- Perform bulk and fine-grained updates using zero-values, SQL expressions, and assigners.
- Create and manipulate related entities using association helpers.
- Execute common CRUD operations with confidence in compile-time validation.

### Time Estimate
You can get started with basic filtering and updating in 10-20 minutes. Mastering association helpers and complex predicates will take additional experimentation and practice.

### Difficulty Level
Intermediate – assumes familiarity with Go, GORM, and basic ORM concepts.

---

## Step-by-Step Instructions

### 1. Using Basic Field Helpers to Build Filters

Each model field generates a typed helper such as `field.String`, `field.Number[int]`, or `field.Bool`.

#### Actions
- Use predicate methods like `.Eq()`, `.Gt()`, `.Like()`, `.Between()` for filtering.
- Combine multiple predicates in `.Where()` calls to build complex conditions.

#### Example
```go
users, err := gorm.G[models.User](db).
  Where(
    generated.User.Age.Gt(18),
    generated.User.Role.Eq("active"),
  ).
  Find(ctx)
```

#### Expected Result
Returns users older than 18 with role 'active'.

---

### 2. Updating Records with Set Assignments

You can update records using `.Set(...)` with field helpers that safely assign zero-values or expressions.

#### Actions
- Use `.Set(value)` to assign a specific value.
- Use `.SetExpr(clause.Expr{...})` to assign using SQL expressions.
- Increment values with `.Incr(n)`.
- Use assigners like `.Upper()` for string transformations.

#### Example
```go
// Flip role from 'pending' to 'active' for users
_, err := gorm.G[models.User](db).
  Where(generated.User.Role.Eq("pending")).
  Set(generated.User.Role.Set("active")).
  Update(ctx)
```

```go
// Increment Bob's age by 3
_, err := gorm.G[models.User](db).
  Where(generated.User.Name.Eq("bob")).
  Set(generated.User.Age.Incr(3)).
  Update(ctx)
```

#### Expected Result
Rows matching the condition are updated safely, including zero-values and complex expressions.

---

### 3. Creating Records Using Set

You can create new rows by providing field values with `.Set(...)` before calling `.Create(ctx)`.

#### Example
```go
err := gorm.G[models.User](db).
  Set(
    generated.User.Name.Set("alice"),
    generated.User.Age.Set(29),
    generated.User.Role.Set("active"),
    generated.User.IsAdult.Set(true),
  ).
  Create(ctx)
```

#### Expected Result
A new user row is inserted with the specified field values.

---

### 4. Working with Associations

Associations are available as structured helpers like `field.Struct[T]` for one-to-one and `field.Slice[T]` for one-to-many or many-to-many.

Supported operations:
- `.Create()` – create and link related rows.
- `.CreateInBatch([]T)` – batch create and link multiple related rows.
- `.Update()` – update associated rows.
- `.Unlink()` – remove links without deleting rows.
- `.Delete()` – delete associated rows.

#### Examples
```go
// Create a user with a pet
err := gorm.G[models.User](db).
  Set(
    generated.User.Name.Set("alice"),
    generated.User.Pets.Create(generated.Pet.Name.Set("fido")),
  ).
  Create(ctx)
```

```go
// Unlink all pets from user with ID 1
_, err := gorm.G[models.User](db).
  Where(generated.User.ID.Eq(1)).
  Set(generated.User.Pets.Unlink()).
  Update(ctx)
```

#### Expected Result
Creates or modifies parent and associated child records atomically and type-safely.

---

### 5. Combining Filters with Updates and Associations

Build rich workflows by chaining filters and set-assignments for parent and related entities together.

#### Example
```go
// Update user's pets where pet name is 'fido'
gorm.G[models.User](db).
  Where(generated.User.ID.Eq(1)).
  Set(
    generated.User.Pets.Where(generated.Pet.Name.Eq("fido")).Update(generated.Pet.Name.Set("rex")),
  ).
  Update(ctx)
```

#### Expected Result
Only 'fido' pets of user 1 get renamed 'rex'.

---

## Examples & Code Samples

### Basic Filtering
```go
// Find users over 18 with role 'active'
users, err := gorm.G[models.User](db).
  Where(generated.User.Age.Gt(18), generated.User.Role.Eq("active")).
  Find(ctx)
```

### Update Zero Values
```go
// Explicitly set age 0 and role to empty string
rows, err := gorm.G[models.User](db).
  Where(generated.User.Name.Eq("alice")).
  Set(
    generated.User.Age.Set(0),
    generated.User.Role.Set("")
  ).
  Update(ctx)
```

### Increment an Integer Field
```go
// Increment age by 1
rows, err := gorm.G[models.User](db).
  Where(generated.User.Name.Eq("bob")).
  Set(generated.User.Age.Incr(1)).
  Update(ctx)
```

### Create with Associations
```go
err := gorm.G[models.User](db).
  Set(
    generated.User.Name.Set("polyglot"),
    generated.User.Languages.CreateInBatch([]models.Language{{Code: "EN"}, {Code: "FR"}}),
  ).
  Create(ctx)
```

## Troubleshooting & Tips

<AccordionGroup title="Common Issues & Solutions">
  <Accordion title="No Field Helpers Generated for Model">
    Ensure you have run the generator with the correct input path including your model packages.
    Also, verify your model structs are exported and placed within the target source directory.
    See [Generating Code](../getting-started/first-steps/generating-code).
  </Accordion>
  <Accordion title="Update Not Applying Zero Values">
    Use `.Set()` helpers from generated fields explicitly to assign zero-values like `0`, `false`, or empty string.
    Avoid relying on GORM’s default omission of zero-values, which can skip fields.
  </Accordion>
  <Accordion title="Association Helpers Not Working as Expected">
    Check that your GORM model tags on associations are correct (e.g., polymorphic, foreign keys).
    Generated code depends on model definitions.
    For polymorphic associations, verify `gorm:"polymorphic:Owner"` or related tags exist.
  </Accordion>
  <Accordion title="SQL Expressions Not Executing Correctly">
    Use `.SetExpr(clause.Expr{SQL: ..., Vars: [...]})` to include raw SQL safely.
    Avoid interpolating strings directly to prevent injection and syntax errors.
  </Accordion>
</AccordionGroup>

<Tip>
  To optimize performance, chain multiple filter predicates in a single `.Where()` call rather than multiple `.Where()` calls.
</Tip>

{/* Optional diagram could be placed here illustrating field helper usage if needed */}

---

## Next Steps & Related Content

- Deepen your knowledge of associations management in [Working with Associations](/guides/advanced-patterns/working-with-associations).
- Explore custom generation and field mapping customization in [Customizing Generation: genconfig and Field Mapping](/guides/advanced-patterns/customizing-generation).
- Use SQL template DSL to write powerful query interfaces in [SQL Template DSL: Power and Flexibility](/guides/advanced-patterns/template-sql-dsl).
- Validate your code with hands-on exercises in [Quick Validation](../getting-started/first-steps/quick-validation).
- Reference the [Core Concepts & Terminology](../overview/concepts-architecture/core-concepts-terminology) to understand how field helpers fit in the bigger picture.

---

<Check>
  Using model-driven field helpers ensures compile-time safety and discovery, helps you avoid SQL injection risks, and drastically improves developer experience by providing a fluent API for query building and updates.
</Check>

---

For detailed usage patterns and tested examples, consult the generated test files such as `models_field_helpers_test.go` in your output directory to see real-world, validated usage scenarios.

---