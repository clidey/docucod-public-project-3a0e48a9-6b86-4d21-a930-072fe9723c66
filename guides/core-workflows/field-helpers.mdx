---
title: "Using Model-Driven Field Helpers"
description: "Explore how field helpers are generated from models for filters, updates, and associations. This guide demonstrates predicates, setters, and the update/create workflow for effortless and safe data manipulation."
---

# Using Model-Driven Field Helpers

Explore how field helpers are generated from models for filters, updates, and associations. This guide demonstrates predicates, setters, and the update/create workflow for effortless and safe data manipulation.

---

## Workflow Overview

### Task Description
This guide helps you understand and effectively use model-driven field helpers generated by GORM CLI. These helpers enable you to build type-safe, fluent predicates for filtering and condition-building, update or create database records with zero-value handling, and manipulate associated records effortlessly.

### Prerequisites
- You have run the GORM CLI code generator on your Go models to produce the generated field helpers.
- You’re familiar with GORM basics and have a working Go environment with GORM and GORM CLI installed.

### Expected Outcome
By following this guide, you will be able to:
- Use generated predicates to build precise WHERE clauses with compile-time safety.
- Use setters and expressions to perform safe updates and creates, including zero value and complex operations.
- Manage associations such as has many, belongs to, and many2many using generated association helpers.

### Time Estimate
Approximately 15–30 minutes to become comfortable with practical usage.

### Difficulty Level
Beginner to Intermediate (no advanced Go metaprogramming required).

---

## Step-by-Step Instructions

### 1. Understanding Basic Field Helpers

When you generate code from your models, each field in the model struct gets a corresponding strongly typed helper with predicates and setters. These helpers express SQL conditions fluently and safely.

#### Common Predicate Methods
- `Eq(value)`: Equals
- `Neq(value)`: Not equals
- `Gt(value)`: Greater than
- `Gte(value)`: Greater than or equal
- `Lt(value)`: Less than
- `Lte(value)`: Less than or equal
- `Between(low, high)`: Between two values
- `Like(pattern)`: SQL LIKE
- `IsNull()`: IS NULL check
- `IsNotNull()`: IS NOT NULL check

#### Example Usage
```go
// Find users with age between 18 and 65
users, err := gorm.G[User](db).
    Where(generated.User.Age.Between(18, 65)).
    Find(ctx)
```

#### Verification
- Query should build and run without errors.
- Results match the filter criteria.

### 2. Using Setters for Updates and Creates

Setters allow you to specify field assignments during update or create operations in a typesafe manner.

#### Common Setter Methods
- `.Set(value)`: Sets the field to a value, including zero values (e.g., empty string, 0, false).
- `.Incr(amount)`: Increments a numeric field by a given amount.
- `.SetExpr(expr)`: Sets a field with a raw SQL expression.

#### Update Example
```go
// Increment age by 1 for user named "bob"
rowsUpdated, err := gorm.G[User](db).
    Where(generated.User.Name.Eq("bob")).
    Set(
        generated.User.Age.Incr(1),
    ).
    Update(ctx)
```

#### Create Example
```go
// Create a user with specific fields
err := gorm.G[User](db).
    Set(
        generated.User.Name.Set("alice"),
        generated.User.Age.Set(30),
        generated.User.IsAdult.Set(true),
    ).
    Create(ctx)
```

#### Verification
- Operations should succeed without errors.
- Database records reflect updates or creations with the correct values.

### 3. Handling Zero Values and Nullable Types

Field helpers handle zero values explicitly, so setting a field to an empty string, zero int, false, or a NULL value (e.g., `sql.NullInt64{}`) is explicit and respected when updating or creating.

#### Example
```go
// Set zero and NULL values explicitly
rows, err := gorm.G[User](db).
    Where(generated.User.Name.Eq("cathy")).
    Set(
        generated.User.Role.Set(""),                // zero string
        generated.User.IsAdult.Set(false),            // zero bool
        generated.User.Score.Set(sql.NullInt64{}),    // NULL value
        generated.User.Age.SetExpr(clause.Expr{SQL: "age + ?", Vars: []any{2}}), // SQL expression
    ).
    Update(ctx)
```

### 4. Working with Associations

GORM CLI generates association helpers for model relations:
- **`field.Struct[T]`** for has one / belongs to
- **`field.Slice[T]`** for has many / many2many

#### Supported Association Operations
- **Create**: Create new related records and link them
- **CreateInBatch**: Batch create multiple related records
- **Update**: Update existing associated records matching conditions
- **Unlink**: Remove link without deleting related rows
- **Delete**: Delete associated rows (join rows for many2many)

#### Usage Examples
```go
// Create a new user and one pet
gorm.G[User](db).
  Set(
    generated.User.Name.Set("alice"),
    generated.User.Pets.Create(generated.Pet.Name.Set("fido")),
  ).
  Create(ctx)

// Update a user's pet by name
gorm.G[User](db).
  Where(generated.User.ID.Eq(1)).
  Set(
    generated.User.Pets.Where(generated.Pet.Name.Eq("fido")).
      Update(generated.Pet.Name.Set("rex")),
  ).
  Update(ctx)

// Unlink all pets from a user
gorm.G[User](db).
  Where(generated.User.ID.Eq(1)).
  Set(generated.User.Pets.Unlink()).
  Update(ctx)

// Delete pets named "old"
gorm.G[User](db).
  Where(generated.User.ID.Eq(1)).
  Set(generated.User.Pets.Where(generated.Pet.Name.Eq("old")).Delete()).
  Update(ctx)
```

---

## Examples & Code Samples

### Using Predicates for Queries
```go
// Find users with role "active" and age greater than 18
users, err := gorm.G[User](db).
    Where(generated.User.Role.Eq("active"), generated.User.Age.Gt(18)).
    Find(ctx)
```

### Update with Setter Helpers
```go
_, err := gorm.G[User](db).
    Where(generated.User.Name.Eq("bob")).
    Set(
        generated.User.Age.Incr(1),
    ).
    Update(ctx)
```

### Create with Setter Helpers
```go
err := gorm.G[User](db).
    Set(
        generated.User.Name.Set("newuser"),
        generated.User.Age.Set(22),
    ).
    Create(ctx)
```

### Association Create
```go
gorm.G[User](db).
    Set(
        generated.User.Name.Set("owner"),
        generated.User.Pets.Create(generated.Pet.Name.Set("fluffy")),
    ).
    Create(ctx)
```

### Association Update
```go
gorm.G[User](db).
    Where(generated.User.ID.Eq(1)).
    Set(
        generated.User.Pets.Where(generated.Pet.Name.Eq("fluffy")).
          Update(generated.Pet.Name.Set("fluff")),
    ).
    Update(ctx)
```

### Association Unlink & Delete
```go
gorm.G[User](db).
    Where(generated.User.ID.Eq(1)).
    Set(generated.User.Pets.Unlink()).
    Update(ctx)

// or delete pets named 'old'
gorm.G[User](db).
    Where(generated.User.ID.Eq(1)).
    Set(generated.User.Pets.Where(generated.Pet.Name.Eq("old")).Delete()).
    Update(ctx)
```

---

## Troubleshooting & Tips

### Common Issues
- **Updates Not Affecting Records**: Verify the `Where` clause uses generated predicates matching the intended rows.
- **Zero or Null Values Not Set Correctly**: Always use the `.Set()` method on the field helper to explicitly assign zero or NULL values.
- **Associations Not Created/Linked**: Confirm your models’ association tags are correct and that you use the dedicated association methods like `.Create()` or `.CreateInBatch()`.
- **Method Not Found on Field Helper**: Confirm you have run `gorm gen` after any model changes and are importing the correct generated package.

### Best Practices
- Always use the generated field helpers to build predicates and setters for maximum type safety.
- Use `.SetExpr()` or `.Incr()` for advanced update patterns instead of raw SQL strings.
- Use association helpers for managing related records to avoid manual FK handling.
- When batch creating associations, prefer `.CreateInBatch()` to generate efficient bulk inserts.

### Performance Considerations
- Filtering with field helpers composes efficient SQL with placeholders.
- Batch operations reduce the number of database calls.
- Avoid excessive nested association updates in a single call to maintain transaction clarity.

### Alternative Approaches
- For complex queries beyond field helpers, combine generated predicates with manual GORM conditions.
- Use Template-based Queries (see related documentation) for advanced, customized SQL.

---

## Next Steps & Related Content

- **[Building Type-Safe Queries with Interfaces](/guides/core-workflows/type-safe-queries)**: Learn how to write query interfaces and generate complex query APIs.
- **[Working with Associations](/guides/advanced-patterns/working-with-associations)**: Deeper dive into managing complex association operations.
- **[Configuring the Generator](/getting-started/configuration/generator-configuration)**: Customize field helper generation for your models.
- **[Validating Your Generated APIs](/getting-started/validation/validating-generated-code)**: Test and confirm your generated field helpers work as expected.

---

For comprehensive onboarding, ensure your environment is ready by reviewing the [Installation & Setup](/overview/integration-getting-started/installation-setup) and follow the [Quickstart Workflow](/overview/integration-getting-started/quickstart-workflow) to generate initial code.

Use this guide to master model-driven field helpers and build safe, maintainable data operations efficiently.
