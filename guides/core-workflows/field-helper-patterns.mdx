---
title: "Model-Driven Field Helpers in Practice"
description: "Detailed guide to using generated field helpers for filtering, updates, and ordering. Includes practical examples for predicates, setters, and chaining, empowering you to express business logic clearly and safely in your queries."
---

# Model-Driven Field Helpers in Practice

Harness the power of GORM CLI's model-driven field helpers to create clear, safe, and fluent database queries and updates. This guide takes you through practical examples of using generated field helpers for filtering data with predicates, performing updates with setters, ordering results, and chaining expressions, empowering you to express business logic elegantly and without sacrificing type safety.

---

## Workflow Overview

### Task Description
This guide helps you understand and master working with **model-driven field helpers** generated by GORM CLI. You'll learn how to use these helpers to build type-safe, expressive queries and updates for your models without writing raw SQL or using string-based conditions.

### Prerequisites
- Have GORM CLI installed and set up in your Go project.
- Generated code for your models must be available (i.e., you have run `gorm gen` on your models).
- Basic familiarity with GORM's `*gorm.DB` usage.
- Example model with generated helpers, e.g., `User` struct and `generated.User` field helpers.

### Expected Outcome
- Confidently use generated predicates to filter queries.
- Use setters to update and create data with fluent and safe API.
- Chain conditions and updates clearly.
- Work with associations using field helpers (covered in related guides).

### Time Estimate
15â€“20 minutes for initial mastery with example code.

### Difficulty Level
Beginner to Intermediate.

---

## Core Concepts

GORM CLI generates for each model a set of **field helpers** that correspond to each database column and association. These helpers provide:

- **Predicates** for query filters (e.g., equals, greater than, like)
- **Setters** for update or create operations
- Support for **associations** (one-to-many, many-to-many)
- Strong typing based on Go struct field types for compile-time safety

The field helpers reside as variables in the generated package, e.g., `generated.User.Name`, `generated.User.Age`.

---

## Step-by-Step Instructions

<Steps>
<Step title="Query Filtering with Predicates">
Use field helpers to create strong-typed query filters without string SQL.

### How to:
1. Use `generated.Model.Field` followed by predicates like `.Eq()`, `.Gt()`, `.Like()`.
2. Pass predicates to GORM query builder with `.Where()`.

### Example:
```go
users, err := gorm.G[User](db).
  Where(generated.User.Age.Gt(18), generated.User.Name.Like("%jinzhu%"))
  .Find(ctx)
```

### Result:
Generates SQL filtering users where age > 18 and name LIKE '%jinzhu%'.
</Step>
<Step title="Updating with Setters">
Update fields using generated setters for safe and expressive updates.

### How to:
1. Use the model's `generated` setters like `.Set(value)`, `.Incr(amount)`.
2. Combine setters in `.Set()` call and chain with `.Update(ctx)`.

### Example:
```go
err := gorm.G[User](db).
  Where(generated.User.Name.Eq("alice"))
  .Set(
    generated.User.Name.Set("jinzhu"),
    generated.User.Age.Incr(1),
    generated.User.IsAdult.Set(false),
  )
  .Update(ctx)
```

### Result:
Increments age, updates name and is_adult for users named "alice".
</Step>
<Step title="Creating Records with Setters">
Create new records using setters to define values.

### How to:
1. Use `.Set()` with generated setters inside `.Create(ctx)`.

### Example:
```go
err := gorm.G[User](db).
  Set(
    generated.User.Name.Set("alice"),
    generated.User.Age.Set(30),
    generated.User.Role.Set("active"),
  )
  .Create(ctx)
```

### Result:
Creates a new User record with specified fields.
</Step>
<Step title="Ordering and Chaining Conditions">
Chain predicates and combine conditions for complex queries.

### How to:
1. Multiple predicates are combined with AND.
2. Use `.Where()` multiple times or combine predicates.

### Example:
```go
q := gorm.G[User](db).
  Where(generated.User.Age.Between(18, 65)).
  Where(generated.User.Status.Eq("active")).
  Order(generated.User.Name.Desc())
users, err := q.Find(ctx)
```

### Result:
Retrieve all active users between 18 and 65, ordered by descending name.
</Step>
</Steps>

---

## Examples

### Working with Basic Fields

Given a `User` model:

```go
  type User struct {
    ID        uint
    Name      string
    Email     string
    Age       int
    Status    string
    CreatedAt time.Time
  }
```

You can build predicates and setters:

```go
// Predicates examples
p1 := generated.User.ID.Eq(1)        // id = 1
p2 := generated.User.Name.Like("%jinzhu%") // name LIKE '%jinzhu%'
p3 := generated.User.Age.Between(18, 65)    // age BETWEEN 18 AND 65

// Update with setters
err := gorm.G[User](db).
  Where(p1).
  Set(
    generated.User.Name.Set("jinzhu"),
    generated.User.Age.Incr(1),
  ).
  Update(ctx)
```

### Using Expressions in Setters

Use `.SetExpr()` to use raw SQL expressions safely, for example:

```go
import "gorm.io/gorm/clause"

err := gorm.G[User](db).
  Where(generated.User.Name.Eq("alice"))
  .Set(
    generated.User.Age.SetExpr(clause.Expr{SQL: "GREATEST(?, ?)", Vars: []any{clause.Column{Name: "age"}, 18}}),
  ).
  Update(ctx)
```

This updates age to be the greatest of current age or 18.

---

## Working with Associations

Model-driven helpers exist for associations as well, enabling you to safely create, update, unlink, or delete associated data with strong typing.

### Example: Create and link an associated pet to a new user

```go
err := gorm.G[User](db).
  Set(
    generated.User.Name.Set("alice"),
    generated.User.Pets.Create(generated.Pet.Name.Set("fido")),
  ).
  Create(ctx)
```

### Example: Unlink pets from a user

```go
err := gorm.G[User](db).
  Where(generated.User.ID.Eq(1)).
  Set(generated.User.Pets.Unlink()).
  Update(ctx)
```

### Association operation semantics

| Association  | Unlink Effect                | Delete Effect                  |
|--------------|-----------------------------|-------------------------------|
| belongs to   | Sets parent foreign key NULL| Deletes associated rows       |
| has one/has many | Sets child foreign key NULL | Deletes child rows           |
| many2many    | Removes join rows only       | Removes join rows only         |

See the guide **Managing Associations: Create, Update, Unlink, Delete** for detailed workflows.

---

## Tips & Best Practices

- **Prefer predicates over raw SQL WHERE strings** to gain compile-time safety.
- Use `.Set()` and `.SetExpr()` together for flexible and safe updates.
- Always check for possible nil or zero values to avoid query surprises.
- Use batch methods like `.CreateInBatch()` to efficiently handle multiple related records.
- For complex conditions, combine multiple predicates using `.Where()` or predicate lists.
- When dealing with JSON or custom types, configure field helpers via `genconfig.Config` for better support.

---

## Troubleshooting

<AccordionGroup title="Common Issues and Solutions">
<Accordion title="Generated Field Helper Not Found">
Ensure you have run the code generator with the correct input path and that your model structs are exported.

Check your output directory for the generated package and `generated.{Model}` variables.
</Accordion>
<Accordion title="Query Returns No Results">
Verify your predicates match the data schema and types correctly.
Ensure values passed to predicates are valid and correspond to existing records.
</Accordion>
<Accordion title="Cannot Compile Due to Type Errors">
Confirm that your Go version is 1.18 or later to support generics.
Check that your model types and generated code versions are in sync.
</Accordion>
</AccordionGroup>

---

## Next Steps & Related Content

- Explore **Working with Type-Safe Queries** to leverage interface-driven SQL templates for advanced query operations.
- Learn about **Managing Associations: Create, Update, Unlink, Delete** for deeper control over relational data with generated helpers.
- Customize generation using the **Customizing Generation with genconfig.Config** guide to tailor the helper behavior.
- Visit the **Quickstart Overview** for a full introductory workflow.

---

## Summary
This guide focused on the practical use of model-driven field helpers generated by GORM CLI, showing you how to build safe, expressive database filters, updates, and create operations using fluent and type-safe APIs. With concrete examples and step-by-step instructions, you're equipped to write cleaner and safer GORM code, leveraging the full power of these helpers.

---