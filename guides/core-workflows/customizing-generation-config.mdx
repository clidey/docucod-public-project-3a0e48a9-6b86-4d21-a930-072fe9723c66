---
title: "Customizing Code Generation with Config"
description: "How to fine-tune generation using genconfig.Config, including customizing output paths, field type/name mappings, and inclusion/exclusion patterns for interfaces and models. Shows practical config snippets and explains the effect of each option."
---

# Customizing Code Generation with Config

## Workflow Overview

This guide helps you customize the behavior of GORM CLI's code generation by using the optional `genconfig.Config` struct. You will learn how to adjust output locations, control which interfaces and structs are included or excluded, and customize field type and name mappings to tune how generated code is shaped.

### Prerequisites
- You have a basic working GORM CLI setup and understand the standard generation workflow.
- You have defined Go models and SQL-annotated query interfaces as input.
- You are familiar with running the CLI `gorm gen` command.

### Expected Outcome
By following this guide, you will be able to create and use a `genconfig.Config` declaration within your package to:
- Redirect generated files to custom paths.
- Map Go types or tagged field names to custom or specialized field helper types.
- Include or exclude specific interfaces and structs from generation.
- Narrow generation scope to the file or package level.

### Time Estimate
Approximately 10–20 minutes to understand and apply custom configurations for basic scenarios.

### Difficulty Level
Intermediate — requires understanding of Go types, struct tags, and basic generator usage.

---

## How to Configure Generation Using `genconfig.Config`

### 1. Declare a Package-Level Configuration

Place a `var _ = genconfig.Config{ ... }` composite literal in any Go source file within the package or directory you want to customize. The generator will automatically detect and apply these settings during code generation.

Example:

```go
package examples

import (
    "database/sql"
    "gorm.io/cli/gorm/field"
    "gorm.io/cli/gorm/genconfig"
)

var _ = genconfig.Config{
    OutPath: "examples/output",
    FieldTypeMap: map[any]any{
        sql.NullTime{}: field.Time{},
    },
    FieldNameMap: map[string]any{
        "date": field.Time{},
        "json": JSON{},
    },
    IncludeInterfaces: []any{"Query*", models.Query(nil)},
    ExcludeInterfaces: []any{"*Deprecated*"},
    IncludeStructs: []any{"User", "Account*", models.User{}},
    ExcludeStructs: []any{"*DTO"},
    FileLevel: false,
}
```

### 2. Customize Output Path (`OutPath`)
- Use `OutPath` to override the default CLI output directory for files within that package.
- This lets you logically separate generated output from source files or group generated files by feature or domain.

### 3. Map Field Types (`FieldTypeMap`)

Map a Go type instance to a custom field helper instance:
- The key is a Go type instance (e.g., `sql.NullTime{}`).
- The value is an instance of a field helper (e.g., `field.Time{}`).

This mapping changes how the generator produces the typed field helpers for matching model fields.

Example:

```go
FieldTypeMap: map[any]any{
    sql.NullTime{}: field.Time{},
}
```

### 4. Map Field Names by Tag (`FieldNameMap`)

Map a `gen` struct tag name to a custom field helper. The generator prioritizes this over `FieldTypeMap`.

Example:

```go
FieldNameMap: map[string]any{
    "json": JSON{},  // Custom JSON field helper used for fields tagged with `gen:"json"`
    "date": field.Time{},
}
```

### 5. Control Inclusion and Exclusion

Fine-tune which interfaces and structs are generated. Filters use shell-style patterns and Go type literals.

- **IncludeInterfaces**: whitelist interface types by name pattern or type conversion literals. Only interfaces matching these will be generated.
- **ExcludeInterfaces**: blacklist interfaces by name pattern; exclusion is skipped if whitelist is used.
- **IncludeStructs**: whitelist struct names or type literals. Only these structs are generated.
- **ExcludeStructs**: blacklist struct names and literals; ignored if whitelist is specified.

Example:

```go
IncludeInterfaces: []any{"Query*", models.Query(nil)},
ExcludeInterfaces: []any{"*Deprecated*"},
IncludeStructs: []any{"User", "Account*", models.User{}},
ExcludeStructs: []any{"*DTO"},
```

### 6. File-Level Configuration

- **FileLevel** (boolean): If true, applies the config only to the current file, otherwise it is package-wide.

---

## Step-by-Step Instructions

<Steps>
<Step title="Create or Edit a Go File for Config">
Create a `.go` file in the target package or directory where your models and query interfaces reside.
</Step>

<Step title="Import Required Packages">
Make sure to import `gorm.io/cli/gorm/genconfig` and any types you need for your mappings, e.g., `database/sql` or custom types.
</Step>

<Step title="Define genconfig.Config Literal">
Declare a package-level variable `_` assigned to your `genconfig.Config` instance.

Example:

```go
var _ = genconfig.Config{
    OutPath: "generated/code",
    FieldTypeMap: map[any]any{
        sql.NullTime{}: field.Time{},
    },
    IncludeInterfaces: []any{"Query*"},
}
```

This embeds your configuration within the scanned codebase.
</Step>

<Step title="Use Custom Field Name Mapping">
If you want to map fields tagged with `gen:` tags to specific field helpers, add entries to `FieldNameMap`.

Example:

```go
FieldNameMap: map[string]any{
    "json": JSON{},
}
```

Then tag your model:

```go
Profile string `gen:"json"`
```
</Step>

<Step title="Customize Include/Exclude Patterns">
Use Include and Exclude slices to filter generated interfaces and structs.

- Include is checked first and takes priority.
- Patterns support wildcards, exact names, and type literals.

Example:

```go
IncludeInterfaces: []any{"Query*"},
ExcludeInterfaces: []any{"*Deprecated*"},
IncludeStructs: []any{"User", models.Account{}},
ExcludeStructs: []any{"*DTO"},
```
</Step>

<Step title="Run `gorm gen` Command">
Run your CLI command as usual.

```bash
gorm gen -i ./path/to/package -o ./desired/output/path
```

The generator will detect and apply your `genconfig.Config` automatically.
</Step>

<Step title="Verify Generated Output">
Check your specified output directory for updated generated files.
Confirm that only desired interfaces and structs are generated and field helpers reflect configured mappings.
</Step>
</Steps>

---

## Practical Examples

### Basic Config with Output Path and Field Mapping

```go
package examples

import (
    "database/sql"
    "gorm.io/cli/gorm/field"
    "gorm.io/cli/gorm/genconfig"
)

var _ = genconfig.Config{
    OutPath: "examples/output",

    FieldTypeMap: map[any]any{
        sql.NullTime{}: field.Time{},
    },

    FieldNameMap: map[string]any{
        "date": field.Time{},
        "json": JSON{},
    },

    IncludeInterfaces: []any{"Query*"},
    ExcludeInterfaces: []any{"*Deprecated*"},

    IncludeStructs: []any{"User", "Account*"},
    ExcludeStructs: []any{"*DTO"},

    FileLevel: false,
}
```

### JSON Field Helper Integration

Define a custom `JSON` field helper type:

```go
package examples

import (
    "gorm.io/cli/gorm/genconfig"
    "gorm.io/gorm/clause"
    "gorm.io/gorm"
    "encoding/json"
)

// JSON is a custom field helper that provides SQL JSON comparison support
// for various databases.
type JSON struct { column clause.Column }

func (j JSON) WithColumn(name string) JSON {
    c := j.column
    c.Name = name
    return JSON{column: c}
}

func (j JSON) Equal(path string, value any) clause.Expression {
    return jsonEqualExpr{col: j.column, path: path, val: value}
}

type jsonEqualExpr struct {
    col  clause.Column
    path string
    val  any
}

func (e jsonEqualExpr) Build(builder clause.Builder) {
    if stmt, ok := builder.(*gorm.Statement); ok {
        switch stmt.Dialector.Name() {
        case "mysql":
            v, _ := json.Marshal(e.val)
            clause.Expr{SQL: "JSON_EXTRACT(?, ?) = CAST(? AS JSON)", Vars: []any{e.col, e.path, string(v)}}.Build(builder)
        case "sqlite":
            clause.Expr{SQL: "json_valid(?) AND json_extract(?, ?) = ?", Vars: []any{e.col, e.col, e.path, e.val}}.Build(builder)
        default:
            clause.Expr{SQL: "jsonb_extract_path_text(?, ?) = ?", Vars: []any{e.col, e.path[2:], e.val}}.Build(builder)
        }
    }
}
```

Then map it in `genconfig.Config`:

```go
var _ = genconfig.Config{
    OutPath: "examples/output",
    FieldNameMap: map[string]any{
        "json": JSON{},
    },
}
```

Tag your model fields:

```go
type User struct {
    Profile string `gen:"json"`
}
```

Query with the JSON helper:

```go
gorm.G[User](db).
    Where(generated.User.Profile.Equal("$.vip", true)).
    Take(ctx)
```

---

## Troubleshooting & Best Practices

<AccordionGroup title="Common Issues">
<Accordion title="Config Not Detected">
- Make sure the `genconfig.Config` literal is defined at package level (not inside functions).
- Ensure the file is in the same package/directory as the generated code inputs.
- Confirm the generator scans the directory where config is defined.
</Accordion>

<Accordion title="Patterns Don't Match Expected Interfaces or Structs">
- Use exact package-qualified names for type literals: `models.Query(nil)`, `models.User{}`.
- Support for shell-style patterns like `Query*`, `*Repo`.
- Blacklists are ignored if whitelist arrays are non-empty.
</Accordion>

<Accordion title="Field Type or Name Map Not Applied">
- The generator prioritizes `FieldNameMap` over `FieldTypeMap`.
- Make sure you use concrete type instances (e.g., `sql.NullTime{}`) and field helper instances (e.g., `field.Time{}`) in the maps.
- If using custom helpers, implement the required methods expected by GORM CLI field helper interface.
</Accordion>
</AccordionGroup>

### Best Practices

- Use inclusive patterns (`IncludeInterfaces` / `IncludeStructs`) for strict control.
- Avoid overly broad exclusion patterns to prevent accidental omission.
- Group related config changes in a dedicated Go file for maintainability.
- Regularly verify outputs after config changes to validate behavior.

---

## Next Steps & Related Content

- After customizing config, see [Getting Started: Code Generation](../core-workflows/getting-started-generation) for running your first tailored generation.
- Learn about [Using Generated APIs in Your Application](../core-workflows/using-generated-apis) to leverage generated code effectively.
- Explore [Custom Field Helpers: JSON Example](../../best-practices-patterns/json-field-customization) for advanced field customization techniques.
- Understand [Basic Configuration](../../getting-started/configuration-first-usage/basic-configuration) for foundational setup.
- Refer to the [System Architecture Overview](../../overview/architecture-core-concepts/system-architecture) for deeper insight into generator internals.

---