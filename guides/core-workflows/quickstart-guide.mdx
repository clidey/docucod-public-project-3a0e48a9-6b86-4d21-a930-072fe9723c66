---
title: "Quickstart: Generate and Use Type-Safe APIs"
description: "A step-by-step introduction to using GORM CLI for generating type-safe query APIs and field helpers, from writing interfaces and models to generating code and executing queries. Ideal as the first stop for new users."
---

# Quickstart: Generate and Use Type-Safe APIs

Welcome to your first step with **GORM CLI** — this guide takes you through generating type-safe query APIs and field helpers using the GORM CLI tool, from writing your SQL template interfaces and models to generating code and executing safe, idiomatic queries in Go.

---

## Workflow Overview

### What You'll Achieve
This guide helps you:
- Define Go interfaces annotated with raw SQL templates.
- Prepare models used by the generator to create field helpers.
- Use GORM CLI to generate type-safe query code and helpers automatically.
- Call the generated APIs in your Go application for safe, expressive database queries.

### Prerequisites
Before starting, ensure:
- You have Go 1.18+ installed.
- You have GORM CLI installed (`go install gorm.io/cli/gorm@latest`).
- Your project includes your model structs and query interfaces (or you know how to write them).
- Basic understanding of Go generics and GORM usage.

### Expected Outcome
By following this guide, you will have:
- Generated type-safe query APIs from your annotated interfaces.
- Model-driven field helpers for building queries and updates fluently.
- Sample working calls to generated code demonstrating typical queries.

### Time Commitment
This quickstart setup and code generation usually takes 10-15 minutes, depending on your familiarity.

### Difficulty Level
Beginner to Intermediate. No previous GORM CLI experience required but some Go and SQL knowledge helps.

---

## Step-by-Step Instructions

### 1. Write Query Interfaces and Models

Define your generic query interfaces with SQL templates in method comments and your model structs within the same package or directory.

Example interface:
```go
// examples/query.go
package examples

type Query[T any] interface {
  // SELECT * FROM @@table WHERE id=@id
  GetByID(id int) (T, error)

  // where("name=@name AND age=@age")
  FilterByNameAndAge(name string, age int)
}
```

Example model:
```go
// examples/models/user.go
package models

type User struct {
  ID   uint
  Name string
  Age  int
}
```

> Tip: The `@@table` macro resolves to your model's table name, and `@param` bindings provide safe SQL parameterization.

### 2. (Optional) Configure Generation Settings

You may declare a package-level `genconfig.Config` to control output paths, type mappings, and generation filters.

Example mapping SQL types and overriding output folder:
```go
package examples

import (
  "database/sql"
  "gorm.io/cli/gorm/field"
  "gorm.io/cli/gorm/genconfig"
)

var _ = genconfig.Config{
  OutPath: "examples/output",
  FieldTypeMap: map[any]any{
    sql.NullTime{}: field.Time{},
  },
}
```

> Note: Configuration is optional. If omitted, defaults apply.

### 3. Run GORM CLI Code Generation

Use the `gorm gen` CLI command providing the input directory/file and output path.

```bash
gorm gen -i ./examples -o ./generated
```

- `-i` or `--input` specifies the directory or Go file containing your interfaces and models.
- `-o` or `--output` specifies where generated code will be saved.

On successful run, your output folder will contain generated `.go` files with:
- Concrete implementations of your interfaces.
- Generated field helper structs for your models.

### 4. Use the Generated APIs in Your Go Application

Import the generated package and call your query methods with type safety and fluent helpers.

Example usage:
```go
import (
  "context"
  "gorm.io/gorm"
  "generated"
  "models"
)

func example(db *gorm.DB) error {
  ctx := context.Background()
  
  // Query by ID
  user, err := generated.Query[models.User](db).GetByID(ctx, 123)
  if err != nil {
    return err
  }

  // Use field helpers for fluent queries
  users, err := gorm.G[models.User](db).
    Where(generated.User.Age.Gt(18)).
    Find(ctx)

  return err
}
```

> ProTip: The generated APIs automatically inject `context.Context` if you omit it.

### 5. Extend Your Queries Using SQL Template DSL

Leverage the SQL template DSL to write flexible, safe SQL in your interface method comments.

Supported constructs include:
- `@@table` and `@@column` for dynamic table and column substitutions
- `@param` bindings for parameters
- `{{where}}` and `{{set}}` blocks for conditional clauses
- `{{if}}` and `{{for}}` for control flow

Example:
```go
// SELECT * FROM @@table
// {{where}}
//   {{if user.Name != ""}} name=@user.Name {{end}}
//   {{if user.Age > 0}} AND age=@user.Age {{end}}
// {{end}}
SearchUsers(user User) ([]T, error)
```

This flexibility enables complex, type-safe queries without writing raw SQL in your app.

---

## Real-World Example

Suppose you want to get active users over 18:

Interface:
```go
// SELECT * FROM @@table WHERE age > 18 AND role = @role
GetActiveAdults(role string) ([]T, error)
```

Code generation generates an implementation with the proper typed SQL, parameters, and return types.

Usage:
```go
users, err := generated.Query[models.User](db).GetActiveAdults(ctx, "active")
```

---

## Troubleshooting & Tips

### Common Issues
- **No output or empty output:** Check your input path and interface annotations.
- **Method lacking return values:** All ‘finish’ methods with raw SQL running queries require at least one return and an error.
- **Compilation errors after generation:** Ensure consistent Go module paths and proper import resolutions.
- **SQL template parsing errors:** Review your interface comments for proper syntax in DSL directives.

### Best Practices
- Keep interfaces and models in the same package/directory for easier generation and configuration discovery.
- Use `genconfig.Config` to customize output folder and selectively include/exclude interfaces or structs.
- Write clear interfaces using the SQL template directives to produce concise, readable generated code.
- Use field helpers generated for your models to build queries fluently and safely.

---

## Next Steps & Related Content

- Explore [Working with Field Helpers](/guides/core-workflows/working-with-field-helpers) to master predicate and update helpers.
- Dive into [Managing Associations](/guides/core-workflows/associations-guide) to learn about generated association APIs.
- Understand [Configuration Basics](/getting-started/essential-setup/configuration-basics) to tailor generation.
- Validate your setup with [Quick Validation Steps](/getting-started/validation-and-troubleshooting/quick-validation).
- In case of setup issues, consult [Troubleshooting Common Setup Issues](/getting-started/validation-and-troubleshooting/troubleshooting-common-issues).

---

## Resources
- [GORM CLI GitHub Repository](https://github.com/go-gorm/cli)
- [Overview & Value Proposition](/overview/introduction-and-key-concepts/value-and-use-cases)
- [Core Concepts & Terminology](/overview/introduction-and-key-concepts/core-concepts-and-terminology)
- [Example Workflows & Feature Highlights](/overview/feature-overview/feature-examples-and-workflows)

---

You’re now equipped to generate and use type-safe query APIs with GORM CLI — enjoy the safety, clarity, and expressiveness this tool brings to your Go database code!

<Check>
Remember: Proper interface annotations and clear model definitions form the foundation of successful code generation. Always validate generated code and test your queries early to ensure smooth development.
</Check>
