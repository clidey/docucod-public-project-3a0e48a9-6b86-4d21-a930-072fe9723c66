---
title: "Integrating Generated Code into Your GORM Projects"
description: "Covers best practices for organizing generated code, importing into application codebases, and seamless integration with gorm.io/gorm for reads, writes, and batch operations. Includes directory structure patterns and build process tips."
---

# Integrating Generated Code into Your GORM Projects

## Workflow Overview

### Task Description
This guide helps Go developers and backend engineers seamlessly integrate code generated by GORM CLI into their existing GORM projects. It focuses on best practices for organizing generated files, importing them properly, and using the generated query APIs and field helpers in day-to-day database operations.

### Prerequisites
- You have generated the code using the GORM CLI `gen` command from your model structs and query interfaces.
- Familiarity with GORM ORM basics (`gorm.io/gorm`).
- Basic understanding of Go modules and package importing.

### Expected Outcome
By following this guide, you will:
- Establish a clean directory structure for generated code and source code.
- Import generated packages correctly to access fluent, type-safe query APIs.
- Use generated field helpers and query APIs effectively for reads, writes, batch, and association operations.
- Improve maintainability and clarity in your GORM project’s data access layer.

### Time Estimate
About 15-30 minutes to organize and integrate generated code in a small to medium project.

### Difficulty Level
Beginner to Intermediate (focus on code organization and usage patterns rather than code generation itself).

---

## Integration Steps

### 1. Organize Your Directory Structure

A well-organized layout helps maintain clarity and simplifies import paths.

- **Source code** (models, interfaces, application logic) resides in source directories, e.g., `./models` or `./internal/models`.
- **Generated code output** is configured separately, typically outside source directories to differentiate manually written code and generated code clearly. Example:
  ```
  /project-root
    /models           # Your model structs and interfaces
    /generated        # Generated code output directory (e.g., "g" or "generated")
    main.go
  ```

- Set the `-o` output flag in the `gorm gen` CLI command accordingly to direct generated files:

  ```bash
  gorm gen -i ./models -o ./generated
  ```

- Use package-level `genconfig.Config` if you need to control output paths more granularly.

<Info>
Keeping generated code in a separate directory prevents unintentional edits and simplifies version control management.
</Info>

### 2. Import Generated Code Correctly

- Your `generated` directory is a bona fide Go package; import it in your application code to access the generated APIs.

```go
import (
    "context"
    "gorm.io/gorm"
    "your-module/generated" // replace with your module path + generated dir
)
```

- Access the generated query interfaces and field helpers through this imported package.

### 3. Use Generated Query APIs for Reads

- Generated query interfaces provide type-safe methods corresponding to your annotated SQL interfaces.
- Example to fetch a record by ID:

```go
func GetUserByID(ctx context.Context, db *gorm.DB, id int) (models.User, error) {
    // generated.Query is the generated query interface
    return generated.Query[models.User](db).GetByID(ctx, id)
}
```

- Incorporate GORM `*gorm.DB` instances and context (`ctx context.Context`) naturally for cancellation and tracing.

### 4. Use Generated Field Helpers for Filtering and Updates

- Field helpers empower fluent conditions, upgrades, and bulk operations with compile-time safety.

- Example: Find active users over 18 years of age

```go
users := []models.User{}
err := gorm.G[models.User](db).
    Where(generated.User.Age.Gt(18)).
    Where(generated.User.Status.Eq("active")).
    Find(ctx, &users)
```

- Update user fields with helpers:

```go
err := gorm.G[models.User](db).
    Where(generated.User.ID.Eq(123)).
    Set(
        generated.User.Name.Set("Jane Doe"),
        generated.User.Age.Incr(1),
    ).
    Update(ctx)
```

### 5. Handle Associations with Generated Helpers

- Use association helpers to create, update, unlink, or delete related rows safely.

- Create and link a related entity in one call:

```go
err := gorm.G[models.User](db).
    Set(
        generated.User.Name.Set("Alice"),
        generated.User.Pets.Create(generated.Pet.Name.Set("Fido")),
    ).
    Create(ctx)
```

- Update associations conditionally:

```go
err := gorm.G[models.User](db).
    Where(generated.User.ID.Eq(1)).
    Set(
        generated.User.Pets.Where(generated.Pet.Name.Eq("Fido")).
            Update(generated.Pet.Name.Set("Rex")),
    ).
    Update(ctx)
```

- Unlink or delete associated entities safely:

```go
// Unlink
err := gorm.G[models.User](db).
    Where(generated.User.ID.Eq(1)).
    Set(generated.User.Pets.Unlink()).
    Update(ctx)

// Delete
err = gorm.G[models.User](db).
    Where(generated.User.ID.Eq(1)).
    Set(generated.User.Pets.Delete()).
    Update(ctx)
```

### 6. Batch Operations with Generated Helpers

- For bulk inserts or linking, use batch helpers like `CreateInBatch`:

```go
pets := []models.Pet{{Name: "Max"}, {Name: "Bella"}}
err := gorm.G[models.User](db).
    Where(generated.User.ID.Eq(1)).
    Set(generated.User.Pets.CreateInBatch(pets)).
    Update(ctx)
```

### 7. Build and Test Your Project

- Build your project normally; the generated code follows standard Go conventions and integrates naturally.
- Use imported types and methods directly.
- Testing is simplified since code generation ensures type safety — compile-time checks catch signature mismatches.

<Check>
Verify generated code is up to date when you change models or interfaces. Rerun the CLI generator and rebuild.
</Check>

---

## Directory Structure Example

```text
/project-root
  /models               # Your manually written models and interfaces
    user.go
    pet.go
  /generated            # GORM CLI generated code
    user_gen.go
    pet_gen.go
  main.go
```

- `main.go` imports "generated" and "models" packages 

### CLI Command Example

```bash
gorm gen -i ./models -o ./generated
```

This preserves input directory structure and places generated code in a parallel `generated` folder.

---

## Practical Tips & Common Pitfalls

- **Avoid modifying generated files:** Edit your models/interfaces in source files only, then regenerate.
- **Match package imports carefully:** Make sure the import path for generated package matches your Go module setup.
- **Context injection:** Generated query methods automatically add `context.Context` if missing in interface declarations.
- **Keep your Go modules tidy:** Run `go mod tidy` after adding new generated code imports.
- **Regenerate often:** Anytime model or query interface changes occur, regenerate code to avoid runtime mismatches.

---

## Troubleshooting

### Generated Code Not Found / Import Errors
- Confirm your `-o` output matches the package import path.
- Check `go.mod` has correct module path.
- Run `go mod tidy` and recompile.

### Compilation Errors on Generated Methods
- Ensure generated code is current by rerunning `gorm gen` on updated interfaces and models.
- Verify no manual edits in generated files causing invalid Go code.

### Runtime Errors with Associations
- Validate Foreign Key constraints and association setup in your models.
- Use generated association helpers as intended — for example, use `Create` to insert and link, not both separately.

<Tip>
Refer to the [Getting Started Guide](/guides/core-workflows/getting-started) for initial code generation and [Field Helper Basics Guide](/guides/core-workflows/field-helper-basics) for deeper association usage.
</Tip>

---

## Next Steps & Related Content

- Explore [Getting Started: Generate Your First Query API](/guides/core-workflows/getting-started) to create your first generated queries.
- Learn advanced association patterns in [Working with Associations](/guides/advanced-patterns/associations-deep-dive).
- Customize generation using [genconfig.Config](/getting-started/setup-and-installation/configuration-basics).
- Troubleshoot using [Troubleshooting Common Issues](/getting-started/troubleshooting-and-help/troubleshooting-common-issues).

---

## Summary Diagram: Integration Workflow

```mermaid
flowchart TD
  A[Define Models & Query Interfaces] --> B[Run GORM CLI Code Generator]
  B --> C[Generated Code (Query APIs & Field Helpers)]
  C --> D[Import in Application Code]
  D --> E[Use Generated APIs & Helpers for DB Operations]
  E --> F[Build & Run Project]

  %% Annotations
  classDef stepFill fill:#dff0d8,stroke:#4cae4c,stroke-width:2px;
  class A,B,C,D,E,F stepFill;
```

---

By structuring your projects with a clear separation between source and generated code and leveraging the generated type-safe APIs and field helpers, integrating GORM CLI into your GORM projects becomes straightforward and boosts your productivity with compile-time safety and clean code.
