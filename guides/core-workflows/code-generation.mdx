---
title: "Generating Type-Safe APIs and Helpers"
description: "Detailed walkthrough of writing interfaces and models, leveraging SQL template comments, and using the `gorm gen` command to produce query methods and field helpers. Explains input/output patterns, required conventions, and generated code structure."
---

# Generating Type-Safe APIs and Helpers

## Overview
This guide walks you through the critical process of writing Go interfaces and models tailored for the GORM CLI code generator. You'll learn how to embed SQL templates using specialized comments, apply the `gorm gen` command effectively, and understand how the generated type-safe query methods and field helpers are structured. This empowers you to create concise, compile-time safe, and maintainable database access code that integrates smoothly with GORM.

---

## 1. Workflow Overview

### Task Description
Learn how to define raw SQL interface methods and model structs with precise annotations that the GORM CLI recognizes to generate type-safe query APIs and model-driven field helpers.

### Prerequisites
- Go 1.18+ installed on your system
- GORM CLI installed (`go install gorm.io/cli/gorm@latest`)
- Basic understanding of Go interfaces, struct tags, and SQL queries
- Models and SQL interfaces should be organized in packages or directories accessible for the generator

### Expected Outcome
- Ready-to-use Go code with:
  - Interfaces transformed into type-safe query methods with embedded SQL logic
  - Field helpers generated from model structs for filters, setters, and association management
- Generation-ready SQL templates embedded in comments following GORM CLI DSL conventions

### Time Estimate
Approximately 15-30 minutes to write interfaces and models and run the generation process

### Difficulty Level
Intermediate – requires familiarity with Go, SQL, and GORM patterns

---

## 2. Writing Interfaces and Models

### 2.1 Defining SQL Templated Interfaces
Write Go interfaces defining methods whose comments contain raw SQL or SQL templates. Use GORM CLI's SQL template DSL to express database queries and updates concisely:

- Use `@@table` to reference the model's table name dynamically.
- Use `@@column` to inject column names dynamically.
- Bind Go method parameters to SQL parameters using `@paramName`.
- Write conditional SQL blocks inside `{{where}}`, `{{set}}`, `{{if}}`, `{{else}}`, `{{for}}` directives.

Example:
```go
// Query interface with SQL annotations
// embedded in method comments
//
type Query[T any] interface {

  // GetByID fetches a record by its ID
  //
  // SELECT * FROM @@table WHERE id=@id
  GetByID(id int) (T, error)

  // Filter with dynamic column name
  // SELECT * FROM @@table WHERE @@column=@value
  FilterWithColumn(column string, value string) (T, error)

  // Complex query with conditional SQL blocks
  // SELECT * FROM users
  // {{where}}
  //   {{if user.ID > 0}} WHERE id=@user.ID {{end}}
  //   {{else if user.Name != ""}} WHERE name=@user.Name {{end}}
  // {{end}}
  QueryWith(user User) (T, error)

  // Update using dynamic SET clause
  // UPDATE @@table
  // {{set}}
  //   {{if user.Name != ""}} name=@user.Name, {{end}}
  //   {{if user.Age > 0}} age=@user.Age, {{end}}
  //   {{if user.Age >= 18}} is_adult=1 {{else}} is_adult=0 {{end}}
  // {{end}}
  // WHERE id=@id
  UpdateInfo(user User, id int) error

  // Complex filter using FOR loops over user slices
  // SELECT * FROM @@table
  // {{where}}
  //   {{for _, user := range users}}
  //     {{if user.Name != "" && user.Age > 0}}
  //       (name = @user.Name AND age=@user.Age AND role LIKE concat("%",@user.Role,"%")) OR
  //     {{end}}
  //   {{end}}
  // {{end}}
  Filter(users []User) ([]T, error)

  // Short WHERE clause definition
  // where("name=@name AND age=@age")
  FilterByNameAndAge(name string, age int)

  // Filter with time ranges
  // SELECT * FROM @@table
  // {{where}}
  //   {{if !start.IsZero()}} created_at > @start {{end}}
  //   {{if !end.IsZero()}} AND created_at < @end {{end}}
  // {{end}}
  FilterWithTime(start, end time.Time) ([]T, error)
}
```

<Tip>
Use escaped `\@` when you want a literal `@` symbol in SQL comments (e.g., in strings).
</Tip>

### 2.2 Writing Go Model Structs
Define your Go model structs in the same or accessible package for the generator. Use struct tags and the `gen:"<name>"` tag to customize field helper generation.

Example:
```go
// User model
// Contains basic fields with tags for generation

type User struct {
  ID   uint
  Name string
  Age  int

  // Use gen tag to specify custom field helper type
  Profile string `gen:"json"`
}
```

### 2.3 Using genconfig.Config (Optional)
Customize generation by declaring a package-level `genconfig.Config` value. This controls:

- Output directories
- Type mappings (mapping Go types to field helpers)
- Field name mappings (e.g., map `json` tag to JSON helper)
- Inclusion/exclusion filters for structs and interfaces

Example:
```go
var _ = genconfig.Config{
  OutPath: "./generated",
  FieldTypeMap: map[any]any{
    sql.NullTime{}: field.Time{},
  },
  FieldNameMap: map[string]any{
    "json": JSON{},
  },
  IncludeInterfaces: []any{"Query*"},
  ExcludeStructs: []any{"*DTO"},
}
```

<Note>
Configuring `OutPath` sets the root directory for generated code output.
</Note>

---

## 3. Running the `gorm gen` Command

Use the GORM CLI `gen` subcommand to generate code from your annotated interface definitions.

### 3.1 Command Overview
```bash
gorm gen -i <path-to-interface-file-or-dir> [-o <output-dir>]
```

- `-i`: Path to the Go file or directory containing interfaces with SQL templates
- `-o`: Optional output directory for generated code (default is `./g`)

Example:
```bash
gorm gen -i ./examples -o ./generated
```

### 3.2 What Happens When You Run `gorm gen`
- The generator parses Go files at the input path, extracting model structs and interface methods
- It reads SQL annotations and applies the SQL template DSL parser to generate Go code snippets
- It uses the configured `genconfig.Config` if present for customizations
- Generates type-safe method implementations and field helper definitions
- Formats and writes generated Go files preserving the package and import context

### 3.3 Verifying Generation
Look for log output like:
```
Generating file ./generated/examples/query.go from ./examples/query.go...
```
The output directory will contain generated Go files with:
- `Query[T any]` interface implementations
- Model field helper variables and methods

---

## 4. Understanding the Generated Code

### 4.1 Generated Interface Implementations
For each method with embedded SQL (raw or templated), the generator produces Go methods that:

- Build SQL query strings dynamically using `strings.Builder`
- Bind parameters safely mapped from method inputs
- Use GORM's underlying query interfaces (`gorm.Interface`) for execution

Example generated method:
```go
func (e QueryImpl[T]) GetByID(ctx context.Context, id int) (T, error) {
  var sb strings.Builder
  params := make([]any, 0, 2)
  sb.WriteString("SELECT * FROM ? WHERE id=? AND name = \"@name\"")
  params = append(params, clause.Table{Name: clause.CurrentTable}, id)

  var result T
  err := e.Raw(sb.String(), params...).Scan(ctx, &result)
  return result, err
}
```

### 4.2 Field Helpers from Models
From your structs, the generator creates strongly typed variables for fields with methods like `.Eq()`, `.Set()`, `.Incr()`, providing expressive predicates and setters.

Example usage:
```go
// Generated field helper for User.Name
generated.User.Name.Eq("alice")   // WHERE name = 'alice'

// Update field using field helper
gorm.G[User](db).
  Where(generated.User.ID.Eq(1)).
  Set(generated.User.Age.Incr(1)).
  Update(ctx)
```

---

## 5. Best Practices and Tips

- Always define clear SQL templates in method comments—prefer raw SQL or the GORM CLI DSL for conditional logic.
- Keep models and interfaces within the same or closely related packages to simplify generation.
- Use `genconfig.Config` to customize output paths and tailor field helper mappings to your project needs.
- Name conventionally: interfaces often named `Query`, structs named after your domain models.
- Escape `@` literals using `\@` in SQL comments to prevent unintended parameter binding.
- Organize large projects by splitting interfaces and models logically, leveraging config's include/exclude capability to focus generation.

---

## 6. Troubleshooting

### 6.1 Common Issues

| Issue                              | Cause                                         | Solution                                      |
|----------------------------------|----------------------------------------------|-----------------------------------------------|
| Method does not generate code     | Missing or malformed SQL template comment     | Ensure correct syntax and SQL DSL directives   |
| Output directory empty or missing | Incorrect `-o` flag or write permissions       | Verify output path and folder permissions      |
| Panic: method return type invalid | Interface method missing `error` return value | Make sure last return value is `error`         |
| Unrecognized SQL directives       | Using unsupported SQL DSL syntax/misspelling | Use documented directives: `where`, `set`, `if`, `for` |

### 6.2 Verification
- Confirm interface methods have correct SQL annotation style
- Run `gorm gen -i ./path/to/interfaces -o ./output` and inspect logs
- Look at generated `.go` files for method bodies and field helpers

<Tip>
For complex queries, test SQL templates separately before embedding in interface comments.
</Tip>

---

## 7. Next Steps & Related Documentation

- Explore [Using the Generated Code](/getting-started/first-codegen-workflow/using-generated-code) for practical API usage
- Read about [Working with Associations](/guides/advanced-patterns/association-helpers) to manage relations with generated helpers
- Customize field helpers further using [Custom Field Helpers and JSON Mapping](/guides/advanced-patterns/custom-fields)
- Deep dive into [Mastering the SQL Template DSL](/guides/advanced-patterns/templating-dsl) for creating powerful query methods
- Configure generation with [Basic Configuration Options](/getting-started/first-codegen-workflow/basic-configuration-options)


---

## Appendix: Sample Interface with SQL Templating
```go
// Query interface with methods illustrating key templates
//
type Query[T any] interface {
  // Simple SELECT
  // SELECT * FROM @@table WHERE id=@id
  GetByID(id int) (T, error)

  // Dynamic column name
  // SELECT * FROM @@table WHERE @@column=@value
  FilterWithColumn(column string, value string) (T, error)

  // Complex conditional WHERE
  // SELECT * FROM users
  // {{where}}
  //   {{if user.ID > 0}} id=@user.ID {{end}}
  //   {{else if user.Name != ""}} name=@user.Name {{end}}
  // {{end}}
  QueryWith(user User) (T, error)

  // Dynamic UPDATE
  // UPDATE @@table
  // {{set}}
  //   {{if user.Name != ""}} name=@user.Name, {{end}}
  //   {{if user.Age > 0}} age=@user.Age, {{end}}
  //   {{if user.Age >= 18}} is_adult=1 {{else}} is_adult=0 {{end}}
  // {{end}}
  // WHERE id=@id
  UpdateInfo(user User, id int) error
}
```

---

For detailed examples, templates, and configuration, always refer to the official [README](https://github.com/go-gorm/cli#readme).


---

<AccordionGroup title="FAQ & Additional Tips">
<Accordion title="Why use interface methods instead of raw SQL queries?">
Expressive, type-safe APIs improve code reliability, IDE support, and reduce runtime errors by generating compile-time checked query methods.
</Accordion>
<Accordion title="What if my SQL template is complex?">
Use the SQL template DSL capabilities like `{{where}}`, `{{set}}`, `{{if}}`, `{{for}}` blocks to structure complex conditional queries elegantly.
</Accordion>
<Accordion title="Can I customize generated code output?">
Yes, declare a package-level `genconfig.Config` with `OutPath`, `FieldTypeMap`, and filters for tailored code layout and helper types.
</Accordion>
</AccordionGroup>