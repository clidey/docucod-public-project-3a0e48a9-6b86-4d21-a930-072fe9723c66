---
title: "SQL Template DSL: Conditional Logic and Dynamic Queries"
description: "Deep dive into the custom SQL template DSL: conditional fragments, dynamic columns, loops, and safe parameter binding. See real-world patterns and learn how to express complex business queries concisely in interface comments."
---

# SQL Template DSL: Conditional Logic and Dynamic Queries

Unlock the full power of GORM CLI's custom SQL template DSL with this comprehensive guide. Here, you will learn how to effectively write conditional SQL fragments, use dynamic columns, iterate over collections, and bind parameters safely — all within Go interface comments. This page dives into real-world patterns to express complex business logic concisely and maintainably through interface-embedded SQL templates.

---

## 1. Understanding the SQL Template DSL

GORM CLI generates type-safe query methods by parsing SQL templates defined in interface comments. These templates use a flexible mini-language designed to embed dynamic, conditional, and reusable SQL fragments right alongside your Go method signatures.

**Key capabilities include:**

- **Placeholders:**
  - `@@table` resolves to the model's table name.
  - `@@column` dynamically binds column names.
  - `@param` binds Go method parameters safely.

- **Directives:**
  - `{{where}}...{{end}}` builds conditional WHERE clauses.
  - `{{set}}...{{end}}` constructs dynamic SET clauses for UPDATEs.
  - `{{if condition}}...{{else}}...{{end}}` conditionally includes fragments.
  - `{{for ...}}...{{end}}` iterates over slices or range expressions.

These tokens transform your SQL into executable code that efficiently appends conditions and parameters without manual string concatenation or risking SQL injection.

---

## 2. Workflow Overview

**Task Description:** Write sophisticated SQL queries with dynamic conditions and loops inside Go interfaces using GORM CLI’s SQL Template DSL.

**Prerequisites:** 
- Familiarity with Go interfaces and method comments.
- A Go project setup with GORM CLI.
- Defined model structs corresponding to your database tables.

**Expected Outcome:**
- Ability to define conditional and dynamic SQL templates in interface comments.
- Generated code that safely and efficiently constructs SQL statements with parameters.
- Simplified complex SQL query logic embedded within your type-safe APIs.

**Time Estimate:** 20–30 minutes to understand and write exemplary queries.

**Difficulty Level:** Intermediate.

---

## 3. Writing Conditional SQL Templates

To express conditional logic, use the `{{if ...}}`, `{{else if ...}}`, and `{{else}}` directives inside `{{where}}` or `{{set}}` blocks. This enables optional filtering, updating only non-empty fields, or complex branching.

### Example — Conditional WHERE clause

```go
// Select user records filtering conditionally on ID or Name
// SELECT * FROM @@table
//   {{if user.ID > 0}}
//     WHERE id=@user.ID
//   {{else if user.Name != ""}}
//     WHERE name=@user.Name
//   {{end}}
QueryWith(user models.User) (T, error)
```

**What happens:**
- If `user.ID` is greater than zero, the query filters by `id`.
- Else if `user.Name` is non-empty, it filters by `name`.
- Otherwise, no WHERE clause is appended.

> Notice that `user` fields are accessed directly with `@user.Field` interpolation for parameters.

### Example — Conditional UPDATE SET clause

```go
// Update user fields if provided, defaulting the is_adult flag
// UPDATE @@table
//  {{set}}
//    {{if user.Name != ""}} name=@user.Name, {{end}}
//    {{if user.Age > 0}} age=@user.Age, {{end}}
//    {{if user.Age >= 18}} is_adult=1 {{else}} is_adult=0 {{end}}
//  {{end}}
// WHERE id=@id
UpdateInfo(user models.User, id int) error
```

**Result:**
- Only non-empty fields are set.
- `is_adult` is calculated conditionally.
- Trailing commas and spaces are cleanly trimmed by the generator.

---

## 4. Iteration Over Collections

The DSL supports looping over slices or collections with `{{for ...}}` directives, which lets you build complex OR filters or composite conditions dynamically.

### Example — Filtering with multiple users

```go
// SELECT * FROM @@table
// {{where}}
//   {{for _, user := range users}}
//     {{if user.Name != "" && user.Age > 0}}
//       (name = @user.Name AND age=@user.Age AND role LIKE concat("%",@user.Role,"%")) OR
//     {{end}}
//   {{end}}
// {{end}}
Filter(users []models.User) ([]T, error)
```

**Explanation:**
- For each `user` in the slice:
  - If `Name` is not empty and `Age` is greater than zero, a filter fragment is appended.
- All matching users are OR’d naturally.
- The DSL smartly trims ending connectors.

---

## 5. Parameter Binding and Safe SQL Generation

Use `@paramName` syntax to automatically bind method parameters or struct fields as query parameters.

- Parameters replaced in SQL as `?` placeholders with corresponding args appended.
- `@@table` and `@@column` insert safe table or column identifiers wrapped properly.
- Escape literal `@` with `\@` if needed inside SQL strings.

### Example — Dynamic Column and Parameter Binding

```go
// SELECT * FROM @@table WHERE @@column=@value
FilterWithColumn(column string, value string) (T, error)
```

Here, `@@column` is replaced by a column identifier from the `column` param, and `@value` safely binds the value.

---

## 6. Common Patterns and Use Cases

- **Conditional filtering:** Include filters only when conditions or fields are valid.
- **Dynamic updates:** Update only modified fields with `{{set}}` and `{{if}}`.
- **Bulk conditions:** Use `{{for}}` loops to OR multiple filters.
- **Zero-value checks:** Guard non-empty fields with `field != ""` or `field > 0`.

Consider this pattern a best practice for keeping queries efficient and your APIs clean.

---

## 7. Practical Tips & Best Practices

<Tip>
Indentation and line breaks inside templates are for readability only. The generator trims irrelevant whitespace.
</Tip>

<Tip>
Always validate your templates with `gorm gen` tooling and test generated queries.
</Tip>

<Tip>
Avoid SQL injection by relying exclusively on parameter bindings (`@param`) not interpolating raw strings.
</Tip>

<Tip>
When constructing multiple conditional filters, use `{{where}}` or `{{set}}` blocks to cleanly group expressions.
</Tip>

<Tip>
For complex WHERE conditions involving AND/OR, be mindful of connector trimming handled automatically.
</Tip>

---

## 8. Troubleshooting Common Issues

<Warning>
**Unmatched directive errors:**
Make sure every `{{if}}`, `{{for}}`, `{{where}}`, or `{{set}}` block has a corresponding `{{end}}`.
</Warning>

<Warning>
**Parameter binding mismatches:**
Parameters in your method signature must match those referenced via `@` in templates exactly.
</Warning>

<Warning>
**Escaped @ signs:**
If you need a literal `@` in SQL (e.g., email addresses), escape as `\@` to avoid parameter parsing.
</Warning>

<Note>
Check the generated Go code in the output directory for insight into template expansion and parameter handling.
</Note>

---

## 9. Putting It All Together — Example Interface

```go
package examples

import (
	"time"
	"gorm.io/cli/gorm/examples/models"
)

// Query interface with SQL template comments
// demonstrating conditional, dynamic, and loop logic
// methods produce fully type-safe, bind-parameterized queries.
type Query[T any] interface {
	// Simple select by ID
	// SELECT * FROM @@table WHERE id=@id AND name = "\@name"
	GetByID(id int) (T, error)

	// Dynamic column filter
	// SELECT * FROM @@table WHERE @@column=@value
	FilterWithColumn(column string, value string) (T, error)

	// Conditional filtering by struct fields
	// SELECT * FROM users
	//   {{if user.ID > 0}}
	//       WHERE id=@user.ID
	//   {{else if user.Name != ""}}
	//       WHERE name=@user.Name
	//   {{end}}
	QueryWith(user models.User) (T, error)

	// Dynamic updates with conditional SET
	// UPDATE @@table
	//  {{set}}
	//    {{if user.Name != ""}} name=@user.Name, {{end}}
	//    {{if user.Age > 0}} age=@user.Age, {{end}}
	//    {{if user.Age >= 18}} is_adult=1 {{else}} is_adult=0 {{end}}
	//  {{end}}
	// WHERE id=@id
	UpdateInfo(user models.User, id int) error

	// Filter over slice of users using loops and conditionals
	// SELECT * FROM @@table
	// {{where}}
	//   {{for _, user := range users}}
	//     {{if user.Name != "" && user.Age > 0}}
	//       (name = @user.Name AND age=@user.Age AND role LIKE concat("%",@user.Role,"%")) OR
	//     {{end}}
	//   {{end}}
	// {{end}}
	Filter(users []models.User) ([]T, error)

	// Using where clause shorthand for simple filters
t	// where("name=@name AND age=@age")
	FilterByNameAndAge(name string, age int)

	// Filtering records by creation time range
	// SELECT * FROM @@table
	//  {{where}}
	//    {{if !start.IsZero()}}
	//      created_at > @start
	//    {{end}}
	//    {{if !end.IsZero()}}
	//      AND created_at < @end
	//    {{end}}
	//  {{end}}
	FilterWithTime(start, end time.Time) ([]T, error)
}
```

---

## 10. Next Steps & Related Content

- Explore the [Interface-Driven Query APIs](/guides/query-and-model-helpers/interface-driven-queries) page for additional patterns using these templates.
- Learn about [Model Field Helpers](/guides/query-and-model-helpers/model-driven-field-helpers) to complement your queries with fluent filtering and updates.
- Review the [Basic Configuration](/getting-started/initial-configuration-and-first-use/basic-configuration) guide to tailor generation behaviors.
- Understand the [Architecture Overview](/overview/architecture-concepts/architecture-overview) for how parsing and code generation maps your interface comments to Go code.

---

By mastering conditional logic and dynamic queries in GORM CLI’s SQL Template DSL, you achieve highly expressive, maintainable, and type-safe database APIs completely embedded within familiar Go interfaces.

---