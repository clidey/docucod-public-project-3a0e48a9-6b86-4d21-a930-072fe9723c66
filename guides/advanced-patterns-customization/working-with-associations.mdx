---
title: "Working with Associations: Parent-Child, Many-to-Many"
description: "Demonstrates generating and using association helpers for all relationship types. Includes step-by-step recipes for common parent/child, many-to-many, and polymorphic relationship scenarios using generated code."
---

# Working with Associations: Parent-Child, Many-to-Many

This guide demonstrates how to use GORM CLI to generate and work with association helpers for various relationship types in Go projects using GORM. You will learn step-by-step how to create, update, unlink, delete, and batch operate on associations such as has-one, has-many, belongs-to, many-to-many, and polymorphic associations with type safety and fluent APIs.

---

## 1. Understanding Association Helpers in Generated Code

GORM CLI generates model-driven field helpers that correspond to associations defined in your Go models. Each association type exposes specific helpers to perform association operations in a type-safe fluent manner.

### Supported Association Types & Helpers
- **Has One / Belongs To**: Use `field.Struct[T]` for single record associations.
- **Has Many / Many-to-Many**: Use `field.Slice[T]` for multiple linked records.
- **Polymorphic Associations**: Also supported with generated helpers.

### Key Operations for Associations
- `Create(...)`: Create and associate a new child record.
- `CreateInBatch([]T)`: Batch create/link multiple records.
- `Update(...)`: Update associated records with optional conditions.
- `Unlink()`: Remove association without deleting associated records.
- `Delete()`: Delete associated records or join table rows.

These operations are composed with the GORM `Set(...).Update(ctx)` or `Set(...).Create(ctx)` calls for atomic and fluent updates.


## 2. Getting Started: Common Association Scenarios

Follow these step-by-step workflows to handle common parent-child and many-to-many relationship use cases.

### 2.1. Creating Associated Records

**Scenario:** Add a new associated record for a single parent.

```go
_, err := gorm.G[User](db).
  Where(generated.User.ID.Eq(parentID)).
  Set(
    generated.User.Pets.Create(generated.Pet.Name.Set("fido")),
  ).
  Update(ctx)
if err != nil {
  // handle error
}
```

**Outcome:** A new pet named “fido” is created and associated with the user having `parentID`.


### 2.2. Creating Associated Records for Multiple Parents

**Scenario:** Create one pet with the same name for each matched user.

```go
_, err := gorm.G[User](db).
  Where(generated.User.Name.In("alice", "bob")).
  Set(
    generated.User.Pets.Create(generated.Pet.Name.Set("multi-pet")),
  ).
  Update(ctx)
if err != nil {
  // handle error
}
```

**Outcome:** Each user named "alice" or "bob" will get a new pet "multi-pet".


### 2.3. Updating Associated Records Conditionally

**Scenario:** Rename a pet where the pet name is “old”.

```go
_, err := gorm.G[User](db).
  Where(generated.User.ID.Eq(userID)).
  Set(
    generated.User.Pets.Where(generated.Pet.Name.Eq("old")).Update(
      generated.Pet.Name.Set("new"),
    ),
  ).
  Update(ctx)
if err != nil {
  // handle error
}
```

**Outcome:** The user’s pet named "old" is renamed to "new".


### 2.4. Deleting Associated Records

**Scenario:** Delete associated records matching a condition.

```go
_, err := gorm.G[User](db).
  Where(generated.User.ID.Eq(userID)).
  Set(
    generated.User.Pets.Where(generated.Pet.Name.Eq("a")).Delete(),
  ).
  Update(ctx)
if err != nil {
  // handle error
}
```

**Outcome:** Deletes pets named "a" associated with the user.


### 2.5. Unlinking Associations Without Deletion

**Scenario:** Remove association link but keep associated rows.

```go
_, err := gorm.G[User](db).
  Where(generated.User.ID.Eq(userID)).
  Set(
    generated.User.Pets.Unlink(),
  ).
  Update(ctx)
if err != nil {
  // handle error
}
```

**Outcome:** The foreign key in pet records is set to NULL; rows remain intact.


### 2.6. Batch Creating/Linking for Has Many or Many-to-Many

**Scenario:** Batch link multiple pets to a user.

```go
pets := []models.Pet{{Name: "bm1"}, {Name: "bm2"}}

_, err := gorm.G[User](db).
  Where(generated.User.ID.Eq(userID)).
  Set(
    generated.User.Pets.CreateInBatch(pets),
  ).
  Update(ctx)
if err != nil {
  // handle error
}
```

**Outcome:** Both pets "bm1" and "bm2" are linked to the user in a single batch operation.


## 3. Detailed Recipes for All Association Types

Below are detailed practical examples for each association type including parent-child, many-to-many, and polymorphic associations.

### 3.1 Has One Association (e.g., User.Account)

- **Create a related record for an existing user:**
  ```go
  _, err := gorm.G[User](db).
    Where(generated.User.ID.Eq(uID)).
    Set(generated.User.Account.Create(generated.Account.Number.Set("A-001"))).
    Update(ctx)
  ```

- **Update the associated account conditionally:**
  ```go
  _, err := gorm.G[User](db).
    Where(generated.User.ID.Eq(uID)).
    Set(
      generated.User.Account.Where(generated.Account.Number.Eq("A-001")).Update(
        generated.Account.Number.Set("A-002"),
      ),
    ).
    Update(ctx)
  ```

- **Unlink the account (set foreign key NULL):**
  ```go
  _, err := gorm.G[User](db).
    Where(generated.User.ID.Eq(uID)).
    Set(generated.User.Account.Unlink()).
    Update(ctx)
  ```

- **Delete the account record:**
  ```go
  _, err := gorm.G[User](db).
    Where(generated.User.ID.Eq(uID)).
    Set(generated.User.Account.Delete()).
    Update(ctx)
  ```

### 3.2 Has Many Association (e.g., User.Pets)

- Follow the Create, Update, Unlink, Delete, and Batch Create patterns as above demonstrated in the common workflows (sections 2.1 - 2.6).

### 3.3 Belongs To Association (e.g., User.Company)

- **Update the associated company record:**
  ```go
  _, err := gorm.G[User](db).
    Where(generated.User.ID.Eq(uID)).
    Set(
      generated.User.Company.Where(generated.Company.Name.Eq("Acme")).Update(
        generated.Company.Name.Set("NewCo"),
      ),
    ).
    Update(ctx)
  ```

- **Unlink company from user (nullify foreign key):**
  ```go
  _, err := gorm.G[User](db).
    Where(generated.User.ID.Eq(uID)).
    Set(generated.User.Company.Unlink()).
    Update(ctx)
  ```

- Note: The company row remains intact.

### 3.4 Many-to-Many Association (e.g., User.Languages, User.Friends)

- **Create and link a new language:**
  ```go
  _, err := gorm.G[User](db).
    Where(generated.User.ID.Eq(uID)).
    Set(
      generated.User.Languages.Create(
        generated.Language.Code.Set("EN"),
        generated.Language.Name.Set("English"),
      ),
    ).
    Update(ctx)
  ```

- **Update language name:**
  ```go
  _, err := gorm.G[User](db).
    Where(generated.User.ID.Eq(uID)).
    Set(
      generated.User.Languages.Where(generated.Language.Code.Eq("EN")).Update(
        generated.Language.Name.Set("English-US"),
      ),
    ).
    Update(ctx)
  ```

- **Unlink language (removes join table row, keeps language):**
  ```go
  _, err := gorm.G[User](db).
    Where(generated.User.ID.Eq(uID)).
    Set(generated.User.Languages.Where(generated.Language.Code.Eq("EN")).Unlink()).
    Update(ctx)
  ```

- **Delete association (join row removed, language remains):**
  ```go
  _, err := gorm.G[User](db).
    Where(generated.User.ID.Eq(uID)).
    Set(generated.User.Languages.Where(generated.Language.Code.Eq("EN")).Delete()).
    Update(ctx)
  ```

- **Batch create/link multiple languages:**
  ```go
  langs := []models.Language{{Code: "B1"}, {Code: "B2"}}
  _, err := gorm.G[User](db).
    Where(generated.User.ID.Eq(uID)).
    Set(generated.User.Languages.CreateInBatch(langs)).
    Update(ctx)
  ```

### 3.5 Polymorphic Association (e.g., Pet.Toy)

- **Create and update a polymorphic toy:**
  ```go
  _, err := gorm.G[models.Pet](db).
    Where(generated.Pet.ID.Eq(petID)).
    Set(
      generated.Pet.Toy.Create(generated.Toy.Name.Set("ball")),
    ).
    Update(ctx)

  _, err = gorm.G[models.Pet](db).
    Where(generated.Pet.ID.Eq(petID)).
    Set(
      generated.Pet.Toy.Where(generated.Toy.Name.Eq("ball")).Update(generated.Toy.Name.Set("cube")),
    ).
    Update(ctx)
  ```

- **Unlink polymorphic association (sets owner_id to zero):**
  ```go
  _, err := gorm.G[models.Pet](db).
    Where(generated.Pet.ID.Eq(petID)).
    Set(generated.Pet.Toy.Unlink()).
    Update(ctx)
  ```

- **Delete polymorphic association:**
  ```go
  _, err := gorm.G[models.Pet](db).
    Where(generated.Pet.ID.Eq(petID)).
    Set(generated.Pet.Toy.Delete()).
    Update(ctx)
  ```


## 4. Practical Tips & Best Practices

- **Use `Where()` to scope association operations** when targeting specific associated records.
- **Unlink before Delete** if you want to keep associated records but remove links safely.
- **Batch operations improve efficiency** when linking multiple associated items.
- **Be mindful of association semantic differences:** 
  - `Unlink()` nullifies foreign keys or removes join rows without deleting data.
  - `Delete()` removes data (or join rows in many2many).
- **Check result counts after operations** to confirm expected effects.
- **Use generated helpers for compile-time safety and discoverability** instead of raw GORM syntax.


## 5. Troubleshooting Common Issues

<AccordionGroup title="Common Problems and Solutions">
<Accordion title="Association operation fails with no effect">
- Ensure you scoped the parent records properly using `Where` before `Set`.
- Confirm that the association name is correctly specified by the generated field helpers.
- Check for errors returned by `Update(ctx)` and handle them.
</Accordion>
<Accordion title="Batch creation or linking creates duplicates ">
- Verify input slice contains unique records to avoid duplicate associations.
- For many2many, unlink existing associations if needed before relinking.
</Accordion>
<Accordion title="Unlink doesn't nullify FK as expected">
- Confirm that the foreign key fields allow NULL values in your database.
- Verify association type supports unlink semantics as per GORM CLI documentation.
</Accordion>
<Accordion title="Created association rows don't have proper foreign keys">
- Check the parent filter matches only one record when using Create to prevent unintended associations.
- Validate generated code uses correct foreign key mappings.
</Accordion>
</AccordionGroup>

## 6. Next Steps & Related Content

- **[Configuring Generation: Customization with genconfig.Config](/guides/advanced-patterns-customization/configuring-codegen):** Customize your generated model and query code.
- **[Writing Custom Queries with SQL Template DSL](/guides/advanced-patterns-customization/sql-template-dsl):** Extend query interfaces with powerful templated SQL.
- **[Defining and Using Custom Field Helpers](/guides/advanced-patterns-customization/custom-field-helpers):** Incorporate JSON and other special types.
- **[Using the Generated APIs in Your Application](/guides/getting-started-workflows/using-generated-apis):** Learn to integrate generated code in your projects.

For foundational setup, see Getting Started guides, and for a detailed understanding of architecture and core concepts, consult the related overview documentation.

---

## Appendix: Code Snippet Example

```go
// Create one pet for a specific user
_, err := gorm.G[User](db).
  Where(generated.User.ID.Eq(1)).
  Set(generated.User.Pets.Create(generated.Pet.Name.Set("fido"))).
  Update(ctx)
if err != nil {
  log.Fatalf("failed to create pet: %v", err)
}

// Update a user's pet name
_, err = gorm.G[User](db).
  Where(generated.User.ID.Eq(1)).
  Set(generated.User.Pets.Where(generated.Pet.Name.Eq("fido")).Update(generated.Pet.Name.Set("rex"))).
  Update(ctx)
if err != nil {
  log.Fatalf("failed to update pet: %v", err)
}

// Unlink all pets from user without deleting
_, err = gorm.G[User](db).
  Where(generated.User.ID.Eq(1)).
  Set(generated.User.Pets.Unlink()).
  Update(ctx)
if err != nil {
  log.Fatalf("failed to unlink pets: %v", err)
}

// Batch create languages and link to user
langs := []models.Language{{Code: "EN"}, {Code: "FR"}}
_, err = gorm.G[User](db).
  Where(generated.User.ID.Eq(1)).
  Set(generated.User.Languages.CreateInBatch(langs)).
  Update(ctx)
if err != nil {
  log.Fatalf("failed batch link languages: %v", err)
}
```

---

This guide equips you with practical knowledge and actionable patterns to leverage GORM CLI's generated association helpers confidently and efficiently. By following these recipes and tips, managing complex database relationships becomes streamlined, predictable, and type-safe.
