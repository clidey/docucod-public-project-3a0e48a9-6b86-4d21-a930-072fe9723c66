---
title: "Project Structure: Patterns for Safe Code Generation"
description: "Shares organizational strategies for code and config placement, naming, and updating generated code to minimize merge conflicts and maximize team productivity as projects scale."
---

# Project Structure: Patterns for Safe Code Generation

Organizing your code and generated files effectively is crucial for maintaining productivity and avoiding merge conflicts in larger GORM CLI projects. This guide shares proven organizational strategies on where to place your query interfaces, model structs, generated code, and configuration files. You will learn how to name your files, structure your packages, and safely update generated code as your project scales from a single developer to a full team.

---

## 1. Why Structure Matters

Projects using GORM CLI grow by generating more code from interfaces and models. Unorganized generated files mixed with handwritten code cause:

- Merge conflicts when multiple developers generate code concurrently.
- Confusion about source versus generated code.
- Difficulty in managing customizations and configurations.

By adopting a clear structure, you ensure developers can focus on handwritten logic while generated code remains easily updatable and reproducible.

---

## 2. Recommended File Placement Strategy

A solid project layout distinguishes handwritten and generated code at the package and directory level.

### 2.1 Query Interfaces and Model Structs

Place your handwritten interfaces and models where your business logic resides, typically alongside your application domain code.

Example:

```plaintext
project-root/
  └─ examples/
      ├─ models/
      │   └─ user.go        # Your model structs
      └─ query.go           # Query interfaces with SQL templates
```

### 2.2 Generated Code

Direct all generated code into a dedicated output directory, outside your handwritten source tree. This keeps generated files isolated and easy to ignore in version control if needed.

Example:

```plaintext
project-root/
  └─ examples/
      └─ output/           # Generated helpers go here
          └─ user_gen.go
```

You control this location using the `-o` (output) flag with the CLI: 

```bash
gorm gen -i ./examples -o ./examples/output
```

### 2.3 Configuration Declarations

You can place your optional `genconfig.Config` declaration within the handwritten code package (e.g., `examples/query.go` or a separate `config.go`) to control generation behavior scoped to that package.

---

## 3. Naming Conventions to Minimize Conflicts

Consistent naming helps both GORM CLI and developers quickly identify code purpose.

- **Query Interfaces:** Use descriptive interface names prefixed with `Query`, e.g., `Query[T any]` or `QueryUser`.
- **Generated Files:** Append `_gen.go` or place generated files into a distinct folder like `output` or `generated`.

Example:

| File Name           | Content                     |
|---------------------|-----------------------------|
| `query.go`          | Handwritten query interface |
| `models/user.go`    | Handwritten model structs   |
| `output/user_gen.go`| Generated helpers           |

This clear distinction reduces the risk of developers editing generated files and merging conflicts.

---

## 4. Updating Generated Code Safely

When you run `gorm gen` multiple times, it overwrites files inside your output directory. To prevent accidental overwrites or conflicts:

- **Do NOT edit generated files.** Change source interfaces/models instead.
- Use version control ignores as needed, but it’s best to commit generated code for reproducibility.
- Keep generated code in dedicated directories.
- Use consistent `OutPath` settings via config or CLI flags.

This workflow ensures your team can regenerate code safely without merge issues.

---

## 5. Example Project Structure

Here’s a complete minimal structure illustrating these guidelines:

```plaintext
project-root/
├─ cmd/
│   └─ main.go               # App entry point
├─ examples/
│   ├─ models/
│   │   └─ user.go           # User model struct
│   ├─ filters/
│   │   └─ pattern/
│   │       └─ config.go     # genconfig.Config for filtering
│   ├─ query.go              # Query interface with SQL templates
│   └─ output/
│       └─ user_gen.go       # Generated code
└─ scripts/
    └─ test_all.sh           # Test scripts
```

This structure:

- Groups handwritten logic clearly.
- Isolates generated code for easy updates.
- Supports scalable development with descriptive naming.

---

## 6. Best Practices and Tips

- **Automate generation in CI**: Use scripts like `scripts/test_all.sh` to regenerate code before building.
- **Use package-level configuration**: Customize generation without repeating CLI flags.
- **Separate generated code from manual edits**: Avoid merge conflicts by never editing generated files.
- **Keep interfaces and models close**: This improves clarity and easier navigation.
- **Name output folders consistently** across your repos.

---

## 7. Troubleshooting Common Issues

<AccordionGroup title="Troubleshooting File and Merge Conflicts">
<Accordion title="My generated files keep getting merge conflicts.">
Make sure you commit generated code separately and avoid manual edits inside them. Keep generated files in a dedicated directory separate from handwritten code.
</Accordion>
<Accordion title="I don’t see my generated code where I expected it.">
Check the CLI `-o` flag value or your package-level `OutPath` inside `genconfig.Config`. By default, generated code goes to `./g` if not specified.
</Accordion>
<Accordion title="How do I customize which files get generated?">
Use `IncludeInterfaces`, `ExcludeInterfaces`, `IncludeStructs`, and `ExcludeStructs` in your `genconfig.Config`. Place this config in the handwritten source package.
</Accordion>
</AccordionGroup>

---

## 8. Next Steps

- Explore [Generating Code](https://gorm.io/docs/generating-code) to learn CLI usage with different flags.
- Read [Using Generated APIs](https://gorm.io/docs/using-generated-apis) to apply your generated query interfaces and helpers.
- Advance to [Working with Associations](https://gorm.io/docs/working-with-associations) to manage relations safely.

By following this structure and workflow, your team gains control over code generation and cohesive project organization, enabling confident scaling while minimizing friction.

---

## References

- GORM CLI [`README.md`](README.md) for overview
- [examples/query.go](examples/query.go) for query interface placement
- [examples/models/user.go](examples/models/user.go) for example model struct organization
- [internal/gen/gen.go](internal/gen/gen.go) CLI command implementation
- [examples/filters/pattern/config.go](examples/filters/pattern/config.go) for configuration example
- [examples/output/query_test.go](examples/output/query_test.go) for integration tests and usage

<Check>
When structuring your project, always keep handwritten and generated code separate to protect your workflow and maintain developer sanity.
</Check>
