---
title: "Integrating with GORM and Continuous Integration"
description: "Walks through how to seamlessly integrate generated code into GORM-powered apps and set up automated regeneration in CI/CD pipelines. Covers idempotency, testing, and versioning."
---

# Integrating with GORM and Continuous Integration

Seamlessly integrating the generated code from GORM CLI into your existing GORM-powered Go applications is essential to unlock the full benefits of type safety and reduced boilerplate. This guide walks you through best practices for integration, establishing idempotent generation workflows in CI/CD pipelines, testing considerations, and versioning strategies.

---

## 1. Integration Overview

### What This Guide Helps You Achieve
- Integrate GORM CLI-generated query APIs and field helpers into your GORM app smoothly
- Automate regeneration of code in continuous integration/continuous delivery (CI/CD) systems
- Maintain idempotent, reproducible builds that avoid merge conflicts and manual fixes
- Implement testing and version control best practices for generated code

### Prerequisites
- A working GORM-powered Go application
- Generated code from GORM CLI (`gorm gen` command) available in your repository
- Familiarity with using the generated APIs (see [Using Generated APIs](https://docs.example.com/getting-started/first-use-configuration/using-generated-apis))
- Access to your CI/CD tooling (GitHub Actions, Jenkins, GitLab CI, etc.)

### Expected Outcome
By following this guide, your project will include the generated code in a reproducible, testable, and maintainable way, with automated regeneration triggered on code/interface/model changes. This enables development teams to confidently rely on generated type-safe functions without manual intervention.

### Time Estimate
15–30 minutes for initial CI setup and integration steps

### Difficulty Level
Intermediate – requires knowledge of Go tooling, version control, and CI/CD concepts

---

## 2. Integrating Generated Code into Your GORM Applications

### 2.1 Placement and Import

1. **Organize Generated Code:**
   - Use the `-o` output flag to place generated code in a dedicated directory, e.g., `./generated`.
   - Keep generated code separated from handwritten sources to reduce merge conflicts and clarify ownership.

2. **Import Generated APIs:**
   - Import the generated package in your application code.
   - Use the generated query interfaces and field helpers exactly as documented in [Using Generated APIs](https://docs.example.com/getting-started/first-use-configuration/using-generated-apis).

3. **Example Usage:**

```go
import (
    "context"
    "gorm.io/gorm"
    "yourapp/generated"
    "yourapp/models"
)

func GetUserByID(ctx context.Context, db *gorm.DB, id int) (models.User, error) {
    return generated.Query[models.User](db).GetByID(ctx, id)
}
```

### 2.2 Managing Associations and Updates
- Handle associations using generated helpers, e.g., `generated.User.Pets.Create(...)`, facilitating safe and fluent related data operations.
- Follow the [Working with Associations](https://docs.example.com/guides/core-workflows/working-with-associations) guide to use association helper methods effectively.

### 2.3 Versioning Generated Code
- **Check generated code into version control** to ensure consistency between builds and share generated helpers with all team members.
- Use `.gitignore` carefully: avoid ignoring generated code directories to prevent mismatch between developers and CI.

<Tip>
Committing generated code ensures that your application builds do not depend on CI regeneration alone, improving developer experience and aiding debugging.
</Tip>

---

## 3. Setting Up Automated Regeneration in CI/CD Pipelines

Automating the code generation ensures changes to your query interfaces or models are always reflected in the generated helpers, avoiding stale code and runtime errors.

### 3.1 Idempotent Generation Workflow

- **Run the same `gorm gen` command on CI as in local development:**
  
```bash
gorm gen -i ./path/to/interfaces -o ./generated
```

- **Check whether generated files have changed:**
  - After generation, use a command like `git diff --exit-code ./generated` to fail builds if output differs unexpectedly.
  - This prevents accidental commits missing regenerated code.

- **Example CI snippet (bash):**

```bash
set -e

# Run generation
gorm gen -i ./interfaces -o ./generated

# Validate no changes
if ! git diff --quiet ./generated; then
  echo "Generated code does not match committed code. Please regenerate and commit."
  exit 1
fi
```

### 3.2 CI Pipeline Integration

- Add a step in your existing pipeline to run code generation and validation.
- Run tests only after generation validation to ensure API consistency.
- Consider caching dependencies but **never cache generated code** to keep pipelines fresh.

### 3.3 Handling Output Directory Consistency
- Always generate into the same output directory structure to keep imports stable.
- Match import paths in your codebase to generated code locations to avoid import errors.

<Tip>
Use the optional `genconfig.Config` in your input packages to override output paths consistently, avoiding hardcoded CLI flags mismatch.
</Tip>

---

## 4. Testing Considerations for Generated Code

### 4.1 Testing Your Queries and Models
- Use the generated query methods to perform integration tests against a real or in-memory database.
- Write tests in your `*_test.go` files importing the generated package.

### 4.2 Idempotency and Reproduction
- Confirm tests pass with freshly generated code after any interface or model change.
- Rerun `gorm gen` locally and in CI to verify results are stable and consistent.

### 4.3 Troubleshooting

<AccordionGroup title="Common Testing and Integration Issues">
<Accordion title="Generated Code Not Found or Import Errors">
Verify that your output directory aligns with import paths used in your code. Adjust the `-o` flag or `OutPath` in `genconfig.Config` to match the expected module structure.
</Accordion>
<Accordion title="CI Fails Due to Uncommitted Generated Code">
Make sure your pipeline runs code generation before compilation and checks for uncommitted changes. Educate developers to regenerate and commit before pushing.
</Accordion>
<Accordion title="Type Errors or Missing Methods After Changes">
Run `gorm gen` whenever query interfaces or model structs change. Check method signatures and generated files carefully.
</Accordion>
</AccordionGroup>

---

## 5. Versioning and Maintenance Best Practices

- **Commit generated code** on every relevant interface/model update.
- Use **meaningful commit messages** noting generated code changes.
- When upgrading the GORM CLI version, re-generate all code to reflect improvements and breaking changes.
- Avoid manual edits to generated files — instead, fix definitions in interfaces/models & re-run generation.

<Tip>
Maintain a clean separation between handwritten and generated code to simplify reviews and prevent accidental edits.
</Tip>

---

## 6. Recommended Workflow Summary

1. **Write/update your query interfaces and models.**
2. **Run `gorm gen` locally to generate helpers and APIs.**
3. **Commit generated code in version control.**
4. **Push changes triggering CI pipeline.**
5. **CI runs `gorm gen` and validates generated code matches committed code.**
6. **Run tests using the generated APIs.**
7. **Deploy with confidence knowing generated code and APIs are consistent.**

---

## 7. Additional Resources
- [Using Generated APIs](https://docs.example.com/getting-started/first-use-configuration/using-generated-apis)
- [Working with Associations](https://docs.example.com/guides/core-workflows/working-with-associations)
- [Generating Code](https://docs.example.com/getting-started/first-use-configuration/generating-code)
- [Basic Configuration](https://docs.example.com/getting-started/first-use-configuration/configuration-basics)

---

This guide ensures your GORM CLI integration into your Go apps is robust, maintainable, and scales well with continuous development and deployment workflows.


---