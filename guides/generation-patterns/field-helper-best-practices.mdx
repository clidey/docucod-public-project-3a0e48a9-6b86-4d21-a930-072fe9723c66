---
title: "Best Practices for Field Helpers & Predicates"
description: "Master efficient use of model-driven field helpers for building expressive and robust database queries and mutations. This guide covers predicate chaining, field selection, and advanced setter usage, promoting maintainable and idiomatic Go code."
---

# Best Practices for Field Helpers & Predicates

Master efficient use of model-driven field helpers to build expressive, type-safe, and maintainable database queries and mutations. This guide focuses exclusively on using the generated field helpers and predicates to construct filters, selectors, and setter expressions that align with idiomatic Go and GORM usage.

---

## Workflow Overview

### What You Will Achieve
This guide empowers you to leverage the power of **field helpers** generated by GORM CLI to write robust queries and updates with fluent, type-safe predicates and setters. You will learn how to chain predicates for filtering, use field setters in update and create operations, and handle zero values and complex SQL expressions cleanly.

### Prerequisites
- A Go project with models defined as structs.
- GORM CLI run to generate field helpers for your models (using `gorm gen`).
- Import of the generated field helpers package in your code.

### Expected Outcome
- Ability to write fluent and discoverable query predicates.
- Effective use of `Set(...)` with generated setters in create and update scenarios.
- Confidently combine conditional predicates and setters, including zero-value assignments and SQL expressions.

### Time Estimate
15–25 minutes to read and practice the examples.

### Difficulty Level
Intermediate (Basic understanding of GORM and Go generics assumed)

---

## Using Field Helpers Effectively

### 1. Building Expressive Predicates

Each model field is represented by a typed helper, e.g., `generated.User.Age`, `generated.User.Name`. They provide common predicate methods:

- Equality/inequality, e.g., `.Eq()`, `.Neq()`
- Comparison, e.g., `.Gt()`, `.Gte()`, `.Lt()`, `.Lte()`
- Range and inclusion, e.g., `.Between()`, `.In()`
- Null checks, e.g., `.IsNull()`, `.IsNotNull()`
- Pattern matching for strings, e.g., `.Like()`, `.NotLike()`

**Example:** Filtering users by age and role
```go
users, err := gorm.G[User](db).
  Where(
    generated.User.Age.Gt(18),
    generated.User.Role.Eq("active"),
  ).
  Find(ctx)
```

#### Predicate Chaining
Predicates can be combined seamlessly as variadic arguments to `Where()`. GORM CLI field helpers generate predicates that compose with `AND` semantics by default, promoting readable and maintainable code.

#### Filtering on Zero Values
Field helpers allow explicit filtering on zero values:
```go
// Find users where Age is 0 explicitly
users, err := gorm.G[User](db).
  Where(generated.User.Age.Eq(0)).
  Find(ctx)
```

### 2. Handling Null and Nullable Fields

If your model includes `sql.Null*` types or nullable database columns, field helpers also provide `IsNull()` and `IsNotNull()`:

```go
// Find users with NULL LastLogin
users, err := gorm.G[User](db).
  Where(generated.User.LastLogin.IsNull()).
  Find(ctx)

// Find accounts where RewardPoints is not null
accounts, err := gorm.G[Account](db).
  Where(generated.Account.RewardPoints.IsNotNull()).
  Find(ctx)
```

### 3. Use Advanced String Predicates
Use `.Like()` and `.NotLike()` to perform SQL LIKE queries:
```go
users, err := gorm.G[User](db).
  Where(generated.User.Name.Like("%jinzhu%"))
  .Find(ctx)
```

### 4. Using Setters for Updates and Creates

The `Set(...)` method accepts field helper setter operations to update or create entities fluently.

- `.Set(value)` sets fields to a specific value.
- `.SetExpr(clause.Expr)` uses raw SQL expressions.
- Special setters like `.Incr(n)` increment numeric fields.

**Updating existing records with setters**
```go
rowsAffected, err := gorm.G[User](db).
  Where(generated.User.Name.Eq("alice")).
  Set(
    generated.User.Role.Set("active"),
    generated.User.Age.Incr(1),
  ).
  Update(ctx)
```

**Creating new records with setters**
```go
err := gorm.G[User](db).
  Set(
    generated.User.Name.Set("bob"),
    generated.User.Age.Set(25),
  ).
  Create(ctx)
```

### 5. Handling Zero Values and Nulls in Setters

The field helpers allow you to explicitly set zero values, which is essential when you want to ensure that fields are updated with zero or nil values:

```go
// Zero out fields explicitly
rows, err := gorm.G[User](db).
  Where(generated.User.Name.Eq("cathy")).
  Set(
    generated.User.Role.Set(""),          // empty string
    generated.User.IsAdult.Set(false),     // false boolean
    generated.User.Score.Set(sql.NullInt64{}), // NULL
  ).
  Update(ctx)
```

### 6. Using SQL Expressions in Setters

With `.SetExpr()`, you can embed raw SQL expressions safely:

```go
rows, err := gorm.G[User](db).
  Where(generated.User.Name.Eq("bob")).
  Set(
    generated.User.Age.SetExpr(clause.Expr{SQL: "age + ?", Vars: []any{1}}),
  ).
  Update(ctx)
```

**Tip:** Use `clause.Expr` to build custom expressions without embedding unsafe SQL strings.

### 7. Common Setters and Helpers

Some useful setter and field helper methods include:

- `.Incr(n)`: Increment integer/number fields by *n*.
- `.Upper()`: For string fields, set the value to uppercase (using GORM assigner helpers).
- `.IsNull()`, `.IsNotNull()`: Filtering for nullable fields.

Example:
```go
rows, err := gorm.G[User](db).
  Where(generated.User.Name.Eq("alice")).
  Set(generated.User.Name.Upper()).
  Update(ctx)
```

---

## Examples

### Filtering Users Older Than 18 And Active
```go
var users []User
err := gorm.G[User](db).
  Where(
    generated.User.Age.Gt(18),
    generated.User.Role.Eq("active"),
  ).
  Find(ctx)
if err != nil {
  // handle error
}
```

### Update Role From "pending" To "active"
```go
rows, err := gorm.G[User](db).
  Where(generated.User.Role.Eq("pending")).
  Set(generated.User.Role.Set("active")).
  Update(ctx)
``` 

### Create User With Zero And Null Values Explicitly
```go
err := gorm.G[User](db).
  Set(
    generated.User.Name.Set("zero_user"),
    generated.User.Age.Set(0),
    generated.User.IsAdult.Set(false),
    generated.User.Score.Set(sql.NullInt64{}),
  ).
  Create(ctx)
```

### Increment Age By 3 For User Named "bob"
```go
_, err := gorm.G[User](db).
  Where(generated.User.Name.Eq("bob")).
  Set(generated.User.Age.Incr(3)).
  Update(ctx)
```

### Using Custom SQL Expression In Setter
```go
_, err := gorm.G[User](db).
  Where(generated.User.Name.Eq("bob")).
  Set(
    generated.User.Age.SetExpr(clause.Expr{SQL: "GREATEST(age, ?)", Vars: []any{18}}),
  ).
  Update(ctx)
```

---

## Troubleshooting & Tips

### I Get No Results Filtering On Fields
- Confirm you are using the exact generated field helper (check import and package).
- Verify filtering values are correct and types match.
- Use `.IsNull()` and `.IsNotNull()` predicates for nullable fields rather than equality checks with Go nil.

### Updates Seem Not To Persist
- Ensure that you’re calling `.Update(ctx)` after `.Set(...)`.
- Query the database directly to confirm no constraints or triggers silently reject updates.
- Use `.Set(field.Set(value))` to overwrite zero values explicitly—normal `.Update()` may skip zero values.

### Using `.SetExpr()` Produces SQL Errors
- Double-check your raw SQL syntax and placeholders.
- Use `clause.Column{Name: "col_name"}` inside Vars to refer to fields.
- Avoid SQL injections by never concatenating user input directly.

### Best Practices
- Always use generated field helpers, never hardcoded column names, for compile-time safety.
- Chain predicates in `Where()` for better readability and correctness.
- Use `Set()` for updates and creates to have a unified API.
- Use the `.Incr()` or `.SetExpr()` helpers for arithmetic updates rather than direct SQL strings.

---

## Next Steps & Related Content

- Explore [Managing Associations: Patterns and Examples](/guides/generation-patterns/association-operations-guide) to handle related data smoothly.
- Learn how to customize generation with [genconfig.Config](/guides/customization-integration/genconfig-config-guide) for tailored field helpers.
- Dive into [Template-based Query Generation](/guides/generation-patterns/template-sql-gen) for advanced query interface patterns.
- Review [Using Generated APIs in Your Application](/guides/getting-started/using-generated-apis) to integrate generated code effectively.

---

Harness the full power of GORM CLI generated field helpers to build clean, maintainable, and type-safe data access layers with confidence and agility.