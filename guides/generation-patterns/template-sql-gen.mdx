---
title: "Template-based Query Generation"
description: "Understand and utilize the SQL templating DSL for building dynamic, type-safe queries directly from Go interfaces. This guide explains template syntax, parameter injection, conditional clauses, and practical examples for real database scenarios."
---

# Template-based Query Generation

## Overview
This guide helps you master writing dynamic, type-safe SQL queries using GORM CLI's SQL templating DSL within Go interfaces. By defining SQL templates directly in method comments, you'll generate flexible, efficient query methods that seamlessly integrate with your Go projects powered by GORM.

### Prerequisites
- Go 1.18+ installed and configured
- GORM CLI installed (`go install gorm.io/cli/gorm@latest`)
- Basic familiarity with GORM and Go interfaces
- Defined Go structs as models and an understanding of how to embed SQL templates within interface methods

### Expected Outcome
After completing this guide, you will be able to:
- Write SQL queries using GORM CLI's templating syntax embedded in Go interface comments
- Use placeholders and advanced directives such as conditional clauses and loops to customize queries
- Bind Go method parameters safely to SQL statements without risking SQL injection
- Generate concise, type-safe query APIs that handle dynamic SQL behavior

### Time Estimate
30–45 minutes

### Difficulty Level
Intermediate

---

## Step-by-Step Instructions

### 1. Embed SQL Templates in Interface Method Comments
Write your query methods within a Go interface, embedding raw SQL or templated SQL in the method comment immediately preceding the method declaration.

Example:
```go
// SELECT * FROM @@table WHERE id=@id
GetByID(id int) (T, error)
```

- `@@table` resolves to the model's database table name
- `@id` binds the Go parameter `id` safely as a SQL parameter

### 2. Use Parameter Placeholders for Safe Binding
- Use `@param` to inject Go parameters into the SQL safely
- Use `@@column` to dynamically bind a column name from a string parameter

Example:
```go
// SELECT * FROM @@table WHERE @@column=@value
FilterWithColumn(column string, value string) (T, error)
```

This enables dynamic SQL filters tailored to your needs.

### 3. Use Conditional Blocks for Dynamic SQL
Use directives like `{{if condition}} ... {{end}}` to conditionally include SQL snippets based on parameter values.

Example:
```go
// SELECT * FROM @@table
// {{where}}
//   {{if name != ""}} name=@name {{end}}
//   {{if age > 0}} AND age=@age {{end}}
// {{end}}
SearchUsers(name string, age int) ([]T, error)
```

GORM CLI generates code that includes only relevant WHERE clauses based on the input.

### 4. Build Conditional UPDATE Statements
The `{{set}}` block lets you construct update SET statements dynamically.

Example:
```go
// UPDATE @@table
// {{set}}
//   {{if user.Name != ""}} name=@user.Name, {{end}}
//   {{if user.Age > 0}} age=@user.Age, {{end}}
// {{end}}
// WHERE id=@id
UpdateUser(user User, id int) error
```

This conditional inclusion ensures that only fields needing updates are included.

### 5. Use Loops to Generate Complex Filters
`{{for}}` enables iteration over collections to produce multiple conditions in a WHERE clause.

Example:
```go
// SELECT * FROM @@table
// {{where}}
//  {{for _, user := range users}}
//    {{if user.Name != "" && user.Age > 0}}
//      (name=@user.Name AND age=@user.Age) OR
//    {{end}}
//  {{end}}
// {{end}}
Filter(users []User) ([]T, error)
```

This builds compound OR conditions dynamically over a slice.

### 6. Generate Your Code
Run the GORM CLI generator with your interface file path:
```bash
gorm gen -i ./your/interfaces/path -o ./generated
```
This command compiles your interface's SQL templates into Go code providing type-safe query APIs.

### 7. Use the Generated APIs
Integrate the generated APIs into your Go application.

Example usage:
```go
user, err := generated.Query[User](db).GetByID(ctx, 123)
users, err := generated.Query[User](db).FilterByNameAndAge("jinzhu", 25).Find(ctx)
err = generated.Query[User](db).UpdateUser(ctx, User{Name: "jinzhu", Age: 20}, 1)
```

You benefit from compile-time safety with fluent, discoverable methods.

---

## Template DSL Reference

| Directive   | Purpose                          | Example Syntax                                |
|-------------|---------------------------------|-----------------------------------------------|
| `@@table`   | Resolves to model's table name   | `SELECT * FROM @@table WHERE id=@id`          |
| `@@column`  | Dynamic column binding           | `@@column=@value`                             |
| `@param`    | Binds Go params safely to SQL   | `WHERE name=@user.Name`                       |
| `{{where}}` | Conditional WHERE block          | `{{where}} age > 18 {{end}}`                  |
| `{{set}}`   | Conditional SET block for UPDATE| `{{set}} name=@name {{end}}`                  |
| `{{if}}`    | Conditional SQL fragment         | `{{if age > 0}} AND age=@age {{end}}`         |
| `{{for}}`   | Iterate collections for filters  | `{{for _, tag := range tags}} ... {{end}}`    |

---

## Practical Examples

### Simple Get By ID
```go
// SELECT * FROM @@table WHERE id=@id
GetByID(id int) (T, error)
```
Use this to fetch a record by primary key.

### Dynamic Column Filter
```go
// SELECT * FROM @@table WHERE @@column=@value
FilterWithColumn(column string, value string) (T, error)
```
This allows arbitrary column filters.

### Conditional Search
```go
// SELECT * FROM @@table
// {{where}}
//   {{if user.Name != ""}} name=@user.Name {{end}}
//   {{if user.Age > 0}} AND age=@user.Age {{end}}
// {{end}}
SearchUsers(user User) ([]T, error)
```
Fetch users filtered by optional fields.

### Update User Info
```go
// UPDATE @@table
// {{set}}
//   {{if user.Name != ""}} name=@user.Name, {{end}}
//   {{if user.Age > 0}} age=@user.Age, {{end}}
// {{end}}
// WHERE id=@id
UpdateInfo(user User, id int) error
```
Update selectively only specified fields.

### Complex Filter with Loop
```go
// SELECT * FROM @@table
// {{where}}
//   {{for _, user := range users}}
//     {{if user.Name != "" && user.Age > 0}}
//       (name=@user.Name AND age=@user.Age) OR
//     {{end}}
//   {{end}}
// {{end}}
Filter(users []User) ([]T, error)
```
Builds dynamic OR clauses for multiple records.

---

## Troubleshooting & Tips

<AccordionGroup title="Common Issues and Solutions">
<Accordion title="SQL Template Parse Errors">
- Check for unmatched `{{end}}` directives in your SQL comment blocks.
- Verify correct syntax for `if`, `else if`, `else` and loop constructs.
- Use the exact identifier names for parameters as used in method signatures.
</Accordion>
<Accordion title="Parameter Binding Problems">
- Ensure parameters in SQL templates match method parameter names.
- Avoid using Go-specific types unsupported in templates; stick to basic or mapped types.
</Accordion>
<Accordion title="Conditional Logic Unexpected Behavior">
- Confirm boolean expressions inside `{{if}}` blocks evaluate correctly and use Go syntax.
- Avoid complex expressions; simplify where possible.
</Accordion>
</AccordionGroup>

<Tip>
Use the `{{where}}` and `{{set}}` blocks to ensure proper placement of SQL keywords and avoid building invalid SQL. This dramatically enhances query flexibility while keeping your code readable.
</Tip>

<Info>
Remember that all parameters preceded by `@` are safely bound by GORM, preventing SQL injection.
</Info>

---

## Next Steps & Related Content

- [Using Generated APIs in Your Application](./using-generated-apis) — Learn how to integrate the generated functions for filtering, updates, and transactions.
- [Define Models & Query Interfaces](./define-models-interfaces) — Guide for good model and interface design patterns to maximize generation benefits.
- [Running the Code Generator](./run-code-generator) — Detailed instructions and configuration options for generation.
- [Field Helper Best Practices](../generation-patterns/field-helper-best-practices) — Advanced usage of field helpers to build powerful queries.

Explore these pages to extend your mastery and fully leverage GORM CLI’s power in your projects.

---