---
title: "Template-Based SQL Queries"
description: "Master the use of query interfaces with SQL templates to define expressive, type-safe, and dynamic access methods. This guide covers writing templates with placeholders, conditional logic, and parameter injection, backed by comprehensive examples."
---

# Template-Based SQL Queries

Master the use of query interfaces with SQL templates to define expressive, type-safe, and dynamic access methods. This guide covers writing templates with placeholders, conditional logic, and parameter injection, backed by comprehensive examples.

---

## 1. Overview

### What You Will Achieve
This guide helps you write and leverage SQL templates inside Go interface method comments to generate type-safe, flexible query APIs for your GORM models. Using SQL templates, you will create complex queries incorporating parameters, conditionals, and dynamic SQL fragments, all while maintaining compile-time safety and seamless integration with GORM.

### Prerequisites
- Familiarity with Go interfaces and method comments.
- A GORM CLI setup generating code from query interfaces.
- Basic understanding of SQL and GORM querying.

### Outcome
After following this guide, you'll master the syntax and practical usage of GORM CLI's SQL templating DSL to build precise, reusable, readable, and maintainable query methods.

### Time Estimate
About 20-30 minutes to work through examples and attempt custom templates.

### Difficulty Level
Intermediate â€” requires understanding both Go and SQL concepts, plus some awareness of templating logic.

---

## 2. Understanding SQL Templates in Query Interfaces

### What Are SQL Templates?
SQL templates are special formatted SQL statements written inside method comments of query interfaces, where placeholders and directives dynamically bind Go function parameters and control query structure.

### Key Features
- **Placeholders**: Translate method parameters to safe SQL parameters
- **Dynamic Table & Column**: Use `@@table` and `@@column` placeholders to dynamically refer to model table and columns
- **Logic Blocks**: Use `{{where}}`, `{{set}}`, `{{if}}`, `{{for}}` blocks for dynamic SQL generation

### How It Works
- Method comments contain SQL templates.
- GORM CLI parses these comments, converting placeholders and templates into Go code.
- Generated methods accept parameters and produce safe, native GORM queries.

---

## 3. Template Syntax and Directives

| Directive    | Purpose                          | Example                              |
|--------------|---------------------------------|------------------------------------|
| `@@table`    | Resolves to the model's table name | `SELECT * FROM @@table WHERE id=@id`|
| `@@column`   | Dynamic column binding           | `@@column=@value`                   |
| `@param`     | Maps Go param to SQL param       | `WHERE name=@user.Name`             |
| `{{where}}`  | Conditional WHERE clause builder | `{{where}} age > 18 {{end}}`        |
| `{{set}}`    | Conditional SET clause for UPDATE | `{{set}} name=@name {{end}}`       |
| `{{if}}`     | Conditional SQL fragments         | `{{if age > 0}} AND age=@age {{end}}`|
| `{{for}}`    | Iteration over collections        | `{{for _, tag := range tags}} ... {{end}}`|

---

## 4. Writing SQL Templates: Step-by-Step Guide

<Steps>
<Step title="Step 1: Define a Query Interface Method with SQL Template">
Write a Go interface method with a comment containing your SQL template.

```go
// SELECT * FROM @@table WHERE id=@id
GetByID(id int) (T, error)
```

The placeholders `@@table` and `@id` dynamically bind to your model's table name and the `id` parameter.
</Step>

<Step title="Step 2: Use Placeholders for Dynamic Columns and Parameters">
Include dynamic placeholders for columns and values.

```go
// SELECT * FROM @@table WHERE @@column=@value
FilterWithColumn(column string, value string) (T, error)
```

Here, the column name and value are parameters, mapped to safe SQL.
</Step>

<Step title="Step 3: Add Conditional Logic with {{where}} and {{if}}">
Use `{{where}}` blocks to conditionally include WHERE clauses.

```go
// SELECT * FROM @@table
// {{where}}
//   {{if user.ID > 0}} id=@user.ID {{end}}
//   {{if user.Name != ""}} AND name=@user.Name {{end}}
// {{end}}
QueryWith(user User) (T, error)
```

Each if condition controls whether a part of the WHERE is included.
</Step>

<Step title="Step 4: Build Dynamic UPDATE Statements with {{set}}">
Inside UPDATE methods, use `{{set}}` for conditional SET parts:

```go
// UPDATE @@table
// {{set}}
//   {{if user.Name != ""}} name=@user.Name, {{end}}
//   {{if user.Age > 0}} age=@user.Age, {{end}}
// {{end}}
// WHERE id=@id
UpdateUser(user User, id int) error
```
</Step>

<Step title="Step 5: Use Iteration {{for}} for Collections">
Loop over slices to extend queries dynamically.

```go
// SELECT * FROM @@table
// {{where}}
//   {{for _, user := range users}}
//     {{if user.Name != "" && user.Age > 0}}
//       (name=@user.Name AND age=@user.Age) OR
//     {{end}}
//   {{end}}
// {{end}}
Filter(users []User) ([]T, error)
```
</Step>
</Steps>

---

## 5. Practical Examples

### Example 1: Simple Select by ID
```go
// SELECT * FROM @@table WHERE id=@id
GetByID(id int) (T, error)
```
Call:
```go
u, err := generated.Query[User](db).GetByID(ctx, 123)
```
Expected SQL:
```sql
SELECT * FROM users WHERE id = ?
```

### Example 2: Conditional WHERE
```go
// SELECT * FROM @@table
// {{where}}
//   {{if user.ID > 0}} id=@user.ID {{end}}
//   {{if user.Name != ""}} AND name=@user.Name {{end}}
// {{end}}
QueryWith(user User) (T, error)
```
Invoke with a partially filled User struct to build flexible filters.

### Example 3: Dynamic UPDATE with SET Block
```go
// UPDATE @@table
// {{set}}
//   {{if user.Name != ""}} name=@user.Name, {{end}}
//   {{if user.Age > 0}} age=@user.Age {{end}}
// {{end}}
// WHERE id=@id
UpdateUser(user User, id int) error
```
This updates only fields where conditions are true.

### Example 4: Iteration in WHERE
```go
// SELECT * FROM @@table
// {{where}}
//   {{for _, user := range users}}
//     {{if user.Name != "" && user.Age > 0}}
//        (name=@user.Name AND age=@user.Age) OR
//     {{end}}
//   {{end}}
// {{end}}
Filter(users []User) ([]T, error)
```
Useful for filtering by a list of criteria dynamically.

---

## 6. Tips and Best Practices

- **Escape `@` with `\@`**: To use a literal `@` in SQL, escape it inside comments.
- **Always return error last**: Generated methods expect the last return type as `error`.
- **Use explicit `context.Context` or let generator add it**: The CLI adds `ctx` if missing.
- **Structure if and for blocks carefully**: Avoid unmatched or nested logic that is unclear.
- **Use `@@table` always for table name**: Avoid hardcoding table names to stay flexible.
- **Avoid complex SQL string concatenation inside templates**: Use directives for clarity and maintainability.

---

## 7. Common Pitfalls and Troubleshooting

<AccordionGroup title="Common Issues with Template-Based SQL Queries">
<Accordion title="Unrecognized Directive Errors">
 Verify that all `{{...}}` directives are supported: `where`, `set`, `if`, `else if`, `else`, `for`, and `end`. Check for typos in directives.
</Accordion>
<Accordion title="Mismatched `{{end}}` or Missing Blocks">
 Every block opened with `{{if}}`, `{{for}}`, or `{{where}}` must be properly closed with a corresponding `{{end}}`.
 Use indentation and comments to keep track.
</Accordion>
<Accordion title="Placeholders Not Resolving as Expected">
 Use `@@table` instead of hardcoded table names for correct resolution.
 Ensure parameter names in SQL match exactly the method parameter or struct field names.
 Escape literal @ signs with `\@`.
</Accordion>
<Accordion title="Generated Code Syntax Errors">
 Carefully check method return types follow expectations: one or two return values, second must be `error`.
 Ensure method comments contain a valid SQL template; otherwise, generation may fail.
</Accordion>
</AccordionGroup>

---

## 8. Next Steps

- Explore the [Using Generated Field Helpers](/guides/getting-started-workflows/using-field-helpers) guide to combine templates with strongly typed fields
- Learn about [Managing Associations](/guides/advanced-usage-patterns/working-with-associations) to handle relational queries
- Consult the [Generate Type-Safe Code](/getting-started/first-steps/generate-code) guide to understand full generation workflow
- Deep dive into [Core Concepts & Terminology](/overview/concepts-architecture-flow/core-concepts-terminology) for architectural insight

---

## 9. Appendix: Example Interface Snippet with Templates

```go
package examples

// Query interface with templated SQL methods
// Note: templates go inside method comments

type Query[T any] interface {
  // SELECT * FROM @@table WHERE id=@id
  GetByID(id int) (T, error)

  // SELECT * FROM @@table WHERE @@column=@value
  FilterWithColumn(column string, value string) (T, error)

  // SELECT * FROM @@table
  // {{where}}
  //   {{if user.ID > 0}} id=@user.ID {{end}}
  //   {{if user.Name != ""}} AND name=@user.Name {{end}}
  // {{end}}
  QueryWith(user User) (T, error)

  // UPDATE @@table
  // {{set}}
  //   {{if user.Name != ""}} name=@user.Name, {{end}}
  //   {{if user.Age > 0}} age=@user.Age {{end}}
  // {{end}}
  // WHERE id=@id
  UpdateUser(user User, id int) error

  // SELECT * FROM @@table
  // {{where}}
  //   {{for _, user := range users}}
  //     {{if user.Name != "" && user.Age > 0}}
  //       (name=@user.Name AND age=@user.Age) OR
  //     {{end}}
  //   {{end}}
  // {{end}}
  Filter(users []User) ([]T, error)

  // where("name=@name AND age=@age")
  FilterByNameAndAge(name string, age int)

  // SELECT * FROM @@table
  // {{where}}
  //   {{if !start.IsZero()}} created_at > @start {{end}}
  //   {{if !end.IsZero()}} AND created_at < @end {{end}}
  // {{end}}
  FilterWithTime(start, end time.Time) ([]T, error)
}
```

---

<Note>
This template-based approach lets you express highly flexible SQL operations directly within your Go interfaces while ensuring generated code is strongly typed and safe. It bridges SQL expressiveness with Go interface clarity.
</Note>
