---
title: "Customizing Code Generation with Configurations"
description: "Guide to using and extending the `genconfig.Config` system for output paths, field type mapping, include/exclude patterns, and file/package-level overrides. Explains best-practices for declaring and organizing config in your project."
---

# Customizing Code Generation with Configurations

This guide explains how to use and extend the `genconfig.Config` system in GORM CLI to customize code generation. It focuses on defining output paths, field type mappings, include/exclude patterns, and file- or package-level overrides. Follow this guide to organize and declare your generation configuration effectively for targeted, maintainable, and flexible code output.

---

## 1. Introduction to Configuration in GORM CLI

GORM CLI provides a powerful configuration struct, `genconfig.Config`, which you can declare in your Go packages to control generation behavior. The generator automatically detects this config in your source code and applies specified overrides during code generation.

This system allows you to tailor:

- Where generated files are written (`OutPath`)
- How Go field types map to generated field helpers (`FieldTypeMap`)
- How named field tags map to custom field helpers (`FieldNameMap`)
- Which interfaces and structs are included or excluded from generation (`IncludeInterfaces`, `ExcludeInterfaces`, `IncludeStructs`, `ExcludeStructs`)
- Whether configurations apply at the file or package level (`FileLevel`)

### Why Use Generation Configuration?

Imagine a growing project with diverse packages and complex models. A single output directory or default type mappings might not suit all cases. Configurations enable you to:

- Organize your generated code output logically per package.
- Use custom field helpers for specific data types or tagged fields.
- Avoid generating deprecated or irrelevant code by filtering interfaces and structs.
- Apply granular overrides at file or package scopes for fine-tuned control.

---

## 2. Prerequisites

Before configuring code generation, ensure you have:

- Installed GORM CLI (Go 1.18+).
- Defined your query interfaces and model structs.
- Familiarity with Go model struct tags.

---

## 3. Expected Outcome

By the end of this guide, you will be able to:

- Declare a `genconfig.Config` instance within a package.
- Map Go field types and tag names to custom field helpers.
- Control which interfaces and structs are generated.
- Configure output directories per package or file.

---

## 4. Declaration and Structure of `genconfig.Config`

Declare the configuration as a package-level variable assigned to `genconfig.Config`. The generator will automatically detect and apply it.

Example template:

```go
package yourpackage

import (
	"database/sql"
	"gorm.io/cli/gorm/field"
	"gorm.io/cli/gorm/genconfig"
)

var _ = genconfig.Config{
	OutPath: "your/output/path",
	FieldTypeMap: map[any]any{
		sql.NullTime{}: field.Time{},
	},
	FieldNameMap: map[string]any{
		"date": field.Time{},
		"json": JSON{}, // custom helper
	},
	FileLevel:         false, // apply to whole package
	IncludeInterfaces: []any{"Query*", models.Query(nil)},
	ExcludeInterfaces: []any{"*Deprecated*"},
	IncludeStructs:    []any{"User", "Account*", models.User{}},
	ExcludeStructs:    []any{"*DTO"},
}
```

### Key Fields Explained

| Field               | Purpose                                                                                 |
|---------------------|-----------------------------------------------------------------------------------------|
| `OutPath`           | Overrides the CLI's `-o` output directory for the package or file.                      |
| `FieldTypeMap`      | Maps specific Go field types (e.g., `sql.NullTime{}`) to custom field helpers.          |
| `FieldNameMap`      | Maps `gen` struct tag names (e.g., `json`) to custom helpers. Takes priority over `FieldTypeMap` |
| `FileLevel`         | When true, config applies only to the specific file instead of the entire package.      |
| `IncludeInterfaces` | Whitelist for interface types to generate by pattern or type literal.                   |
| `ExcludeInterfaces` | Blacklist for interface types to skip, applied after inclusion.                        |
| `IncludeStructs`    | Whitelist for struct types by pattern or type literal.                                 |
| `ExcludeStructs`    | Blacklist for struct types to exclude, applied after inclusion.                        |

---

## 5. Step-by-Step Instructions

### Step 1: Create Your Config Declaration

In any source file of your target package that the generator will scan, declare a `var _ = genconfig.Config{...}` with your customization options.

**Example:**

```go
package examples

import (
	"database/sql"
	"gorm.io/cli/gorm/field"
	"gorm.io/cli/gorm/genconfig"
)

var _ = genconfig.Config{
	OutPath: "examples/output",
	FieldTypeMap: map[any]any{
		sql.NullTime{}: field.Time{},
	},
	FieldNameMap: map[string]any{
		"json": JSON{},
	},
	IncludeStructs: []any{},
}
```

*Outcome:* This config tells the generator to emit files under `examples/output`, use `field.Time{}` for `sql.NullTime`, and use the custom `JSON{}` helper for fields tagged with `gen:"json"`.


### Step 2: Use Proper Values in Field Mapping

In `FieldTypeMap`, keys are instances of Go field types (e.g., `sql.NullTime{}`), and values are instances of wrapper types (`field.Time{}`, or your own custom helper). The generator detects imports and renders code accordingly.

In `FieldNameMap`, keys are strings matching the `gen` struct tag name, and values are similarly typed instances.

**Tip:** `FieldNameMap` takes precedence when a field has a matching `gen` tag.


### Step 3: Use Include and Exclude Filters

Control which interfaces and structs get generated to reduce noise and focus on relevant types.

- Use shell-style string patterns (`"Query*"`, `"*Deprecated*"`) or type literals (`models.Query(nil)`, `models.User{}`).

- Inclusion lists (`IncludeInterfaces`, `IncludeStructs`) act as whitelists.
  If non-empty, only matching types are generated.

- Exclusion lists (`ExcludeInterfaces`, `ExcludeStructs`) act as blacklists applied after inclusions.

Example:

```go
IncludeInterfaces: []any{"Query*"},
ExcludeInterfaces: []any{"*Deprecated*"},
IncludeStructs:    []any{"User", "Account*"},
ExcludeStructs:    []any{"*DTO"},
```


### Step 4: Set `FileLevel` for Granular Control

By default, if `FileLevel` is `false` (the default), the config applies at the package level, affecting all files under that package/directory. When set to `true`, the configuration affects only the file where it is declared.

**Use case:**

You want a package-wide output directory but need some file-level overrides for certain files.


### Step 5: Run the Generator with Your Config Active

Run the CLI command normally, specifying the input path:

```bash
gorm gen -i ./examples -o ./generated
```

The generator will detect your `genconfig.Config` declarations, apply per-package or per-file settings, and generate code accordingly.


---

## 6. Real-World Configuration Examples

### Example 1: Basic JSON Field Helper Mapping

```go
package examples

import (
	"gorm.io/cli/gorm/genconfig"
)

// Declares JSON helper for fields tagged `gen:"json"`
var _ = genconfig.Config{
	OutPath: "examples/output",
	FieldNameMap: map[string]any{
		"json": JSON{},
	},
}
```

Model struct usage:

```go
package models

type User struct {
	Profile string `gen:"json"`
}
```

The generator uses your custom `JSON` field helper for the `Profile` field.


### Example 2: Filtering by Interface Name Pattern

```go
package pattern

import "gorm.io/cli/gorm/genconfig"

var _ = genconfig.Config{
	IncludeInterfaces: []any{"Query*"},
}
```

Only interface types with names starting with "Query" are generated.


### Example 3: File-Level Exclusion

```go
package nested

import "gorm.io/cli/gorm/genconfig"

// Config excludes some interface and struct types in this package
var _ = genconfig.Config{
	FileLevel:         false,
	ExcludeInterfaces: []any{"I3"},
	ExcludeStructs:    []any{"S3"},
}
```

---

## 7. Practical Tips and Best Practices

- **Place configs near related models and interfaces:** This improves discoverability and encapsulation.
- **Use patterns thoughtfully:** Wildcards like `"Query*"` can simplify large projects.
- **Prefer `FieldNameMap` for custom tags:** Makes it explicit how tagged fields behave.
- **Set `FileLevel` only when needed:** Per-file configs add complexity; prefer package-level configs unless overriding.
- **Validate generated outputs:** After config changes, verify your generated files for intended effects.

---

## 8. Common Pitfalls & Troubleshooting

<AccordionGroup title="Configuration Troubleshooting">
<Accordion title="Config Not Applied to Output">
- Ensure `genconfig.Config` is declared at package level (not inside functions).
- Check if `FileLevel` is set correctly for your use case.
- Verify your input path and package structure match the config scope.
</Accordion>
<Accordion title="Custom Field Helpers Not Used">
- Confirm `FieldTypeMap` keys use type instances (e.g., `sql.NullTime{}`), not just string names.
- Confirm `FieldNameMap` keys correspond exactly to the `gen` struct tag values.
- Ensure your custom helper types are imported and accessible.
</Accordion>
<Accordion title="Include/Exclude Filtering Issues">
- Inclusion acts as a whitelist: if non-empty, only matching names are generated.
- Exclusion is applied after inclusion: excluded names never generate.
- Use full package-qualified patterns (e.g., `models.User`) or wildcard patterns.
</Accordion>
</AccordionGroup>

---

## 9. Next Steps & Related Content

- Review [Generating Type-Safe Query APIs](/guides/core-workflows/generate-type-safe-queries) to optimize interface generation.
- Explore [Generating Model-driven Field Helpers](/guides/core-workflows/generate-field-helpers) for field helper mastery.
- Dive into [Mastering the SQL Template DSL](/guides/advanced-usage-patterns/template-sql-dsl) for powerful query customizations.
- Check [Handling JSON Columns with Custom Field Helpers](/guides/advanced-usage-patterns/json-field-helpers) for extended helper customization.

---