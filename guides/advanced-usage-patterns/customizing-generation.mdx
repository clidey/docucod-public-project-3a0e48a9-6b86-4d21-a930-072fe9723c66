---
title: "Customizing Generation with Configurations"
description: "Unlock advanced generation scenarios by using the configuration system. Learn how to override output paths, map custom types, control field and interface inclusion, and extend field helpers for JSON or other custom fields. Includes in-depth examples and recommendations."
---

# Customizing Generation with Configurations

Unlock advanced generation scenarios using GORM CLI's configuration system. This guide empowers you to tailor code generation by overriding output paths, mapping custom Go types to generated field helpers, controlling which interfaces and structs are included or excluded, and extending field helpers to support JSON or other custom data types.

---

## 1. Why Customize Generation?
GORM CLI generates powerful, type-safe query APIs and model-driven field helpers by default. However, complex projects often require additional control:

- Organize generated code in custom directories.
- Map specialized Go types or struct tags to custom field helper implementations.
- Include only specific interfaces or structs, or exclude deprecated or unwanted ones.
- Extend code generation to support JSON or other custom column types.

This page guides you step-by-step to unlock these advanced capabilities.

---

## 2. Prerequisites
- Familiarity with GORM CLI's basic usage and code generation process.
- A Go project with defined models and query interfaces.
- GORM CLI installed (`go install gorm.io/cli/gorm@latest`).
- Understanding of Go struct tags and basic Go type system.

---

## 3. Expected Outcome
After completing this guide, you will be able to configure GORM CLI to:

- Direct generated code to your preferred output path.
- Map complex types to specialized field helpers seamlessly.
- Filter generation by specifying exactly which interfaces and structs to include or exclude.
- Define and use custom field helpers for JSON or other custom column types.

---

## 4. Time Estimate
Approximately 20-30 minutes for thorough reading, setup, and experimentation.

---

## 5. Step-by-Step Instructions

### Step 1: Declare a Package-Level `genconfig.Config`
To customize generation, define a package-level variable of type `genconfig.Config` in any Go source file within the package you are generating.

```go
package examples

import (
  "database/sql"
  "gorm.io/cli/gorm/field"
  "gorm.io/cli/gorm/genconfig"
)

var _ = genconfig.Config{
  OutPath: "examples/output", // Override default output directory
  FieldTypeMap: map[any]any{
    sql.NullTime{}: field.Time{}, // Map sql.NullTime to field.Time helper
  },
  FieldNameMap: map[string]any{
    "date": field.Time{},       // Use field.Time for `gen:"date"` tag
    "json": JSON{},             // Use custom JSON helper for `gen:"json"` tag
  },

  IncludeInterfaces: []any{"Query*"}, // Generate only interfaces starting with 'Query'
  ExcludeInterfaces: []any{"*Deprecated*"}, // Exclude any with 'Deprecated' in name

  IncludeStructs: []any{"User", "Account*"}, // Generate only selected struct types
  ExcludeStructs: []any{"*DTO"},               // Exclude all structs ending with 'DTO'
}
```

<Check>
Declaring `genconfig.Config` variable applies the configuration automatically to the current package and any files it processes.
</Check>

---

### Step 2: Control Output Path

Customize where generated files are saved by setting `OutPath`. This overrides the CLI `-o` flag for the package this config is in (unless CLI flag is different).

```go
OutPath: "my/custom/path",
```

This keeps your generated code organized exactly how your project demands.

---

### Step 3: Map Custom Types to Field Helpers

When your models contain types that GORM CLI does not map by default (like `sql.NullTime` or custom JSON), map them via `FieldTypeMap`.

```go
FieldTypeMap: map[any]any{
  sql.NullTime{}: field.Time{}, // use standard time helper for sql.NullTime
},
```

This instructs GORM CLI to replace all such fields with the specified field helper, ensuring fluent predicate and update syntax.

---

### Step 4: Map Named Field Tags to Custom Helpers

Sometimes you want fields with particular struct tags (e.g., `gen:"json"`) to use custom helpers.

In `FieldNameMap`, specify the tag value and corresponding helper:

```go
FieldNameMap: map[string]any{
  "json": JSON{}, // custom JSON helper defined by you
},
```

In your model, add the tag:

```go
type User struct {
  // ... other fields ...
  Profile string `gen:"json"`
}
```

---

### Step 5: Include or Exclude Interfaces and Structs

You can precisely control which query interfaces or structs are generated with these filters:

- `IncludeInterfaces` and `ExcludeInterfaces`: Use shell-style patterns or type literals (`models.Query(nil)`) to whitelist or blacklist interfaces.
- `IncludeStructs` and `ExcludeStructs`: Filter model structs with patterns or type literals (`models.User{}`).

**Example:**

```go
IncludeInterfaces: []any{"Query*"},
ExcludeInterfaces: []any{"*Deprecated*"},

IncludeStructs: []any{"User", "Account*"},
ExcludeStructs: []any{"*DTO"},
```

<Info>
The whitelist (`Include*`) takes precedence over exclude filters. If you specify an include list, only those matching items will be generated.
</Info>

---

### Step 6: Define a Custom JSON Field Helper

Custom field helpers allow you to extend code generation to special column types like JSON. Here’s how to implement a JSON helper that generates database-specific SQL.

```go
package examples

import (
  "encoding/json"
  "gorm.io/gorm"
  "gorm.io/gorm/clause"
)

type JSON struct { column clause.Column }

func (j JSON) WithColumn(name string) JSON {
  c := j.column
  c.Name = name
  return JSON{column: c}
}

func (j JSON) Equal(path string, value any) clause.Expression {
  return jsonEqualExpr{col: j.column, path: path, val: value}
}

type jsonEqualExpr struct {
  col  clause.Column
  path string
  val  any
}

func (e jsonEqualExpr) Build(builder clause.Builder) {
  if stmt, ok := builder.(*gorm.Statement); ok {
    switch stmt.Dialector.Name() {
    case "mysql":
      v, _ := json.Marshal(e.val)
      clause.Expr{SQL: "JSON_EXTRACT(?, ?) = CAST(? AS JSON)", Vars: []any{e.col, e.path, string(v)}}.Build(builder)
    case "sqlite":
      clause.Expr{SQL: "json_valid(?) AND json_extract(?, ?) = ?", Vars: []any{e.col, e.col, e.path, e.val}}.Build(builder)
    default: // PostgreSQL
      clause.Expr{SQL: "jsonb_extract_path_text(?, ?) = ?", Vars: []any{e.col, e.path[2:], e.val}}.Build(builder)
    }
  }
}
```

Use this helper in the config as explained in Step 4.

---

## 6. Common Patterns & Real-World Example

Here's a minimal example that captures common customization needs:

```go
package examples

import (
  "database/sql"
  "time"
  "gorm.io/cli/gorm/field"
  "gorm.io/cli/gorm/genconfig"
)

var _ = genconfig.Config{
  OutPath: "examples/output",
  FieldTypeMap: map[any]any{
    sql.NullTime{}: field.Time{},
  },
  FieldNameMap: map[string]any{
    "json": JSON{},
  },
  IncludeInterfaces: []any{"Query*"},
  ExcludeInterfaces: []any{"*Deprecated*"},
  IncludeStructs: []any{"User", "Account*"},
  ExcludeStructs: []any{"*DTO"},
}

// Your JSON helper must be defined as shown previously
```

---

## 7. Best Practices

- **Start simple:** Use default generation first. Add configuration only as your project complexity grows.
- **Use Patterns:** Use shell-style wildcards (`*`) in include/exclude arrays for flexible filtering.
- **Separate Config Files:** Consider placing configuration in dedicated Go files for clarity.
- **Custom Helpers Consistency:** Custom helpers should implement expected field helper interfaces to integrate well.
- **Version Control:** Treat generated directories as build artifacts — regenerate after config changes.

---

## 8. Troubleshooting & Tips

### Problem: Configuration Not Applying
- Ensure `genconfig.Config` is declared at the package level (not inside functions).
- Confirm your `go` files with config are included as input when running the CLI.
- Check for possible conflicting multiple configs in the same package.

### Problem: Generated Code Missing Certain Interfaces or Structs
- Failed to match include/exclude patterns?
- Pattern matching uses shell-style patterns on fully qualified names; verify your patterns.

### Problem: Custom Type Mappings Not Taking Effect
- Check that `FieldTypeMap` keys are the exact Go type instance (e.g., `sql.NullTime{}`), not pointer or alias.
- Verify your model fields' tags align with `FieldNameMap` keys.

### Tips
- Run `gorm gen -i ./path/to/pkg` without `-o` to see if package-level `OutPath` is picked.
- Play with `Include*` and `Exclude*` filters carefully; the whitelist always has priority.

---

## 9. Next Steps & Related Content

- **Basic Configuration:** For simple config options and overriding, see [Basic Configuration](../getting-started/configuration-troubleshooting/basic-configuration).
- **Generate Code:** After configuring, run your generation as described in [Generate Type-Safe Code](../getting-started/first-steps/generate-code).
- **Using Field Helpers:** Learn how to use the generated field helpers in [Using Generated Field Helpers](../guides/getting-started-workflows/using-field-helpers).
- **Advanced Queries:** Then extend your knowledge with SQL template queries at [Template-Based SQL Queries](../guides/advanced-usage-patterns/template-queries).
- **Association Management:** Work with relations through [Managing Associations and Relationships](../guides/advanced-usage-patterns/working-with-associations).

---

# Summary Diagram of Generation Configuration Flow
```mermaid
flowchart TD
  A[Write Go Models & Query Interfaces] --> B[Add Package-level genconfig.Config]
  B --> C{Apply Config Options}
  C -->|OutPath Override| D[Set Output Directory]
  C -->|FieldTypeMap| E[Map Go Types to Field Helpers]
  C -->|FieldNameMap| F[Map Struct Tag Keys to Helpers]
  C -->|Include/Exclude| G[Filter Interfaces & Structs]
  D & E & F & G --> H[Run `gorm gen` Command]
  H --> I[Generate Customized Type-Safe Code & Helpers]
  I --> J[Use Generated Code in Your Project]

  classDef configStyle fill:#f9f,stroke:#333,stroke-width:2px
  B,C,D,E,F,G class configStyle
```

---

This workflow highlights where configuration influences generation, guiding you from writing models to consuming generated, customized code.

---

# Additional Examples

### Include Only Interfaces Starting with "Query" (Glob Pattern)
```go
var _ = genconfig.Config{
  IncludeInterfaces: []any{"Query*"},
}
```

### Exclude Deprecated Structs Ending with "DTO"
```go
var _ = genconfig.Config{
  ExcludeStructs: []any{"*DTO"},
}
```

### Mapping sql.NullTime to field.Time
```go
var _ = genconfig.Config{
  FieldTypeMap: map[any]any{
    sql.NullTime{}: field.Time{},
  },
}
```

### Custom JSON Field Helper Tag Mapping
```go
var _ = genconfig.Config{
  FieldNameMap: map[string]any{
    "json": JSON{},
  },
}
```

---