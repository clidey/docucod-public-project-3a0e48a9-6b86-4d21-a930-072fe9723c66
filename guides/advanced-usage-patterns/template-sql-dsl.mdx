---
title: "Mastering the SQL Template DSL"
description: "A deep dive into writing expressive, parameterized SQL templates in Go interfaces. Covers all available directives, real-world examples, and conditional/looping logic for maximum query flexibility."
---

# Mastering the SQL Template DSL

Welcome to your comprehensive guide on mastering the SQL Template DSL feature within GORM CLI. This page is a deep dive focused exclusively on how to write expressive, parameterized SQL templates inside your Go query interfaces, unlocking powerful, flexible, type-safe query generation.

---

## 1. Understanding the SQL Template DSL

### What This Guide Helps You Accomplish
This guide shows you how to craft advanced SQL templates directly in Go interface method comments using GORM CLI’s templating directives. You’ll learn how to leverage placeholders, conditionals, iteration, and parameter binding to express complex, dynamic SQL queries and updates that remain type-safe and idiomatic.

### Prerequisites
- Familiarity with Go interfaces and method definitions.
- A working GORM CLI setup with models and basic query interfaces.
- Basic knowledge of SQL syntax.

### Expected Outcome
After following this guide, you will be able to write:
- Parameterized SQL queries using placeholders.
- Flexible conditional query blocks.
- Looping constructs to iterate over collections in SQL.
- Dynamic clauses such as `WHERE` and `SET` that adjust based on input.

### Estimated Time Commitment
~20–30 minutes to read and experiment.

### Difficulty Level
Intermediate to Advanced (requires understanding of Go and SQL).

---

## 2. Core Concepts of the SQL Template DSL

GORM CLI enables you to define methods in Go interfaces annotated with special SQL template comments. At generation time, these templates are parsed, transformed into Go code, and bound to method parameters with full type safety.

### Key Directives and Placeholders
| Directive   | Purpose                            | Example                                 |
| ----------- | --------------------------------- | --------------------------------------- |
| `@@table`   | Resolves to the current model’s database table name | `SELECT * FROM @@table WHERE id=@id`    |
| `@@column`  | Binds a dynamic column name       | `SELECT * FROM @@table WHERE @@column=@value`|
| `@param`    | Inserts method parameter as a bound SQL parameter | `WHERE name=@user.Name`                 |
| `{{where}}` | Conditionally renders a WHERE clause if not empty  | `{{where}} age > 18 {{end}}`             |
| `{{set}}`   | Conditionally renders an UPDATE SET clause | `{{set}} name=@name {{end}}`             |
| `{{if}}`    | Conditional SQL fragments based on Go expressions | `{{if age > 0}} AND age=@age {{end}}`   |
| `{{for}}`   | Iterates over a Go slice or collection | `{{for _, tag := range tags}} ... {{end}}` |

### Advantages of Using the DSL
- **Type Safety**: Parameters match Go method signatures with compile-time checks.
- **Expressive Queries**: Complex, dynamic SQL conditions without string concatenation.
- **Integration**: Combines seamlessly with model-driven field helpers and GORM’s API.

---

## 3. Writing SQL Templates: Step-by-Step

Follow these steps to write effective SQL templates inside your Go interfaces.

### Step 1: Define Your Go Interface Method
Write a method inside your generic query interface with parameters matching your query requirements.

```go
// Filter users by name and age
// SELECT * FROM @@table WHERE name=@name AND age=@age
FilterByNameAndAge(name string, age int) ([]T, error) 
```

### Step 2: Add Parameterized SQL in Comments
Use placeholders and directives to bind parameters and specify dynamic parts.

- Use `@@table` to refer to the table for the current model.
- Use `@param` for safe value placeholders matching method argument names.

Example:

```go
// SELECT * FROM @@table WHERE name=@name AND age=@age
FilterByNameAndAge(name string, age int) ([]T, error)
```

### Step 3: Use Conditional Blocks for Flexibility
Leverage `{{where}}` to conditionally add filters only if variables hold meaningful values.

Example:

```go
// SELECT * FROM @@table
// {{where}}
//   {{if name != ""}} name=@name {{end}}
//   {{if age > 0}} AND age>@age {{end}}
// {{end}}
FilterDynamic(name string, age int) ([]T, error)
```

### Step 4: Iterate with `{{for}}` for Collections
Use `{{for}}` to loop through a slice parameter and construct dynamic OR/AND conditions.

Example:

```go
// SELECT * FROM @@table
// {{where}}
//   {{for _, tag := range tags}}
//     {{if tag != ""}} tags LIKE concat("%",@tag,"%") OR {{end}}
//   {{end}}
// {{end}}
FilterByTags(tags []string) ([]T, error)
```

### Step 5: Use `{{set}}` Blocks for Updates
When writing update methods, use `{{set}}` to build conditional `SET` clauses.

Example:

```go
// UPDATE @@table
// {{set}}
//   {{if user.Name != ""}} name=@user.Name, {{end}}
//   {{if user.Age > 0}} age=@user.Age {{end}}
// {{end}}
// WHERE id=@id
UpdateUser(user User, id int) error
```

### Step 6: Escape `@` with `\@` When Needed
If you want to write a literal `@` symbol, prefix it with a backslash (`\@`) inside comments.

Example:

```go
// SELECT * FROM @@table WHERE email = "\@example.com"
GetUserByEmail(email string) (T, error)
```

This will ensure `@` does not get interpreted as a parameter.

---

## 4. Real-World Examples

Here are practical templates extracted from GORM CLI’s standard usage to inspire your SQL templates.

### Example 1: Simple Query with Placeholders
```go
// SELECT * FROM @@table WHERE id=@id AND name = "\@name"  // literal '@name'
GetByID(id int) (T, error)
```

### Example 2: Dynamic Column and Value Binding
```go
// SELECT * FROM @@table WHERE @@column=@value
FilterWithColumn(column string, value string) (T, error)
```

### Example 3: Conditional WHERE Using `{{where}}` and `{{if}}`
```go
// SELECT * FROM @@table
// {{where}}
//   {{if user.ID > 0}} WHERE id=@user.ID {{else if user.Name != ""}} WHERE name=@user.Name {{end}}
// {{end}}
QueryWith(user User) (T, error)
```

### Example 4: Conditional UPDATE with `{{set}}`
```go
// UPDATE @@table
// {{set}}
//    {{if user.Name != ""}} name=@user.Name, {{end}}
//    {{if user.Age > 0}} age=@user.Age, {{end}}
//    {{if user.Age >= 18}} is_adult=1 {{else}} is_adult=0 {{end}}
// {{end}}
// WHERE id=@id
UpdateInfo(user User, id int) error
```

### Example 5: Filtering Over a List with `{{for}}`
```go
// SELECT * FROM @@table
// {{where}}
//   {{for _, user := range users}}
//     {{if user.Name != "" && user.Age > 0}}
//       (name = @user.Name AND age=@user.Age AND role LIKE concat("%",@user.Role,"%")) OR
//     {{end}}
//   {{end}}
// {{end}}
Filter(users []User) ([]T, error)
```

---

## 5. Practical Tips & Best Practices

- **Match Your Method Params:** The names in your SQL placeholders (e.g., `@id`) must exactly match method parameter names.
- **Use `@@table` for Table Name:** Always use the `@@table` directive instead of hardcoding table names to ensure consistency.
- **Guard Conditionals Properly:** Use `{{where}}` and `{{set}}` blocks to avoid empty or malformed SQL clauses.
- **Trim Trailing Connectors:** The generator automatically trims leading/trailing `AND` and `OR` in conditional blocks.
- **Escape Literal `@`:** Whenever you need a literal `@` symbol in SQL strings (e.g., emails), escape it as `\@`.
- **Use Go Expressions in Conditionals:** Inside `{{if}}`, you can use any Go boolean expression using method parameters or struct fields.
- **Test Generated Code:** Use CLI’s validation and generation commands to check your templates and generated Go code.

---

## 6. Troubleshooting

### Common Issues

| Problem                                      | Solution                                |
|----------------------------------------------|---------------------------------------|
| Method parameters do not match template names| Ensure placeholder names match exactly the parameter names in your method signature. |
| SQL clauses generate empty or invalid SQL    | Use `{{where}}` and `{{set}}` around conditional blocks to avoid missing WHERE/SET keywords. |
| Literal `@` symbols in SQL cause errors      | Escape with `\@` in comments. |
| Unmatched or missing `{{end}}` directives    | Verify every `{{if}}`, `{{for}}`, `{{where}}`, and `{{set}}` has matching `{{end}}`. |
| Complex expressions fail to compile           | Simplify conditional expressions or split logic into simpler parts if needed. |

### How to Debug
- Run `gorm gen` with verbose logging.
- Check generated Go files for the method bodies.
- Write unit tests calling generated APIs to catch mismatches early.

---

## 7. Next Steps & Related Content

- Explore [Generating Type-Safe Query APIs](/guides/core-workflows/generate-type-safe-queries) for practical code generation workflows using SQL templates.
- Learn to [Validate Generated APIs](/getting-started/first-use-validation/validate-generated-code) to ensure your generated query interfaces work as intended.
- Customize your generation with [Config Options & Field Mapping](/guides/advanced-usage-patterns/customizing-generation) to tailor the DSL behavior.
- Deepen grasp with [Core Concepts & Terminology](/overview/concepts-architecture/core-concepts-glossary) for foundational knowledge.

---

Happy querying! With mastery of the SQL Template DSL, you encode rich, flexible database operations that compile cleanly, execute safely, and maintain easily in your Go projects.
