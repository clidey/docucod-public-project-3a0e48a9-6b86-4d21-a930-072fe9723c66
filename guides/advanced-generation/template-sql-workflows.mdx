---
title: "Building Template-Based Query Interfaces"
description: "Unlock the power of GORM CLI’s SQL template DSL. Follow detailed examples for writing query interfaces with embedded SQL or control blocks, supporting conditional, dynamic, and safe parameterized queries. Best practices for readable and maintainable templates."
---

# Building Template-Based Query Interfaces

Unlock the full potential of GORM CLI by mastering its SQL template domain-specific language (DSL). This guide empowers you to write expressive, type-safe query interfaces using embedded SQL and control blocks that enable conditional, dynamic, and parameterized queries. You will learn practical techniques, supported syntax, and best practices that ensure your templates remain readable, maintainable, and safe.

---

## 1. Understanding the Purpose of Template-Based Query Interfaces

GORM CLI allows you to define Go interfaces with method comments containing SQL templates enriched with placeholders and control directives. These annotations drive code generation, producing type-safe query APIs that are powerful, maintainable, and seamlessly integrated with GORM.

### What You'll Achieve

By the end of this guide, you'll be able to:

- Write SQL with placeholders that automatically bind Go method parameters.
- Use control-flow directives like `{{if}}`, `{{for}}`, `{{where}}`, and `{{set}}` to build conditional and dynamic queries.
- Embed safe parameter bindings to prevent SQL injection.
- Follow recommended patterns to keep templates clear and concise.

### Who This is For

If you are a Go backend developer using GORM and want safer, more maintainable, and flexible database querying without manually writing boilerplate SQL or risking unsafe string concatenation, this guide is for you.

---

## 2. Core Concepts of the SQL Template DSL

GORM CLI’s template DSL extends traditional SQL with placeholders and control directives that map directly to Go code generation.

### Key DSL Elements

| Directive   | Description                                     | Example                                         |
|-------------|------------------------------------------------|------------------------------------------------|
| `@@table`   | Resolves to the table name of the model         | `SELECT * FROM @@table WHERE id=@id`            |
| `@@column`  | Dynamic column name resolved at runtime         | `WHERE @@column=@value`                          |
| `@param`    | Bind a Go method parameter safely               | `WHERE name=@user.Name`                          |
| `{{where}}` | Conditional `WHERE` clause block, renders if content present | `{{where}} age > 18 {{end}}`           |
| `{{set}}`   | Conditional `SET` clause in UPDATE statements   | `{{set}} name=@name {{end}}`                     |
| `{{if}}`    | Conditional block to include SQL fragments      | `{{if age > 0}} AND age=@age {{end}}`            |
| `{{else if}}` | Additional condition branches                   | `{{else if user.Name != ""}} WHERE name=@user.Name {{end}}` |
| `{{else}}`  | Fallback clause for conditionals                 | `{{else}} WHERE 1=1 {{end}}`                      |
| `{{for}}`   | Iterate over slices or collections                | `{{for _, tag := range tags}} tags LIKE concat('%',@tag,'%') OR {{end}}` |

### Important Notes:

- Use `@param` to bind parameters; this ensures safe, parameterized queries avoiding SQL injection risks.
- `@@table` and `@@column` placeholders dynamically resolve to current context table or passed column names.
- Control blocks must be properly closed with `{{end}}`.

---

## 3. Step-by-Step: Writing Your First Template-Based Query Interface

Follow this clear workflow to create interfaces that GORM CLI turns into powerful query APIs.

### Prerequisites

- A working Go project with models defined.
- GORM CLI installed and validated.
- Basic familiarity with Go generics and GORM query usage.

### Time Estimate

~30-45 minutes to write interfaces and generate code including initial testing.

### Difficulty Level

Intermediate — requires proper use of SQL templating and Go method declarations.

<Steps>
<Step title="Define a Go Interface With SQL Template Comments">
Create a Go interface in your project with methods annotated by SQL templates or template DSL directives.

Example:
```go
// Query defines template-based query methods
// embedding parameters with @ syntax and control blocks
//
type Query[T any] interface {

  // SELECT * FROM @@table WHERE id=@id
  GetByID(id int) (T, error)

  // SELECT * FROM @@table WHERE @@column=@value
  FilterWithColumn(column string, value string) (T, error)

  // SELECT * FROM @@table
  // {{where}}
  //   {{if user.ID > 0}}
  //     id=@user.ID
  //   {{else if user.Name != ""}}
  //     name=@user.Name
  //   {{end}}
  // {{end}}
  QueryWith(user User) (T, error)

  // UPDATE @@table
  // {{set}}
  //   {{if user.Name != ""}} name=@user.Name, {{end}}
  //   {{if user.Age > 0}} age=@user.Age, {{end}}
  //   {{if user.Age >= 18}} is_adult=1 {{else}} is_adult=0 {{end}}
  // {{end}}
  // WHERE id=@id
  UpdateInfo(user User, id int) error
}
```

This clearly expresses your query logic, including dynamic conditions.

<Check>
Make sure:
- Method parameters correspond to `@param` bindings.
- Comments include valid SQL and template syntax.
</Check>
</Step>

<Step title="Use Placeholders to Bind Parameters Safely">
Embed placeholders with `@` prefix to refer to Go method parameters or nested fields.

Example:
```sql
-- Bind parameter id
SELECT * FROM @@table WHERE id=@id
```

- `@id` matches the Go method parameter named `id`.
- Nested fields support access via dot notation, e.g. `@user.Name`.

<Tip>
Avoid injecting variables via string concatenation. Always use `@` placeholders for safe parameter binding.
</Tip>
</Step>

<Step title="Add Conditional SQL With `{{if}}`, `{{else if}}`, and `{{else}}`">
Control which SQL fragments are included at runtime based on Go expressions.

Example:
```sql
{{where}}
  {{if user.ID > 0}}
    id=@user.ID
  {{else if user.Name != ""}}
    name=@user.Name
  {{else}}
    1=1
  {{end}}
{{end}}
```

This builds the `WHERE` clause dynamically depending on supplied values.

<Note>
Conditional expressions directly use Go syntax for expressions and operators.
</Note>
</Step>

<Step title="Use `{{for}}` to Loop Over Collections for Complex Conditions">
For queries involving collections, iterate with `{{for}}` to generate combined conditions.

Example:
```sql
{{where}}
  {{for _, user := range users}}
    {{if user.Name != "" && user.Age > 0}}
      (name = @user.Name AND age = @user.Age) OR
    {{end}}
  {{end}}
{{end}}
```

This creates OR-combined dynamic filters from slice elements.
</Step>

<Step title="Use `{{set}}` for Dynamic UPDATE Statements">
Build your `SET` clause dynamically for update queries.

Example:
```sql
UPDATE @@table
{{set}}
  {{if user.Name != ""}} name=@user.Name, {{end}}
  {{if user.Age > 0}} age=@user.Age, {{end}}
  {{if user.Age >= 18}} is_adult=1 {{else}} is_adult=0 {{end}}
{{end}}
WHERE id=@id
```

Only fields with meaningful values are included in the update to reduce unnecessary writes.
</Step>

<Step title="Generate Code Using GORM CLI">
Run the generator CLI with your input interface and desired output folder.

Command:
```bash
gorm gen -i ./path/to/your/package -o ./generated
```

This compiles your templates into type-safe Go APIs.
<Check>
Verify generation logs indicating files and successful creation.
</Check>
</Step>

<Step title="Integrate and Use Generated APIs in Your Go Application">
Import the generated package and invoke query methods normally.

Example usage:
```go
user, err := generated.Query[User](db).GetByID(ctx, 123)
```

The generated methods are fully type-safe with Go static checking.
</Step>
</Steps>

---

## 4. Practical Examples

### Example Interface

```go
package examples

type Query[T any] interface {
  // SELECT * FROM @@table WHERE id=@id
  GetByID(id int) (T, error)

  // SELECT * FROM @@table WHERE @@column=@value
  FilterWithColumn(column string, value string) (T, error)

  // SELECT * FROM @@table
  // {{where}}
  //   {{if user.ID > 0}}
  //     id=@user.ID
  //   {{else if user.Name != ""}}
  //     name=@user.Name
  //   {{end}}
  // {{end}}
  QueryWith(user User) (T, error)

  // UPDATE @@table
  // {{set}}
  //   {{if user.Name != ""}} name=@user.Name, {{end}}
  //   {{if user.Age > 0}} age=@user.Age, {{end}}
  //   {{if user.Age >= 18}} is_adult=1 {{else}} is_adult=0 {{end}}
  // {{end}}
  // WHERE id=@id
  UpdateInfo(user User, id int) error
}
```

### Corresponding Generated SQL Behavior

- `GetByID(id int)` generates: `SELECT * FROM users WHERE id=?` with `id` as parameter.
- `FilterWithColumn(column, value string)` generates SQL with dynamic column binding.
- `QueryWith(user User)` builds conditional `WHERE` depending on user.ID or user.Name.
- `UpdateInfo(user User, id int)` builds a dynamic `SET` clause updating only non-empty fields.

### Template DSL in Action

```sql
SELECT * FROM @@table WHERE id=@id AND name="\@name"
```
- Escaped `\@name` yields a literal `@name` in query.

```sql
{{where}}
  {{if !start.IsZero()}}
    created_at > @start
  {{end}}
  {{if !end.IsZero()}}
    AND created_at < @end
  {{end}}
{{end}}
```
- Conditional date range filtering.

```sql
{{for _, tag := range tags}}
  {{if tag != ""}} tags LIKE concat('%',@tag,'%') OR {{end}}
{{end}}
```
- Iterates to create OR-filter conditions on tags.

---

## 5. Best Practices and Tips

- **Always use placeholders (`@`) for parameters** to ensure safe SQL parameterization and prevent injection vulnerabilities.
- **Keep your methods’ Go parameters consistent with placeholders.** The mapping is by name.
- Use `{{where}}` and `{{set}}` blocks to conditionally include WHERE and SET clauses only when parameters exist, avoiding invalid SQL.
- Use `{{if}}` and `{{else if}}` to express mutually exclusive conditions cleanly.
- When iterating over slices with `{{for}}`, be mindful to append trailing `OR` or `AND` carefully. Use trimming functions inside generated code if needed.
- Avoid complex SQL logic inside templates; keep them declarative and simple. Delegate complex logic to Go code if it does not impact generated SQL coherence.
- Add comments in interfaces to document intent and usage for maintainability.

<Tip>
If you accidentally leave an unclosed block (missing `{{end}}`), generation will fail with a clear parsing error. Carefully check block syntax.
</Tip>

---

## 6. Troubleshooting Common Issues

<AccordionGroup title="Common Problems & Solutions">
<Accordion title="Unclosed Block Errors">
If you receive errors indicating unclosed blocks, verify you have matching `{{end}}` statements for every `{{if}}`, `{{for}}`, `{{where}}`, and `{{set}}` directive.
</Accordion>
<Accordion title="Parameter Binding Failures">
Ensure every `@param` used in the template matches a method parameter by name. Mismatches cause code generation or runtime errors.
</Accordion>
<Accordion title="Syntax Errors in SQL Templates">
Watch for missing or misplaced curly braces and quotes. The generator performs strict parsing and will reject invalid syntax.
</Accordion>
<Accordion title="Dynamic Column or Table Names Not Resolved">
Use `@@table` and `@@column` exactly as shown to resolve model table or column names at generation time.
</Accordion>
</AccordionGroup>

---

## 7. Next Steps & Further Learning

- Explore the [Generating Your First Code](../getting-started/first-generation) guide to see full end-to-end workflows.
- Dive into [Using the Generated APIs](../getting-started/using-generated-apis) for practical code usage patterns.
- Review [Basic Generator Configuration](../../getting-started/troubleshooting-configuration/basic-configuration) to customize generation for your project needs.
- For advanced SQL templates, study examples in the `examples/query.go` source file within the GORM CLI repository.

---

## References & Resources

- [What is GORM CLI?](../../overview/getting-started-intro/what-is-gorm-cli) – understand the core purpose.
- [Target Audience & Use Cases](../../overview/getting-started-intro/target-audience-use-cases) – see who benefits most.
- [Feature Overview](../../overview/core-concepts-basics/feature-overview) – see key capabilities.
- GORM CLI official [README](https://github.com/go-gorm/cli/blob/main/README.md) for more examples.

---

Unlocking the power of template-based query interfaces in GORM CLI greatly amplifies your productivity and safety when crafting Go ORM database operations. Follow this guide to write expressive, clean, and powerful SQL annotations that transform into type-safe, fluent APIs that scale with your project.

---

##### End of Guide
