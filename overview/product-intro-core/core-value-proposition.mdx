---
title: "Value Proposition & Use Cases"
description: "Explore how GORM CLI eliminates boilerplate, reduces runtime errors, and elevates productivity through compile-time safety, with examples of common use cases—like interface-driven queries and rich model helpers—in real GORM projects."
---

# Value Proposition & Use Cases

Discover how GORM CLI transforms your GORM projects by eliminating repetitive code, preventing runtime errors, and boosting developer productivity through compile-time safety. This page highlights the core advantages of using GORM CLI and illustrates practical scenarios where its powerful features simplify database interaction in real-world applications.

---

## Why GORM CLI Matters: Elevate Your Development

Imagine building a Go application where every database query and update is type-safe, fluent, and backed by generated code tailored exactly to your models and SQL needs. GORM CLI achieves this by generating two tightly integrated components:

- **Interface-driven, type-safe query APIs** from your own Go interfaces annotated with SQL templates
- **Model-driven field helpers** providing compile-time verified filters, updates, and association operations

This fusion delivers an error-resistant development experience where boilerplate vanishes and the API discovers itself as you code.

---

## Key Value Propositions

- **Eliminate Boilerplate**: Automatically generate query methods and field helpers from interfaces and models, reducing manual coding.
- **Compile-Time Safety**: Catch errors early by generating strongly typed APIs and association helpers.
- **Fluent, Discoverable API**: Work with generated query and field helper methods that are intuitive and auto-completable.
- **Robust Association Management**: Perform create, update, unlink, and delete operations on associations with ease and safety.
- **Flexible Generation Configurations**: Tailor generation behavior with `genconfig.Config` to include/exclude specific interfaces or structs.

---

## Real-World Use Cases

### 1. Interface-Driven Type-Safe Queries
You define Go interfaces with embedded SQL templates that describe exactly how to query your data.

```go
// Define your query interface with SQL annotations
type Query[T any] interface {
  // SELECT * FROM @@table WHERE id=@id
  GetByID(id int) (T, error)

  // SELECT * FROM @@table WHERE @@column=@value
  FilterWithColumn(column string, value string) (T, error)

  // Complex conditional query
  QueryWith(user models.User) (T, error)
}
```

GORM CLI generates methods implementing these interfaces, giving you complete type safety and reusable, optimized code.


### 2. Model-Driven Field Helpers for Safe Queries and Updates
From your GORM model structs, GORM CLI creates field helpers that let you build queries and updates fluently.

```go
// Example: Filtering users older than 18
users, err := gorm.G[User](db).
  Where(generated.User.Age.Gt(18)).
  Find(ctx)

// Example: Update user's name and increment age atomically
err := gorm.G[User](db).
  Where(generated.User.ID.Eq(1)).
  Set(
    generated.User.Name.Set("jinzhu"),
    generated.User.Age.Incr(1),
  ).
  Update(ctx)
```

This approach prevents errors like misspelled column names or invalid type assignments by enforcing compile-time validation.

### 3. Seamless Association Operations
Perform complex CRUD operations on model associations with clear, type-safe helpers:

```go
// Create and link a new pet for a user
gorm.G[User](db).
  Set(
    generated.User.Name.Set("alice"),
    generated.User.Pets.Create(generated.Pet.Name.Set("fido")),
  ).
  Create(ctx)

// Unlink all pets from a user safely
gorm.G[User](db).
  Where(generated.User.ID.Eq(1)).
  Set(generated.User.Pets.Unlink()).
  Update(ctx)
```

This API abstracts away the underlying SQL joins or foreign key manipulations, reducing manual errors and improving maintainability.

### 4. Template-Based Dynamic SQL Queries
Write SQL templates directly in interface method comments with placeholders and conditional logic to handle dynamic queries.

Example method with conditional WHERE clauses:

```go
type Query[T any] interface {
  // SELECT * FROM @@table
  // {{where}}
  //   {{if user.Name != ""}} name=@user.Name {{end}}
  //   {{if user.Age > 0}} AND age=@user.Age {{end}}
  // {{end}}
  FilterByNameAndAge(name string, age int)
}
```

GORM CLI generates corresponding methods that safely bind parameters and generate optimized SQL per call.

---

## Before and After Using GORM CLI

| Without GORM CLI | With GORM CLI |
|-----------------|--------------|
| Manually writing SQL snippets and query methods prone to typos and errors | Auto-generated, type-safe query interfaces minimizing human error |
| Maintaining custom association logic with complex joins | Fluent association helpers with standardized methods for create, update, unlink, delete |
| Relying on runtime errors to catch invalid queries or column names | Catch errors at compile time with strongly typed fields and query methods |

---

## Benefits Summary

- **Save Time and Reduce Errors** by generating code that perfectly matches your models and SQL style
- **Increase Confidence** with compile-time checked queries and updates
- **Improve Developer Experience** with discoverable, fluent code completion
- **Scale Safely** across complex data models including polymorphic and many-to-many relations

---

## Practical Tips & Best Practices

- **Start Small:** Define simple interfaces and models, then expand queries as your application grows.
- **Leverage Configurations:** Use `genconfig.Config` to filter which interfaces and models to generate code for.
- **Use Associations Wisely:** Make use of `CreateInBatch` and conditional unlink/delete operations to efficiently manage related data.
- **Test Generated Code:** Integration testing ensures that generated APIs align with your database schema and model logic.

---

## Getting Started Preview

Begin by defining your Go interfaces annotated with SQL templates alongside your GORM models. Run the CLI tool with the interface files as input to generate the type-safe query APIs and model field helpers.

```bash
gorm gen -i ./examples -o ./generated
```

Use the generated code to write safe, clean business logic without worrying about SQL injection or database mismatches.

**Next Steps:** Proceed to the [Getting Started: Generate Your First API](/guides/core-workflows/getting-started) guide to see the end-to-end workflow from interface to generated query.

---

## FAQ: Common Pitfalls

<AccordionGroup title="Common Questions on Value Proposition & Use Cases">
<Accordion title="Why should I prefer generated code over hand-written queries?">
Generated code eliminates repetitive manual coding and catches potential query mistakes at compile time, which hand-written queries often miss until runtime errors.
</Accordion>
<Accordion title="Can I customize the generated query methods?">
Yes, by defining your own interfaces with SQL templates, you control the generated methods and tailor their behavior to your application's needs.
</Accordion>
<Accordion title="How does association helper generation improve my workflow?">
They abstract away SQL and foreign key intricacies, letting you cleanly create, update, unlink, or delete related records with intuitive, type-safe methods.
</Accordion>
<Accordion title="What if I need support for custom or JSON fields?">
GORM CLI supports field mappings via config, enabling you to write custom field helpers—see the JSON example in the configuration section.
</Accordion>
<Accordion title="Is there performance overhead from using generated methods?">
No, generated code compiles down to idiomatic GORM calls and efficient SQL; it avoids runtime reflection or dynamic query construction.
</Accordion>
</AccordionGroup>

---

Explore how GORM CLI empowers your Go data layer with safety, clarity, and productivity.

---

### See Also

- [What is GORM CLI?](/overview/product-intro-core/what-is-gorm-cli) — Introduction to the core system
- [Core Concepts & Terminology](/overview/architecture-concepts/concepts) — Learn about key terms and design patterns
- [Getting Started: Generate Your First API](/guides/core-workflows/getting-started) — Step-by-step tutorial
- [Working with Associations: Patterns and Pitfalls](/guides/real-world-patterns/advanced-associations) — Deep dive on managing associations
- [Customizing Code Generation via Configuration](/guides/real-world-patterns/configuring-generation) — Adjust generator behavior

---

Start leveraging compile-time safety and fluent APIs today with GORM CLI.
