---
title: "Target Audience & Use Cases"
description: "Identify if GORM CLI is the right fit for you. This page outlines who benefits most from using GORM CLI, such as Go backend developers, teams demanding robust ORM abstractions, and projects seeking maintainable, type-safe query layers. Common usage scenarios are highlighted."
---

# Target Audience & Use Cases

## Is GORM CLI Right for You?

Are you a Go backend developer aiming to build robust, maintainable data access layers with compile-time safety? GORM CLI is designed precisely to fit your needs. This page helps you identify if GORM CLI aligns with your development goals by outlining who benefits most and how.

## Who Benefits Most from GORM CLI?

- **Go Backend Developers**
  - Developers who want type-safe, ergonomic, and expressive database query APIs.
  - Those who prefer defining their queries declaratively via interfaces instead of writing raw SQL scattered in code.
  - Users who benefit from automated model-driven field helpers for updates, filters, and association management.

- **Teams Seeking Robust and Maintainable ORM Layers**
  - Organizations prioritizing code quality, safety, and maintainability in their data layers.
  - Teams that want to standardize querying and updating data through consistent, auto-generated APIs.
  - Developers looking to avoid runtime errors caused by SQL mismatches or type issues.

- **Projects With Complex Domain Models and Association Relationships**
  - Systems with entities having one-to-many, many-to-many, and polymorphic relationships.
  - Applications that benefit from fluent, compile-time checked association operations like create, update, unlink, and delete.

- **Anyone Looking to Improve Developer Productivity in Database Code**
  - Users who want to reduce boilerplate and repetitive SQL/ORM code.
  - Teams eager to leverage code generation to keep data access code in sync with evolving models.

## Common Use Cases

### 1. Generating Type-Safe Query APIs

Imagine you want to fetch users by ID or filter users dynamically with conditional SQL without losing type safety. By defining Go interfaces with templated SQL comments, GORM CLI generates implementations that offer:

- Strongly typed methods with clear parameters.
- SQL templates that automatically handle parameter binding and conditions.
- Easy querying using familiar Go idioms without raw SQL strings in your business logic.

Example:
```go
// Interface declares custom query method
func (q Query[User]) GetByID(id int) (User, error)

// Generated code lets you fetch user reliably
user, err := generated.Query[User](db).GetByID(ctx, 123)
```

### 2. Model-Driven Field Helpers for Fluent Queries and Updates

Working directly with struct fields, you get helper objects to build predicates and setters with validation and type inference:

- Compose filters like `User.Age.Between(18, 65)` or `User.Name.Like("%someone%")`.
- Use setters that support zero-values and SQL expressions in updates.
- Guaranteed compile-time checks reduce runtime surprises.

### 3. Managing Complex Associations with Confidence

When your models include relationships such as has-many, belongs-to, or many-to-many, GORM CLI generates helpers to seamlessly manage these associations:

- Create and link related records in a single operation.
- Update associated records conditionally.
- Unlink or delete associations with descriptive methods.
- Batch operations supported for efficiency.

Use Cases:
```go
// Create a user with associated pets
gorm.G[User](db).
  Set(
    generated.User.Name.Set("alice"),
    generated.User.Pets.Create(generated.Pet.Name.Set("fido")),
  ).
  Create(ctx)
```

### 4. Enforcing SQL Query Logic Consistency Through Templates

Use SQL template DSL directives to write dynamic queries:

- Placeholders like `@@table`, `@param` map Go types to SQL safely.
- Conditional clauses `{{where}}`, `{{set}}`, and loops `{{for}}` enable complex yet maintainable query logic.

This eliminates the pain of manually string-building queries and conviction about SQL correctness.

## Before and After GORM CLI Adoption

| Without GORM CLI                         | With GORM CLI                                      |
|---------------------------------------|---------------------------------------------------|
| Hand-written SQL prone to errors       | Type-safe, interface-driven query methods         |
| Scattered SQL strings in code          | Centralized query definitions in interfaces       |
| Manual handling of updates and filters | Automated field helpers reduce repetitive code    |
| Complex association management         | Fluent API for create/update/unlink/delete        |


## Practical Benefits You Will Experience

- **Time Savings:** Cut development time by automatically generating type-safe code.
- **Reduced Bugs:** Compile-time checks catch query mistakes early.
- **Consistency:** Enforce uniform query and update patterns throughout your project.
- **Clear Expressiveness:** Use Go-native syntax and idioms for database operations.

## Getting Started with GORM CLI

If you identify with these use cases and benefits, you’re ready to explore next steps:

- Prepare your models and interfaces following recommended patterns.
- Run the code generator to produce strongly typed query and field helper APIs.
- Use the generated code confidently in your application logic.

Explore the [Getting Started with GORM CLI](/guides/core-workflows/getting-started) guide or see [Preparing Your Models and Interfaces](/getting-started/first-run-basic-usage/prepare-code) for detailed instructions.

---

## Additional Resources

- [What is GORM CLI?](/overview/product-introduction/what-is-gorm-cli) — Understand the product’s purpose and core features.
- [Core Features Overview](/overview/product-introduction/feature-highlights) — Deep dive on generated APIs and capabilities.
- [Configuring GORM CLI](/getting-started/configuration-and-troubleshooting/configuring-generator) — Customize code generation to your project.
- [Best Practices and Troubleshooting](/guides/advanced-patterns/best-practices) — Tips to maximize your success.


<Tip>
GORM CLI is optimized for projects leveraging Go generics (Go 1.18+) to deliver unparalleled type safety and developer ergonomics in database code.
</Tip>

<Warning>
Ensure your interfaces and models are defined with clean SQL comments and struct tagging to unlock the full power of GORM CLI’s generator.
</Warning>
