---
title: "What is GORM CLI?"
description: "Learn what GORM CLI is—a code generator that produces type-safe, interface-driven query APIs and model-based field helpers for GORM projects. Understand its business value in ensuring compile-time safety, developer productivity, and maintainable data access layers for Go applications."
---

# What is GORM CLI?

## Empower Your Go Data Access with Type-Safe, Interface-Driven Code Generation

GORM CLI is a powerful code generator designed to elevate your GORM-based Go projects by automatically producing **type-safe query APIs** and **model-driven field helpers**. It transforms your interfaces and models into fluent, compile-time checked code, dramatically improving developer productivity, enforcing correctness, and ensuring maintainable data access layers.

### Why GORM CLI Matters to You

- **Eliminate runtime SQL errors** by catching bugs through compile-time safety.
- **Boost development speed** with generated, discoverable APIs for queries and updates.
- **Simplify complex CRUD and association operations** via intuitive helper methods.
- **Maintain cleaner codebases** by separating raw SQL templates from implementation.
- **Customize generation effortlessly** through configuration to fit your project conventions.

### Who Should Use GORM CLI?

- Go developers building data-driven applications with GORM.
- Teams desiring a robust, maintainable data access layer with fewer bugs.
- Architects prioritizing scalability and type safety in database interactions.

---

## What is GORM CLI?

Simply put, GORM CLI is a command-line tool that **generates Go code** to interact with your database more safely and efficiently. It reads Go interfaces annotated with raw SQL templates and your model definitions, and produces two complementary pieces of code:

- **Interface-driven query APIs:** Concrete, type-safe methods generated from annotated interfaces enable you to run queries without writing repetitive SQL execution code.
- **Model-based field helpers:** Strongly typed helpers for model fields that allow expressive filtering, updating, and association handling.

This generation strategy empowers you with a **fluent and discoverable API** while guaranteeing that type mismatches and incorrect SQL usage are caught by the Go compiler before runtime.

### What Problem Does It Solve?

Without GORM CLI, developers typically write raw SQL or generic GORM code that can lead to:

- Runtime SQL errors due to typos in queries or parameters.
- Complex, repetitive boilerplate code for common operations.
- Fragile association handling prone to foreign key mistakes.
- Difficulty maintaining and scaling evolving data access layers.

GORM CLI automates code generation to sharply reduce these issues, making your database layer **more resilient, maintainable, and developer-friendly**.

### How Does It Work?

The tool scans your Go code, focusing on:

- Interfaces with specially formatted SQL templates embedded in method comments.
- Model structs with fields and association metadata.

From this input, GORM CLI generates comprehensive Go code that:

- Implements interface methods with type-safe SQL execution.
- Builds predicates and setters for every model field and association.

You run it via the CLI command:

```bash
gorm gen -i ./yourproject/pkg -o ./yourproject/generated
```

Resulting code integrates seamlessly with your GORM-based Go app, ready to use without further coding.

---

## Core Features of GORM CLI

### 1. Type-Safe Query APIs from Interfaces

Write simple Go interfaces with raw SQL templates as comments — GORM CLI interprets and generates real Go methods that guarantee matching method signatures and correct parameter binding.

```go
// Query interface example
// SELECT * FROM @@table WHERE id=@id
GetByID(id int) (T, error)
```

This eliminates manual implementation and enforces compile-time correctness.

### 2. Model-Driven Field Helpers

From your model structs, GORM CLI produces field helper structs and methods for all fields and relationships:

- **Filters:** `.Eq()`, `.Like()`, `.Between()`, etc.
- **Setters:** `.Set()`, `.SetExpr()`, `.Incr()` for updates and creates.
- **Associations:** Create, update, unlink, delete related records with type safety.

Example:

```go
generated.User.Name.Eq("alice")        // name = 'alice'
gorm.G[User](db).Where(generated.User.Age.Gt(18)).Find(ctx) // WHERE age > 18
```

### 3. Association Operation Support

Use generated helpers to manage relations easily:

- Create related records together with parent
- Update or unlink associated entities
- Batch create or link many-to-many relationships

This approach avoids manual foreign key manipulation errors and complex joins.

### 4. SQL Template DSL

Write flexible, parameterized SQL directly in comments using a simple templating DSL:

- `@@table` and `@@column` placeholders for dynamic names
- `@param` bindings for safe parameter substitution
- Conditional blocks with `{{if}}`, `{{where}}`, `{{set}}` and loops

Example:

```sql
-- SELECT with conditional WHERE clause
SELECT * FROM @@table
{{where}}
  {{if name != ""}} name=@name {{end}}
  {{if age > 0}} AND age=@age {{end}}
{{end}}
```

### 5. Configurable and Extendable

Customize generation per package with a `genconfig.Config` struct where you can:

- Redirect output paths
- Map custom types to field helpers
- Include or exclude specific interfaces or structs

Example configuration snippet:

```go
var _ = genconfig.Config{
  OutPath: "examples/output",
  FieldNameMap: map[string]any{"json": JSON{}},
  IncludeInterfaces: []any{"Query*"},
}
```

This flexibility lets you adapt GORM CLI to your coding standards.

---

## Why Should You Care?

### Unlock Tangible Benefits

- **Catch errors early:** Typo or mismatched SQL queries become compiler errors, not runtime surprises.
- **Reduce boilerplate:** Write your queries once as interfaces and get ready-to-use methods.
- **Easier maintenance:** Changes in models propagate automatically to helpers.
- **Simplify complex association logic:** Intuitive helpers prevent FK and join table mistakes.
- **Increase development velocity:** Spend less time debugging and more on business logic.

### Practical Use Cases

- Building type-safe repositories for your data models.
- Maintaining large projects where data access code must be reliable.
- Projects requiring strong compile-time guarantees around database interactions.
- Enabling teams unfamiliar with raw SQL templating to write safe queries.

### Experience Before and After

| Without GORM CLI                                | With GORM CLI                                             |
|------------------------------------------------|----------------------------------------------------------|
| Manual SQL embedded in code, prone to typos    | Type-safe interfaces ensure SQL correctness at compile-time |
| Handwritten conversions and query building     | Generated fluent APIs simplify query logic               |
| Complex CRUD and association code duplication  | One interface drives consistent data access              |
| Fragile schema updates causing runtime bugs    | Model changes auto-sync to helpers                        |

---

## Getting Started Preview

Starting with GORM CLI is straightforward:

1. **Write your query interfaces and models** — annotate methods with SQL templates.
2. **Run the CLI generator** specifying input and output directories.
3. **Use the generated query API and field helpers** in your Go application.

Prerequisites:

- Go 1.18 or above with generics support.
- GORM installed and integrated in your project.

You'll find detailed steps, examples, and troubleshooting in the [Getting Started](../getting-started) section.

---

## Example Workflow

```bash
# Write interface with SQL
cat > examples/query.go <<EOF
package examples

type Query[T any] interface {
	// SELECT * FROM @@table WHERE id=@id
	GetByID(id int) (T, error)
}
EOF

# Run the generator
orm gen -i ./examples -o ./generated

# Use generated code
cat > main.go <<EOF
package main

import (
	"context"
	"gorm.io/cli/gorm/generated"
	"gorm.io/driver/sqlite"
	"gorm.io/gorm"
	"log"
)

func main() {
	db, _ := gorm.Open(sqlite.Open(":memory:"), &gorm.Config{})
	query := generated.Query[User](db)
	user, err := query.GetByID(context.Background(), 1)
	if err != nil {
		log.Fatalf("failed: %v", err)
	}
	log.Println(user)
}
EOF
```

This quick start highlights the ease and outcome of incorporating GORM CLI.

---

For a detailed understanding of installation, configuration, and advanced patterns, explore the rest of the GORM CLI documentation.

---

<Info>
GORM CLI is a critical tool bridging Go's type safety and the flexibility of raw SQL, helping teams maintain cleaner, safer, and more robust data layers.
</Info>

---

## Related Documentation

- [Target Audience & Use Cases](/overview/product-introduction/target-audience-use-cases)
- [Core Features Overview](/overview/product-introduction/feature-highlights)
- [Getting Started Guide](/getting-started/prerequisites-installation/system-requirements)

---