---
title: "What is GORM CLI?"
description: "A high-level overview of GORM CLI's purpose and the problems it solves. Explains how GORM CLI streamlines the creation of type-safe, interface-driven query APIs and model-based helpers for GORM, enhancing productivity and code quality."
---

# What is GORM CLI?

## Unlocking Type-Safe, Interface-Driven Database Access for Go Developers

GORM CLI is a powerful command-line tool designed to transform the way you write database queries and data manipulation code in Go projects using GORM. It streamlines the creation of comprehensive, type-safe query APIs based on your Go interfaces and generates strongly typed helpers from your models â€” eliminating boilerplate, reducing runtime errors, and improving developer productivity.

### Why Does This Matter?
In traditional Go projects using GORM, writing raw SQL queries or manually crafting query builder code is error-prone and lacks compile-time guarantees. GORM CLI bridges this gap by allowing you to:

- Define your database queries declaratively as Go interfaces with embedded SQL templates
- Automatically generate concrete, type-safe implementations of those interfaces
- Generate field-level helpers based on your model structs for convenient and error-resistant filtering, updating, and association handling

This approach offers safety, discoverability, and maintainability in your data layer without sacrificing flexibility.

---

## What is GORM CLI?

At its core, GORM CLI generates two complementary forms of code for your GORM projects:

1. **Interface-Driven, Type-Safe Query APIs**
   - Write Go interfaces where method comments contain SQL or SQL-like templates.
   - Each method maps parameters to query placeholders automatically.
   - GORM CLI generates concrete implementations that you call with full type safety and context-aware parameters.

2. **Model-Driven Field Helpers**
   - Generate helper types per model field, such as `field.String`, `field.Number[int]`, or association helpers like `field.Struct[T]`, `field.Slice[T]`.
   - These helpers provide predicates (`Eq`, `Like`, `Between`, etc.) and setters (`Set`, `Incr`, etc.) for use with GORM query builders.

Together, these form a fluent and reliable API for interacting with your database through GORM.

---

## The Problem GORM CLI Solves

- **Reduce Runtime Errors:** Catch invalid queries at compile time rather than at runtime.
- **Eliminate Boilerplate:** Avoid writing repetitive SQL or query builder code manually.
- **Increase Discoverability:** Benefit from Go's IDE autocompletion to explore available fields and queries.
- **Enable Maintainable Data Access Layers:** Clearly separate SQL query intent (via interfaces) from usage.

## Key Differentiators

- **Generics-Powered:** Leverages Go 1.18+ generics to generate concise, reusable query APIs.
- **Declarative SQL Templates:** Embed powerful SQL templating DSLs directly in Go interface comments.
- **Strong Model Integration:** Helper types reflect your model fields and associations precisely.
- **Flexible Configuration:** Customize generation scopes and field mappings through simple `genconfig.Config` declarations.

---

## How Does GORM CLI Work?

1. **Write Query Interfaces:**
   Define interfaces in your Go packages whose methods are annotated with SQL templates.

2. **Define Your Models:**
   Write standard GORM models in the same package or directory.

3. **Run the CLI Tool:**
   Use the `gorm gen` command to generate:
   - Concrete implementations of your interfaces with type-safe methods
   - Model field helpers for filters and update operations

4. **Use Generated APIs:**
   Import generated code and call methods like `generated.Query[User](db).GetByID(ctx, 1)` or build queries using field helpers like `generated.User.Name.Like("%example%")`.

---

## Illustrative Example

```go
// Define query interface with SQL in method comments
// examples/query.go

type Query[T any] interface {
  // SELECT * FROM @@table WHERE id=@id
  GetByID(id int) (T, error)

  // where("name=@name AND age=@age")
  FilterByNameAndAge(name string, age int) ([]T, error)
}

// Define your GORM model
// examples/models/user.go

type User struct {
  gorm.Model
  Name string
  Age  int
}
```

Generate code:

```bash
gorm gen -i ./examples -o ./generated
```

Use the generated code in your application:

```go
// Fetch user by ID
user, err := generated.Query[User](db).GetByID(ctx, 123)

// Filter users by name and age
users, err := generated.Query[User](db).FilterByNameAndAge(ctx, "jinzhu", 25)

// Build a custom filter using model field helpers
users, err := gorm.G[User](db).
  Where(generated.User.Name.Like("%jinzhu%"), generated.User.Age.Between(18, 65)).
  Find(ctx)
```

---

## Why Should You Care?

- **Productivity:** Write concise interface definitions instead of verbose query logic.
- **Reliability:** Prevent bugs by catching query errors at compile time.
- **Maintainability:** Clearly organize queries and field filters for large codebases.
- **Integration:** Seamlessly fits into existing GORM workflows, preserving the power of GORM with enhanced safety and clarity.

---

## Next Steps

Ready to try it out? Start with the [Prerequisites & System Requirements](../getting-started/setup-basics/prerequisites) and then install GORM CLI following the [Installing GORM CLI](../getting-started/setup-basics/installation) guide. After installation, explore the [Quickstart: Generate Type-Safe APIs](../guides/getting-started/quickstart-workflow) for a hands-on introduction.


---

## Additional Resources

- [Value Proposition & Unique Features](./value-proposition-and-unique-features)
- [Target Audience & Key Use Cases](./target-audience-use-cases)
- [Core Concepts & Terminology](./core-concepts-terminology)
- [How Code Generation Works](../../guides/getting-started/understanding-generation)


---

Explore GORM CLI today and elevate your Go data access layer with robust, type-safe APIs that scale with your project.
