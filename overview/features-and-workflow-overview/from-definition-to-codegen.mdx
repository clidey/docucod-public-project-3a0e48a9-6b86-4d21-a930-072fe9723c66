---
title: "From Definitions to Generated Code: Developer Workflow"
description: "Walk through the workflow: writing models and interfaces, running the CLI's codegen command, and using the resulting strongly-typed APIs for querying and updating. Explains the developer experience end-to-end, from first step to productive use."
---

# From Definitions to Generated Code: Developer Workflow

Discover how to move smoothly from defining your models and query interfaces to generating strongly typed, fluent APIs with GORM CLI’s `gen` command. This guide walks you through the entire developer experience — from writing SQL-annotated Go interfaces and model structs, to running the CLI's codegen, and finally using the generated type-safe APIs for querying and updating your database.

---

## Streamlined Workflow Overview

GORM CLI empowers Go developers using GORM with a clear-cut process that transforms interface definitions and models directly into safe, maintainable, and discoverable code. The workflow includes three essential steps:

1. **Write Your Models and Query Interfaces**
2. **Run the `gen` CLI Command to Generate Code**
3. **Use Generated Strongly Typed APIs for CRUD and Queries**

This end-to-end experience prevents runtime errors by providing compile-time guarantees and streamlines database access through fluent, contextual helpers.

---

## Step 1: Define Your Models and Interfaces

### Writing Your Models

Models are standard Go structs annotated with GORM conventions. They represent your database tables and their fields, including basic types and relationships such as associations.

```go
// models/user.go
package models

import (
  "gorm.io/gorm"
)

type User struct {
  gorm.Model
  Name string
  Age  int
}
```

### Crafting Query Interfaces with SQL Templates

Interfaces use Go generics with `[T any]` to express type safety. Each method comment contains SQL and template directives, which GORM CLI parses to generate implementation.

```go
// examples/query.go
package examples

type Query[T any] interface {
  // SELECT * FROM @@table WHERE id=@id
  GetByID(id int) (T, error)

  // where("name=@name AND age=@age")
  FilterByNameAndAge(name string, age int)
}
```

- Use special directives like `@@table` (resolves model table), `@param` (binds Go param), and Go templating (`{{if}}`, `{{where}}`) to build dynamic queries.
- Method return signatures enforce proper error handling.

<Tip>
Keep interfaces precise and descriptive. The CLI expects at least one return value for methods representing finished queries, with the final return value as error.
</Tip>

---

## Step 2: Generate Your Code with the CLI

Run the `gorm gen` command specifying your interface input path and output directory:

```bash
gorm gen -i ./examples -o ./generated
```

What happens during generation:

- GORM CLI parses your interfaces and attached SQL templates.
- It analyzes your model structs, including field types and associations.
- It generates two complementary outputs:
  - **Type-safe query API implementations**: concrete struct methods implementing your interface.
  - **Model-driven field helpers**: strong-typed filter, update, and association helpers for composing fluent queries.

The generated code ensures:

- Compile-time type safety minimizing bugs.
- Fluent APIs aligned with Go's conventions.
- Extensible and readable queries built on native Go constructs.

<Info>
You can also use generation config files (`genconfig.Config`) to customize output path, field helper types, and inclusion/exclusion rules.
</Info>

---

## Step 3: Use the Generated APIs in Your Projects

### Querying with Strong Typing

Generated APIs give you type-checked methods per your interface, allowing safe query construction.

```go
u, err := generated.Query[User](db).GetByID(ctx, 123)
if err != nil {
  // handle error
}
```

### Filtering and Updating with Field Helpers

The generated model helpers provide methods like `.Eq()`, `.Like()`, `.Between()`, and more to build expressive filters and updates.

```go
users, err := gorm.G[User](db).
  Where(generated.User.Age.Gt(18)).
  Find(ctx)

err = gorm.G[User](db).
  Where(generated.User.Name.Eq("alice")).
  Set(generated.User.Age.Incr(1)).
  Update(ctx)
```

### Managing Associations Safely

Use generated association helpers to create, update, unlink, or delete associated records with compile-time safety.

```go
gorm.G[User](db).
  Set(
    generated.User.Name.Set("alice"),
    generated.User.Pets.Create(generated.Pet.Name.Set("fido")),
  ).
  Create(ctx)
```

<Tip>
The generated code respects association semantics by type (has one, has many, belongs to, many2many), ensuring your operations correctly maintain your relational schema.
</Tip>

---

## Practical Tips and Best Practices

- **Context parameter**: If missing in interfaces, the generator automatically adds `context.Context` ensuring Go idiomatic async support.
- **Use SQL template DSL**: Leverage `{{where}}`, `{{set}}`, and Go templating inside method comments for powerful dynamic queries.
- **Customize generation**: Define `genconfig.Config` in your packages for flexible output paths, customized field mappings (e.g., for JSON fields), and filtering targets.
- **Generate often**: Run `gorm gen` after interface or model changes to keep generated APIs updated.
- **Error handling**: Follow Go idioms by checking error returns from all generated methods.

---

## Troubleshooting Common Scenarios

<AccordionGroup title="Common Generation and Usage Issues">
<Accordion title="No Generated Files After Running CLI">
Ensure that your `-i` input path correctly points to Go files with interfaces and that the interfaces are named and annotated per conventions. Check your `genconfig.Config` filters to avoid accidental exclusions.
</Accordion>
<Accordion title="Method Returns Don't Match Generated Code">
Verify each method in your interface returns either `(T, error)` or `error` as per method semantics. Check for the presence of SQL templates in documentation comments.
</Accordion>
<Accordion title="Runtime Errors in Queries">
Confirm that field names and types in your models accurately reflect your database schema. Use generated field helpers for composing queries to avoid SQL errors.
</Accordion>
</AccordionGroup>

---

## Summary

The `From Definitions to Generated Code` page demonstrates clearly how GORM CLI turns your Go interfaces annotated with SQL templates and models into a robust, type-safe database access layer. Mastering this workflow helps you reduce runtime errors, improve maintainability, and build fluent, discoverable query APIs quickly.

---

## Related Documentation

- [What is GORM CLI?](/overview/product-intro-and-value/what-is-gorm-cli): Understand the core purpose and uniqueness of GORM CLI.
- [Value Proposition & Benefits](/overview/product-intro-and-value/value-proposition-and-benefits): Learn about the benefits and value gained by adopting GORM CLI.
- [Core Concepts & Terminology](/overview/architecture-and-core-concepts/core-concepts-and-terminology): Deep dive into key terms like field helpers, association operations, and the template DSL.
- [Quick Feature Overview](/overview/features-and-workflow-overview/quick-feature-overview): Get an overview of key features supporting this workflow.
- [Using Type-Safe Query APIs](/guides/getting-started-workflows/using-type-safe-queries): Practical guide to using the generated query APIs.

---

## Next Steps

- Follow the [Quick Setup & First Generation](/guides/getting-started-workflows/quick-setup) to create your initial code generation pipeline.
- Explore [Template-Based SQL Queries](/guides/advanced-usage-patterns/template-sql-queries) to unleash powerful query customization.
- Customize your generation with [Generation Configuration](/guides/advanced-usage-patterns/customization-and-config) for tailored output.

---

## External Resources

- [GORM CLI GitHub Repository](https://github.com/go-gorm/cli) — Explore source code and examples.

---

Happy coding with GORM CLI — where your interfaces become safe, efficient, and intuitive database APIs.
