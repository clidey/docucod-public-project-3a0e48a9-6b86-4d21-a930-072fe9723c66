---
title: "What is GORM CLI?"
description: "An essential introduction to GORM CLI: a powerful code generation tool that creates type-safe, interface-driven query APIs and model-driven field helpers for GORM projects. Learn how it streamlines database code, increases compile-time safety, and enables fluent, discoverable APIs for efficient development."
---

# What is GORM CLI?

## Unleashing Fluent, Type-Safe Database Code for GORM Projects

GORM CLI transforms your routine database interactions into a fluid, type-safe experience by generating code that blends seamlessly with your existing GORM models. Imagine writing simple Go interfaces and model structs—and instantly gaining powerful, compile-time checked query APIs and helper fields that shorten development cycles and eliminate many runtime surprises.

### Why GORM CLI Matters
- **Boost Developer Confidence:** Catch query errors at compile time instead of debugging runtime SQL mistakes.
- **Fluent, Discoverable APIs:** Navigate generated code with intuitive methods and field helpers that make building queries straightforward and expressive.
- **Cut Boilerplate:** No more hand-writing repetitive SQL operations; GORM CLI generates these exactly to your specifications.

### Who Should Use This?
- Go developers working on database-heavy applications with GORM
- Teams striving to improve code safety, quality, and readability
- Projects that prioritize maintainable, scalable database access layers

---

## Introducing GORM CLI: Your Code Generation Companion

At its heart, GORM CLI is a **code generation tool** designed specifically for GORM projects. It automatically produces two synergistic components that streamline your database code:

1. **Interface‑Driven, Type‑Safe Query APIs**
2. **Model‑Driven Field Helpers**

Together, these provide a **compile-time safe**, fluent interface for both querying and manipulating your database models—whether working with simple filters or complex associations.

### What GORM CLI Enables You To Do
- Write Go interfaces annotated with SQL templates to define data retrieval and modification methods.
- Automatically generate concrete, type-safe implementations of these interfaces to avoid manual SQL crafting.
- Use generated field helpers that mirror your models’ fields and associations, simplifying complex query conditions and update operations.
- Manage database associations (has one/many, belongs to, many-to-many) with compile-time safety and expressive method calls.

### How It Fits in Your Workflow
- **Define your models:** Continue modeling your database entities as usual with GORM structs.
- **Write SQL-template interfaces:** Compose small interfaces with annotated SQL queries.
- **Run the generator:** Use the GORM CLI 'gen' command to produce code.
- **Build with confidence:** Use generated APIs and helpers for safe, expressive queries and updates.


---

## Core Features of GORM CLI

### 1. Type-Safe Query APIs
- Transform simple Go interface methods annotated with SQL into fully-generated query implementations.
- Strongly typed results ensure errors like column mismatches or parameter type issues are caught early.

### 2. Model-Driven Field Helpers
- For every model field—basic types or associations—generate strongly typed helpers (e.g., `.Eq()`, `.Between()`, `.Create()`) to use in `Where()`, `Set()`, and other clauses.
- Field helpers enable fluent and readable predicates and updates.

### 3. Association Management
- Create, batch create, update, unlink, or delete associated records easily, with full type safety.
- Supported association types include has one, has many, belongs to, many-to-many, and polymorphic relationships.

### 4. Template-based SQL DSL
- Embed dynamic SQL logic with directives like `@@table`, `@@column`, `@param`, `{{where}}`, and `{{set}}` inside interface method comments.
- Write complex conditional filters and updates that the generator translates into correct, type-safe code.

### 5. Configurable Code Generation
- Customize output paths, include/exclude specific interfaces or structs, and map Go types to custom field helpers through `genconfig.Config`.
- Easily extend and integrate generation into your existing projects.


---

## Why Should You Care?

GORM CLI not only speeds up development but **raises the quality and safety** of your data access layer. It eliminates common pain points like:

- Writing and maintaining repetitive SQL queries manually
- Handling error-prone string interpolation and param-binding
- Losing type safety with raw SQL execution
- Managing complex association operations with cumbersome code

### Real-World Benefits
- **Save Development Time:** With generated query interfaces and helpers, you spend less time debugging SQL and more on actual business logic.
- **Increase Code Reliability:** Compile-time checks catch mistakes early, reducing production bugs.
- **Improve Code Readability:** Fluent APIs make reading and writing query code intuitive.

### Common Use Cases
- REST APIs with complex filtering and pagination
- Backend services requiring safe batch updates and association management
- Projects at scale aiming for maintainable data access layers

---

## Getting Started Preview

To start experiencing the benefits of GORM CLI, begin with these simple steps:

1. **Write Your Interfaces and Models**
   - Define your queries as Go interfaces with embedded SQL templates.
   - Keep your model structs with GORM tags as usual.

```go
// examples/query.go
// Query interface with SQL templates in comments
type Query[T any] interface {
  // SELECT * FROM @@table WHERE id=@id
  GetByID(id int) (T, error)
}

// examples/models/user.go
type User struct {
  gorm.Model
  Name string
  Age  int
}
```

2. **Generate Code**

```bash
gorm gen -i ./examples -o ./generated
```

3. **Use the Generated APIs**

```go
// Query by ID
u, err := generated.Query[User](db).GetByID(ctx, 123)
// Filter users with age > 18
users, err := gorm.G[User](db).Where(generated.User.Age.Gt(18)).Find(ctx)
```

Explore the generated code to leverage field helpers and association operations fully.

---

## Additional Tips and Best Practices

- **Leverage Configurations:** Use `genconfig.Config` to tailor generation to your project’s needs, such as custom JSON field handling or output location.
- **Compose Complex Queries:** Utilize the template DSL directives (`{{where}}`, `{{if}}`) for dynamic query filters.
- **Manage Associations Clearly:** Use the detailed association helpers to create, update, unlink, or delete related data safely and efficiently.
- **Keep Interfaces Focused:** Define small, purpose-specific query interfaces for maximum clarity and code reuse.

---

Harness the power of code generation with GORM CLI to build safer, cleaner, and more powerful database code that scales with your project’s complexity and grows with your team’s confidence.

For detailed installation and comprehensive usage, refer to the [Getting Started guide](/getting-started/setup-basics/installation) and [Core Workflows](/guides/core-workflows/type-safe-queries).
