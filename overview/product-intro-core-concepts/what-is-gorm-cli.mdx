---
title: "What is GORM CLI?"
description: "GORM CLI is a code generator that builds type‑safe, fluent query APIs and field helpers directly from your Go interfaces and models. By bridging SQL templates and models, it gives you compile-time safety and discoverability for all CRUD operations, reducing boilerplate and runtime errors."
---

# What is GORM CLI?

## Delivering Type-Safe, Fluent Query APIs from Your Go Code

GORM CLI is a powerful code generator designed to bridge the gap between your Go data models, interface definitions, and database operations by converting annotated Go interfaces and models into type-safe, fluent query APIs and field helpers. This tool transforms your static Go interfaces and structured models, enriched with SQL templates and annotations, into fully generated code that dramatically reduces boilerplate, prevents runtime query errors, and enhances development productivity.

### Why GORM CLI Matters to You

Imagine writing database queries and updates entirely as clear, idiomatic Go method calls — with full compile-time safety, excellent discoverability, and zero manual SQL crafting in your application code. GORM CLI enables this by:

- Generating type-safe query methods from your annotated Go interfaces.
- Creating strongly typed field helpers from your models for constructing dynamic, safe filters and updates.
- Supporting advanced association handling with intuitive helpers for related entities.

This means your day-to-day database operations become seamless, less error-prone, and easier to maintain while staying fully integrated with the GORM ecosystem.

---

## What GORM CLI Does

At its core, GORM CLI is a generator tool that processes:

- **Go interfaces annotated with SQL templates:** Methods defined with special comments containing SQL and templating directives generate concrete, type-safe query APIs.
- **Go model structs:** Your data definitions transform into field helper sets that simplify writing filters, updates, and association operations.

The generator parses and interprets your code, applies filtering and customization configurations if specified, and writes out ready-to-use Go packages containing all the generated helpers and implementations.

This approach addresses the common pains of manual SQL management in codebases:

- Typos and parameter mismatches are caught at compile time.
- Complex SQL templates become reusable high-level methods.
- Field helpers provide clear, fluent, and strongly typed query builder parts.

---

## How It Works: Your Workflow With GORM CLI

1. **Define Your Interfaces and Models:**
   Write Go interfaces capturing your query intentions using SQL templates in method comments and declare your data models in structs.

2. **Run the CLI Generator:**
   Use `gorm gen` with your input directory or files containing these interfaces and models, specifying output directories as needed.

3. **Use the Generated APIs:**
   Import and call the generated query methods and field helpers directly in your application code with full IDE autocompletion and strong typing.

This flow empowers developers to work at a higher abstraction level and concentrate on business logic rather than tedious SQL details.

---

## Key Features & Capabilities

### 1. SQL Template-Driven Query API Generation
- Write interfaces with rich SQL templates and conditional directives in comments.
- Automatically generate matching Go methods that bind parameters and execute queries.
- Examples include querying by ID, filtering by dynamic columns, batch filtering with complex conditions, and updates with conditional SET clauses.

### 2. Model-Based Field Helper Generation
- From your Go structs, generate typed query predicates like `.Eq()`, `.Like()`, `.Between()`, and update setters `.Set()`.
- Properly type and infer predicates for common data types and custom mapped fields.
- Helpers for relations (has one/many, belongs to, many2many) generate association methods (`Create()`, `Update()`, `Unlink()`, `Delete()`, etc.).

### 3. Configurable and Extensible
- Declare package-level `genconfig.Config` to customize output paths, include/exclude patterns, file-level granularity, and custom field helper mapping.
- Supports filtering generation by interfaces or structs to keep output manageable.
- Custom field helper types enable adapting to JSON fields or database-specific types.

### 4. Seamless Integration With GORM
- Generated code naturally plugs into `gorm.io/gorm` query chains.
- Context parameter injection and clause expression usage optimize developer ergonomics and runtime efficiency.

### Real-World Example
```go
// Interface method example with SQL template
// SELECT * FROM @@table WHERE id=@id
GetByID(id int) (T, error)

// Usage
user, err := generated.Query[User](db).GetByID(ctx, 123)
```

This code compiles into an implementation that safely runs the SQL with parameter binding, returning a strongly typed `User` instance.

---

## Why Should You Care? The Benefits at a Glance

- **Compile-Time Safety:** Catch query errors and signature mismatches during build, not in production.
- **Readable & Maintainable:** Your SQL logic lives close to your Go interfaces, improving clarity and reuse.
- **Reduced Boilerplate:** No repetitive CRUD code; just write the interfaces and models you need.
- **Enhanced Productivity:** Autocomplete IDE support on generated methods and fields accelerates application development.
- **Flexible Integration:** Use with any GORM-backed system, enjoying consistent API patterns.

**Use Cases:**
- Projects requiring safe, maintainable complex SQL operations.
- Teams standardizing query interfaces across large codebases.
- Applications benefiting from generated association helpers to manage related data.

---

## Getting Started Preview

### Quick start command
```bash
gorm gen -i ./your_interfaces_and_models -o ./generated_code
```

### Basic prerequisites
- Go 1.18+ (for generics support).
- Your interfaces defined with SQL templates in comments.
- Models defined as Go structs.

### Next steps
- Explore the [Preparing Models & Query Interfaces](/getting-started/first-codegen-workflow/prepare-models-interfaces) guide.
- Run code generation as shown in [Running the Code Generator](/getting-started/first-codegen-workflow/generate-code).
- Consume and integrate the generated types per [Using the Generated APIs](/getting-started/first-codegen-workflow/using-generated-code).

---

## Tips & Best Practices

- Keep SQL templates simple and use provided DSL directives to conditionally build queries.
- Use `genconfig.Config` to tailor generation and avoid clutter.
- Test generated code with the examples provided in the repository's `examples/` folder.
- Leverage association helper methods to write expressive relational data mutations.

## Troubleshooting

- Ensure your input files are parseable Go source code and interfaces contain valid SQL templates.
- If generation outputs no files, check your include/exclude config filters.
- Errors during code generation usually detail the problematic interface/method for quick fixes.

---

Experience the power of fully type-safe query generation tailored to your Go codebase’s needs—streamline your database interactions with confidence using GORM CLI.

---

For further details and examples, refer to the [GORM CLI README](https://github.com/go-gorm/cli/blob/main/README.md).