---
title: "Integration and Extensibility"
description: "Explore how GORM CLI integrates seamlessly with gorm.io/gorm and fits into typical Go project structures. Learn about its extension points, configuration flexibility, and compatibility with common workflows."
---

# Integration and Extensibility

GORM CLI is designed not only to generate type-safe query APIs and field helpers but also to fit naturally into existing Go project structures and workflows. This page explores how GORM CLI integrates seamlessly with the core `gorm.io/gorm` ORM package, details its extension points, shows the configuration flexibility it offers, and explains its compatibility with common Go project patterns.

---

## Seamless Integration with `gorm.io/gorm`

GORM CLI is built to extend `gorm.io/gorm` rather than replace it. The generated query interfaces and field helpers work directly with GORM’s `*gorm.DB` instance, layering type safety and expressive querying on top of the familiar GORM APIs.

- **Native GORM Builder Compatibility:** The generated code accepts a `*gorm.DB` and produces implementations exposing GORM query chaining and expression composition, so you don’t lose any power or flexibility.
- **Fluent API for Model Queries:** Field helpers provide strongly typed predicates, setters, and association operations tailored to your domain models.
- **Context Support:** All generated query methods include `context.Context` by default if you omit it, ensuring aligned use with GORM’s best practices.

By maintaining this close coupling, you can drop GORM CLI-generated code into any existing GORM-based project without rewriting core database interaction layers.

## Fit into Typical Go Project Structures

GORM CLI’s design respects idiomatic Go project organization. It detects interfaces and model structs within standard package layouts and allows flexible output paths to match your project’s import structure.

### Package-level Configuration

You can declare a `genconfig.Config` variable at the package level to customize generation for that specific package, including:

- Output directory relative to the package
- Interface and struct inclusion/exclusion patterns using glob-like matching or explicit types
- File-level scopes to control generation granularity
- Custom field type mappings, enabling integration with specialized types or third-party libraries

### Example: Custom Package Config

```go
package examples

import (
  "database/sql"
  "gorm.io/cli/gorm/field"
  "gorm.io/cli/gorm/genconfig"
)

var _ = genconfig.Config{
  OutPath: "examples/output",
  FieldTypeMap: map[any]any{
    sql.NullTime{}: field.Time{},
  },
  IncludeInterfaces: []any{"Query*"},
  ExcludeStructs: []any{"*DTO"},
}
```

This configuration directs the generator to output code into `examples/output`, map `sql.NullTime` to custom `field.Time`, include interfaces matching `Query*`, and exclude DTO structs.

### Layout Flexibility

- Supports nested module and package structures
- Respects separate config files in sub-packages
- Handles common and custom naming conventions for interfaces and models

## Extension Points and Customization

GORM CLI encourages extensibility through multiple hooks:

- **Custom Field Helpers:** Replace or extend built-in field helper types by mapping your types in `FieldTypeMap` or via Go struct tags.
- **SQL Template DSL:** Write raw SQL templates with dynamic expressions, conditions, and iterations directly in interface comments. This supports complex queries beyond basic CRUD patterns.
- **Association Operations:** Supports complex operations on relationships (create, update, unlink, delete, batch create) mapped to generated association helpers.
- **Generation Filters:** Use glob or explicit type filters to include or exclude interfaces and structs for fine-grained control over generated code.

### Example: Custom JSON Field Helper

```go
// JSON is a custom field helper for JSON columns with DB-specific support
// See https://gorm.io/cli/gorm/examples/json.go

type JSON struct { ... }

var _ = genconfig.Config{
  FieldNameMap: map[string]any{
    "json": JSON{},
  },
}
```

This enables custom query and update operations on JSON columns with database aware SQL generation.

## Compatibility with Common Workflows

GORM CLI fits naturally into standard Go and GORM workflows without requiring special handling:

- **Go Modules:** Output generated code into your project’s module tree, import as usual
- **Build Tools:** Integrate the `gorm gen` CLI command into Makefiles, Go generate directives, or CI pipelines
- **Testing:** Easily mock or stub generated interfaces for unit testing
- **Incremental Generation:** Support for file-level configs enables re-generation of only changed parts

## Practical User Flow: Using Integration Features

1. **Define your query interfaces and models** under standard Go packages.
2. **Optionally declare package-level config** (e.g., `genconfig.Config`) to customize generation behavior and output.
3. **Run `gorm gen` CLI** specifying the input directory or Go file.

```bash
gorm gen -i ./examples -o ./generated
```

4. **Use the generated APIs** with your regular GORM DB instance, leveraging type safety and fluent expressions.

```go
u, err := generated.Query[User](db).GetByID(ctx, 123)
```

5. **Extend or customize behaviors** by mapping field types or writing advanced SQL templates in interfaces.

---

## Troubleshooting Integration Issues

<AccordionGroup title="Common Integration Issues and Solutions">
<Accordion title="Generated Code Not Found or Import Errors">
- Ensure the output path (`OutPath` in configuration or `-o` in CLI) matches your module and import paths.
- Run `go mod tidy` after generation to refresh dependencies.
- Confirm package-level `genconfig.Config` is placed in the correct directory.
</Accordion>
<Accordion title="Custom Types Not Mapped Correctly">
- Verify your `FieldTypeMap` entries use the exact Go types.
- Check for conflicting struct tags or name mismatches.
- Implement any required interfaces like GORM’s `Valuer` or `Scanner` on your custom types.
</Accordion>
<Accordion title="Interface or Struct Not Included in Generation">
- Review your `IncludeInterfaces` and `ExcludeInterfaces` settings.
- Confirm patterns or explicit type literals are correctly specified.
- Use verbose CLI options or logs to diagnose inclusion filtering.
</Accordion>
</AccordionGroup>

---

## Further Reading and Next Steps

- Explore the [Quick Feature Tour](/overview/product-intro/quick-feature-tour) to understand core capabilities.
- Review the [First Code Generation Guide](/guides/getting-started-workflows/first-generation) for initial setup.
- Dive into [Field Helpers Basics](/guides/getting-started-workflows/field-helpers-basics) for customizing and extending generated fields.
- Study [SQL Template DSL](/guides/advanced-patterns-integration/template-sql-dsl) to write powerful, dynamic SQL.
- Consult [Managing Associations](/guides/advanced-patterns-integration/associations-in-depth) for advanced relation handling.

<Check>
Harness GORM CLI’s integration capabilities to improve your project’s database code safety, maintainability, and speed.
</Check>
