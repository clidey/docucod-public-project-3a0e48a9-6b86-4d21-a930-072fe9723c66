---
title: "Core Concepts & Terminology"
description: "Build foundational knowledge: learn what type-safe query APIs, field helpers, model-driven associations, and template-based SQL mean in GORM CLI. This reference orients users to the domain language used throughout the product."
---

# Core Concepts & Terminology

Understanding GORM CLI’s core domain language is essential to effectively harnessing its power. This page builds your foundational knowledge by demystifying the key concepts you will encounter throughout the documentation: **type-safe query APIs**, **field helpers**, **model-driven association management**, and **template-based SQL queries**. By mastering these terms, you will confidently navigate usage patterns, generate robust code, and optimize your data operations.

---

## What Are Type-Safe Query APIs?

At the heart of GORM CLI lies the ability to convert raw SQL interface definitions into **type-safe, fluent query APIs** for your Go applications.

- **Definition:** These APIs are generated Go methods based on your interface signatures annotated with SQL templates.
- **Why it matters:** They enable compile-time checking of your database queries, dramatically reducing runtime errors from SQL syntax issues or mismatched parameters.
- **What you get:** Autocompletion, discoverability, and safety while building complex queries with familiar Go constructs.

### Example

```go
// Define an interface with embedded SQL templates
 type Query[T any] interface {
   // SELECT * FROM @@table WHERE id=@id
   GetByID(id int) (T, error)
 }
```

The generator creates a type-safe function `GetByID` that you call directly on the generated API, which ensures parameter types and SQL structures align.

---

## Field Helpers: Model-Driven, Typed Helpers for Database Fields

GORM CLI generates **field helpers** tailored to your model structs, providing expressive and type-safe methods for filtering, updating, and ordering database fields.

- **What are they?** Wrapper types like `field.String`, `field.Number[int]`, `field.Bool`, and custom wrappers for specialized fields (e.g., JSON, Time).
- **Core benefit:** They abstract SQL predicate and update expressions with fluent helpers that map directly to your Go model fields.
- **How it works:** Each field in your struct gains helper methods such as `Eq()`, `Like()`, `Between()`, `Set()`, and increment or expression setters.

### Example

```go
// Model example
 type User struct {
   ID   uint
   Name string
   Age  int
 }

// Using field helpers
 gorm.G[User](db).
   Where(generated.User.Name.Eq("alice"), generated.User.Age.Between(18, 30)).
   Find(ctx)
```

This results in strongly typed queries, eliminating common errors from raw string SQL construction.

---

## Model-Driven Association Helpers

Relationships between database entities come with their own complexities. GORM CLI extends model-driven generation to associations, giving you **compile-time-safe helpers** to manage linked data.

- **Supported associations:** belongs to, has one, has many, many-to-many, polymorphic relations.
- **Operations provided:**
  - Create and batch create linked records
  - Update linked records with conditions
  - Unlink (detach) relationships without deleting data
  - Delete linked records or join rows, conditionally
- **Semantics tailored by association type:**
  - For example, `Unlink` on belongs-to clears the foreign key on the parent.

### Example

```go
gorm.G[User](db).
  Set(
    generated.User.Name.Set("alice"),
    generated.User.Pets.Create(generated.Pet.Name.Set("fido")),
  ).
  Create(ctx)
```

Here, a new `User` and a related `Pet` are created and linked in a single operation, all in a fully type-safe manner.

---

## Template-Based SQL in Interface Methods

GORM CLI enables you to write **flexible SQL queries with templating** directly in Go interface method comments.

- **Purpose:** Write concise, reusable SQL templates that bind parameters dynamically, supporting conditional logic.
- **Key directives:**
  - `@@table` and `@@column` for model-aware dynamic table or column names
  - `@param` placeholders that map method parameters to SQL
  - `{{where}}` and `{{set}}` for conditional clauses
  - `{{if}}` and `{{for}}` for control flow and iteration

### Example

```go
// SELECT * FROM @@table
// {{where}}
//   {{if user.Name != ""}} name=@user.Name {{end}}
//   {{if user.Age > 0}} AND age=@user.Age {{end}}
// {{end}}
FilterWithUser(user User) ([]T, error)
```

This query dynamically constructs `WHERE` clauses based on populated user fields, avoiding unnecessary conditions.

---

## How These Concepts Work Together

When combined, these components form a seamless developer experience around GORM projects:

- **You define interfaces** with SQL templates describing the queries you want.
- **You define your models** with struct fields and annotations where required.
- **GORM CLI generates:**
  - Fluent, type-safe query methods
  - Typed field helpers for predicates and updates
  - Robust association management helpers
- **You write your application code** calling generated APIs with confidence that queries are checked at compile-time.

---

## Practical Tips

- Use **field helpers** for all filtering and updates—avoid raw strings.
- Leverage **template DSL** for dynamic, conditionally constructed SQL to keep your queries concise and maintainable.
- Configure generation explicitly with `genconfig.Config` where package-level overrides help tailor field types and code output locations.
- Remember association helper semantics differ by relationship type—understand `Unlink` vs. `Delete` before mutating associations.

---

## Common Pitfalls & Troubleshooting

- Forgetting to include `context.Context` in interfaces: the generator adds it, but be explicit for clarity.
- Misconfigured generator filters (`IncludeInterfaces`, `ExcludeStructs`) may cause expected types or interfaces not to generate.
- Unhandled SQL syntax errors in template comments can cause generation to fail; carefully ensure valid SQL and correct templating syntax.

---

## Visual Overview of Core Concepts

```mermaid
flowchart TD
  UserModels["User-defined Models (structures)"] --> Gen["GORM CLI Generator"]
  QueryInterfaces["Query Interfaces with SQL templates"] --> Gen
  Gen --> GeneratedAPIs["Generated
- Query APIs
- Field Helpers
- Association Helpers"]
  GeneratedAPIs --> Dev["Application Code
(type-safe and fluent usage)"]

  subgraph ""
    UserModels
    QueryInterfaces
  end

  classDef source fill:#cde,stroke:#036,stroke-width:2px
  classDef output fill:#9f6,stroke:#060,stroke-width:2px
  class UserModels,QueryInterfaces source
  class GeneratedAPIs output

```

This flowchart demonstrates how your user-defined code inputs feed the generator, which produces the APIs you integrate into your applications.

---

## Next Steps

Advance your mastery by exploring:

- [What is GORM CLI?](/overview/introduction/what-is-gorm-cli) for the complete product introduction
- [Product Value & Use Cases](/overview/introduction/value-prop-and-use-cases) for understanding why these concepts translate into real-world benefits
- [Feature Summary](/overview/introduction/feature-overview) to drill into capabilities enabled by these core concepts
- [Getting Started with GORM CLI](/guides/essential-workflows/getting-started) to apply these concepts in practice


-----

<Tip>
Use this page as your terminology reference and frequent touchpoint when reading examples or advanced workflow documentation. Familiarity with these concepts ensures you leverage GORM CLI to its fullest.
</Tip>


---

<AccordionGroup title="Glossary of Core Terms">
<Accordion title="Type-Safe Query API">
APIs generated from annotated Go interfaces that guarantee compile-time checking for SQL queries and parameters.
</Accordion>
<Accordion title="Field Helpers">
Typed wrappers around struct fields that provide expressive query predicates and update methods mapped to Go types.
</Accordion>
<Accordion title="Model-Driven Associations">
Helper APIs generated from struct relationships enabling safe and consistent operations on related data.
</Accordion>
<Accordion title="SQL Template DSL">
A domain-specific language embedded in interface comments enabling dynamic SQL with placeholders, conditionals, and loops.
</Accordion>
</AccordionGroup>

---

## References

- [GORM CLI Overview & Introduction](https://gorm.io/cli/gorm/overview/introduction/what-is-gorm-cli)
- [Product Value & Use Cases](https://gorm.io/cli/gorm/overview/introduction/value-prop-and-use-cases)
- [Feature Summary](https://gorm.io/cli/gorm/overview/introduction/feature-overview)
- [System Architecture Overview](https://gorm.io/cli/gorm/overview/core-architecture-concepts/architecture-overview)
- [Getting Started Guide](https://gorm.io/cli/gorm/guides/essential-workflows/getting-started)

---

## Source Code Reference

- Core generator logic: [`internal/gen/generator.go`](internal/gen/generator.go)
- Interface definitions and SQL template parsing: [`examples/query.go`](examples/query.go)
- Configuration structure: [`genconfig/config.go`](genconfig/config.go)



---

*Last updated: main branch of [GORM CLI GitHub repository](https://github.com/go-gorm/cli)*
