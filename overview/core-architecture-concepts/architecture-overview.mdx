---
title: "System Architecture"
description: "See how GORM CLI works under the hood with a mermaid diagram showing the relationship between generator, input definitions, and generated code. Understand the data flow from interface/model definition through to safe, fluent APIs."
---

# System Architecture

Discover how GORM CLI transforms your Go source code and SQL annotations into safe, fluent, and discovery-friendly query APIs and model helpers. This page provides a clear look under the hood, illustrating the key components and their interactions during code generation.

---

## How GORM CLI Works: From Inputs to Outputs

At its core, GORM CLI automates generation of two complementary components:

- **Query API implementations** driven by your *Go interfaces* with inline SQL templates
- **Model-driven field helpers** based on your *Go struct models* for fields and associations

This system architecture shows how these parts interact, the data flow through the generator, and the resulting generated Go code that you use in your projects.

<Accordion title="View Full Mermaid Architecture Diagram">
```mermaid
flowchart TD

  subgraph User Inputs
    direction TB
    InterfaceFiles["Go Interface Files with SQL Annotations"]
    ModelFiles["Go Model Struct Files"]
    ConfigFiles["Optional genconfig.Config Files"]
  end

  subgraph GORM CLI Generator
    direction TD

    Processor["Source Code Processor & Parser"]
    SQLExtractor["Extract SQL Templates from Interface Comments"]
    ConfigResolver["Resolve & Merge Generation Configs"]
    TypeAnalyzer["Analyze Model Structs & Field Types"]
    TemplateRenderer["Render Templates for Queries and Field Helpers"]
    CodeFormatter["Format & Write Generated Code Files"]
  end

  subgraph Generated Outputs
    QueryAPIs["Type-Safe Query API Go Code"]
    ModelHelpers["Model-Driven Field Helper Go Code"]
  end

  InterfaceFiles --> Processor
  ModelFiles --> Processor
  ConfigFiles --> ConfigResolver

  Processor --> SQLExtractor
  Processor --> TypeAnalyzer

  SQLExtractor --> TemplateRenderer
  TypeAnalyzer --> TemplateRenderer
  ConfigResolver --> TemplateRenderer

  TemplateRenderer --> CodeFormatter
  CodeFormatter --> QueryAPIs
  CodeFormatter --> ModelHelpers

  classDef component fill:#f4f4f8,stroke:#777,stroke-width:2px,stroke-dasharray: 5 5;
  class User Inputs,Generated Outputs component;

  classDef generator fill:#e3f2fd,stroke:#1e88e5,stroke-width:2px;
  class GORM CLI Generator generator;

```
</Accordion>

---

## Data Flow Explained

1. **User Inputs**: You start by providing your projectâ€™s *Go interface files* with embedded SQL comment annotations, *model struct files* defining your data models and associations, and optionally, *configuration files* to customize the generation behavior.

2. **Source Code Processing**: The generator parses all input files, walks the Go Abstract Syntax Tree (AST), and collects:
   - Interfaces and their documented SQL templates
   - Structs and their fields, including embedded types and tags
   - Configuration metadata for filtering and mapping

3. **SQL Template Extraction**: SQL fragments inside interface method comments are parsed and prepared with parameter placeholders and directives.

4. **Model Type Analysis**: Each struct and field is analyzed to infer types, detect associations (e.g., `has one`, `many to many`), and map fields to appropriate helper types for DSL predicates or setters.

5. **Configuration Resolution**: Any `genconfig.Config` settings are resolved hierarchically to influence output paths, filters, and custom type mappings.

6. **Template Rendering**: Using these parsed inputs, the generator populates Go source code templates that produce:
   - Concrete implementations of your query interfaces with type-safe methods
   - Structured, discoverable field helper variables reflecting model fields and associations

7. **Code Formatting & Output**: The generated Go code is formatted using standard Go tooling, ensuring idiomatic style and correctness, then written to the configured output directories.

---

## Components Breakdown

| Component                    | Role & User Impact                                                   |
|-----------------------------|--------------------------------------------------------------------|
| **Go Interface Files**       | Define your intended query APIs with embedded SQL templates. This is your developer-friendly contract for data retrieval and update. |
| **Go Model Structs**          | Represent your database schema and relationships in Go types; drive generation of field helpers used in filters, updates, and association operations. |
| **Configuration Files**       | Customize output path, inclusion/exclusion rules, and map specialized Go types to custom field helpers to fit your project needs. |
| **Source Processor**          | Parses all input source code and extracts metadata. Users interact indirectly by structuring their project files appropriately. |
| **SQL Extractor**             | Validates and prepares SQL templates ensuring safe parameter binding and dynamic SQL features, enabling fluent and flexible querying. |
| **Type Analyzer**             | Detects field types and association semantics to enable typed, discoverable DSLs that prevent runtime errors. |
| **Template Renderer**         | Generates the actual Go code your project consumes, turning interfaces and models into working, type-safe APIs and helpers. |
| **Code Formatter & Writer**  | Produces clean, formatted, and idiomatic Go code files that integrate seamlessly with your build and development workflows. |

---

## Example User Workflow with Architecture in Mind

Imagine you want to query users by ID and update user info safely:

1. Define `Query[T] interface` methods with SQL templates in your Go source code.
2. Define your `User` model struct with GORM annotations and relationships.
3. Run `gorm gen -i ./examples -o ./generated` to kick off the generator.
4. Under the hood, the CLI:
   - Parses interfaces and extracts SQL
   - Reads model structs and detects associations
   - Applies any generation configs
   - Renders type-safe query methods and field helpers
   - Outputs ready-to-use Go files.
5. Consume the generated code in your apps with full compile-time safety.

---

## Best Practices & Tips

- **Organize your input files with clear separation between interfaces and models** to help the parser extract relevant constructs effectively.
- **Use configuration files to filter interfaces or structs** when working with large codebases to optimize generation time and output size.
- **Embed clear SQL templates in interface method comments**: the generator depends on their accuracy to produce correct implementations.
- **Annotate model fields properly** to leverage association helpers fully (e.g., using GORM tags for polymorphisms, many-to-many).

---

## Troubleshooting Common Issues

<AccordionGroup title="Troubleshooting & Tips">
<Accordion title="Input Parsing Errors">
These occur when the generator fails to parse interfaces or structs due to syntax issues or unsupported types. Always validate Go source files compile cleanly before generation.
</Accordion>
<Accordion title="Missing Generated Code">
Check your `-i` and `-o` flags to ensure input paths and output directories are correctly specified. Verify config files do not exclude your interfaces or structs unintentionally.
</Accordion>
<Accordion title="SQL Template Problems">
Ensure your SQL templates are valid, especially placeholders `@param` and directives like `{{where}}` or `{{set}}`. Syntax issues in templates will cause generation failures.
</Accordion>
</AccordionGroup>

---

## Next Steps

Now that you understand GORM CLI's core architecture and data flow:

- Explore [Define Models and Query Interfaces](/getting-started/first-gen-workflow/define-models-interfaces) to begin crafting your inputs.
- Dive into [Generating and Using Query APIs](/guides/essential-workflows/generating-and-using-apis) for a practical guide on integrating generated code.
- Refer to [Managing Associations and Relationships](/guides/advanced-use-cases/association-operations) for complex model scenarios.

---

For full perspective, see the [Overview & Introduction](../introduction/what-is-gorm-cli) and [Feature Summary](../introduction/feature-overview) pages.

<Info>
This page focuses on the generator's internal system architecture and data flow, enabling users to deepen their understanding of how GORM CLI delivers its value.
</Info>
