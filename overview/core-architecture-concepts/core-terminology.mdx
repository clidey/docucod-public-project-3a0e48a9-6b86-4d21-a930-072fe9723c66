---
title: "Core Concepts & Terminology"
description: "Master the essential terms—like query APIs, field helpers, association operations, generation templates, and config patterns—used throughout GORM CLI's documentation. Build a solid conceptual baseline for deeper engagement."
---

# Core Concepts & Terminology

Master the essential terms—like query APIs, field helpers, association operations, generation templates, and config patterns—used throughout GORM CLI's documentation. This foundational guide establishes a clear conceptual baseline to help you confidently navigate, use, and extend GORM CLI.

---

## Why Understanding Core Concepts Matters

Embarking on your GORM CLI journey begins with grasping the key concepts and terminology behind the tool. This knowledge unlocks the power of its type-safe query APIs, model-driven field helpers, and flexible generation configurations, enabling you to write fluent, maintainable, and robust database code effectively.

---

## Key Concepts Explained

### Query APIs

**What They Are:**
Query APIs are Go interface-driven, type-safe methods generated from your annotated interfaces. These APIs let you perform database operations using statically-typed Go functions, eliminating runtime errors caused by typos or mismatched SQL parameters.

**Why You Need Them:**
By writing annotated interface methods with SQL templates, GORM CLI generates concrete implementations that:
- Bind parameters safely
- Produce compile-time checked code
- Provide fluent and discoverable query builders

**Example:**
```go
// Sample interface method with SQL annotation
// SELECT * FROM @@table WHERE id=@id
GetByID(id int) (T, error)
```
The generated method `GetByID` will execute a parameter-safe SQL query with a result mapped to your Go model.


### Field Helpers

**What They Are:**
Field helpers are generated, strongly-typed representations of your model struct fields. They provide expressive predicates and setter methods to build filters, updates, and expressions for basic fields and associations.

**Benefits:**
- Promote reusable, type-safe expressions
- Simplify complex query building
- Support zero value handling and SQL expressions

**Examples:**
```go
// Basic filters
generated.User.Name.Eq("alice")             // name = 'alice'
generated.User.Age.Between(18, 65)            // age between 18 and 65

// Update setters
generated.User.Score.Set(sql.NullInt64{})    // set score to NULL

// Association helpers
generated.User.Pets.Create(generated.Pet.Name.Set("fido"))  // create associated pet
```

### Association Operations

**What They Are:**
Specialized helpers for managing model relationships like has one, has many, belongs to, and many-to-many associations. They support create, update, unlink, delete, and batch creation operations with built-in safety.

**Key Operations:**
- **Create:** Insert related rows and link them
- **Update:** Modify associated records selectively
- **Unlink:** Remove links without deleting data
- **Delete:** Remove associated rows or join table entries
- **CreateInBatch:** Efficiently create multiple related records

**Semantics Vary Per Association Type:**
- Belongs to: unlink clears parent FK; delete removes associated row
- Has one/has many: unlink clears child FK; delete removes child rows
- Many2many: unlink/delete remove join rows only


### Generation Templates and SQL Template DSL

**What They Are:**
Generation templates underpin the type-safe query API methods, constructed from SQL templates in interface method comments. GORM CLI interprets these SQL templates with special templating directives to produce dynamic, conditional, and parameter-bound queries.

**Core DSL Elements:**
- `@@table`: Injects table name dynamically
- `@@column`: Binds dynamic column names
- `@param`: Maps method parameters to SQL
- `{{where}}`, `{{set}}`: Conditional SQL blocks for filtering and updates
- `{{if}}`, `{{for}}`: Conditional and iterative logic in SQL

**Example:**
```sql
// SELECT * FROM @@table WHERE id=@id
GetByID(id int) (T, error)

// UPDATE @@table
// {{set}}
//   {{if user.Name != ""}} name=@user.Name, {{end}}
//   {{if user.Age > 0}} age=@user.Age {{end}}
// {{end}}
// WHERE id=@id
UpdateUser(user User, id int) error
```

This approach lets you embed flexible SQL logic directly in your Go interface methods, with generation ensuring type safety and correctness.

### Generation Configuration Patterns

**What They Are:**
The `genconfig.Config` object lets you customize code generation on a per-package or per-file basis. Config settings control output paths, filtering of interfaces and structs by patterns, field type mappings, and file-level application.

**Typical Config Fields:**
- `OutPath`: Specify output directory for generated code
- `IncludeInterfaces` / `ExcludeInterfaces`: Whitelisting/blacklisting interface types for generation
- `IncludeStructs` / `ExcludeStructs`: Similar control for model structs
- `FieldTypeMap`: Custom Go type to field helper mapping
- `FieldNameMap`: Resolve named Go types by struct tags to custom field helpers
- `FileLevel`: Whether config applies to a single file or the entire package

**Example:**
```go
var _ = genconfig.Config{
  OutPath: "./generated",
  IncludeInterfaces: []any{"Query*"},
  FieldNameMap: map[string]any{"json": JSON{}},
}
```

This lets you tailor generation behavior to fit your project structure and conventions.

---

## Getting the Big Picture

Here is a high-level workflow of how GORM CLI fits together:

```mermaid
flowchart TD
  Start[Start: Write Go Interfaces & Models] -->
  AnnotatedInterfaces[Define Interfaces with SQL Templates]
  AnnotatedInterfaces --> ModelStructs[Define Model Structs]
  ModelStructs -->
  Generation[Run `gorm gen` (Generator)]
  Generation -->
  GeneratedCode[Produces Query APIs & Field Helpers]
  GeneratedCode -->
  Application[Use Generated Code in App]

  classDef startend fill:#93c5fd,stroke:#1e40af,stroke-width:2px
  class Start,Application startend
```

This flow lets you start with plain Go types and interfaces, then obtain fully generated APIs and helpers that empower safe and expressive database interactions.

---

## Practical Tips and Best Practices

- **Consistent Annotations:** Always keep SQL templates correctly annotated in interface method comments.
- **Context Awareness:** If you omit `ctx context.Context` in interface methods, the generator inserts it automatically.
- **Use Config for Large Codebases:** Use `genconfig.Config` to control scope and customize field helper mapping.
- **Leverage Generated Association Helpers:** Use `.Create()`, `.Update()`, `.Unlink()`, and `.Delete()` methods on associations to manage related data cleanly.
- **Avoid Naming Conflicts:** Use Go package structure and config filters to avoid generating code for unwanted interfaces or structs.
- **Test Generated Code:** Run generation as part of your build process and include generated code in your tests to ensure correctness.

---

## Troubleshooting Common Issues

<AccordionGroup title="Common Pitfalls & Their Solutions">
<Accordion title="Method Return Value Errors">
If a query method has no return values or invalid returns (e.g., missing an error type), generation will fail with an explicit message. Check method signatures carefully.
</Accordion>
<Accordion title="Missing SQL Annotations">
Methods without SQL templates marked in comments will cause generator errors or unexpected behavior. Ensure each method has a suitable SQL template.
</Accordion>
<Accordion title="Incorrect Config Matching">
Selectors in your `genconfig.Config` may fail if patterns or type specifications don't match exactly. Validate patterns and use full package-qualified types when needed.
</Accordion>
<Accordion title="File-Level Config Unexpected Behavior">
Setting `FileLevel` true restricts config influence to the declaring file. Use with care to avoid excluding needed interfaces or structs.
</Accordion>
</AccordionGroup>

---

## Next Steps

- Explore the [What is GORM CLI?](../overview/product-intro/what-is-gorm-cli) page for an introductory walkthrough.
- Review [Feature Highlights at a Glance](../overview/product-intro/quick-feature-tour) to see key capabilities.
- Get hands-on with [First Code Generation](../../getting-started/first-usage/first-code-generation) to start generating your own query APIs.
- Deep dive into [Field Helpers: Filtering, Updates, and Expressions](../../guides/getting-started-workflows/field-helpers-basics) to master model-driven queries.
- Consult the [SQL Template DSL](../../guides/advanced-patterns-integration/template-sql-dsl) guide for advanced templating techniques.

---

_For source code details and ongoing development, visit the GORM CLI [GitHub Repository](https://github.com/go-gorm/cli)._

---
