---
title: "System Architecture Overview"
description: "A high-level diagram (using mermaid syntax) and explanation of GORM CLI's architecture: how it takes in models and interfaces, generates query APIs and field helpers, and integrates with GORM in user projects. Visualizes key data flow and component interactions, ensuring users understand the generator's place in the development pipeline."
---

# System Architecture Overview

GORM CLI is a powerful code generation tool designed to seamlessly integrate with your Go projects that use GORM. This page provides a high-level architectural diagram and explanation of how GORM CLI ingests your Go models and interfaces, generates type-safe, query APIs along with field helpers, and integrates them back into your project. Understanding the flow of data and key component interactions empowers you to harness the generator effectively and optimize your development workflow.

---

## GORM CLI Architecture Explained

At its core, GORM CLI operates as a generator tool that converts your input Go code — specifically query interfaces annotated with SQL templates and model structs — into compile-time safe, fluent APIs that simplify database operations.

### What Happens Behind the Scenes?

1. **Input Processing:**
   - You write Go interfaces containing methods with embedded SQL or template annotations to define queries.
   - You also provide Go model structs that describe your database entities.

2. **Code Generation:**
   - The generator parses these interfaces and structs.
   - It produces **query APIs** from your interfaces, embracing type safety using generics and SQL templates.
   - Simultaneously, it creates **field helpers** from models, representing columns and associations with strongly typed constructs.

3. **Integration:**
   - The generated code plugs directly into your user project.
   - You use the resulting fluent, discoverable APIs to compose queries, updates, and association operations with confidence.


### Why This Architecture Matters

- By separating **interface-driven query definition** from **model-driven field helpers**, the generator ensures:
  - Clear, user-defined query intents transformed into safe, automated code.
  - Rich model metadata leveraged for precise filters, updates, and association handling.

- Centralizing generation logic via the `gen` command in the CLI reduces repetitive boilerplate, accelerates development, and enforces compile-time correctness.

---

## High-Level Component Diagram

```mermaid
flowchart TD

  subgraph UserProject["User Project"]
    Models["Go Model Structs"]
    Interfaces["Query Interfaces with SQL Annotations"]
  end

  subgraph GORM_CLI_GEN["GORM CLI Generator"]
    CLI["gorm gen CLI Command"]
    Parser["Parser & AST Extractor"]
    GeneratorEngine["Code Generator Engine"]
    TemplateRenderer["Template Renderer"]
  end

  subgraph GeneratedCode["Generated Code"]
    QueryAPI["Type-Safe Query APIs"]
    FieldHelpers["Model-Driven Field Helpers"]
  end

  subgraph GORM_INTEGRATION["GORM & User Code Integration"]
    UseGenerated["Use Generated APIs in User Code"]
    GORMCore["gorm.io/gorm Core Library"]
  end

  %% Flow connections
  Models --> CLI
  Interfaces --> CLI
  CLI --> Parser
  Parser --> GeneratorEngine
  GeneratorEngine --> TemplateRenderer
  TemplateRenderer --> QueryAPI
  TemplateRenderer --> FieldHelpers
  QueryAPI --> UseGenerated
  FieldHelpers --> UseGenerated
  UseGenerated --> GORMCore

  %% Styling
  classDef cli fill:#f9f,stroke:#333,stroke-width:2px
  class CLI cli

  classDef genEngine fill:#bbf,stroke:#333
  class GeneratorEngine,Parser,TemplateRenderer genEngine

  classDef userApp fill:#efe,stroke:#333
  class UserProject,GeneratedCode,GORM_INTEGRATION,userApp
```


---

## Key Components and Their Roles

| Component               | Role & Responsibilities                                                |
|-------------------------|------------------------------------------------------------------------|
| **Go Model Structs**     | Define database entities with types and fields used for field helpers. |
| **Query Interfaces**     | Specify SQL templates in annotated methods to define queries.          |
| **gorm gen CLI Command** | Entry point for generation; accepts input paths and output configuration.|
| **Parser & AST Extractor** | Parses Go source code to extract interfaces, structs, methods, and annotations.|
| **Code Generator Engine**| Processes parsed data, applies configs, filters, and prepares for rendering. |
| **Template Renderer**    | Renders Go source files including query APIs and field helpers from templates.| 
| **Generated Query APIs** | Provides type-safe methods for executing queries, integrating SQL templates.| 
| **Generated Field Helpers** | Provides strongly typed helpers for model fields and associations enabling fluent queries.| 
| **User Code Integration**| Developers incorporate generated code into projects, interacting with GORM core for ORM operations.| 


---

## How Data Flows in the Generator Pipeline

1. **Writing Your Source Code:**
   - You define your **models** structuring your data.
   - You define **query interfaces** specifying SQL queries using GORM CLI’s SQL template DSL.

2. **Running the Generator:**
   - Execute `gorm gen -i ./inputpath -o ./outputpath`.
   - The tool reads your source, parses it with standard Go tools, then
   - Extracts interfaces and models along with SQL templates and config metadata.

3. **Code Generation:**
   - The generator resolves types, applies config rules, and prepares structured data.
   - It renders templates producing two major code outputs:
     - **Query API files:** Interfaces implemented as type-safe concrete query methods.
     - **Field helpers files:** Strongly typed field and association helpers (e.g., `generated.User.Age.Eq(20)`).

4. **Compilation and Use:**
   - The generated code is then compiled with your project.
   - You call fluent APIs on models and queries, benefiting from auto-completion, static type checks, and simplified ORM interactions with GORM.


---

## Practical Benefits Demonstrated

- **Compile-time Safety:** Eliminates many runtime SQL errors by enforcing types and query correctness.

- **Enhanced Developer Productivity:** Write less boilerplate, rely on intuitive generated helpers.

- **Customizable & Extensible:** Supports user configurations, field name/type mappings, and complex SQL template logic.

- **Seamless GORM Integration:** Generated code fits naturally into GORM’s existing ecosystem.


---

## Getting Started Preview

To start using GORM CLI's generator within your project:

<Steps>
<Step title="Prepare Your Go Interfaces and Models">
Define your SQL query interfaces with annotated methods and declare your model structs in your project.
</Step>
<Step title="Run GORM CLI Generator">
Invoke `gorm gen -i <input-path> -o <output-path>` specifying your source and destination.
</Step>
<Step title="Use the Generated Code">
Import the generated package into your project, then call query APIs and field helpers to build type-safe ORM code.
</Step>
</Steps>

Refer to the [Getting Started Guide](/getting-started/configure-and-generate/first-generation) for detailed steps.


---

## Troubleshooting & Tips

<AccordionGroup title="Common Issues and How to Resolve">
<Accordion title="My generator run produces no files">
Check that your input interface and model files contain correctly annotated interfaces and exported model structs. Confirm your `Include*` and `Exclude*` settings in genconfig are not filtering out all types.
</Accordion>
<Accordion title="SQL Template Errors in Interface Methods">
Ensure that your SQL template syntax matches GORM CLI’s DSL exactly. Pay attention to placeholder syntax like `@@table`, `@param`, and directives like `{{where}}`.
</Accordion>
<Accordion title="Association Helpers Not Generated">
Verify that your model struct fields properly define relations using GORM tags like `gorm:"many2many"` or `gorm:"polymorphic"`. Also, check your config doesn’t exclude related structs.
</Accordion>
<Accordion title="Cannot find generated package after generation">
Make sure the `-o` output directory is set correctly and is included as a Go module import path in your project.
</Accordion>
</AccordionGroup>


---

Understanding this architecture ensures you can confidently plan and maintain your GORM-based projects with GORM CLI, streamlining complex queries and preserving type safety throughout your database interactions.

For a deeper dive into specific steps of writing interfaces, running generation, and using the resulting code, consult the following related documentation pages.

---

### Related Documentation

- [What is GORM CLI?](/overview/product-intro-basics/what-is-gorm-cli)
- [Defining Query Interfaces & Models](/guides/getting-started-workflows/defining-interfaces-models)
- [Generating and Using Type-Safe APIs](/guides/getting-started-workflows/generating-using-apis)
- [Template-Based Queries & SQL DSL](/guides/advanced-usage-patterns/template-based-queries)
- [Integration with GORM & Go Projects](/overview/architecture-features-integration/integration-points)

---

### See Also

- `main.go` — Entry point invoking the `gen` command
- `internal/gen/gen.go` and related files — Core generator logic handling parsing and generation
- `examples/query.go` & `examples/models/user.go` — Sample interfaces and model declarations

---

Harness GORM CLI’s architecture to revolutionize how you build database interactions in Go with GORM: safer, faster, and developer-friendly.

---
