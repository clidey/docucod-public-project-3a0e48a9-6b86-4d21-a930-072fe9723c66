---
title: "Architecture Overview"
description: "Visualize how GORM CLI operates, including the system’s pipeline—from user-written Go code through the CLI invocation, generation engine, and output artifacts. A mermaid diagram depicts the high-level data flow and component boundaries."
---

# Architecture Overview

Understand how GORM CLI operates end-to-end, transforming your Go code into powerful, type-safe query APIs and model helpers. This page unfolds the system’s pipeline—from your raw Go source, through CLI invocation and the generation engine, finally to the generated output artifacts—enabling you to grasp how your inputs become flawless, compile-time safe code.

---

## Visualizing the GORM CLI Workflow

At its core, GORM CLI is a bridge between developer-written Go interfaces and models, and the generated code that integrates seamlessly with GORM. This architecture overview outlines the distinct stages of this process, clarifying where your input fits and what the tool produces.

### Key Elements of the Architecture

- **User Source Code**: Your Go interfaces annotated with SQL templates and your model structs serve as the source.
- **CLI Invocation**: The `gorm gen` command parses your specified input files and initiates code generation.
- **Generation Engine**: Analyzes your interfaces and models, applies configuration, and produces type-safe query APIs and field helpers.
- **Output Artifacts**: Generated `.go` files containing fluent, type-safe APIs that you consume in your Go projects.

<MermaidDiagram/>

```mermaid
flowchart TD

  subgraph "User Source"
    UserCode["Go Interfaces + Model Structs"]
  end

  subgraph "CLI Tool"
    CLI[gorm CLI "gorm gen"]
  end

  subgraph "Generation Engine"
    Parser["Parse Interfaces & Models"]
    Config["Apply genconfig.Config"]
    Generator["Generate Type-Safe APIs & Field Helpers"]
  end

  subgraph "Output"
    GeneratedCode["Generated Go Code"]
  end

  UserCode --> CLI --> Parser --> Config --> Generator --> GeneratedCode

  %% Styling
  classDef user fill:#E0F7FA,stroke:#006064,stroke-width:1px;
  class UserCode user;
  classDef cli fill:#FFECB3,stroke:#EF6C00,stroke-width:1px;
  class CLI cli;
  classDef gen fill:#C8E6C9,stroke:#1B5E20,stroke-width:1px;
  class Parser,Config,Generator gen;
  classDef out fill:#D1C4E9,stroke:#4A148C,stroke-width:1px;
  class GeneratedCode out;
```

---

## Step-by-Step Workflow Explanation

### 1. User Source Code

You start by writing:

- **Go Interfaces annotated with SQL templates** — Define query methods with comments containing raw SQL and templating DSL.
- **Model Structs** — Define GORM-backed models with fields and relationship metadata.

This code reflects your application’s data access intent and schema.

### 2. CLI Invocation

Run the CLI command:

```bash
gorm gen -i ./path/to/interfaces -o ./generated
```

This invokes GORM CLI with your input interfaces and sets the output directory.

### 3. Parsing and Configuration

Internally, the tool:

- Parses your Go interfaces and models to extract method signatures and struct fields.
- Applies any code generation configuration specified via `genconfig.Config` to include/exclude types or customize mapping.

### 4. Code Generation Engine

Based on parsing and configuration, it:

- Synthesizes **type-safe query API implementations** from your SQL-template-annotated interfaces.
- Generates **model-driven field helpers** providing fluent predicates, setters, and association operations with compile-time guarantees.

This automatic, template-driven generation ensures correctness and discoverability.

### 5. Output Artifacts

Finally, generated Go source files are output to the specified directory (`OutPath`), ready to be imported and used in your Go projects.

---

## Practical Value of This Architecture

- **Separation of Concerns**: You write clean, declarative interface definitions. The CLI tool handles all boilerplate and complex implementation.
- **Compile-Time Safety**: Generated code is strongly typed, reducing runtime errors in queries.
- **Customizable Output**: Config overrides let you tailor generation to your project structure and naming conventions.
- **Incremental Workflow**: Regenerate efficiently when interfaces or models change.

---

## Tips for Success

- Maintain clear Go interface annotations with valid SQL templates to maximize generation accuracy.
- Use the `genconfig.Config` in the same package as your interfaces to control output structure.
- Keep your models updated with proper GORM associations for richer field helper generation.

---

For more context on how the CLI integrates with your Go project and examples of generated code usage, see the [Integration with Go and GORM](../integration-overview) and [Quickstart: Your First Workflow](../../../getting-started/project-configuration-run/quickstart-overview) documentation.


<Tip>
Understanding this architecture empowers you to debug generation issues, customize your project’s generated bindings, and fully leverage GORM CLI’s productivity benefits.
</Tip>