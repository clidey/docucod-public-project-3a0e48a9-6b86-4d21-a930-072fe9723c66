---
title: "Feature Overview at a Glance"
description: "Get a rapid summary of GORM CLI’s major capabilities—type-safe query generation, field helpers, association management, template-based DSL, and flexible configuration—with pointers for where each is explored in detail within the docs."
---

# Feature Overview at a Glance

Unlock the full power of GORM CLI with a quick tour of its major capabilities. This page distills the essential features that give Go developers using GORM the ability to generate robust, type-safe database query code seamlessly, helping you understand what the tool offers at a glance—and where to explore each topic in detail within the docs.

---

## Why This Matters

GORM CLI transforms raw SQL annotations into reliable, fluent Go APIs aligned with your data models. Instead of juggling string queries prone to runtime errors, you get compile-time safety and discoverable methods, letting you write more accurate and maintainable backend code.

By summarizing the core features here, you can quickly identify the parts that best serve your project—whether it's type-safe queries, managing associations, or tailoring generation output. This overview forms a foundation for deeper dives across the system architecture, integration, and usage guides.

---

## Core Capabilities

### 1. Type-Safe Query Generation from Interfaces

Write Go interfaces with embedded SQL templates in comments, and GORM CLI generates concrete query implementations that are fully type-safe. This eliminates runtime SQL errors by binding method parameters directly to SQL placeholders with type checks.

**Benefits:**
- Compile-time validation of query parameters and results
- Fluent Go API replacing brittle raw SQL strings
- Easy composition of complex queries with contextual binding

**Example usage:**
```go
// Query interface with SQL template
 type Query[T any] interface {
   // SELECT * FROM @@table WHERE id=@id
   GetByID(id int) (T, error)
 }

// Generated usage
 u, err := generated.Query[User](db).GetByID(ctx, 123)
```

### 2. Model-Driven Field Helpers

From your Go model structs, GORM CLI generates helpers for fields that simplify filters, updates, ordering, and working safely with associations.

**Benefits:**
- Strongly typed predicates like `.Eq()`, `.Like()`, `.Between()` on fields
- Helper methods for setting or incrementing field values
- Integration with GORM's query builder for concise syntax

**Example:**
```go
gorm.G[User](db).
  Where(generated.User.Age.Gt(18)).
  Find(ctx)
```

### 3. Comprehensive Association Management

Handle entity relationships with type-safe helpers for all association types: belongs to, has one, has many, many-to-many.

**Operations include:**
- Create and link associated records
- Batch create associations
- Update linked records with conditions
- Unlink (clear foreign keys or remove join rows) without deleting parent or associated entities
- Delete associated rows from the database

**Example:** Create a user with pets:
```go
gorm.G[User](db).
  Set(
    generated.User.Name.Set("alice"),
    generated.User.Pets.Create(generated.Pet.Name.Set("fido")),
  ).
  Create(ctx)
```

### 4. Flexible, Template-Based SQL DSL

Embed SQL logic directly in interface method comments using a powerful templating syntax. Features include:
- `@@table` and `@@column` dynamic placeholders
- Conditional blocks with `{{if}}...{{end}}` for flexible WHERE and SET clauses
- Iterations over collections with `{{for}}` to generate SQL dynamically

This DSL accelerates crafting adaptable queries while keeping safety and type binding intact.

**Example SQL template:**
```sql
SELECT * FROM @@table
{{where}}
  {{if user.Name != ""}} name=@user.Name {{end}}
  {{if user.Age > 0}} AND age=@user.Age {{end}}
{{end}}
```

### 5. Configurable Code Generation

Tailor generation behavior at the package or file level with `genconfig.Config`:
- Specify output paths
- Whitelist or blacklist interfaces and structs
- Map Go types or struct tags to custom field helpers (e.g., JSON)
- Control generation scope (package vs. file)

This lets you precisely fit generation to your project’s structure and coding standards.

**Example config for JSON field helper:**
```go
var _ = genconfig.Config{
  FieldNameMap: map[string]any{
    "json": JSON{},
  },
}
```

---

## How It Fits in the Documentation

This page provides a quick digest of GORM CLI’s core features for users who want a high-level summary before diving into technical details or practical workflows.

For deeper understanding and step-by-step guidance, explore:

- [Core Concepts & Terminology](../core-concepts-terminology) — foundational definitions and mental models
- [Integration with Go and GORM](../integration-overview) — how generated code fits into Go projects
- [Quickstart: Your First Workflow](../../../getting-started/project-configuration-run/quickstart-overview) — practical first steps
- [Best Practices for Code Generation Configuration](../../../guides/advanced-usage-patterns/generation-config-best-practices) — advanced configuration

---

## Practical Tips and Common Scenarios

- Start by defining clear query interfaces with SQL templates where your project needs type safety and readability.
- Use generated field helpers extensively in GORM queries to avoid raw string conditions.
- Leverage association helpers to model complex object graphs and relationship operations with confidence.
- Apply generation config early to manage large codebases or incorporate project-specific helpers.

---

By mastering these key features, GORM CLI empowers Go developers to write safer, cleaner, and more efficient database code that scales with project complexity.

---

## Explore Next

Ready to see GORM CLI in action or customize your generation?

- Walk through the [Quickstart Tutorial](../../../getting-started/project-configuration-run/quickstart-overview)
- Learn detailed [Core Concepts & Terminology](../core-concepts-terminology)
- Configure your generation with [Best Practices](../../../guides/advanced-usage-patterns/generation-config-best-practices)

Harness the power of GORM CLI’s type-safe code generation to transform your Go & GORM development experience today.
