---
title: "Core Concepts & Terminology"
description: "Establish a shared mental model by defining GORM CLI’s primary terms: Query Interfaces, Field Helpers, Association Operations, Templates/SQL DSL, and Configurations. Internalize how these concepts relate and how they map to Go structures and workflows."
---

# Core Concepts & Terminology

Welcome to the foundational guide that anchors your understanding of GORM CLI by defining its core concepts and terminology. This page is your shared mental model, clarifying essential terms, their interrelations, and how they map naturally to Go structures and workflows.

---

## Understanding GORM CLI's Core Components

GORM CLI streamlines working with GORM-based projects in Go by generating type-safe, idiomatic query APIs and structured field helpers from your code. Below we break down its critical concepts to help you internalize their purpose and usage.

### 1. Query Interfaces

**What they are:**

User-defined Go interfaces with methods that include SQL templates within their comments.

**Purpose:**

- Define your database queries declaratively, using embedded templated SQL inside interface method comments.
- Automatically generate type-safe query methods that bind Go parameters to SQL safely.

**How it fits:**

These interfaces serve as the starting point for GORM CLI’s code generation of query APIs. Methods in these interfaces represent operations you want your application to perform, such as selecting, filtering, or updating data.

**Example:**

```go
// Query defines user-related data access methods
type Query[T any] interface {
  // SELECT * FROM @@table WHERE id=@id
  GetByID(id int) (T, error)

  // SELECT * FROM @@table WHERE @@column=@value
  FilterWithColumn(column string, value string) (T, error)

  // UPDATE @@table
  // {{set}}
  //   {{if user.Name != ""}} name=@user.Name, {{end}}
  //   {{if user.Age > 0}} age=@user.Age, {{end}}
  // {{end}}
  // WHERE id=@id
  UpdateInfo(user User, id int) error
}
```

> **Tip:** All method parameters are automatically bound safely into SQL templates, preventing injection and improving readability.

### 2. Field Helpers

**What they are:**

Generated strongly typed field references corresponding to your Go model structs and their database columns and associations.

**Purpose:**

- Provide fluent, discoverable, and type-safe ways to build complex GORM queries and updates.
- Abstract away raw column names with methods like `.Eq()`, `.In()`, `.Like()`, and update setters.

**How it fits:**

They complement query interfaces by helping you construct filters, conditions, and update statements without raw strings.

**Example:**

```go
// Filter users whose age is between 18 and 65
users, err := gorm.G[User](db).Where(
  generated.User.Age.Between(18, 65),
).Find(ctx)

// Update a user's name
err = gorm.G[User](db).
  Where(generated.User.ID.Eq(1)).
  Set(generated.User.Name.Set("alice")).
  Update(ctx)
```

**Associations:**

Field helpers also empower association operations like creating, updating, unlinking, or deleting related entities (has one, has many, belongs to, many2many).

---

### 3. Association Operations

**What they are:**

Specialized operations on linked records expressed via field helpers for model relationships.

**Capabilities:**

- **Create / CreateInBatch:** Insert new rows and link them to the parent.
- **Update:** Modify fields of associated rows with conditions.
- **Unlink:** Remove foreign key references or join table rows without deleting actual records.
- **Delete:** Remove associated rows or join rows from many2many relations.

**How it fits:**

These operations let you manipulate related data safely and conveniently within the same update or create context.

**Practical example:**

```go
// Create a user with one pet
gorm.G[User](db).
  Set(
    generated.User.Name.Set("alice"),
    generated.User.Pets.Create(generated.Pet.Name.Set("fido")),
  ).
  Create(ctx)
```

---

### 4. Templates and SQL DSL

**What it is:**

A domain-specific language embedded in Go interface method comments for writing SQL templates.

**Purpose:**

- Express dynamic SQL queries compactly with placeholders.
- Leverage directives like `@@table` (model's table name), `@@column` (dynamic column), `@param` (parameter placeholder), and control flow tags `{{if}}`, `{{for}}`, `{{where}}`, and `{{set}}`.

**Why it matters:**

- Write expressive, reusable, and safe SQL snippets directly tied to your Go method signatures.
- GORM CLI processes these templates to generate Go code that executes queries efficiently.

**Example:**

```sql
SELECT * FROM @@table
{{where}}
  {{if user.Name != ""}} name=@user.Name {{end}}
  {{if user.Age > 0}} AND age=@user.Age {{end}}
{{end}}
```

**Key DSL directives:**

| Directive  | Description                          | Example
|------------|------------------------------------|----------------------------
| `@@table`  | Model table name substitution       | `SELECT * FROM @@table`
| `@@column` | Dynamic column name                  | `WHERE @@column=@value`
| `@param`   | Bind method parameters              | `WHERE name=@user.Name`
| `{{where}}`| Conditional WHERE clause            | `{{where}} age > 18 {{end}}`
| `{{set}}`  | Conditional UPDATE SET clause       | `{{set}} name=@name {{end}}`
| `{{if}}`   | Conditional SQL fragment            | `{{if x > 0}} AND age=@x {{end}}`
| `{{for}}`  | Loop over collection                | `{{for _, t := range tags}} ... {{end}}`

---

### 5. Configurations (genconfig.Config)

**What it is:**

A user-declared Go variable for customizing code generation in a package.

**Capabilities:**

- Specify output folders for generated files.
- Map Go types to specific field helper types.
- Include or exclude interfaces and structs by patterns.
- Control granularity, such as file-level or package-level generation.

**How it fits:**

The generator reads this config automatically to adjust its behavior, enabling tailored workflows.

**Example:**

```go
var _ = genconfig.Config{
  OutPath: "examples/output",
  FieldTypeMap: map[any]any{
    sql.NullTime{}: field.Time{},  // map sql.NullTime to Time field helper
  },
  IncludeInterfaces: []any{"Query*"},
  IncludeStructs: []any{"User", models.User{}},
}
```

---

## How These Concepts Connect in Your Development Workflow

```mermaid
flowchart TD
  A[Define Go Models (Structs)] --> B[Configure genconfig.Config]
  B --> C[Write Query Interfaces with SQL DSL]
  C --> D[Run GORM CLI Code Generator]
  D --> E[Generated Query APIs & Field Helpers]
  E --> F[Use Generated Code in your Project]

  style A fill:#e3f6f5,stroke:#069,stroke-width:2px
  style B fill:#dcfcee,stroke:#35b569,stroke-width:2px
  style C fill:#eafff5,stroke:#3d9970,stroke-width:2px
  style D fill:#f0f0f0,stroke:#aaa,stroke-width:2px,stroke-dasharray: 5 5
  style E fill:#d0f0d0,stroke:#228822,stroke-width:2px
  style F fill:#b0ddb0,stroke:#005500,stroke-width:2px

  classDef dashed stroke-dasharray: 5 5;
  D:::dashed
```

**Why this model matters:**

- Your Go structs define the data shape.
- The config controls generation specifics.
- Query interfaces express the intended database operations safely.
- Generation translates this into efficient, type-safe APIs
- You consume generated code to streamline database work with clarity and safety.

---

## Best Practices and Tips

- **Start with your data models:** Ensure model structs are well-defined with necessary struct tags.
- **Write clear query interfaces:** Use concise SQL with templating for maintainability.
- **Leverage field helpers:** Always use generated field helpers rather than raw strings to avoid typos and injection risks.
- **Customize generation via config:** Tailor the generator with `genconfig.Config` for your project’s needs.
- **Handle associations carefully:** Use association helpers to safely manage related records preventing foreign key mismatch or orphaned data.

## Troubleshooting Common Questions

<AccordionGroup title="Common Questions about Core Concepts">
<Accordion title="Why use interfaces with SQL template comments?">
This approach combines the expressiveness of raw SQL with the safety, discoverability, and ergonomics of generated code. It ensures queries are clear, maintainable, and type-checked at compile time.
</Accordion>
<Accordion title="What if my models have complex associations?">
GORM CLI generates helpers that mirror even complex relationships such as polymorphic associations, many-to-many, has-one, and belongs-to, enabling safe and fluent operations.
</Accordion>
<Accordion title="Can I customize field helper types for special columns?">
Yes. Use `genconfig.Config` to map custom Go types or struct tags (like JSON fields) to specialized field helpers for optimized query expressions.
</Accordion>
<Accordion title="How does GORM CLI relate to the standard GORM?">
GORM CLI generates code that builds on top of GORM’s APIs, augmenting them with type safety and convenient field helpers without replacing core GORM functionality.
</Accordion>
</AccordionGroup>

---

By mastering these core concepts and terminology, you'll have a shared framework to effectively use GORM CLI's powerful code generation capabilities, accelerating your Go development with GORM.

---

For a broader view, consider exploring the following related documentation pages:

- [What is GORM CLI?](../product-intro/what-is-gorm-cli)
- [Key Benefits and Use Cases](../product-intro/benefits-use-cases)
- [Architecture Overview](../system-architecture/architecture-diagram)
- [Quickstart Guide for Generating APIs](../../guides/getting-started/quickstart-generate-apis)

---