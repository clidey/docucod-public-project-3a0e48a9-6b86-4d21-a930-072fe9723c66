---
title: "Who Should Use GORM CLI?"
description: "Understand the target audience—Go developers and teams using GORM for database access—and explore primary use cases, including rapid API scaffolding, safer filter logic, and scalable association management for complex models."
---

# Who Should Use GORM CLI?

GORM CLI is designed specifically for Go developers and teams leveraging the GORM ORM to access and manipulate relational databases. If you are part of a development team aiming to build robust, type-safe, and maintainable data access layers in your Go applications, GORM CLI brings significant value to your workflow.

---

## Understand Your Audience

- **Go Developers Building Data-Driven Applications:** Whether you are developing new REST APIs, internal services, or command-line tools, GORM CLI offers tools to generate safe, fluent, and discoverable query APIs from your Go code.

- **Teams Managing Complex Models & Relationships:** Projects with rich domain models involving many associations (has one, has many, belongs to, many2many) will benefit from GORM CLI’s generated association helpers, which simplify operations like batch creation, conditional unlinking, and safe updates.

- **Developers Seeking Compile-Time Safety:** If you want to catch SQL query errors and schema mismatches early, GORM CLI combines Go generics with SQL template comments to enforce type safety and reduce runtime surprises.

- **Projects Needing Rapid API Scaffolding:** GORM CLI accelerates prototyping and production development by transforming raw SQL interfaces and GORM models into ready-to-use query APIs and helpers, enabling rapid iteration without sacrificing safety or clarity.


## Primary Use Cases

### 1. Rapid API Scaffolding and Development

Create query interfaces with embedded SQL templates directly in Go interfaces. With a single command, generate type-safe implementations that integrate seamlessly with your existing GORM models. This lets you focus on designing queries and business logic rather than writing repetitive boilerplate code.

```go
// Define a query interface with embedded SQL templates
// SELECT * FROM @@table WHERE id=@id
GetByID(id int) (T, error)

// Use the generated API
user, err := generated.Query[User](db).GetByID(ctx, 123)
```

### 2. Safer Filter Logic for Complex Queries

Leverage the generated field helpers that provide type-safe predicate generation for all model fields, including support for common filters like equals, like, between, and null checks. This protects against mistakes like misspelled column names or improper value bindings.

```go
users, err := gorm.G[User](db).Where(generated.User.Age.Between(18, 65)).Find(ctx)
```

### 3. Scalable Association Management

Maintain and manipulate complex relationships naturally with generated helpers for all association types. Perform linked operations such as create with association, update linked records with filters, unlink relationships, and batch create and link associated entities — all while maintaining compile-time safety.

```go
// Create user and associate pets in one operation
gorm.G[User](db).
  Set(
    generated.User.Name.Set("alice"),
    generated.User.Pets.Create(generated.Pet.Name.Set("fido")),
  ).
  Create(ctx)
```

### 4. Customizable Generation for Project Needs

Easily tailor the generation process with configuration to include or exclude specific interfaces, structs, or fields. Customize helper mappings for special types like JSON or time, ensuring the generated code fits your code style and use cases.


## Before and After Using GORM CLI

| Without GORM CLI                                 | With GORM CLI                                         |
|------------------------------------------------|------------------------------------------------------|
| Hand-write queries and manually embed SQL       | Write Go interfaces with declarative SQL templates   |
| Manage complex associations with error-prone code | Use generated association helpers with safe APIs      |
| Debug SQL errors at runtime                      | Catch query mismatches and type errors at compile time|
| Slow iteration and boilerplate maintenance      | Rapid scaffolding and fluent API discovery            |


## Why This Matters for Development Teams

- **Boost Productivity:** Automates repetitive coding tasks allowing teams to focus on core application logic.
- **Reduce Bugs:** Compile-time safety eliminates a class of runtime SQL errors.
- **Improve Code Quality:** Generated APIs are discoverable and consistent across the codebase.
- **Enhance Collaboration:** Standardized query interfaces and helpers foster team alignment.


## Next Steps

- Explore the [Defining Models & Query Interfaces](https://docs.example.com/getting-started/first-run-usage/defining-models-interfaces) guide to learn how to create your initial setup.
- Proceed to [Generating Code](https://docs.example.com/getting-started/first-run-usage/generating-code) to see the generation workflow in action.
- For managing associations confidently, visit [Working with Associations: Create, Update, Unlink & Delete](https://docs.example.com/guides/core-getting-started/association-operations).


---

<Callout>
**Tip:** Even if you have existing GORM models and SQL queries, integrating GORM CLI can streamline your development and significantly improve code safety and maintainability without drastic refactoring.
</Callout>


---

## Summary
This page identifies Go developers and teams using GORM as the core users of GORM CLI, highlighting use cases surrounding rapid API scaffolding, safer filter logic, and complex association management. It explains why and how these users should adopt GORM CLI to accelerate development while improving code safety.

