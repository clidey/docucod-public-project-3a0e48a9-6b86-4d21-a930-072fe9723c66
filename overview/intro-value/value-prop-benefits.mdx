---
title: "Core Value Proposition"
description: "Learn how GORM CLI accelerates GORM projects by automating query layer generation and field helper creation, reducing boilerplate, and promoting best practices. Explore the advantages of compile-time safety, fluent APIs, and seamless integration for both reads and writes."
---

# Core Value Proposition

## Accelerate Your GORM Projects with Automated Query and Field Helper Generation

GORM CLI transforms the way you develop database access layers in your Go projects by automating the generation of type-safe, fluent APIs for querying and updating your data models. By leveraging interfaces with embedded SQL templates alongside your existing GORM model structs, GORM CLI eliminates repetitive boilerplate code, enforces compile-time correctness, and promotes best practices for interacting with relational data.

### Why GORM CLI Matters for Your Workflow

- **Automated Query APIs:** Instantly get type-safe, compile-time verified query methods that make database interactions clear, concise, and discoverable.
- **Model-Driven Field Helpers:** Use generated, strongly-typed field helpers to craft filters, updates, and association operations seamlessly.
- **Save Time, Reduce Errors:** Eliminate common runtime issues by catching query mistakes and type mismatches early during compilation.
- **Fluent Integration:** Works harmoniously with your existing `gorm.io/gorm` setup for both reads and writes.
- **Handle Complex Associations Safely:** Create, update, unlink, or delete related data with dedicated, compile-checked helpers.

### Who Benefits Most?

This tool is indispensable for Go developers and teams who build and maintain data-intensive applications using GORM. Whether you’re implementing simple CRUD operations or orchestrating rich relational updates, GORM CLI empowers you to write safer, cleaner, and more maintainable data access layers.

---

## Understanding GORM CLI's Core Value

At its essence, GORM CLI bridges the gap between your data models and database operations by generating two key code components:

1. **Interface-Driven Query APIs:** Write Go interfaces annotated with SQL templates describing your queries, and GORM CLI generates concrete implementations that are fully type-safe and check parameter correctness at compile time.

2. **Model-Driven Field Helpers:** From the fields and associations of your struct models, it produces fluent, strongly-typed field helpers that ease filtering, updates, ordering, and managing associations.

This combination drastically improves developer productivity by guiding correct usage patterns and dramatically reducing the need to write, review, and maintain repetitive SQL-centric code.

### Key Differentiators

- **Compile-Time Safety:** Unlike hand-written SQL or string-based queries, the generated APIs catch type mismatches and syntax issues before runtime.
- **Fluency and Discoverability:** The generated methods and field helpers provide an ergonomic experience with fluent method chaining and clear semantic naming.
- **Comprehensive Association Handling:** Covers complex relations such as has-one, has-many, belongs-to, and many-to-many, including polymorphic associations.
- **Configurable and Extendable:** Customize generation rules via `genconfig.Config` to fit your project’s structure and specific needs.

---

## How GORM CLI Works to Deliver Value

### Two-Pronged Code Generation Workflow

- **Query API Generation:** You write Go interfaces with methods documented by SQL templates using a flexible DSL. These templates use directives like `@@table` for table names, `@param` for binding parameters, and conditional clauses  to describe queries dynamically.

- **Field Helper Generation:** Using your GORM model structs, GORM CLI creates field helper variables and methods to build conditions and updates fluently.

Together, they form a powerful duo that streamlines common database tasks into strongly-typed, reusable code.

### What You Gain

- **Reduced Boilerplate:** Skip manual SQL crafting and repetitive GORM query building.
- **Error Prevention:** Avoid SQL syntax errors and mismatched query parameters early.
- **Maintainability:** Centralize query definitions with interfaces and auto-generated types.
- **Performance and Optimization:** Generated APIs encourage best practices, aiding more efficient queries.

---

## Feature Highlights and Benefits

### 1. **Type-Safe Query APIs from Interfaces**
Write Go generic interfaces with annotated SQL template comments, then generate query methods with:

- Parameter binding that matches method signatures
- Conditional SQL parts for flexible filtering
- Compile-time validation ensuring correctness

**Example:**

```go
// Interface Method with SQL Template
// SELECT * FROM @@table WHERE id=@id
GetByID(id int) (T, error)
```

Generates:

```go
user, err := generated.Query[User](db).GetByID(ctx, 123)
```

### 2. **Model-Driven Field Helpers**
Generate helpers for each model field enabling expressive query conditions and updates:

- Predicates such as `.Eq()`, `.Like()`, `.Between()`, and `.IsNull()`
- Update setters that handle zero-values and expressions
- Filters, ordering, and advanced operations

**Example:**

```go
// Filtering users with age > 18
users, _ := gorm.G[User](db).Where(generated.User.Age.Gt(18)).Find(ctx)

// Setting a user's name
_, _ = gorm.G[User](db).
  Set(generated.User.Name.Set("alice"))
  .Create(ctx)
```

### 3. **Robust Association Support with Compile-Time Checks**
Handle complex relations safely and fluently:

- Operations: Create, Update, Unlink (remove link), Delete related entities
- Supports has-one, has-many, belongs-to, many-to-many, polymorphic associations
- Batch operations for efficient inserts/updates

**Example:**

```go
// Create a user with associated pets
gorm.G[User](db).
  Set(
    generated.User.Name.Set("alice"),
    generated.User.Pets.Create(generated.Pet.Name.Set("fido")),
  ).
  Create(ctx)
```

### 4. **Configurable Generation via genconfig.Config**
Customize:

- Output paths
- Inclusion and exclusion of structs/interfaces
- Custom field mappings (e.g., map JSON fields to custom helpers)

This flexibility ensures generation fits your project layout and use cases precisely.

---

## Real-World Impact: Why This Matters to You

### Primary Benefits

- **Accelerated Development:** Automate repetitive query and update code, freeing you to focus on business logic.
- **Improved Code Quality:** Enforce consistent patterns, reduce runtime bugs from query errors.
- **Better Readability and Maintainability:** Generated APIs make intent clear and usage straightforward.

### Common Use Cases

- Safely implement complex filtering scenarios combining multiple optional fields.
- Manage deep relational data across entities without manual SQL or fragile joins.
- Quickly onboard new developers with self-explanatory, generated query methods.

### Before vs. After

| Without GORM CLI                        | With GORM CLI                                             |
|--------------------------------------|----------------------------------------------------------|
| Hand-written SQL prone to typos      | Type-safe generated query methods prevent errors         |
| Boilerplate GORM calls scattered     | Centralized interface definitions with generated code    |
| Difficult to maintain complex filters| Fluent, composable field helpers simplify condition building |

### Return on Investment (ROI)

- Dramatically reduces time spent debugging SQL errors.
- Cuts down on boilerplate by up to 80% in data access layers.
- Ensures consistent database interactions across teams.

---

## Getting a Taste: How to Experience the Benefits

### Quick Preview of the Workflow

1. Define your query interface with SQL templates and your model structs.
2. Run the GORM CLI generator command:

```bash
gorm gen -i ./examples -o ./generated
```

3. Use generated typed methods and field helpers within your application.

### Prerequisites to Know

- Requires Go 1.18 or newer (generics support).
- Familiarity with GORM models and basic SQL concepts.
- Define query interfaces in the same package or accessible directory.

### Next Steps

Move forward by:

- [What is GORM CLI?](/overview/intro-value/product-intro) to understand the tool’s foundation.
- Explore [Handling Associations](/guides/core-getting-started/association-operations) to master relational data.
- Customize your generation with [Configuring Generation](/overview/feature-tour/customization-config).

---

This page is a crucial part of the broader GORM CLI documentation that guides you from core value understanding through architecture, setup, and advanced usage, allowing you to unlock the full power of automated, type-safe data access.

---