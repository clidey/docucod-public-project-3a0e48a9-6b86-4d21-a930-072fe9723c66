---
title: "Target Audience & Common Use Cases"
description: "Who should use GORM CLI? This page profiles Go developers using GORM, outlines types of projects that benefit most, and showcases common use casesâ€”from simple model management to advanced query tailoring."
---

# Target Audience & Common Use Cases

## Who Should Use GORM CLI?

GORM CLI is built specifically for Go developers who use the [GORM ORM library](https://gorm.io) in their projects and seek a more robust, type-safe, and efficient way to interact with databases. It is ideal for those who:

- Write Go applications that need expressive and compile-time checked query interfaces.
- Want to automate generation of model-driven, fluent APIs that reduce runtime errors.
- Seek to manage model associations (has-one, has-many, belongs-to, many-to-many) with greater safety and ease.
- Prefer template-based SQL querying within Go interfaces to streamline complex query logic.

Whether you are building small services or large-scale applications with complex relationships, GORM CLI enhances your development workflow by generating concise, discoverable, and type-safe data access layers.

## Types of Projects That Benefit Most

### 1. Enterprise Web Applications
Large web apps often have complex domain models with many associations. GORM CLI's generated APIs allow you to create, update, unlink, or delete related data with confidence and minimal boilerplate.

### 2. Microservices with Strong Type Safety
When multiple microservices interact with databases, GORM CLI helps ensure that all database operations conform to expected contracts by catching errors at compile time.

### 3. Rapid Prototyping and Iterative Development
Generating query APIs and field helpers from interfaces and structs accelerates prototyping, letting developers quickly test assumptions and refine database models.

### 4. Projects Requiring Custom Complex Queries
GORM CLI supports templated SQL queries declared in Go interfaces, allowing for complex, parameterized queries coded visually and with IDE support.

### 5. Applications Emphasizing Maintainability
With its strict typing, model-driven helpers, and association semantics, the codebase is easier to maintain and evolve over time.

---

## Common Use Cases

### 1. Simple CRUD and Model Management
Generate type-safe query APIs and field helpers for your GORM models to perform standard Create, Read, Update, and Delete operations safely.

```go
// Load a user by ID with type safety
user, err := generated.Query[models.User](db).GetByID(ctx, 123)

// Create a new user
err = gorm.G[models.User](db).Set(
	generated.User.Name.Set("alice"),
	generated.User.Age.Set(30),
).Create(ctx)
```

### 2. Fluent Filtering and Dynamic Queries
Use generated helpers to construct expressive filters and conditions with autocompletion and guarantees against typos.

```go
// Find adult users aged between 18 and 30
users, err := gorm.G[models.User](db).
	Where(generated.User.Age.Between(18, 30), generated.User.IsAdult.Eq(true)).
	Find(ctx)
```

### 3. Managing Associations With Compile-Time Checks
Operate on related data sets (e.g., pets, companies, managers) safely using generated association helpers that understand relation types.

```go
// Add a pet while creating a user
err := gorm.G[models.User](db).
	Set(
		generated.User.Name.Set("bob"),
		generated.User.Pets.Create(generated.Pet.Name.Set("fluffy")),
	).
	Create(ctx)

// Update a user's pets where the pet name matches
err = gorm.G[models.User](db).
	Where(generated.User.ID.Eq(5)).
	Set(
		generated.User.Pets.Where(generated.Pet.Name.Eq("fluffy")).
		Update(generated.Pet.Name.Set("rex")),
	).
	Update(ctx)

// Unlink pets from a user
err = gorm.G[models.User](db).
	Where(generated.User.ID.Eq(5)).
	Set(generated.User.Pets.Unlink()).
	Update(ctx)
```

### 4. Advanced Querying Using SQL Templates in Interfaces
Define interfaces with SQL templates to generate flexible, reusable query methods with full control over SQL but retaining type safety.

```go
// Interface snippet
// SELECT * FROM @@table WHERE id=@id
func GetByID(id int) (User, error)

// Use generated code
user, err := generated.Query[models.User](db).GetByID(ctx, 42)
```

### 5. Batch Operations and Conditional Updates
Utilize batch creation, filtered updates, and conditional unlinking/deleting of associated rows programmatically.

```go
// Batch create UserLanguages for a user
err := gorm.G[models.User](db).
	Where(generated.User.ID.Eq(1)).
	Set(
		generated.User.Languages.CreateInBatch([]models.Language{{Code: "EN"}, {Code: "FR"}}),
	).
	Update(ctx)

// Conditional delete of pets
err := gorm.G[models.User](db).
	Where(generated.User.ID.Eq(1)).
	Set(generated.User.Pets.Where(generated.Pet.Name.Like("old%")).Delete()).
	Update(ctx)
```

---

## Benefits of Using GORM CLI for These Use Cases

- **Compile-Time Safety:** Eliminate common runtime errors by catching invalid queries or field accesses beforehand.
- **Discoverable APIs:** Generated code offers IDE-friendly autocompletion, making database operations intuitive.
- **Reduced Boilerplate:** Avoid writing repetitive SQL and query logic manually.
- **Consistent Associations Management:** Built-in operations reflect association semantics accurately (e.g., unlinking vs deleting).
- **Flexible Custom Queries:** Template-driven interface methods enable complex SQL while preserving safety.

---

## Next Steps

To get started with GORM CLI for your project, explore:

- [What is GORM CLI?](./what-is-gorm-cli) for a foundational introduction.
- [Key Benefits & Value Proposition](./benefits-value) to understand the impact.
- [Install and Set Up GORM CLI](../../guides/getting-started/install-and-setup) to begin coding.

Together, these resources will equip you to implement type-safe, maintainable data access layers that fit your application needs perfectly.

---

## Troubleshooting Common Scenarios

<AccordionGroup title="Common Questions & Challenges">
<Accordion title="My model associations aren't generating expected helpers. What could be wrong?">
Make sure your GORM struct tags reflect the correct association types (e.g., `gorm:"many2many"`, `gorm:"foreignkey"`). Also verify that your generation includes your model packages without exclude filters in the `genconfig.Config`.
</Accordion>
<Accordion title="How to handle custom field types, like JSON or SQL nullables?">
Use the `FieldTypeMap` and `FieldNameMap` in your `genconfig.Config` to map custom Go types or tags (e.g., `gen:"json"`) to appropriate field helpers. See the JSON field mapping example for practical guidance.
</Accordion>
<Accordion title="I want to write a complex query with conditional SQL. How can I do that safely?">
Define a Go interface with SQL templates in method comments. Use the SQL template DSL directives (`@@table`, `@param`, `{{where}}`) to build queries. The generator creates type-safe implementations respecting your SQL logic.
</Accordion>
</AccordionGroup>