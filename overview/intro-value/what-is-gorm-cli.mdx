---
title: "What is GORM CLI?"
description: "An introduction to GORM CLI, the command-line companion for GORM projects. Learn how it bridges your Go models and database queries through automated, type-safe code generation, enabling rapid development with fewer errors."
---

# What is GORM CLI?

Unlock the full potential of your Go projects with GORM CLI, the powerful command-line companion crafted specifically for GORM users. GORM CLI seamlessly bridges your Go model definitions and database queries by automatically generating type-safe, fluent APIs that dramatically speed up development and reduce runtime errors.

---

## Introducing GORM CLI

At its core, GORM CLI is a code generation tool designed to transform your hand-written Go interfaces and model structs into strongly typed, compile-time safe Go code tailored for GORM. By leveraging intuitive SQL templates within standard Go interfaces, it creates ready-to-use query APIs while producing model-driven field helpers for constructing filters, updates, and managing associations with ease.

This automation empowers you to focus on writing business logic instead of boilerplate, ensuring every database interaction is validated by the Go compiler and seamlessly integrated within your application.

---

## Why GORM CLI Matters to You

Imagine eliminating the guesswork and tedious maintenance of SQL queries scattered across your codebase. GORM CLI turns this vision into reality by:

- **Saving Development Time**: Automatically generating query methods from annotated interfaces reduces manual coding efforts.
- **Ensuring Type Safety**: Compile-time validation prevents common errors such as mismatched parameters or invalid queries.
- **Providing Fluent APIs**: Easily discoverable, chainable methods make database operations intuitive and expressive.

Whether you are building new data layers or maintaining complex applications, GORM CLI streamlines workflows and strengthens reliability.

---

## What GORM CLI Does Under the Hood (User Perspective)

Use GORM CLI to write interfaces with clear method signatures and SQL templates right in comments. Then, generate concrete implementations plus helper fields for your models that cover filtering, sorting, and association handling—all with zero manual SQL coding beyond your templates.

For example, define an interface like this:

```go
// Query[T any] interface defines SQL queries with typed parameters and return values
type Query[T any] interface {
  // SELECT * FROM @@table WHERE id=@id
  GetByID(id int) (T, error)

  // where("name=@name AND age=@age")
  FilterByNameAndAge(name string, age int)
}
```

Run GORM CLI to generate the implementation, then use it seamlessly:

```go
user, err := generated.Query[User](db).GetByID(ctx, 123)
users, err := generated.Query[User](db).FilterByNameAndAge("jinzhu", 25).Find(ctx)
```

Behind the scenes, GORM CLI also generates field helpers for `User` to express conditions and updates conveniently:

```go
generated.User.Name.Like("%jinzhu%")
generated.User.Age.Between(18, 65)
```

---

## Core Features of GORM CLI

- **Interface-Driven Query API Generation**: Generate concrete query implementations with SQL templating, ensuring that the queries always reflect your business logic and data structures.
- **Model-Driven Field Helpers**: Produce strong-typed helpers for all model fields and associations used to build filters, updates, and joins safely and clearly.
- **Association Operations Support**: Easily create, update, unlink, or delete related records with built-in, type-safe helpers for one-to-one, one-to-many, and many-to-many relationships.
- **Configurable Generation**: Customize output directory, include/exclude interfaces and structs, and override field mappings using the `genconfig.Config` configuration.
- **Seamless GORM Integration**: Built to harmonize with `gorm.io/gorm` so you can adopt GORM CLI without changing your existing project setup.

---

## Real-World Benefits and Use Cases

### Benefits You Can Count On

- **Error Reduction**: Catch mistakes during compilation instead of at runtime, giving you confidence in your database code.
- **Increased Productivity**: Minimize repetitive code and manual SQL maintenance, letting developers focus on solving real problems.
- **Consistent Codebase**: Enforce uniform query patterns and method signatures across teams.

### Common Use Cases

- Generating type-safe APIs for complex query patterns in enterprise applications.
- Building dynamic filtering and updating mechanisms for RESTful services.
- Managing elaborate database relationships with type-safe association operations.

### Before and After GORM CLI

| Without GORM CLI                     | With GORM CLI                         |
|------------------------------------|-------------------------------------|
| Manually write raw SQL queries     | Define SQL templates in Go interfaces|
| Handle SQL bindings by hand        | Automate parameter binding and safety|
| Write repetitive filter and update code | Use generated fluent field helpers|
| Debug SQL errors at runtime         | Capture errors at compile time      |

---

## Getting Started at a Glance

To start benefiting from GORM CLI:

1. **Prepare Input Interfaces and Models**: Write Go interfaces documenting SQL templates and define related model structs.
2. **Run the Generator**: Use the CLI command `gorm gen -i ./path-to-interfaces -o ./generated` to produce the concrete code.
3. **Use Generated APIs**: Import your generated package and invoke the fluent, type-safe query APIs in your application.

For example:

```bash
gorm gen -i ./examples -o ./generated
```

<Check>
Your Go project should be using Go 1.18+ to support generics required by GORM CLI.
</Check>

---

## Helpful Tips for Success

- Use descriptive SQL templates following the [template DSL guidelines](https://gorm.io/docs/clauses.html) to maximize flexibility.
- Leverage `genconfig.Config` in your packages to customize generation (paths, name mappings, filters).
- Regularly review generated code to understand and utilize its fluent APIs effectively.
- Integrate generated helpers with existing GORM queries to build complex logic easily.

---

## Troubleshooting Common Issues

<AccordionGroup title="Common Issues When Getting Started with GORM CLI">
<Accordion title="Missing or Incorrect Generated Code">
Verify your interface files include method comments with valid SQL templates. Ensure `-i` input paths are correct and that your configuration does not exclude interfaces unintentionally.
</Accordion>
<Accordion title="Type Errors in Generated Code">
Confirm your Go version is 1.18 or newer for generics support. Check field type mappings in your configuration if using custom or uncommon types.
</Accordion>
<Accordion title="Association Operations Not Working as Expected">
Use the field helpers on your generated models for associations (e.g., `generated.User.Pets.Create(...)`). Confirm your models define relationships properly for generation.
</Accordion>
</AccordionGroup>

---

Explore the [Key Benefits & Value Proposition](../overview/intro-value/benefits-value), [Target Audience & Common Use Cases](../overview/intro-value/audience-usecases), and [Getting Started guides](../../guides/getting-started) to deepen your understanding and accelerate adoption.

---

GORM CLI unlocks type-safe database interactions with minimal fuss — ready to transform how you write queries and manage data in Go applications.

Start generating fluent APIs today and unlock the power of automated, reliable, and maintainable GORM code.