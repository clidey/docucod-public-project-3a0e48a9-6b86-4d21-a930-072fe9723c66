---
title: "Feature Overview"
description: "A concise roundup of GORM CLI’s core and advanced features: type-safe query generation, field helpers, association helpers, DSL for SQL templates, and light configuration. This page helps users gauge fit and impact at a glance."
---

# Feature Overview

Discover the powerful core and advanced capabilities of GORM CLI that transform your Go data layer with unmatched type safety, flexibility, and developer-friendly ergonomics. This page offers a clear and concise summary of key features like type-safe query generation, expressive field and association helpers, a domain-specific language for SQL templating, and a light configuration system. Use this guide to quickly evaluate how GORM CLI fits your project needs and accelerates your database development workflow.

---

## What You Gain with GORM CLI

GORM CLI empowers Go developers working with GORM to automatically generate robust, type-safe query APIs and model helpers based on your existing Go interfaces and structs. Here's what makes it indispensable:

- **Type-Safe Query Generation:** Write idiomatic Go interfaces with embedded SQL templates, and get fully type-safe query methods that eliminate runtime errors from malformed queries.
- **Field Helpers:** Gain strongly-typed field predicates and setters for all your model fields, including basic types and custom mappings.
- **Association Helpers:** Handle relationships with ease using generated helpers for create, update, unlink, delete, and batch operations on associations.
- **DSL for SQL Templates:** Write expressive, dynamic SQL using GORM CLI’s templating language with conditional clauses, loops, and placeholder bindings.
- **Light Configuration:** Tailor generation behavior with simple, extensible config files without complicating your build or dev process.

This page breaks down each of these features with concrete examples and usage insights.

---

## Core Features & Capabilities

### Type-Safe Query Generation from Interfaces

At the heart of GORM CLI is the ability to convert annotated Go interfaces into type-safe query APIs.

- Define interfaces with method comments containing SQL templates.
- Use placeholders to bind parameters directly to Go method arguments.
- Get generated implementations with fluent, compile-time checked methods.

Example:

```go
// Define a generic Query interface with SQL templates
// SELECT * FROM @@table WHERE id=@id
GetByID(id int) (T, error)

// Dynamic conditional filtering
// {{where}}
//   {{if user.Name != ""}} name=@user.Name {{end}}
//   {{if user.Age > 0}} AND age=@user.Age {{end}}
// {{end}}
Filter(users []User) ([]T, error)
```

This approach removes error-prone string concatenation and provides IDE autocompletion and static validation.

### Model-Driven Field Helpers

GORM CLI generates strongly typed field helper objects for every struct field in your models.

- Supports base Go types (int, float, string, bool, time, []byte) and custom types via mapping.
- Generated helpers offer predicates like `.Eq()`, `.Like()`, `.Between()`, `.IsNull()`, and setters like `.Set()`, `.Incr()`, `.SetExpr()`.

Example usage:

```go
generated.User.Name.Eq("Alice")           // WHERE name = 'Alice'
generated.User.Age.Between(18, 65)        // WHERE age BETWEEN 18 AND 65
generated.User.Score.IsNull()              // WHERE score IS NULL
```

### Association Helpers

Relationships defined in your models automatically generate helpers to simplify complex association operations.

Supported operations:

- **Create:** Create and associate new related records.
- **CreateInBatch:** Batch create and associate multiples.
- **Update:** Update related records matching filters.
- **Unlink:** Remove association links by nulling foreign keys or deleting join rows.
- **Delete:** Delete related records cleanly.

Example:

```go
gorm.G[User](db).
  Set(
    generated.User.Pets.Create(generated.Pet.Name.Set("Fido")),
  ).
  Create(ctx)

// Unlink pets where name = 'Oldie'
gorm.G[User](db).
  Set(
    generated.User.Pets.Where(generated.Pet.Name.Eq("Oldie")).Unlink(),
  ).
  Update(ctx)
```

This provides compile-time safety and clear semantics for parent-child and many-to-many relationships.

### DSL for SQL Templates

Write flexible SQL queries with the GORM CLI template language for conditionals, loops, and dynamic binding.

- `@@table` and `@@column`: for dynamic table and column names.
- Parameter placeholders like `@param` map to Go function parameters directly.
- Control structures like `{{where}}...{{end}}`, `{{set}}...{{end}}` for conditional SQL.
- Looping with `{{for ...}}`, nested conditionals.

Example snippet:

```sql
SELECT * FROM @@table
{{where}}
  {{if user.Name != ""}} name=@user.Name {{end}}
  {{if user.Age > 0}} AND age=@user.Age {{end}}
{{end}}
```

This DSL simplifies even complex SQL scenarios, keeping your queries readable and maintainable.

### Lightweight Configuration

Control code generation behavior via easy-to-use package-level `genconfig.Config` structs.

Options include:

- Output directories.
- Field type mappings for custom Go or database types.
- Inclusion/exclusion patterns for interfaces and structs.
- File-level vs package-level application.

Example:

```go
var _ = genconfig.Config{
  OutPath: "examples/output",
  FieldTypeMap: map[any]any{
    sql.NullTime{}: field.Time{},
  },
  IncludeInterfaces: []any{"Query*"},
}
```

This keeps generation flexible without burdening your build pipeline or source code.

---

## Why Should I Care?

### Real Outcomes for Your Projects

- **Eliminate runtime query errors:** Your queries become checked by the compiler.
- **Boost developer productivity:** Write less boilerplate and discover fields and queries through IDEs.
- **Simplify complex SQL management:** Templates with conditions and loops replace verbose handcrafted SQL.
- **Manage associations confidently:** No need for error-prone manual FK manipulation or join table handling.

### Typical Use Cases

- Server backends requiring rapid yet safe CRUD operations.
- Projects with evolving data models benefitting from compile-time safety.
- Teams standardizing database access layers for consistency and maintainability.
- Applications leveraging complex filtering, paging, relations, and custom SQL.

### Before and After

| Without GORM CLI                              | With GORM CLI                                      |
|---------------------------------------------|---------------------------------------------------|
| Handwritten SQL prone to typos and bugs     | Type-checked, generated query code                |
| Manual association management                | Generated helpers for safe create/update/unlink   |
| Query concatenation string manipulation      | DSL templates with clear placeholders and logic   |

### Quantifiable Benefits

- Reduce query-related runtime failures to near zero.
- Cut boilerplate code by up to 80%, speeding up development.
- Faster onboarding due to standardized and discoverable APIs.

---

## Getting Started Preview

Ready to dive in? Here’s a quick look at your path forward:

1. **Define your query interfaces and models:** Annotate interfaces with SQL templates and define Go structs.
2. **Configure generation if needed:** Set up simple `genconfig.Config` for output paths and mappings.
3. **Run the GORM CLI generator:** Generate type-safe query APIs and field helpers with a single command.
4. **Use generated code:** Enjoy autocomplete and exceptional type safety in your data layer.

For detailed steps, see [First Code Generation Workflow](/getting-started/first-codegen-workflow/prepare-models-interfaces) and the [Quickstart Glimpse](/overview/feature-highlights/quickstart-glimpse) pages.

---

## Additional Resources

- Explore the SQL Template DSL in detail: [Mastering the SQL Template DSL](/guides/advanced-patterns/templating-dsl)
- Learn about association helpers with examples: [Working with Associations](/guides/advanced-patterns/association-helpers)
- Customize your field helpers and JSON mappings: [Custom Field Helpers and JSON Mapping](/guides/advanced-patterns/custom-fields)

---

Harness the full power of GORM CLI by starting with your models and interfaces—and let the tool generate reliable, efficient, and expressive query code for you.


