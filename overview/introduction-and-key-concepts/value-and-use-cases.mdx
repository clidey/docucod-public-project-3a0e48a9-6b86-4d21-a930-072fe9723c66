---
title: "Value Proposition & Use Cases"
description: "Explore how GORM CLI empowers Go developers by reducing boilerplate and errors, making database access safer and more expressive. See common use cases: building queries from interfaces, generating model-driven field helpers, and working seamlessly with associations and advanced field types like JSON."
---

# Value Proposition & Use Cases

## Empowering Safer, More Expressive Database Access with GORM CLI

GORM CLI revolutionizes how Go developers interact with databases by automatically generating type-safe, interface-driven query APIs and model-based field helpers tailored for GORM projects. It dramatically reduces the boilerplate and error-prone manual code needed for typical CRUD operations and complex queries, providing fluent, discoverable, and compile-time safe database interactions.

---

## Why GORM CLI Matters to You

Imagine you’re building an application with complex data models and associations: writing repetitive query code is tedious and risky, leading to subtle bugs or runtime errors. GORM CLI transforms this by generating strongly typed, interface-driven query methods and field helpers directly from your Go interfaces and models. This empowerment frees you to focus on business logic rather than plumbing tedious SQL or error-prone manual construction.

---

## Core Benefits at a Glance

- **Compile-Time Type Safety**: Catch query and update errors during compilation — not at runtime — minimizing bugs related to invalid queries or mismatched data types.
- **Discoverable Fluent APIs**: Use auto-generated methods and fields that work seamlessly with GORM, making queries readable, writable, and easy to learn.
- **Seamless Association Management**: Create, update, unlink, or delete related rows and associations with intuitive generated helpers, eliminating manual foreign key handling.
- **Customizable and Configurable**: Tailor code generation precisely via configuration for interfaces, structs, and field mappings.
- **Advanced Support for Complex Field Types**: Work effortlessly with JSON fields and custom types through generated helpers adapting to different databases.

---

## Who Should Use This Page

This documentation is intended for Go developers, backend engineers, and teams adopting GORM who want to leverage code generation to build robust, maintainable database access layers with less manual effort and safer queries.


---

## What Is Covered on This Page

This page explores the real-world value and typical use cases of GORM CLI, featuring how it benefits the everyday developer workflow through interface-driven queries, model-based helpers, association handling, and advanced template-driven SQL.

It guides you to understand why adopting GORM CLI improves developer productivity, code quality, and application safety.


---

# Interface-Driven Query APIs: Write Your Queries Once, Use Them Safely Everywhere

With GORM CLI, you define Go interfaces with embedded SQL templates as method comments. The generator then crafts concrete, type-safe implementations adhering to those interfaces, ensuring your query logic aligns perfectly with your Go types.


## How It Works

- Write an interface method with embedded SQL template, e.g.:  
  ```go
  // SELECT * FROM @@table WHERE id=@id
  GetByID(id int) (T, error)
  ```
- GORM CLI parses the method, generates a type-safe implementation  
- Use the generated interface with your `gorm.DB` instance:
  ```go
  u, err := generated.Query[User](db).GetByID(ctx, 123)
  ```

## Why This Matters

- **Eliminates manual SQL string handling** and potential injection risks.
- **Improves type correctness** — the compiler guides you.
- **Enables complex SQL with conditions, iterations, and bindings** through powerful template DSL.


---

# Model-Driven Field Helpers: Intuitive and Fluent Query Construction

The CLI also generates field helpers for your model structs, enabling fluent query building with predicates, update setters, and association operations.


## Practical Examples

Using the generated `User` struct field helpers:

```go
// Predicates
generated.User.ID.Eq(1)                 // WHERE id = 1
generated.User.Name.Like("%jinzhu%")   // WHERE name LIKE '%jinzhu%'
generated.User.Age.Between(18, 65)     // WHERE age BETWEEN 18 AND 65

// Updates
gorm.G[User](db).
  Where(generated.User.Name.Eq("alice")).
  Set(
    generated.User.Name.Set("jinzhu"),
    generated.User.Age.Incr(1),
  ).
  Update(ctx)

// Create with association
gorm.G[User](db).
  Set(
    generated.User.Name.Set("alice"),
    generated.User.Pets.Create(generated.Pet.Name.Set("fido")),
  ).
  Create(ctx)
```

## What You Gain

- **Clear and expressive API for queries and updates, avoiding string concatenation.**
- **Supports zero and non-zero value updates safely.**
- **Integration with GORM’s query builder, maintaining familiar patterns.**

---

# Managing Associations Made Easy

Association operations—such as creating and linking related records, updating children, unlinking relations, or deleting associated rows—can become complex.

GORM CLI generates association helpers tailored to your relationships, enabling:

- **Create single or batch associations with safety and clarity**
- **Update associated records with optional filtering**
- **Unlink associations gracefully without data loss**
- **Delete join or child records with conditions**


### Examples

```go
// Create user with one pet
gorm.G[User](db).
  Set(
    generated.User.Name.Set("alice"),
    generated.User.Pets.Create(generated.Pet.Name.Set("fido")),
  ).
  Create(ctx)

// Update a user’s pet name
gorm.G[User](db).
  Where(generated.User.ID.Eq(1)).
  Set(generated.User.Pets.Where(generated.Pet.Name.Eq("fido")).
    Update(generated.Pet.Name.Set("rex")),
  ).
  Update(ctx)

// Unlink all pets from a user
gorm.G[User](db).
  Where(generated.User.ID.Eq(1)).
  Set(generated.User.Pets.Unlink()).
  Update(ctx)
```

---

# Advanced Field Types, Including JSON

GORM CLI supports custom and advanced field types such as JSON columns through configurable field mappings and generated helpers that translate into database-specific expressions.

This means you can query and update JSON fields just as naturally as simple typed fields, with the generator handling database dialect and function differences.

Example:

```go
// Check if JSON field 'profile' has VIP status
gorm.G[User](db).
  Where(generated.User.Profile.Equal("$.vip", true)).
  Take(ctx)
```

---

# Common Use Cases Where GORM CLI Shines

- **Reducing Boilerplate in CRUD-heavy Projects**: Auto-generate your entire data access layer, accelerating development.
- **Building Complex Filtered Queries**: Use interfaces with embedded SQL templates containing dynamic conditions.
- **Ensuring Consistent Association Operations**: Safely manage `has one`, `has many`, `belongs to`, and `many2many` links.
- **Working with Custom or Polymorphic Field Types**: Generate helpers to handle fields like JSON, datetime, or nullable types.
- **Scaling Teams and Codebases**: Maintain uniform query APIs across large codebases, easing onboarding and refactoring.

---

# Before and After Using GORM CLI

| Without GORM CLI                                        | With GORM CLI                                                |
|-------------------------------------------------------|-------------------------------------------------------------|
| Writing raw SQL strings prone to typos and injection  | Write Go interfaces with SQL comments — type-safe, robust   |
| Manual construction of query/filter predicate functions| Use generated fluent field helpers for predicates and setters|
| Handling associations manually with FK management     | Intuitive, generated association helpers simplifying linkage|
| No compile-time validation of query correctness       | Compile-time checks prevent common bugs                      |

---

# Getting Started Preview

Starting with GORM CLI looks like this:

1. **Define Go interface(s)** with method comments containing SQL templates.
2. **Define your model struct(s)** with any required annotations.
3. **Run the CLI code generation tool** to produce strongly typed query methods and field helpers.
4. **Use the generated code** in your application to build safe queries and updates.

For detailed setup and usage instructions, visit the [Getting Started Guide](/getting-started/essential-setup/first-code-generation).

---

# Tips and Best Practices

- Always keep your query interfaces clean and focused on specific query intents.
- Use field helpers for predicates and updates instead of raw SQL strings for safer code.
- Leverage batch association operations to optimize database interactions.
- Customize generation behavior via `genconfig.Config` for large or complex projects.
- Regularly regenerate code after model changes to keep API accurate.


---

For complete walkthroughs, examples, and advanced uses, see related pages:

- [Quickstart: Generate and Use Type-Safe APIs](/guides/core-workflows/quickstart-guide)
- [Working with Field Helpers](/guides/core-workflows/working-with-field-helpers)
- [Managing Associations with Generated Code](/guides/core-workflows/associations-guide)
- [Writing and Using Template-Based Queries](/guides/advanced-patterns/template-dsl-guide)

---