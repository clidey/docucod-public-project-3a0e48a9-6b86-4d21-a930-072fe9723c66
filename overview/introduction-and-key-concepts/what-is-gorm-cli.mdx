---
title: "What is GORM CLI?"
description: "Get an at-a-glance understanding of GORM CLI: an extensible code generator that produces type-safe query APIs and field helpers for GORM projects. Learn how it streamlines query writing, increases compile-time safety, and creates fluent APIs for interacting with your database."
---

# What is GORM CLI?

## Unlock Fluent, Type-Safe Database Queries with GORM CLI

GORM CLI is an extensible, code-generating command-line tool designed to supercharge your GORM projects by automatically producing **type-safe query APIs** and **model-driven field helpers**. It liberates developers from writing repetitive query code by generating fluent, discoverable, and compile-time safe interfaces based on simple Go interface definitions and your data models.

---

## At-a-Glance: Why GORM CLI Matters for You

- **Write Less, Do More:** Instead of hand-crafting raw SQL or building queries imperatively, use plain Go interfaces and struct models. GORM CLI generates robust querying APIs that save hours of manual coding.
- **Compile-Time Confidence:** Generated queries are validated by the Go compiler, reducing runtime errors and bugs due to mismatched parameters or SQL mistakes.
- **Fluent APIs for Your Models:** Automatically created field helpers for filters, updates, and associations enable expressive and type-safe query construction.
- **Customizable and Extensible:** Configuration options let you tailor code generation for your project's structure and needs.

**Perfect For:** Go developers building database-backed applications who want safer, maintainable, and efficient data access layers.

---

## What Is GORM CLI?

GORM CLI is a command-line utility that processes Go source files containing:

1. **Interface definitions** annotated with SQL templates in doc comments that describe the query logic.
2. **Struct model definitions** that represent your database tables.

From these, it generates:

- **Type-safe query interface implementations** that require minimal boilerplate while enabling rich query expressions.
- **Field helper variables** for each model’s columns and relationships, supporting fluent query building and updates.

By parsing these interfaces and model structures, GORM CLI empowers you to run database operations with **compile-time guarantees** and **intuitive API design**, making your data-access code reliable and easy to maintain.

---

## How Does It Work?

1. You define your query methods as Go interfaces, writing SQL or templated SQL comments to express the queries you want.
2. You define your model structs that map to database tables.
3. Run `gorm gen` with the CLI, specifying the input path to these interfaces and models.
4. GORM CLI analyzes your code, infers field types, templates method implementations, and generates fully functional query APIs and field helpers in output files.

Behind the scenes, GORM CLI uses Go’s abstract syntax tree (AST) parsing and templating to produce go files that integrate seamlessly with `gorm.io/gorm`.

---

## Core Features & Capabilities

### 1. Type-Safe Query API Generation

Write simple interfaces with method signatures and embedded SQL templates as comments. From these, GORM CLI generates implementations that:

- Bind parameters automatically to SQL placeholders.
- Return strongly typed results or errors.
- Automatically inject `context.Context` into methods if omitted.
- Support conditional and dynamic query parts using a powerful template DSL.

Example interface method:
```go
// SELECT * FROM @@table WHERE id=@id AND name = "\@name"
GetByID(id int) (T, error)
```
Generates a method returning a struct of type `T` and an error, bound to parameter `id`.


### 2. Model-Driven Field Helpers

For each struct field, GORM CLI creates a field helper that enriches queries:

- Supports predicate methods like `.Eq()`, `.Like()`, `.Between()` for filtering.
- Setters such as `.Set()`, `.Incr()` for updates.
- Relationship helpers for associations (`has one`, `has many`, `belongs to`, `many2many`) enable create, update, unlink, and delete operations with compile-time safety.

Using these, you can build expressive queries like:
```go
gorm.G[User](db).Where(
  generated.User.Name.Eq("alice"),
  generated.User.Age.Between(18, 30),
).Find(ctx)
```

### 3. Extensible Configuration

You control generation via package-level `genconfig.Config` objects that let you:

- Override output directories.
- Include or exclude interfaces and structs via shell-style patterns.
- Map Go types or field tags to custom field helper types.
- Decide whether configuration applies per file or entire package.

This flexibility streamlines generation for large or modular projects.

### 4. Flexible SQL Template DSL

Write expressive SQL templates with directives like:

| DSL Directive | Purpose                             | Example                                   |
|---------------|-----------------------------------|-------------------------------------------|
| `@@table`     | Resolves to the model's table name| `SELECT * FROM @@table WHERE id=@id`      |
| `@@column`    | Dynamic column name binding        | `WHERE @@column=@value`                    |
| `@param`      | Maps Go parameters to SQL          | `WHERE name=@user.Name`                    |
| `{{where}}`   | Conditional WHERE clauses          | `{{where}} age > 18 {{end}}`               |
| `{{set}}`     | Conditional UPDATE SET clauses     | `{{set}} name=@name {{end}}`               |
| `{{if}}`      | Conditional SQL fragments          | `{{if age > 0}} AND age=@age {{end}}`      |
| `{{for}}`     | Iterate over collections           | `{{for _, tag := range tags}} ... {{end}}`|

These templates produce concise, maintainable query code.

---

## Why Should You Care?

### Experience Safer Queries with Less Boilerplate

Without GORM CLI, writing and maintaining raw SQL queries or even ORM-based queries can be error-prone and tedious. GORM CLI’s generated APIs give you:

- **Compile-time guarantees** that SQL parameters and return types match exactly.
- **Auto-binding** of parameters eliminating tedious manual code.
- **Rich, fluent helpers** for common query patterns like filtering, updating, and working with associations.

### Empower Cleaner, More Maintainable Codebases

Generated code is DRY and expressive. Teams can:

- Define query contracts as interfaces.
- Share query logic clearly via SQL templates.
- Focus on business logic rather than boilerplate query plumbing.

### Common Scenarios Where GORM CLI Excels

- Building REST APIs that depend on complex, safe query APIs.
- Large projects where type safety reduces runtime bugs.
- Teams wanting consistent query patterns across services.
- Projects requiring dynamic queries with compile-time validations.

### Proven Efficiency Gains

Users report dramatic reductions in bugs related to SQL mismatches and parameter binding, plus significant developer time regained previously spent on writing repetitive query scaffolding.

---

## Getting Started Preview

Using the `gorm` CLI tool, you generate code by pointing it at your interfaces and model structs.

Example quick start:

```bash
gorm gen -i ./examples -o ./generated
```

This produces generated files under `./generated`.

### Prerequisites
- Go 1.18+ (for generics support).
- Defined Go interfaces with SQL templates.
- Model structs representing your database schema.

### Next Steps
- Explore the [`Value Proposition & Use Cases`](./value-and-use-cases.md) page to understand practical applications.
- Try the [`Quickstart: Generate and Use Type-Safe APIs`](../../guides/core-workflows/quickstart-guide.md) guide.
- Learn how to customize generation via [`Customizing Generation with genconfig`](../../guides/advanced-patterns/customizing-generation.md).

---

<Tip>
Start by writing intuitive query interfaces paired with your model structs; GORM CLI will transform these into safe, convenient APIs that bring speed and confidence to your database interactions.
</Tip>