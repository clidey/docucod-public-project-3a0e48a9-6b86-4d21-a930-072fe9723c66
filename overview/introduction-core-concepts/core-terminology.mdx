---
title: "Core Concepts & Terminology"
description: "Define fundamental terms—'Query API Generation,' 'Field Helpers,' 'Associations,' 'Type Safety,' and 'SQL Templates.' Explain the generator’s dual purpose (interface- and model-driven codegen) and reference the main objects and DSL users interact with."
---

# Core Concepts & Terminology

Welcome to the foundational guide that defines the essential terms and core concepts you need to understand before diving into GORM CLI's powerful code generation capabilities. This page lays out the key terminology and introduces the generator's dual code generation purposes, setting the stage for seamless use of its APIs and DSL.

---

## What You Will Learn Here

- Definitions of critical terms like **Query API Generation**, **Field Helpers**, **Associations**, **Type Safety**, and **SQL Templates**.
- The dual role of the generator in producing both interface-driven and model-driven code.
- An overview of the main objects and DSL constructs you will interact with when using GORM CLI.

---

## Defining Key Terms

### Query API Generation
This refers to the process where GORM CLI transforms Go interfaces containing SQL templates into concrete, type-safe query APIs. You write simple interface methods annotated with SQL template comments, and the generator produces fluent Go code that supports your application's database queries seamlessly.

- **Purpose:** Converts raw interface declarations into usable implementations bound to GORM queries.
- **User Benefit:** Eliminate manual SQL coding while gaining compile-time type safety and readable, maintainable APIs.

### Field Helpers
Field Helpers are generated from your Go model structs. For every field—including basic types and associations—the generator creates strongly typed helpers for filtering, updating, ordering, and association management.

- **Purpose:** Provide fluent, type-safe accessors and mutators for model fields.
- **User Benefit:** Write expressive queries and updates without boilerplate or unsafe string-based column references.

### Associations
In GORM CLI, **Associations** describe the relationships between models (e.g., has-one, has-many, belongs-to, many-to-many), including polymorphic associations.

- The generator creates dedicated helpers for each association, enabling operations such as:
  - Create, Update, Batch Create
  - Unlink (clearing foreign keys or join tables)
  - Delete (removing associated rows or join entries)

- **Benefit:** Manage complex relational data with clear, safe syntax, eliminating manual join or foreign key handling.

### Type Safety
Type safety is a core goal of GORM CLI. All generated code is strongly typed with full integration into Go's type system, ensuring:

- Compile-time checks prevent SQL errors stemming from mismatched parameters or incorrect field access.
- Fluent interfaces guide developers with autocompletion and error detection early in the development process.

### SQL Templates
GORM CLI uses a specialized SQL templating DSL embedded within Go interface method comments. This DSL supports:

- Parameter binding (`@param`), dynamic table and column references (`@@table`, `@@column`)
- Conditional clauses (`{{if}}`, `{{where}}`, `{{set}}`)
- Looping constructs (`{{for}}`)

These templates define the SQL to be executed, tied directly to Go method parameters, ensuring tight integration between SQL and Go code.

---

## The Generator’s Dual Code Generation Purposes

GORM CLI operates on two complementary axes to produce a complete developer experience:

1. **Interface-Driven Generation (Query APIs)**
   - From your defined Go interfaces, the generator composes concrete implementations that embed raw SQL queries in a type-safe manner.
   - These generated query APIs return your model types or collections thereof, enabling database reads and updates aligned with your domain logic.
   - Example: A method `GetByID(id int) (User, error)` in an interface becomes a generated function that safely executes `SELECT * FROM users WHERE id = ?`.

2. **Model-Driven Generation (Field Helpers & Associations)**
   - The generator examines your model structs (e.g., `User`, `Account`, `Pet`) and produces fluent helpers for each field.
   - These helpers support predicates (`Eq`, `Gt`, `Between`), setters, and association operations.
   - This enables writing expressive, fluent queries and updates, e.g., `generated.User.Name.Eq('alice')` or managing associated pets with `generated.User.Pets.Create(...)`.

Combining these two enables seamless integration of declarative query interfaces with model-based data manipulation helpers.

---

## Main Objects and DSL You Will Interact With

### Generated Query Interface Objects

- Named after your interfaces prefixed with `_` internally for type definitions.
- Provide concrete implementations for your SQL-annotated interface methods.
- Example:
  ```go
  type _QueryInterface[T any] interface {
      GetByID(ctx context.Context, id int) (T, error)
      FilterByNameAndAge(name string, age int)
      // ... other methods
  }

  // Usage
  q := generated.Query[User](db)
  user, err := q.GetByID(ctx, 123)
  ```

### Generated Field Helper Objects

- Structured as variables named after your model structs.
- Include one property per field, each returning a strongly typed field helper.
- Types include `field.String`, `field.Number[int]`, `field.Time`, and more specialized types for associations like `field.Struct[T]` and `field.Slice[T]`.

Example access:
```go
// Filter for users named "alice" and age over 18
gorm.G[User](db).Where(
  generated.User.Name.Eq("alice"),
  generated.User.Age.Gt(18),
).Find(ctx)
```

### Association Helpers

- Appear as typed fields for associations on your generated model helper variables.
- Support rich operations:
  - `Create()`, `CreateInBatch()` to insert related rows.
  - `Update()` to modify associated rows with conditions.
  - `Unlink()` to clear foreign key links or remove join table entries.
  - `Delete()` to fully remove associated records when needed.

Example:
```go
gorm.G[User](db).
  Set(
    generated.User.Pets.Create(generated.Pet.Name.Set("fido")),
  ).
  Create(ctx)
```

---

## Summary

This page provides a clear vocabulary and conceptual frame to understand GORM CLI's code generation engine. By mastering these terms and recognizing how the two generator roles produce complementary APIs, you’ll unlock powerful, type-safe data operations tailored to your Go projects using GORM.

Next, continue with the [Product Overview](../introduction-core-concepts/product-overview) page for a high-level introduction or jump into practical usage via [Using Field Helpers for Queries and Updates](../../guides/core-usage-patterns/using-field-helpers).

---

<AccordionGroup title="Quick Reference: Core Terms">  <Accordion title="Query API Generation">  Defined as the process of converting Go interfaces with annotated SQL templates into concrete, type-safe query implementations in Go. Enables precise, compile-time checked database reads and updates through fluent methods.  </Accordion>  <Accordion title="Field Helpers">  Generated helpers derived from your model structs that allow fluent construction of predicates, setters, and association handlers for both basic and relational fields, providing compile-time safety and code clarity.  </Accordion>  <Accordion title="Associations">  The representation of relationships between models, including various types (has one, has many, belongs to, many-to-many, polymorphic). The generator produces helpers to manage these relationships easily within your data operations.  </Accordion>  <Accordion title="Type Safety">  The guarantee that all generated APIs and helpers enforce correct types at compile time, preventing common runtime errors caused by mismatched SQL and Go constructs and improving developer productivity.  </Accordion>  <Accordion title="SQL Templates">  Embedded SQL DSL in Go interface method comments allowing conditional, parameterized, and dynamic SQL generation tied directly to method parameters, which the generator converts into executable code.  </Accordion></AccordionGroup>


---

## Practical Tips

- Start by defining clear query interfaces with SQL template comments to specify the exact database operations you require.
- Complement these with well-structured Go model structs to leverage field helpers and association operations.
- Utilize the conditional and iterative templating constructs (`{{if}}`, `{{where}}`, `{{for}}`) to build flexible queries.
- Keep your code organized by grouping interfaces and models logically within your project directories.
- Refer to generation configuration to customize field helper mappings and inclusion rules.

---

## Troubleshooting

- **Unrecognized Fields in Helpers:** Ensure your model struct fields are exported and confirm that custom field mappings, if any, are correctly configured.
- **SQL Template Errors:** Validate template syntax and parameter binding annotations carefully; syntax errors often arise from malformed conditional or iteration blocks.
- **Type Mismatches at Compile Time:** Check that your queries and helpers use the correct Go types matching your model definitions and SQL expectations.



---

## See Also

- [What is GORM CLI? (Product Overview)](/overview/introduction-core-concepts/product-overview)
- [Using Field Helpers for Queries and Updates](/guides/core-usage-patterns/using-field-helpers)
- [Working with Associations: Create, Update, Unlink, Delete](/guides/core-usage-patterns/association-operations)
- [Template-Based Queries: Writing and Using SQL Templates](/guides/core-usage-patterns/template-based-queries)
- [Generation Configuration Patterns](/gorm-cli-concepts/customization-and-templates/generation-configuration)


---

_Last updated: GORM CLI (main branch)_

---