---
title: "Core Concepts and Terminology"
description: "Master essential GORM CLI concepts: Query APIs, field helpers, associations (has one/many, belongs to, many2many), model-driven vs. interface-driven generation, templates and DSL, configuration patterns, and integration idioms. Each term defined in practical, user-centered language."
---

# Core Concepts and Terminology

Master the essential building blocks of GORM CLI to unlock its full potential in your Go projects. This documentation demystifies key terms and core constructs you’ll encounter as you define query APIs, generate field helpers, and manage associations. We present these concepts with straightforward explanations, practical examples, and clear guidance to ensure your success.

---

## What Are Query APIs?

Query APIs are type-safe, fluent Go interfaces generated from your own raw SQL interface definitions. Instead of writing raw SQL calls repeatedly, you model queries as Go interface methods with in-code SQL templates.

**User Intent:**
You want concise, reusable, and type-safe query methods that integrate seamlessly with GORM, minimizing runtime errors.

**How It Works:**
- Define Go interfaces where each method includes a SQL template comment.
- GORM CLI parses these interfaces and generates concrete implementations.
- Generated methods accept typed parameters and return structured results, protecting you from SQL syntax errors and mismatches at compile time.

Example:
```go
// UserQuery provides custom query methods for User model
 type UserQuery[T any] interface {
   // SELECT * FROM @@table WHERE id=@id
   GetByID(id int) (T, error)
   
   // SELECT * FROM @@table WHERE name=@name
   FindByName(name string) ([]T, error)
 }
```
You write your interface, then run the generator. Use the produced method `GetByID` type-safely in your code.

---

## Field Helpers: Model-Driven API Generation

Field helpers are strongly typed helpers generated from struct models, designed to make filtering, updating, sorting, and association handling smooth and compile-time safe.

**Purpose:**
Automate generation of helper constants and methods reflecting your model's columns and relationships.

**Examples:**
- Basic field helpers for scalar types (e.g., Int, String, Bool) support methods like `.Eq()`, `.Gt()`, `.Like()` to build SQL predicates.
- Association helpers for `has one`, `has many`, `belongs to`, and `many2many` relationships provide convenient methods—`Create()`, `Update()`, `Unlink()`, `Delete()`—to manage related data with safety.

Example Usage:
```go
// generated from User struct
 generated.User.Name.Eq("alice")     // WHERE name = 'alice'
 generated.User.Age.Between(18, 30)    // WHERE age BETWEEN 18 AND 30

// Association helpers
 generated.User.Pets.Create(generated.Pet.Name.Set("fido"))
```

---

## Associations Explained

GORM CLI creates specialized helpers for managing relationships between models, ensuring each association type behaves according to database semantics.

### 1. Has One
- One-to-one relationship where the foreign key is in the related model.
- Example: User has one Profile.
- `Unlink()` clears the child’s foreign key; `Delete()` removes child rows.

### 2. Has Many
- One-to-many relationship where the foreign key is in multiple related records.
- Example: User has many Pets.
- Operations affect child records accordingly.

### 3. Belongs To
- Inverse of Has One/Many: the model holds the foreign key.
- Example: Pet belongs to User.
- `Unlink()` sets the parent FK NULL; `Delete()` deletes the associated parent.

### 4. Many2Many
- Many-to-many relationship via a join table.
- Example: User relates to Languages.
- `Unlink()` and `Delete()` remove join rows but do not affect either side’s rows.

**User Benefit:**
You manipulate associations through generated helpers with clear operations and compiled-time guarantee of correctness.

---

## Model-Driven vs Interface-Driven Generation

| Aspect               | Model-Driven Field Helper Generation          | Interface-Driven Query API Generation               |
|----------------------|-----------------------------------------------|-----------------------------------------------------|
| Source               | Struct model definitions                       | Custom Go interfaces with SQL in comments           |
| Functionality        | Typing fields and associations as Go values   | Custom typed query methods with SQL templating      |
| Output               | Fluent helpers for building queries and actions| Concrete Go implementations for query interfaces    |
| Ideal For            | CRUD operations, association management        | Custom complex queries, filters, conditional statements  |

Use them together for maximum productivity.

---

## SQL Template DSL: Writing Safe, Reusable Queries

GORM CLI supports a powerful embedded templating DSL inside your interface method comments. This DSL uses placeholders with intuitive syntax:

- `@@table` — Dynamically resolves to the model’s table name
- `@@column` — Dynamic column binding
- `@param` — Parameterized binding from method inputs
- `{{where}} ... {{end}}` — Conditional WHERE clauses
- `{{set}} ... {{end}}` — Conditional UPDATE SET clauses
- `{{if ...}} ... {{end}}` — Conditional SQL fragments
- `{{for ...}} ... {{end}}` — Iteration for building repeated query parts

Example:
```sql
// SELECT * FROM @@table WHERE @@column=@value
FilterWithColumn(column string, value string) (T, error)
```

The generator safely expands these into prepared statements ensuring SQL injection protection and type safety.

---

## Configuration Patterns

While GORM CLI works out-of-the-box, you can customize generation via `genconfig.Config` values declared at the package level:

- **FileLevel**: Limit generation to current file or whole package.
- **Include/Exclude Interfaces and Structs**: Use patterns or type literals to whitelist/blacklist.
- **FieldTypeMap and FieldNameMap**: Override default field helper types, e.g., for JSON fields or SQL Nulls.
- **OutPath**: Control generated code output directory.

Example config snippet:
```go
var _ = genconfig.Config{
  OutPath: "examples/output",
  IncludeInterfaces: []any{"Query*"},
  ExcludeStructs: []any{"*DTO"},
  FieldNameMap: map[string]any{
    "json": JSON{},
  },
}
```

Set configurations as you grow from simple projects to advanced use cases.

---

## Integration Idioms and Best Practices

- Generated APIs consume `*gorm.DB` and integrate seamlessly with the broader GORM ecosystem.
- Query methods automatically get `context.Context` injected for cancellation and tracing.
- Leverage the fluent, composable API to build complex conditions.
- Use association helpers in conjunction with parent operations (`Create(ctx)`, `Update(ctx)`) to maintain consistency.

**Practical Tips:**
- Define scoped interfaces focusing on application requirements.
- Leverage field helpers for code clarity and compile-time validation.
- Apply configuration sparingly for targeted customizations.

---

## Summary

Understanding these core concepts and terminology empowers you to harness GORM CLI effectively across the full development lifecycle—from defining precise, safe queries to managing complex data relationships with confidence.

Explore related pages for a deeper dive into each topic and start extending your Go applications with elegant, generated query APIs today.


---

## Related Documentation

- [What is GORM CLI?](/overview/introduction-core-value/what-is-gorm-cli) — Introduction and core value
- [Value Proposition & Key Features](/overview/introduction-core-value/value-proposition-and-key-features) — Why use GORM CLI
- [Quickstart Workflow](/overview/feature-highlights-getting-started/quickstart-workflow) — Start generating code quickly
- [Defining Query Interfaces & SQL Templates](/guides/core-workflows/query-apis-and-templates) — Create your first query interface
- [Using Generated Field Helpers for Filtering and Updates](/guides/core-workflows/using-generated-field-helpers) — Leverage helpers effectively
- [Working with Associations: Create, Update, Unlink, Delete](/guides/core-workflows/associations-best-practices) — Manage model relations
- [Configuring Generation with genconfig.Config](/guides/advanced-usage/configuring-generation) — Advanced customization


---

## Mermaid Diagram: Conceptual Relationships

```mermaid
flowchart TD

  ModelStructs["Model Structs"] --> FieldHelpers["Generate Field Helpers"]
  InterfaceDefs["Query Interfaces with SQL Templates"] --> QueryAPIs["Generate Query APIs"]

  FieldHelpers -->|Typed| QueryAPIs
  QueryAPIs -->|Used by| Application["Your Application Code"]
  FieldHelpers -->|Used by| Application

  subgraph Associations
     HasOne["Has One"]
     HasMany["Has Many"]
     BelongsTo["Belongs To"]
     Many2Many["Many to Many"]
  end

  FieldHelpers --> Associations

  Associations -->|Create/Update/Unlink/Delete| Application

  Application -->|Invokes| QueryAPIs

  classDef concept fill:#f9f,stroke:#333,stroke-width:2px;
  ModelStructs,InterfaceDefs,FieldHelpers,QueryAPIs,Application,Associations,HasOne,HasMany,BelongsTo,Many2Many concept
```
