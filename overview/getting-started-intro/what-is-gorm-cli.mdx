---
title: "What is GORM CLI?"
description: "Get an introduction to GORM CLIâ€”a code generator for GORM projects that delivers type-safe query interfaces and model-driven field helpers, providing compile-time safety and fluent APIs for Go database code."
---

# What is GORM CLI?

GORM CLI is a powerful code generator designed specifically for GORM projects in Go. It transforms your Go interfaces annotated with SQL templates and your model structs into a type-safe, fluent API for database access with compile-time safety.

Whether you are writing complex queries or managing associations, GORM CLI equips you with convenient, discoverable helpers and query interfaces that significantly increase productivity and reduce runtime errors.

---

## Unlock Type-Safe, Fluent Database Code for Go

Imagine writing database queries and updates in Go with the confidence that the compiler catches mistakes before you even run your program. GORM CLI makes this possible by generating:

- **Typed query interfaces** from Go interfaces with embedded SQL templates.
- **Model-driven field helpers** for all your model structs to enable expressive filters, updates, and association operations.

This synergy not only catches errors at compile time but also streamlines your workflow with powerful, readable, and reusable code.

---

## What Is GORM CLI?

GORM CLI is a code generation tool focused on enhancing GORM projects with two main pillars:

- **Query API generation:** Write your query methods as Go interfaces annotated with SQL templates. GORM CLI generates concrete, type-safe implementations that map directly to your database.
- **Field helper generation:** From your model structs, it generates strongly typed helpers that let you compose filters, updates, and manage associations fluently.

This makes reading and writing database code in Go faster, safer, and more expressive.

### Why It Matters

Traditional SQL query construction in Go can be error-prone, verbose, and lacking in type safety. GORM CLI bridges the gap by providing:

- **Compile-time verification** of your query interfaces and field operations.
- **Fluent API:** Method chaining and intuitive helpers simplify complex query logic.
- **Declarative templates:** Manage SQL fragments in Go doc comments with placeholders, easing maintenance and readability.

### How It Works at a High Level

You write interface methods with SQL templates and define your Go model structs as usual. Then you run the GORM CLI generator to produce:

- Concrete implementations of your query interfaces for type-safe database interactions.
- Field helpers for all struct fields and associations.

These generated outputs integrate seamlessly into your Go codebase.

---

## Key Features & Capabilities

- **Type-Safe Query APIs from Interfaces:**
  Write Go interfaces with SQL template annotations describing queries. GORM CLI generates methods with strong type guarantees, reducing runtime SQL errors.

- **Model-Driven Field Helpers:**
  Automatically generate field helpers for basic types and associations (has one, has many, belongs to, many2many), supporting predicates, setters, and more.

- **Association Operations:**
  Support safe, compile-time checked operations like Create, Update, Unlink, Delete on related records.

- **Configurable Generation:**
  Customize output paths, inclusion/exclusion of interfaces/structs, and field type mappings through an optional `genconfig.Config`.

- **SQL Template DSL:**
  Use directives like `@@table`, `@param`, `{{where}}` to write expressive, conditional SQL fragments directly in Go comments.

### Real-World Example

```go
// Define your query interface with SQL templates
// SELECT * FROM @@table WHERE id=@id
GetByID(id int) (T, error)

// Define your model struct
type User struct {
  ID   uint
  Name string
  Age  int
}

// Use the CLI to generate code
// gorm gen -i ./path/to/your/package -o ./generated

// Use generated API in your application
user, err := generated.Query[User](db).GetByID(ctx, 123)
```

This workflow eliminates boilerplate while providing compile-time safety and code discoverability.

---

## Why Should I Care?

GORM CLI transforms your Go database layer into a robust, maintainable asset. Here's why developers and teams rely on it:

- **Prevent bugs early:** Catch mismatches between your queries and models at compile time.
- **Save development time:** Avoid hand-writing repetitive query code and error-prone string concatenations.
- **Improve readability:** Generated methods and field helpers use fluent APIs that describe intent clearly.
- **Facilitate complex queries:** Template DSL lets you express conditional logic and iteration within SQL safely.
- **Manage associations confidently:** Perform complex create, update, unlink, and batch operations on related data with ease.

### Use Cases

- Projects requiring strict type safety in database access
- Teams looking to standardize query and update patterns
- Applications with complex relational models needing safe association handling
- Developers wanting to leverage Go generics for cleaner database code

### Experience Before and After GORM CLI

| Before GORM CLI                            | After GORM CLI                              |
|------------------------------------------|--------------------------------------------|
| Manual SQL string building                | Typed interfaces with embedded SQL templates|
| Error-prone parameter substitution       | Compile-time checked parameter binding     |
| Boilerplate CRUD and filters              | Fluent field helpers with predicates and setters|
| Manual association management             | Strongly typed association helpers         |

---

## Getting Started Preview

Getting started with GORM CLI is straightforward:

1. **Write Query Interfaces & Models:** Define your query methods using interfaces with SQL templates in comments, alongside your Go model structs.

2. **Run the Generator:** Use the `gorm gen` command, specifying your input directory and desired output path.

```bash
gorm gen -i ./path/to/models -o ./generated
```

3. **Use Generated Code:** Import and use the generated packages in your Go code to perform type-safe queries and manipulations.

### Prerequisites

- Go 1.18+ (Generics support)
- GORM v2 installed and properly set up

### Next Steps

For a hands-on guide, check out:

- [Installation, Code Generation, and First Steps](overview/getting-started-intro/install-generate-getstarted)
- [Writing Template-based Queries](guides/core-workflows/template-queries-quickstart)
- [Working With Field Helpers](guides/advanced-features-patterns/working-with-field-helpers)

---

## Additional Tips & Best Practices

- Use the `genconfig.Config` struct in your packages to fine-tune generation behavior such as output directories and included interfaces.
- Leverage the template directives like `{{where}}` and `{{set}}` to write dynamic SQL efficiently.
- Define custom field helpers (e.g., JSON fields) if your project requires special SQL handling.
- Organize interfaces and models in the same package or directory to streamline generation.

## Troubleshooting

- Ensure your Go interfaces include proper SQL template comments; missing templates can cause generation errors.
- If generation fails, verify your input paths and that Go code parses correctly.
- Use the `-o` output flag to avoid overwriting your source files accidentally.

---

For full details on syntax, configuration, and examples, be sure to explore the broader GORM CLI documentation and example repositories.

---

*Generated by the GORM CLI documentation system*

---

## References

- [GORM CLI GitHub repository](https://github.com/go-gorm/cli)
- [GORM CLI on Go Modules](https://pkg.go.dev/gorm.io/cli/gorm)
- Explore related documentation on [Overview], [Getting Started], and [Guides] tabs in this documentation set.


