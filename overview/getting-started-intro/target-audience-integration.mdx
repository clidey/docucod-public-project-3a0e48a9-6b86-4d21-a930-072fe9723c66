---
title: "Target Audience & Integration"
description: "Understand who will benefit most from GORM CLI—Go developers using GORM who want safer, more expressive data operations. Learn how GORM CLI fits into the Go/GORM stack, as well as its minimal integration requirements and compatibility."
---

# Target Audience & Integration

GORM CLI is designed with precision to serve Go developers who utilize the GORM ORM framework and seek to elevate their database interaction through safer, more expressive, and type-safe APIs. This page helps you understand exactly who benefits most from GORM CLI, how it integrates into your existing Go and GORM stack, and what minimal requirements you need for adoption.

---

## Who Should Use GORM CLI?

**GORM CLI is tailored for:**

- **Go Developers Using GORM**: If you build applications with Go and rely on GORM for ORM, GORM CLI complements your workflow by generating type-safe query APIs and model-driven field helpers that drastically reduce boilerplate and avoid runtime SQL errors.

- **Teams Prioritizing Code Safety and Maintainability**: It’s perfect for teams aiming to catch data query issues at compile time, making codebases more reliable and easier to refactor.

- **Developers Managing Complex Data Models and Associations**: Those working with intricate relations like has-one, has-many, many-to-many, and polymorphic associations will find the generated APIs not only simplify operations but also enforce correct association semantics seamlessly.

- **Users Leveraging Dynamic SQL Queries**: For developers who need flexible, template-based SQL queries embedded within interfaces, GORM CLI automates generation, binding, and execution with type safety.

- **Go Projects Seeking Integration Without Overhead**: GORM CLI fits effortlessly into existing projects with minimal setup, requiring only Go 1.18+ generics support and standard GORM integration.


## How GORM CLI Integrates into Your Go & GORM Projects

GORM CLI acts as a code generation tool that enhances your current Go + GORM development environment by generating additional source files based on your model and query interface definitions.

### Seamless Extension of GORM

- **Type-safe Query Interfaces**: You write Go interfaces decorated with SQL templates, then GORM CLI generates strongly typed implementation methods that integrate with the underlying GORM `*gorm.DB` instance.

- **Model-driven Field Helpers**: GORM CLI introspects your model structs to create field helpers that simplify building filter conditions, updates, and managing associations with compile-time checks.

- **Minimal Runtime Integration**: The generated APIs reuse your existing GORM instance (`*gorm.DB`) transparently, so there is no need for additional runtime libraries or complex configuration.

### Minimal Requirements

- **Go 1.18 or Later**: Generics support is essential for the type-safe APIs GORM CLI generates.

- **GORM ORM Usage**: Requires GORM as the ORM foundation since generated code extends GORM’s query builder.

- **Code Generation Step**: A one-time (or repeated on demand) CLI command to produce generated files based on your interface and model definitions.

- **Standard Go Project Structure**: Works effortlessly with typical Go module-based project layouts.


## Integration Workflow at a Glance

1. **Define Your Models and Interfaces**

   Write Go structs for your database models and interfaces that declare your query methods with SQL templates in comments.

2. **Run GORM CLI Generator**

   Use `gorm gen` to generate type-safe code based on your inputs, emitting strongly typed interfaces and helpers.

3. **Utilize Generated APIs in Code**

   Import the generated packages and seamlessly call typed methods for database operations, leveraging compiler verification and IDE autocompletion.

---

## Concrete Example of Generated Usage

```go
import (
	"context"
	"gorm.io/gorm"
	"yourproject/generated"
	"yourproject/models"
)

func example(ctx context.Context, db *gorm.DB) error {
	userQuery := generated.Query[models.User](db)

	// Fetch user by ID with type safety
	user, err := userQuery.GetByID(ctx, 123)
	if err != nil {
		return err
	}

	// Filter users with dynamic condition
	activeUsers, err := userQuery.FilterWithColumn(ctx, "role", "active")
	if err != nil {
		return err
	}

	// Update user info safely
	err = userQuery.UpdateInfo(ctx, models.User{Name: "Alice", Age: 30}, int(user.ID))
	if err != nil {
		return err
	}

	return nil
}
```

This highlights how GORM CLI generated code slots neatly into your existing GORM workflows, improving clarity and reducing risk.

---

## Key Benefits of GORM CLI Integration

| Benefit                          | Description                                                                                         |
|---------------------------------|-------------------------------------------------------------------------------------------------| 
| **Type Safety at Compile Time** | Prevents common mistakes like typos in SQL, mismatched types, or invalid filters before runtime. |
| **Fluent, Discoverable APIs**    | Generated helpers provide IDE autocompletion, making database operations faster and less error-prone. |
| **Seamless GORM Compatibility** | Uses your familiar `*gorm.DB` instances and idioms, requiring no special runtime or environment changes. |
| **Support for Associations**    | Model-driven field helpers simplify managing belongs-to, has-many, many-to-many, and polymorphic relationships. |
| **Dynamic SQL Templating**      | Write expressive query interfaces with conditional and iterative SQL templates, generated for you. |

---

## Troubleshooting Integration

<Tip>
If you encounter integration issues:
- Ensure your Go version is 1.18 or above to support generics.
- Confirm that your project uses GORM (`gorm.io/gorm`) as the ORM layer.
- Verify the `genconfig.Config` and `Include*`/`Exclude*` settings match your interfaces and structs.
- Rerun the generator after any code or configuration changes to keep generated code up to date.
</Tip>

---

## Next Steps

- Visit **[Create Models and Query Interfaces](/getting-started/project-initialization/first-query-interface)** to learn how to define the inputs for code generation.
- Follow **[Generate Code with the CLI](/getting-started/project-initialization/run-generator)** for detailed instructions on running the GORM CLI.
- Explore **[Using the Generated APIs in Real Projects](/guides/core-workflows/using-generated-apis)** to master practical usage patterns.

---

## Summary
Understanding your role as a Go developer using GORM is key to leveraging GORM CLI effectively. Minimal integration effort brings powerful advantages: safety, expressiveness, and efficiency in your data layer.

Make GORM CLI the natural extension of your Go/GORM projects to transform database access into a type-safe, developer-friendly experience.

---

<Source url="https://github.com/go-gorm/cli" paths={[{"path": "examples/query.go", "range": "1-67"},{"path": "examples/output/query_test.go", "range": "1-78"},{"path": "README.md", "range": "1-227"}]} />
