---
title: "Target Audience & Use Cases"
description: "Defines the primary users—GORM developers, Go backend engineers, and teams seeking safe, maintainable, and expressive database layers. Lists common use cases: building query layers with compile-time safety, generating field helpers, and customizing SQL with templates."
---

# Target Audience & Use Cases

Welcome to the `Target Audience & Use Cases` page for GORM CLI—a focused guide designed to help you understand precisely who benefits most from this tool and how you can leverage it to build safe, maintainable, and expressive database layers within your Go projects.

---

## Who Should Use GORM CLI?

GORM CLI is crafted with particular users in mind, proudly serving:

- **GORM Developers:** Engineers actively working with GORM who want to enhance their data access layer with strong typing and fluent APIs.
- **Go Backend Engineers:** Programmers building backend services in Go who require concise, type-safe query abstractions that integrate seamlessly with GORM.
- **Development Teams:** Groups aiming to standardize and enforce compile-time safety, reduce boilerplate, and improve maintainability of their database interactions.

If your goal is to build robust Go applications powered by GORM with less error-prone, more expressive queries and helpers, GORM CLI is a perfect fit.

---

## What Does GORM CLI Empower You To Do?

At its core, GORM CLI generates two complementary code components that drastically improve your developer experience:

1. **Type-safe Query APIs:** From your defined Go interfaces annotated with SQL templates, it produces concrete query methods with compile-time safety and fluent chaining.
2. **Model-driven Field Helpers:** Based directly on your GORM model structs, it creates strongly typed field helpers for filters, updates, ordering, and association operations.

Together, these components give you a firm guardrail against common runtime errors and empower you to write clean, discoverable database access code.

## Key User Workflows & Use Cases

### 1. Building Compile-time Safe Query Layers

GORM CLI lets you define query interfaces with rich SQL templates, from simple `GetByID` operations to conditional filters and updates. The generator produces fully typed methods that ensure only valid queries compile.

Example:
```go
// Interface method with SQL template
// SELECT * FROM @@table WHERE id=@id
GetByID(id int) (T, error)
```
Usage:
```go
user, err := generated.Query[User](db).GetByID(ctx, 123)
```
Outcome:
- Eliminate manual SQL string concatenation.
- Catch SQL misuse or parameter mismatches at compile time.

### 2. Generating Field Helpers for Models

From your GORM models, GORM CLI generates helpers for all basic fields and complex associations (has one, has many, belongs to, many-to-many). This allows you to write expressive filter and update predicates effortlessly.

Example:
```go
generated.User.Name.Eq("alice")          // WHERE name = 'alice'
generated.User.Age.Between(18, 30)        // WHERE age BETWEEN 18 AND 30
```
Association operations like create, update, unlink, and delete are seamlessly supported with compile-time guarantees.

### 3. Customizing SQL with Templates

With GORM CLI's advanced template DSL, you can craft sophisticated queries that respond dynamically to parameters.

Example snippet:
```sql
SELECT * FROM @@table
{{where}}
  {{if user.Name != ""}} name=@user.Name {{end}}
  {{if user.Age > 0}} AND age=@user.Age {{end}}
{{end}}
```
This templating approach enables building flexible queries to match complex business logic while maintaining type safety.

---

## Why Should You Care About These Use Cases?

- **Boost Developer Confidence:** Type safety not only reduces bugs but speeds up development by catching mistakes early.
- **Reduce Boilerplate:** Write concise query interfaces and get full implementations generated for you.
- **Expressive, Discoverable APIs:** Fluent, interface-driven method chains improve code readability and maintenance.
- **Handle Complex Associations Safely:** Manage related entities with clear, structured helpers.
- **Tailored SQL Flexibility:** Customize exactly what your queries do in a safe DSL.

---

## Practical Tips for Success

- Define your Go interfaces with meaningful SQL template comments to leverage full power.
- Annotate models carefully for associations to generate robust helpers.
- Use the CLI `gorm gen` command pointing to your interfaces and model packages to generate code.
- Integrate generated code as drop-in replacements for raw queries or manual SQL in your apps.

<Check>
Leveraging GORM CLI can transform your database interaction layer from error-prone code into a safe, readable API that scales with your application's complexity.
</Check>

---

## Next Steps

Ready to dive deeper?

- Explore the [What is GORM CLI?](/overview/getting-started-intro/what-is-gorm-cli) page to understand the tool's fundamental approach.
- Learn about the key benefits in [Why Use GORM CLI?](/overview/getting-started-intro/value-proposition).
- When ready, set up your project and start code generation with [Generating Your First Code](/getting-started/first-codegen-project/generate-code).

---