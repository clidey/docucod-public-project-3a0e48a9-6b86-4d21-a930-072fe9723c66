---
title: "Value Proposition & Primary Use Cases"
description: "Explore the main benefits offered by GORM CLI, including type-safe query APIs, model-driven field helpers, and seamless workflows for querying and updating databases in Go. See how developers can use GORM CLI to streamline repetitive SQL tasks, reduce runtime errors, and boost productivity."
---

# Value Proposition & Primary Use Cases

## Unlocking the Power of GORM CLI: Why It Matters

GORM CLI transforms the way Go developers interact with databases, delivering an intelligent, type-safe code generation tool that eliminates common pain points of manual SQL handling. It empowers you to write clean, reliable, and maintainable database access code that works perfectly with GORM.

By leveraging your Go interfaces and model structs, GORM CLI generates **fluent APIs** that provide compile-time safety, reducing runtime errors and accelerating development time. Forget brittle string-based queries and repetitive SQL boilerplate — GORM CLI handles these for you, so you can focus on delivering business value.

### The Core Value Propositions of GORM CLI

- **Type-Safe Query APIs:** Generate interface-driven query methods from your Go interfaces annotated with SQL templates. Enjoy compile-time validation for queries, eliminating SQL errors that only surface at runtime.

- **Model-Driven Field Helpers:** Automatically create strongly typed helpers from your Go model structs. These helpers simplify filtering, updating, ordering, and association operations.

- **Seamless Association Management:** Perform create, update, unlink, and delete actions on associated records with clear, safe, and discoverable APIs.

- **Configurable & Extensible:** Customize generation behavior through `genconfig.Config` to control output paths, include/exclude interfaces or structs, and map complex field types.

- **Integrated Workflow:** Works hand-in-hand with GORM (`gorm.io/gorm`), fitting naturally into your existing Go projects with minimal setup.

## What Problems Does GORM CLI Solve?

### 1. Repetitive and Error-Prone SQL
Writing SQL queries as raw strings or concatenations leads to duplicated code and runtime errors that are costly to debug. GORM CLI lets you define your queries declaratively in Go interfaces, then generates safe, ready-to-use implementations.

### 2. Limited Discoverability and Intellisense
Manual query construction and string-based filtering offer poor IDE support. With generated typed APIs and field helpers, you get enhanced discoverability, auto-completion, and usage correctness guidance.

### 3. Complex Association Operations
Handling database associations manually can quickly become complicated and error-prone. GORM CLI abstracts these operations into intuitive association helpers that respect relational semantics with compile-time safety.

### 4. Difficulty Managing Dynamic Queries
Complex conditional SQL queries with dynamic WHERE or SET clauses are tedious to write and maintain. The SQL template DSL integrated with Go interfaces enables elegant expression of dynamic logic without sacrificing type safety.

## Real-World Use Cases and Workflows

### Streamlining CRUD Operations with Type Safety
Imagine a user management service needing repeatable queries like fetching by ID or filtering by attributes. Simply write minimal Go interface methods with embedded SQL templates — GORM CLI generates typed query interfaces that seamlessly plug into your app:

```go
// Define your query interface
 type Query[T any] interface {
   // SELECT * FROM @@table WHERE id=@id
   GetByID(id int) (T, error)

   // where("name=@name AND age=@age")
   FilterByNameAndAge(name string, age int)
 }
```

Run the generator:

```bash
gorm gen -i ./examples -o ./generated
```

Use the generated code:

```go
u, err := generated.Query[User](db).GetByID(ctx, 123)
users, err := generated.Query[User](db).FilterByNameAndAge("jinzhu", 25).Find(ctx)
```

### Managing Associations Effortlessly
Need to create a new user with pets or languages linked? Use association helpers:

```go
gorm.G[User](db).
  Set(
    generated.User.Name.Set("alice"),
    generated.User.Pets.Create(generated.Pet.Name.Set("fido")),
  ).
  Create(ctx)

// Batch link many2many languages

gorm.G[User](db).
  Where(generated.User.ID.Eq(1)).
  Set(generated.User.Languages.CreateInBatch([]models.Language{{Code: "EN"}, {Code: "FR"}})).
  Update(ctx)
```

This declarative approach lets you update parent and child entities in one fluent call, following relational semantics accurately.

### Building Dynamic Queries with SQL Templates
Want to support complex conditional filtering?

```go
// In your interface
// SELECT * FROM @@table
// {{where}}
//    {{if user.Name != ""}} name=@user.Name {{end}}
//    {{if user.Age > 0}} AND age=@user.Age {{end}}
// {{end}}
SearchUsers(user User) ([]T, error)
```

The powerful SQL template DSL dynamically builds queries with minimal code, keeping safety and readability intact.

## Before and After GORM CLI

| Without GORM CLI                         | With GORM CLI                           |
|---------------------------------------|---------------------------------------|
| Raw SQL as strings, error-prone        | Type-safe interface methods           |
| Manually managing query parameters     | Automated binding and compile-time checks |
| Repetitive code for common patterns    | Code generation reduces boilerplate  |
| Complex manual association management  | Association helpers streamline relations |
| Low IDE support and discoverability    | Fluent APIs with autocomplete and safety |

## Return on Investment

- **Boost Productivity:** Slash development time by automating SQL query generation and field helper creation.
- **Reduce Bugs:** Catch common SQL mistakes at compile time, significantly improving reliability.
- **Foster Maintainability:** Clear, generated code templates that scale with your project complexity.

## Summary
GORM CLI is an indispensable tool for Go developers using GORM who want to tame SQL complexity, improve code quality, and speed up development by adopting a declarative, type-safe approach to database querying and updates.

Explore how these benefits come together to enhance your daily development workflow and empower you to innovate faster.

---

## Next Steps
To put these values into practice, visit:
- [Create Models and Query Interfaces](https://your-docs-domain/getting-started/project-initialization/first-query-interface) to learn about writing your interfaces and models.
- [Generate Code with the CLI](https://your-docs-domain/getting-started/project-initialization/run-generator) to see the step-by-step process.
- [Using the Generated APIs in Real Projects](https://your-docs-domain/guides/core-workflows/using-generated-apis) for practical coding examples.

For a deeper understanding of the core concepts behind the CLI, refer to the [Core Concepts & Terminology](https://your-docs-domain/overview/architecture-concepts/core-concepts-terminology) page.

---

## Additional Resources
- Official GitHub Repository: [https://github.com/go-gorm/cli](https://github.com/go-gorm/cli)
- Introduction to [What is GORM CLI?](https://your-docs-domain/overview/getting-started-intro/what-is-gorm-cli)
- Guide to [Writing Template-based Queries](https://your-docs-domain/guides/core-workflows/template-queries-quickstart)
- Advanced [Customizing Generation with genconfig.Config](https://your-docs-domain/guides/advanced-features-patterns/customizing-generation-config)


---