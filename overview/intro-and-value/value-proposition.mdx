---
title: "Why Use GORM CLI?"
description: "GORM CLI delivers compile-time safety, improved discoverability of your database API, and seamless GORM integration. It saves development time, reduces bugs, and supports advanced use cases like dynamic queries and complex associations, freeing you to focus on your business logic."
---

# Why Use GORM CLI?

GORM CLI is more than just a code generatorâ€”it's your trusted companion for building robust, type-safe database interactions seamlessly integrated with the GORM ecosystem. By delivering compile-time safety, enhancing API discoverability, and supporting complex query patterns, GORM CLI empowers you to write safer code faster and focus on your core business logic instead of boilerplate.

---

## Unlock Compile-Time Safety

Imagine catching SQL errors, parameter mismatches, or association misuse before your code even runs. GORM CLI translates your Go interfaces and model structs into fully typed query methods and field helpers. This means your IDE and compiler become your first line of defense, preventing bugs that often surface only during runtime.

**Why it matters:**
- Prevents common SQL injection and syntax errors
- Ensures method parameters strictly match your query definitions
- Makes your codebase more reliable and easier to maintain

---

## Discover Your Database API Instantly

Workflows with GORM CLI feel natural and fluid because it generates fluent, idiomatic Go APIs tailored to your models and query interfaces.

- Generated query methods mirror your custom SQL interface definitions with clear, discoverable signatures.
- Model-driven field helpers provide intuitive predicates and setters for filtering, updating, and managing relationships.
- Autocomplete and inline documentation become powerful allies, speeding development and reducing guesswork.

> **Example:**
> ```go
> // Quickly find a user by ID with compile-time validation
> user, err := generated.Query[User](db).GetByID(ctx, 123)
> 
> // Filter users by age and name with fully typed helpers
> users, err := gorm.G[User](db).
>     Where(generated.User.Age.Gt(18), generated.User.Name.Like("%jinzhu%"))
>     .Find(ctx)
> ```

---

## Seamless Integration With GORM

GORM CLI extends GORM's power rather than replacing it. It complements your existing setup by generating code that plugs directly into `gorm.io/gorm`.

- Use generated query interfaces and helpers alongside your normal GORM operations.
- Perform create, update, unlink, and delete operations on associations with compile-time safety.
- Effortlessly handle complex associations like has-many, belongs-to, and many-to-many relationships using idiomatic Go patterns.

---

## Save Development Time, Reduce Bugs

By automating tedious and error-prone boilerplate, GORM CLI liberates your development bandwidth.

- No manual SQL string building or error-prone query construction
- Generate batch operations and conditional queries from simple interface definitions
- Focus on your business logic instead of low-level database plumbing

---

## Support for Advanced Use Cases

Whether you need dynamic queries, conditional WHERE clauses, or template-driven SQL, GORM CLI has you covered.

- Write SQL templates in interface comments with full parameter binding and conditional logic
- Generate robust query implementations automatically
- Use field helpers for expressions, ranges, NULL checks, and complex filters

> **Example: Dynamic Template Query**
> ```go
> type Query[T any] interface {
>   // SELECT * FROM @@table WHERE id=@id
>   GetByID(id int) (T, error)
>
>   // Conditional WHERE clause example
>   // SELECT * FROM @@table
>   // {{where}}
>   //   {{if @user.Name != ""}} name=@user.Name {{end}}
>   //   {{if @user.Age > 0}} AND age=@user.Age {{end}}
>   // {{end}}
>   SearchUsers(user User) ([]T, error)
> }
> ```

---

## What You Gain with GORM CLI

- **Compile-time safety** across queries and association operations
- **Discoverability** through generated, idiomatic Go APIs
- **Seamless GORM integration** with support for complex relationships
- **Efficiency gains** by eliminating manual SQL and query scaffolding
- **Flexibility** to handle dynamic and template-driven queries easily

---

## Getting Started Preview

1. Define your models as usual using GORM conventions.
2. Write Go interfaces with SQL templates for your query methods.
3. Run `gorm gen` to generate type-safe, fluent APIs.
4. Start using the generated code immediately in your GORM-powered application.

For detailed steps and examples, see [Set Up Your Models & Query Interfaces](https://docs.gorm.io/overview/intro-and-value/project-structure) and [Generate Type-Safe APIs](https://docs.gorm.io/getting-started/initial-usage/basic-generation).

---

## Tips & Best Practices

- Keep your SQL templates simple and expressive to maximize generated code clarity.
- Utilize association operations (`Create`, `Update`, `Unlink`, `Delete`) to manage related data reliably.
- Use `genconfig.Config` for advanced customization of generation behavior.
- Leverage batch creates and updates to optimize performance when working with collections.

---

## Troubleshooting

- Ensure your Go environment supports generics (Go 1.18+).
- Verify models and query interfaces are in the same package or correctly referenced.
- Check for build errors indicating mismatches in interface method signatures or model fields.
- Use the generated code as guidance for correct method usage and parameters.

---

By choosing GORM CLI, you adopt a proven approach to generate robust, maintainable, and type-safe database access code, accelerating your development and elevating your GORM projects to the next level.

---

_For comprehensive guidance, refer to the [GORM CLI GitHub Repository](https://github.com/go-gorm/cli) and the full product documentation on our website._
