---
title: "What is GORM CLI?"
description: "An introduction to GORM CLI: a code generation tool that produces type-safe query APIs and model-driven field helpers for Go projects using GORM. Learn how it empowers developers to write concise, discoverable, and compile-time safe database logic, boosting productivity and code quality."
---

# What is GORM CLI?

## Unlock Type-Safe, Model-Driven Database Queries in Go with GORM CLI

GORM CLI is a revolutionary code generation tool tailored for Go developers using the GORM ORM. It produces **type-safe query APIs** based on developer-defined interfaces, alongside **model-driven field helpers** that make database interactions concise, discoverable, and guaranteed safe at compile time. By automating repetitive boilerplate and enforcing strong typing, GORM CLI empowers you to write database logic that is both robust and efficient.

### Why GORM CLI?

- **Type-Safety at the Forefront**: Eliminate runtime errors caused by incorrect SQL queries or mismatched parameters by generating compile-time verified query APIs.
- **Model-Driven Helpers**: Automatically generated field helpers reflect your structs, providing fluent interfaces for filtering, updating, and managing associations.
- **Greater Productivity**: Focus on defining your queries and models, then let GORM CLI generate the heavy lifting code for you.
- **Strong Discoverability**: Generated methods and fields in your IDE offer autocompletion and documentation, reducing guesswork.
- **Seamless Integration**: Works natively with GORM and Go’s generics system, making adoption and usage straightforward.

### Who Should Use This?

- Go developers who want safer, cleaner, and more efficient database code.
- Teams maintaining large codebases with complex queries and associations.
- Developers looking for a streamlined bridge between SQL templates and strongly typed Go code.

---

## What is GORM CLI?

At its core, GORM CLI is a **code generation tool** that reads Go interface definitions annotated with SQL templates and Go model structs, then produces:

1. **Type-Safe Query APIs:** Interfaces become concrete implementations where methods correspond to SQL query templates, automatically binding parameters with Go types and verifying correctness at compile time.
2. **Model-Driven Field Helpers:** Struct fields generate helper objects that provide fluent predicates (e.g., `Eq`, `Like`) and setters. These helpers extend to associations, enabling compile-time safe CRUD operations on related entities.

### Core Purpose

GORM CLI solves the common pitfalls in manual SQL query coding by blending the flexibility of raw SQL with the safety and clarity of Go’s type system. It enables you to define your queries once as interfaces with embedded SQL, and then rely on generated, immutable code to interact with your database.

### What Sets It Apart?

- **Interface-First Design:** Write your queries declaratively as Go interfaces.
- **SQL Template DSL:** Leverages a powerful SQL templating language for dynamic and conditional SQL inside method comments.
- **Comprehensive Modeling:** Provides first-class support for associations with many-to-many, one-to-many, and polymorphic relationships.
- **Configurable Generation:** Customize output paths, included types, and field mappings through Go-based config literals.

---

## Key Features & Capabilities

### 1. Type-Safe Query APIs from Interfaces
Define an interface with methods documented by SQL templates. The CLI generates concrete implementations providing fluent, type-safe methods:

```go
// Define query interface with SQL templates
 type Query[T any] interface {
     // SELECT * FROM @@table WHERE id=@id
     GetByID(id int) (T, error)
 }

// Generated usage
 user, err := generated.Query[User](db).GetByID(ctx, 123)
```

### 2. Model-Driven Field Helpers
Helper objects representing fields let you construct predicates and setters fluently:

```go
// Predicates
generated.User.Name.Like("%jinzhu%")  // name LIKE '%jinzhu%'

// Updates
gorm.G[User](db).
  Where(generated.User.Name.Eq("alice")).
  Set(generated.User.Age.Incr(1)).
  Update(ctx)
```

### 3. Association Operations With Compile-Time Safety
Manage related entities via generated association helpers supporting:
- Create
- Batch create (CreateInBatch)
- Update
- Unlink (disassociate without deletion)
- Delete

Example:
```go
gorm.G[User](db).
  Set(
    generated.User.Pets.Create(generated.Pet.Name.Set("fido")),
  ).
  Create(ctx)
```

### 4. Configurable Generation
Use package-level `genconfig.Config` literals to:
- Override output directory
- Specify included/excluded interfaces and structs
- Customize field type mappings (e.g., for SQL Null types or JSON fields)

### 5. SQL Template DSL Support
GORM CLI supports a mini-DSL with directives:

| Directive    | Purpose                                 | Example                           |
|--------------|-----------------------------------------|---------------------------------|
| `@@table`    | Resolves to the model's table name      | `SELECT * FROM @@table WHERE id=@id` |
| `@@column`   | Dynamic column binding                   | `@@column=@value`                |
| `@param`     | Maps Go params to SQL params             | `WHERE name=@user.Name`          |
| `{{where}}`  | Conditional WHERE clause (based on input) | See example below                |
| `{{set}}`    | Conditional SET clause for updates     | Used in UPDATE statements        |
| `{{if}}`     | Conditional blocks                      | `{{if age > 18}} AND is_adult=1 {{end}}` |
| `{{for}}`    | Iterate collections in SQL parts        | Loop over tags or filters        |

Example Usage:

```sql
SELECT * FROM @@table
{{where}}
  {{if name != ""}} name=@name {{end}}
  {{if age > 0}} AND age=@age {{end}}
{{end}}
```

---

## Why Should I Care?

### Real Benefits
- **Eliminate Runtime SQL Bugs:** Reduce errors from incorrect SQL or parameter mismatches by bringing validation to compile time.
- **Boost Developer Velocity:** Write less boilerplate while getting feature-rich, strongly-typed query APIs.
- **Clear Maintainability:** Generated code is consistent, self-documenting, and easy to refactor.
- **Strong IDE Support:** Autocompletion and inline help make database access more intuitive.

### Common Use Cases
- Building complex applications where SQL queries need to stay maintainable and type-safe.
- Handling models with rich relationships requiring complex CRUD operations on associations.
- Teams seeking to enforce a standard pattern for database access through generated APIs.

### Before & After
| Without GORM CLI                              | With GORM CLI                              |
|---------------------------------------------|-------------------------------------------|
| Write raw SQL strings + manual scanning     | Define interfaces + use generated type-safe methods |
| Manual binding + error-prone update queries | Fluent field helper predicates and setters ensure consistency |
| Limited IDE assistance                       | Full code completion and discoverability |

---

## Getting Started Preview

### Quick Start Workflow

1. **Define Query Interfaces with SQL Templates**
    - Annotate Go interfaces with SQL query comments representing your intended queries.
2. **Define Your Models**
    - Use Go structs representing your database tables.
3. **Run the CLI Generator**
    ```bash
gorm gen -i ./path/to/interfaces -o ./generated
```
4. **Use Generated Code in Your Application**
    - Access type-safe methods and field helpers with IDE autocompletion.

### Prerequisites
- Go 1.18 or newer with generics support.
- Your project uses the GORM library.
- Write your interfaces and models in Go with standard conventions.

### Next Steps
Explore guides on:
- [Generating Type-Safe Query APIs](../guides/core-workflows/generate-type-safe-queries)
- [Generating Model-Driven Field Helpers](../guides/core-workflows/generate-field-helpers)
- [Mastering the SQL Template DSL](../guides/advanced-usage-patterns/template-sql-dsl)

---

## Additional Resources

- [Official GitHub Repository](https://github.com/go-gorm/cli)
- Explore example code under `examples/` directories for practical patterns.

---

By introducing GORM CLI into your workflow, you gain a powerful ally in crafting safe, expressive, and maintainable database code — fully embracing Go’s type system and GORM’s capabilities with ease.
