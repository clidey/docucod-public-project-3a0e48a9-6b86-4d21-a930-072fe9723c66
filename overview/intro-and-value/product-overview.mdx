---
title: "What is GORM CLI?"
description: "GORM CLI is a command-line code generator that creates type-safe query APIs and field helpers for GORM projects. By transforming Go interfaces and model structs into fluent, reliable methods, it enhances productivity and avoids runtime SQL errors. Discover how GORM CLI bridges the gap between interface-driven design and database safety."
---

# What is GORM CLI?

## Empower Your GORM Projects with Type-Safe Code Generation

GORM CLI is a powerful command-line tool designed to generate type-safe query APIs and field helpers tailored specifically for your GORM projects. By converting Go interfaces with raw SQL annotations and your model structs into fluent, reliable, and compile-time-safe methods, it saves you from runtime SQL errors, accelerates development, and bridges the gap between interface-driven design and database safety.

### Why GORM CLI Matters

- **Eliminate Runtime SQL Errors:** Generate code that validates SQL queries during compilation, preventing costly bugs.
- **Boost Developer Productivity:** Use an intuitive, fluent API crafted automatically from your Go code.
- **Seamless Integration:** Works effortlessly with standard GORM workflows.
- **Comprehensive Code Generation:** From query interfaces to model-driven field helpers, covering filters, updates, sorting, and associations.

### Who Benefits Most?

- Go developers building data-intensive applications with GORM.
- Teams aiming for safe, maintainable, and scalable database access layers.
- Projects requiring flexible, interface-driven query definitions.

---

## What is GORM CLI?

GORM CLI is a command-line code generator that transforms your Go code into robust, type-safe query interfaces and field helpers tailored to your database models. It takes raw SQL queries embedded in Go interface comments and model structs, then outputs concrete implementations and helpers that guarantee safety and fluency.

### Core Purpose

It empowers developers to:

- Write SQL as annotated interface methods with compile-time verification.
- Generate strongly typed helpers for model fields and associations to build queries safely.
- Avoid manual SQL crafting or error-prone string concatenations.

### What Sets GORM CLI Apart?

- **Interface-Driven Generation:** Convert your raw SQL interfaces directly into fully typed implementations.
- **Model-Driven Field Helpers:** Auto-generate expressive fields for filters, updates, and relational operations.
- **Comprehensive Association Support:** Create, update, unlink, or delete associations with strong typing.
- **Configurable via Go Code:** Customize generation behavior with Go-based configuration (`genconfig.Config`).

### How it Works (At a High Level)

GORM CLI reads your Go source code to identify:

- Interfaces annotated with SQL templates – where methods define queries.
- Structs that represent your database models.

It then generates:

- Concrete Go implementations of your query interfaces with type-safe methods.
- A set of field helpers reflecting your models’ columns and associations for fluent query construction.

This integration ensures you can write high-level Go code while GORM CLI guarantees the SQL is safe and discoverable.

---

## Key Features & Capabilities

### 1. Type-Safe Query API Generation
Write SQL queries in Go interface method comments using a specialized SQL templating DSL. GORM CLI generates implementations that enforce parameter binding, result types, and compile-time safety.

```go
// Your interface example with SQL in comments:
type Query[T any] interface {
  // SELECT * FROM @@table WHERE id=@id
  GetByID(id int) (T, error)
}
```

### 2. Model-Driven Field Helpers
From your GORM model structs, GORM CLI generates helpers for all basic fields (int, string, bool, time, etc.) and associations (has one, has many, belongs to, many2many). These helpers enable expressive filter, update, and ordering criteria with full type safety.

```go
// Example usage of generated helpers:
gorm.G[User](db).
  Where(generated.User.Age.Gt(18)).
  Find(ctx)
```

### 3. Rich Association Operations
Automatically generated helpers allow actions like:

- Creating related rows while associating them in one fluent call.
- Updating or unlinking associations conditionally.
- Batch creation or linking in many-to-many relationships.

This covers all common relational patterns with compile-time guarantees.

### 4. Configurable Generation
Customize which interfaces and structs are processed, output paths, field type mappings, and more via a Go-based `genconfig.Config` declaration in your source packages.

### 5. Intuitive SQL Template DSL
Embed SQL with directives like `@@table` for dynamic table names, `@param` for parameter binding, and `{{where}}`/`{{set}}` blocks for complex conditional query sections.

---

## Why Should I Care? (Benefits & Use Cases)

### Unlock Developer Efficiency
- No more guessing column names or SQL syntax errors.
- Autocomplete-ready APIs to speed query building.

### Improve Code Quality
- Compile-time validation reduces bugs going into production.
- Clear separation of query definition (interfaces) and implementation.

### Real-World Use Cases
- Building multi-filter, dynamic queries for web APIs.
- Managing complex relationships across entities with safe association operations.
- Generating project-specific, maintainable access layers.

### Before & After with GORM CLI

| Without GORM CLI | With GORM CLI |
|-----------------|--------------|
| Manually compose raw SQL strings prone to typos and injection risks. | Write Go interfaces with typed query methods and rely on generated safe code. |
| Work with untyped map or raw JSON for filters and updates. | Use auto-generated field helpers with precise types and methods. |
| Maintain brittle and duplicated SQL scattered in codebase. | Centralize queries in interfaces with templates and regenerated code on every model change. |

---

## Getting Started Preview

### Quick Start
1. Define GORM models and create Go interfaces with SQL annotated in comments.
2. Run the CLI command `gorm gen -i ./path/to/interfaces -o ./generated`.
3. Use the generated code directly in your application for safe, fluent queries.

### Prerequisites
- Go 1.18 or later (support for generics).
- GORM integration in your Go application.

### Next Steps
- Explore [Integration with GORM](#) to leverage generated APIs.
- Learn about [Writing SQL Templates](#) to fully harness the DSL power.

---

## Example: From Interface to Usage

### Interface Definition
```go
// Define query methods with SQL annotations
// SELECT * FROM @@table WHERE id=@id
GetByID(id int) (T, error)
```

### Generate with CLI
```bash
gorm gen -i ./examples -o ./generated
```

### Use the Generated API
```go
user, err := generated.Query[User](db).GetByID(ctx, 123)
```

---

## Additional Tips & Best Practices

- Separate your model structs and query interfaces logically within your project to maintain clarity.
- Use `genconfig.Config` to selectively generate code, improving build efficiency.
- Leverage the field helpers for complex filters and association manipulations instead of crafting raw SQL.

## Troubleshooting

- Ensure your Go interfaces have properly formatted SQL templates in comments.
- Verify your environment uses Go 1.18+ for generics support.
- Use the provided example projects and tests to validate your setup.

---

GORM CLI transforms your approach to database interaction by generating reliable, type-safe query code from your own interfaces and models. It redefines productivity and safety in Go GORM projects—making your database queries cleaner, safer, and more maintainable.


---

## References
- [GORM CLI GitHub Repository](https://github.com/go-gorm/cli)
- [Integration with GORM Documentation](/overview/integration-and-use/integration-overview)
- [How Code Generation Works](/overview/integration-and-use/generation-workflow)


---

*Explore the next pages for why to use GORM CLI and who benefits most.*