---
title: "What is GORM CLI?"
description: "Discover GORM CLI: a purpose-built code generator empowering Go projects with type-safe, interface-driven query APIs and strongly-typed field helpers for GORM. Learn how it elevates database safety, code fluency, and productivity by bridging your data models and application logic."
---

# What is GORM CLI?

## Empowering Go Developers with Type-Safe, Fluent Database Access

Welcome to GORM CLI, the purpose-built code generation tool designed to bridge your Go data models with powerful, type-safe, interface-driven query APIs and strongly-typed field helpers. It elevates database interactions by transforming your existing models and raw SQL interfaces into fluent, robust, and compile-time safe code — dramatically improving both safety and developer productivity.

---

## Introducing GORM CLI

GORM CLI is a command-line tool that scans Go code — specifically your interfaces annotated with SQL templates and your struct models — and generates:

- **Type-safe query APIs:** Concrete implementations of your SQL-backed interfaces with method signatures typed precisely to your data models.
- **Model-driven field helpers:** Strongly typed helpers for filtering, updating, and working with associations, tailored to your model fields.

Think of it as your trusted assistant that translates your intent expressed in Go interfaces and models into efficient, safe, and idiomatic GORM queries — no repetitive boilerplate, no fragile string-based SQL.

---

## Why GORM CLI? The Problem It Solves

In typical GORM projects, developers write raw SQL as strings or build queries dynamically, which introduces risks:

- **Lack of compile-time safety:** Any typo or mismatch in field names or parameters only shows up at runtime.
- **Verbose and error-prone code:** Manually managing query strings reduces fluency and readability.
- **Inconsistent query building:** Filtering, updates, and association handling often repeat similar patterns without strong typing.

GORM CLI eliminates these pain points by generating seamless, strongly-typed APIs from your interfaces and models, letting you code with confidence and fluidity.

---

## How GORM CLI Works at a Glance

- You write **Go interfaces** with embedded SQL templates in comments that define your queries, updates, and filtering logic — binding method parameters to SQL placeholders.
- You define your **Go struct models**, representing database tables, which the tool scans for fields and associations.
- GORM CLI **processes these inputs** by parsing Go Abstract Syntax Trees (AST), extracting interface methods, SQL templates, and struct field metadata.
- It **generates Go code** implementing:
  - Query APIs that provide fluent methods implementing your SQL templates.
  - Typed field helpers for every model field and association to build safe, expressive GORM conditions and updates.

This workflow integrates naturally with your existing Go project and the GORM ecosystem.

---

## Key Features and Capabilities

### 1. Interface-Driven Generation

Define your data access layer as Go interfaces with SQL templates in method comments. GORM CLI generates concrete, type-safe implementations that:
- Inject `context.Context` automatically if missing.
- Respect your method's return types, supporting single or double return values (result + error).
- Handle raw SQL, conditional clauses, and parameter bindings transparently.

Example:

```go
// SELECT * FROM @@table WHERE id=@id
GetByID(id int) (User, error)
```

### 2. Strongly-Typed Model Field Helpers

For every model, GORM CLI generates field helpers with types derived from Go types and configured mappings. These helpers enable fluent predicates and updates:
- Basic fields like `int`, `string`, `time.Time` mapped to typed helpers (e.g., `field.Number[int]`, `field.String`).
- Custom mappings and special cases supported via configuration.
- Association helpers for `has one`, `has many`, `belongs to`, and `many2many` relations with built-in operations like `Create`, `Update`, `Unlink`, and `Delete`.

Example usage:

```go
generated.User.Name.Eq("alice")             // WHERE name = 'alice'
generated.User.Pets.Create(generated.Pet.Name.Set("fido"))  // create and associate pet
```

### 3. Configurable Generation

Use package-level `genconfig.Config` literals to customize:
- Output path customization per package.
- Fine-grained inclusion/exclusion filters for interfaces and structs.
- Type and field mappings to connect custom Go types with appropriate field helpers.
- File-level vs package-level applicability.

### 4. SQL Template DSL

Craft dynamic, expressive SQL templates right inside method comments, with support for:
- Table (`@@table`) and column (`@@column`) placeholders.
- Parameter binding with `@param` syntax.
- Conditional blocks with `{{if}}`, `{{where}}`, `{{set}}`, and `{{for}}` directives.

This lets you write rich queries and updates that are translated safely.

---

## Why Should You Care?

### Unlock Compile-Time Safety
Eliminate risk of runtime SQL errors caused by typos or mismatched parameters. Your SQL queries become guaranteed to align with your method signatures and models.

### Improve Productivity and Code Fluency
Write less boilerplate and more idiomatic, discoverable code that integrates with your GORM experience seamlessly.

### Work with Associations Safely
Creating, updating, unlinking, or deleting related entities becomes straightforward, strongly typed, and consistent.

### Extensive Customization
Control generation details flexibly via configs without compromising simplicity.

---

## Real-World Context

Imagine you want to fetch a user by ID or update a user’s name conditionally. With GORM CLI, you write these intent expressions once as an interface:

```go
// SELECT * FROM @@table WHERE id=@id
GetByID(id int) (User, error)

// UPDATE @@table
// {{set}}
//   {{if user.Name != ""}} name=@user.Name, {{end}}
// {{end}}
// WHERE id=@id
UpdateUser(user User, id int) error
```

Run the CLI generator, and use the generated API:

```go
user, err := generated.Query[User](db).GetByID(ctx, 123)
err = generated.Query[User](db).UpdateUser(ctx, updatedUser, 123)
```

Behind the scenes, this code is type-safe, context-aware, and dynamically builds SQL with your conditions.

---

## Getting Started Preview

Begin by installing GORM CLI:

```bash
go install gorm.io/cli/gorm@latest
```

Write your interfaces and models in the same package or directory.

Execute the generator specifying input and output paths:

```bash
gorm gen -i ./path/to/interfaces -o ./generated
```

Finally, import and use the generated query APIs and field helpers in your application for safer, expressive data access.

For complete instructions and examples, visit the [Quick Start & Typical Workflow](https://gorm.io/cli/docs/overview/features-workflows/quickstart-workflow) page.

---

## Related Documentation

- [Who Should Use GORM CLI?](./audience-usecases)
- [Feature Overview](./feature-overview)
- [Quickstart & Typical Workflow](./quickstart-workflow)
- [Template-Driven Query Interfaces](../../guides/advanced-patterns/guide-sql-templates)
- [Customizing Generation with genconfig.Config](../../guides/advanced-patterns/guide-genconfig)

---

Harness the power of GORM CLI to transform your Go projects with strong typing, fluent APIs, and seamless database integration — accelerating your development while protecting against common errors and inefficiencies.

_Start your journey with GORM CLI today!_