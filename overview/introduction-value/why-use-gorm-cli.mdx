---
title: "Why Use GORM CLI?"
description: "GORM CLI eliminates boilerplate, reduces runtime errors, and enables a fluent, discoverable, and type-safe API for both reads and writes. It streamlines development by offering compile-time checking, predictable code generation, and seamless GORM integration for real-world database work."
---

# Why Use GORM CLI?

GORM CLI revolutionizes how developers interact with databases in Go by eliminating repetitive boilerplate code and significantly reducing runtime errors. It delivers a fluent, discoverable, and type-safe API that accelerates both read and write operations, ensuring your database interactions are as intuitive as they are robust.

---

## Unlocking Efficiency Through Compile-Time Safety

At the core of GORM CLI’s value is *compile-time type safety*. By generating concrete query APIs from your Go interfaces and model structs, it catches common mistakes such as incorrect SQL syntax or mismatched parameter types *before* your application runs. This proactive verification saves hours otherwise spent debugging subtle runtime errors.

By defining your queries as Go interfaces annotated with SQL templates, GORM CLI automatically generates fully implemented, strongly typed methods. This approach means every query method you call is guaranteed to align with your database schema and input parameters.


## Why GORM CLI Works Better for Real-World Projects

- **Predictable Code Generation:** Your source code interfaces and structs drive the entire generation process. This predictability ensures generated methods precisely reflect your intended queries and model relationships—*no surprises or guesswork.*

- **Seamless GORM Integration:** The generated APIs operate naturally on `*gorm.DB` instances, leveraging GORM’s powerful ORM features with the added benefit of type safety and templated, dynamic SQL.

- **Fluent API for Reads and Writes:** Both query methods and model field helpers are generated, allowing you to compose expressive database operations with clear intent. For example, your code can safely chain filters, updates, and association operations with intuitive method calls.

- **Configurable, Flexible Generation:** The optional generation configuration (via `genconfig.Config`) allows you to include or exclude specific interfaces or structs, map custom field helpers, and control output paths. This flexibility adapts GORM CLI to diverse project structures and coding conventions.


## Real-World User Flow: From Writing Interfaces to Safer Queries

Imagine you want to fetch users by ID and filter them by dynamic criteria:

1. **Define an Interface:** You create a Go interface with methods annotated via SQL templates specifying dynamic bindings.

2. **Run GORM CLI Generation:** Using the CLI (`gorm gen -i ./models -o ./generated`), your concrete implementations and typed field helpers are generated.

3. **Write Queries Using Generated APIs:** You use the resulting API, for example,

   ```go
   user, err := generated.Query[User](db).GetByID(ctx, 123)
   users, err := generated.Query[User](db).FilterByNameAndAge("alice", 30).Find(ctx)
   ```

4. **Benefit from Compile-Time Checks:** Calling these methods with wrong parameters or return types results in compilation errors, preventing bugs early.

5. **Perform Typed Writes and Associations:** Using generated field helpers, you perform updates and association operations with clear semantics and zero guesswork.


## Key Outcomes When You Use GORM CLI

- **Reduced Boilerplate:** No manual implementation of query methods or field helpers.
- **Fewer Runtime Failures:** Early detection of invalid queries and parameter mismatches.
- **Improved Developer Experience:** Discoverability and auto-completion with rich, fluent APIs.
- **Consistent, Maintainable Code:** Clear source-of-truth in Go interfaces and models.
- **Faster Iteration:** Build complex queries with conditional logic and templates without repetitive code.


## Common Use Cases Where GORM CLI Excels

- Large codebases where manually writing query methods leads to errors and inconsistencies.
- Projects requiring dynamic, template-driven SQL for complex queries.
- Teams emphasizing type-safe APIs to satisfy code quality and maintainability requirements.
- Applications needing advanced association handling with compile-time support.
- Developers wanting seamless integration with GORM and standard Go tooling.


## Before and After GORM CLI

| Without GORM CLI                                     | With GORM CLI                                           |
|----------------------------------------------------|--------------------------------------------------------|
| Manually writing query code prone to typos         | Auto-generated, type-safe query methods from interfaces|
| Runtime SQL errors and parameter mismatches         | Compile-time verification of query correctness          |
| Tedious and error-prone CRUD and association code  | Fluent, discoverable APIs for queries and associations  |
| Hard to maintain and evolve queries                  | Configuration-driven generation for flexible control    |


## Getting Started: Your Next Steps

To start benefiting from GORM CLI’s powerful features:

- Define query interfaces with embedded SQL templates.
- Annotate your models and optionally provide a `genconfig.Config` for custom mapping.
- Use the `gorm gen` CLI command to generate your type-safe APIs.

For detailed steps, see the [Quick Start: From Models to Queries](/overview/quickstart-features/quickstart-workflow) and [Installing GORM CLI](/getting-started/setup-requirements-installation/installing-gorm-cli) documentation.


---

## Summary of Benefits

- **Write less, do more**: Generate safe and efficient query code, avoiding tedious hand-coding.
- **Catch bugs early**: Leverage compile-time safety to prevent runtime surprises.
- **Use flexible, templated SQL**: Embed conditional logic and parameters naturally.
- **Harness powerful GORM features**: Combine auto-generated APIs with GORM’s ORM capabilities.


<Info>
Explore the [What is GORM CLI?](/overview/introduction-value/what-is-gorm-cli) page to understand the product’s full scope, and view [Interface-Driven Query APIs: From Template to Usage](/guides/query-and-model-helpers/interface-driven-queries) for practical coding examples.
</Info>