---
title: "Who Should Use GORM CLI?"
description: "Identify whether GORM CLI aligns with your team: it's ideal for Go developers leveraging GORM ORM who value compile-time correctness, maintainable patterns for filtering, updates, and associations, and customizable generation for their data layer. Common scenarios include greenfield projects, data-centric APIs, and mature codebases seeking type safety."
---

# Who Should Use GORM CLI?

GORM CLI is designed to deliver robust, type-safe database query code generation tailored specifically to Go developers who leverage the GORM ORM. This page helps you identify if GORM CLI matches your project's needs by outlining the ideal user profile, common scenarios, and why adopting this tool will maximize your code safety and maintainability.

---

## Is GORM CLI Right for Your Team?

### Primary Audience
- **Go developers using GORM ORM:** If your project is built around GORM and you want to extend its capabilities with compile-time safety, GORM CLI is purpose-built for you.

- **Teams valuing type safety:** GORM CLI transforms interface definitions and model structs into strongly-typed, fluent APIs that eliminate common runtime errors and improve code discoverability.

- **Projects needing maintainable filtering and update patterns:** By generating helpers from your models, GORM CLI provides consistent, reusable building blocks for queries, updates, and complex association handling.

- **Developers requiring customizable generation:** With options to filter what gets generated and map custom types/fields, you gain control over your data layerâ€™s structure and style.

### Typical Use Cases
- **Greenfield projects:** Start new applications with a strong foundation by constructing query interfaces and models upfront, then auto-generating clean, type-safe data access code.

- **Data-centric APIs:** Build APIs where data retrieval and updates must be precise, predictable, and free of SQL injection or runtime mismatches.

- **Mature codebases adopting type safety:** Incrementally adapt existing projects by writing interfaces reflecting evolving query needs and generating safe, idiomatic code.

---

## Why You Should Care

### Achieve Compile-Time Correctness
GORM CLI converts your Go interfaces annotated with SQL templates into concrete implementations that are checked at compile-time. This prevents SQL/Go type mismatches or parameter binding mistakes early in development.

### Improve Code Maintainability and Clarity
Generated model field helpers create a uniform, discoverable API pattern for all your filters, updates, and association operations. This consistency reduces bugs and onboarding time for new team members.

### Customize Generation to Fit Your Workflow
You control which interfaces and structs get generated and how field types map to helper constructs via a simple, package-level configuration. This flexibility lets you tune output for your domain and coding conventions.

### Support Complex Patterns Easily
From conditional SQL via templates to operations on associations (create, update, unlink, delete), GORM CLI enables expressing complex data access logic declaratively, letting generation handle the details.

---

## Real-World Scenarios

### Scenario 1: Fast Prototyping a New API
Your team builds a new microservice in Go using GORM. With GORM CLI, you write interfaces that specify your queries with embedded SQL templates and define your data models. Running the CLI generates type-safe query implementations and field helpers, letting you quickly build CRUD endpoints with compile-time safety.

### Scenario 2: Migrating Existing Queries to Safer Patterns
In an established codebase, you want to reduce boilerplate and runtime errors. GORM CLI lets you gradually write interface definitions reflecting current queries, then auto-generates strongly typed functions. You incrementally replace raw SQL calls with generated code for safer updates and filters.

### Scenario 3: Managing Complex Associations
You have models linked via `has many`, `belongs to`, or `many2many` relationships. GORM CLI generates helpers letting you express create, batch create, update, unlink, or delete operations on associations declaratively. This makes complex transactions cleaner and safer.

---

## What You Need Before Using GORM CLI

- **Go 1.18+** with generics support
- Familiarity with GORM ORM and Go interfaces
- Models defined as Go structs
- Queries defined as interfaces with SQL templates in comments

If these align with your stack, GORM CLI fits naturally into your workflow.

---

## Next Steps
- Explore the [Product Overview](/overview/introduction-value/product-overview) page to see GORM CLI's core capabilities.
- Get hands-on with the [Quick Start & Typical Workflow](/overview/features-workflows/quickstart-workflow) to generate your first code.
- Deep dive into [Feature Overview](/overview/features-workflows/feature-overview) to understand specific functions and helpers.

<Tip>
If your team prioritizes type safety, maintainability, and streamlined data access in Go with GORM, GORM CLI will empower your development with compile-time correctness and efficient workflow.
</Tip>

---

## Common Pitfalls to Avoid

- **Not defining model structs and query interfaces together:** GORM CLI depends on both your model definitions and query interfaces to generate complete APIs. Keep them organized in related packages/directories.

- **Ignoring configuration options:** Customize generation to avoid unneeded files and map custom types via `genconfig.Config` to tailor output.

- **Overlooking association operations:** Take advantage of generated association helpers instead of manually writing complex joins or updates.

- **Assuming runtime SQL checks:** GORM CLI shifts error detection to compile-time, but double-check your interface annotations and method signatures carefully.

---