---
title: "Target Audience and Use Cases"
description: "Outlines who should use GORM CLI (Go developers using GORM wanting stronger typing or more ergonomic APIs). Provides example scenarios—automating query boilerplate, customizing code generation, migrating from handwritten DAOs, or building large data-driven Go applications."
---

# Target Audience and Use Cases

## Who Should Use GORM CLI?

GORM CLI is purpose-built for Go developers who use the GORM ORM and seek to elevate their data access layer with **stronger type safety** and **more ergonomic, maintainable APIs**. Whether you are a solo developer or part of a team building medium to large-scale Go applications, GORM CLI helps you streamline database interactions through code generation.

### Ideal Users Include:
- **Go developers leveraging GORM** who want to eliminate error-prone manual query code.
- Teams needing **consistent, type-safe, compile-time verified query APIs**.
- Developers aiming to adopt a **fluent and discoverable API** for database reads, writes, and association management.
- Users who want to **automate boilerplate query/code generation** without sacrificing control.


## Real-World Scenarios and How GORM CLI Fits

### 1. Automate Query Boilerplate
Maintaining handwritten data access objects (DAOs) often leads to repetitive code and subtle bugs, especially in dynamic queries. GORM CLI lets you define interfaces with SQL templates, then auto-generates fully typed query methods that keep your codebase clean and maintainable.

**Example:**
```go
// Define query interface with SQL template
type Query[T any] interface {
  // SELECT * FROM @@table WHERE id=@id
  GetByID(id int) (T, error)

  // SELECT * FROM @@table WHERE name=@name
  FilterByName(name string) ([]T, error)
}
```
Using this, you get ready-made, type-safe method implementations that are consistent and error-free.

### 2. Customize Generated Code to Fit Your Domain
GORM CLI’s generation is highly configurable. By declaring a package-level `genconfig.Config`, you can tailor how field helpers and query interfaces are generated to match custom types, naming conventions, or behaviors.

**Example Config:**
```go
var _ = genconfig.Config{
  OutPath: "examples/output",
  FieldNameMap: map[string]any{
    "json": JSON{},  // Map `json` tagged fields to custom JSON helper
  },
  IncludeInterfaces: []any{"Query*"},
  IncludeStructs: []any{"User"},
}
```
This allows easy extension without modifying generated files manually.

### 3. Replace or Modernize Legacy DAOs
If your project has large amounts of handwritten SQL or DAO layers, migrating to GORM CLI lets you gain **compile-time safety**, reduce bugs, and standardize on a fluent, idiomatic interface-based pattern.

- Define minimal interfaces with templates
- Generate robust, tested implementations
- Use generated model-driven field helpers for filters and updates

This drastically cuts down manual maintenance:
```go
user, err := generated.Query[User](db).GetByID(ctx, 123)
```
vs.
manually handwritten query code.

### 4. Build Large-Scale Data-Driven Go Applications
For applications with complex models, associations, and domain logic, GORM CLI equips you with:
- **Strongly typed field helpers** for every model field (basic and associations)
- Fluent methods to create/update/unlink/delete related records (has one, has many, many2many)
- Template-based SQL interfaces that scale as your data layer grows

This means fewer runtime errors, better autocomplete, and faster development across teams.

## Summary of Typical Use Cases

| Use Case                         | Benefits                            | Outcome                                       |
|---------------------------------|------------------------------------|-----------------------------------------------|
| Automating Query Boilerplate    | Reduce errors and repetitive code  | Fast, reliable query methods                   |
| Customizing Generated Code      | Match project-specific needs       | Clean integration with existing conventions   |
| Migrating from Handwritten DAOs | Gain type safety & consistency     | Safer, maintainable codebase                    |
| Developing Complex Apps         | Full coverage of associations and models | Scalable, fluent ORM usage                   |


## Getting Started Tips

- Begin by defining your query interfaces with inline SQL templates in comments.
- Organize your Go models with appropriate struct tags to benefit from field helper generation.
- Optionally provide a `genconfig.Config` to tailor output and mapping.
- Run `gorm gen` to generate query APIs and field helpers.
- Implement your business logic using the generated, type-safe APIs.


<Note>
For deep dive examples and tutorials on creating query interfaces and models, see our [Defining Query Interfaces & Models](/getting-started/first-run-and-validation/defining-interfaces-models) guide.
</Note>


## Common Pitfalls and How to Avoid Them

- **Missing context.Context in interface methods:** GORM CLI will add it automatically if omitted, but explicitly including it clarifies your method signatures.
- **Incorrect SQL template usage:** Use the provided DSL directives like `@@table`, `@param`, `{{where}}` correctly to ensure valid generated queries.
- **Not configuring output paths in large projects:** Use `genconfig.Config.OutPath` to keep generated files organized.


---

## Related Documentation

- [What is GORM CLI?](/overview/product-intro-concepts/what-is-gorm-cli) - Understand the product’s core value.
- [Core Concepts and Terminology](/overview/product-intro-concepts/core-concepts-terminology) - Learn essential terms and components.
- [Generating & Using Type-Safe Query APIs](/guides/core-workflows/generating-and-using-query-apis) - Step-by-step usage of query generation.
- [Model-Driven Field Helper Generation](/guides/core-workflows/model-driven-field-helpers) - Learn how model fields translate into helpers.


---

This page aims to help you quickly identify if GORM CLI suits your development needs and how it can transform your GORM-based data access into safer, more efficient Go code.
