---
title: "Integration with GORM and Your Projects"
description: "Explain how GORM CLI fits into standard GORM-based Go projects, where the generated code lives, and how developers interact with it in real application scenarios. Describe compatibility, required Go/GORM versions, and how generation wraps around typical GORM workflows."
---

# Integration with GORM and Your Projects

GORM CLI seamlessly fits into your standard GORM-based Go projects by generating type-safe query APIs and field helpers that integrate naturally with the GORM ecosystem. This page explains where the generated code lives, how you interact with it during real-world development, compatibility requirements with Go and GORM versions, and how generation complements typical GORM workflows.

---

## How GORM CLI Fits Into Your Project

GORM CLI enhances the developer experience by automatically generating strongly typed, fluent APIs based on your own interfaces and model structs. The generated packages integrate directly with your existing GORM ORM usage, making type-safe, discoverable queries and updates effortless.

### Location of Generated Code

- **Output Directory**: By default, generated files go into the `./g` directory, preserving your input directory structure.
- **Package Co-location**: You can configure the output path on a per-package basis using `genconfig.Config` declarations in your code, maintaining logical package boundaries.
- **Typical Flow**:
  1. Define your GORM model structs and query interfaces in your package or sub-packages.
  2. Run `gorm gen -i ./yourpkg -o ./generated` to generate the code.
  3. Import the generated package to use the generated APIs directly with your database connection.

### Example

```bash
gorm gen -i ./examples -o ./generated
```

Then in your Go code:

```go
import "yourproject/generated"

// Use generated query API
user, err := generated.Query[User](db).GetByID(ctx, 123)
```

## Developer Workflow in Real Applications

GORM CLI-generated code wraps around your common GORM workflows, enabling you to write cleaner, more maintainable data access code with compile-time safety.

1. **Define Models and Interfaces**: Your typical GORM model structs remain normal Go structs with GORM tags.

2. **Write Query Interface Methods**: Define interfaces with method signatures annotated by SQL templates (comments) that describe the queries.

3. **Run Generator**: `gorm gen` interprets these interfaces and model structs, producing:
   - **Query API interfaces and implementations** for type-safe queries.
   - **Field helper constants** corresponding to model columns and associations.

4. **Use the Generated Code**:
   - Query APIs provide convenient methods that accept parameters and return typed results.
   - Field helpers allow you to build `Where`, `Set`, and association operations fluently.

5. **Operate with Associations**: Create, update, unlink, and delete associated records with simple method calls that mirror your data relationships.

6. **Integration with `*gorm.DB`**: All generated code uses and extends your existing `*gorm.DB` instances, preserving the flexibility and power of GORM's builder pattern.

### Example Usage in a Typical Request Handler

```go
func GetUserByID(ctx context.Context, db *gorm.DB, id int) (*User, error) {
    // Type-safe query method generated by GORM CLI
    user, err := generated.Query[User](db).GetByID(ctx, id)
    if err != nil {
        return nil, err
    }
    return &user, nil
}
```

```go
func UpdateUserName(ctx context.Context, db *gorm.DB, id int, newName string) error {
    // Use field helper for filtered update
    return gorm.G[User](db).
        Where(generated.User.ID.Eq(id)).
        Set(generated.User.Name.Set(newName)).
        Update(ctx)
}
```

## Compatibility and Requirements

- **Go Version**: Requires Go 1.18 or later for generics support.
- **GORM Version**: Compatible with GORM version 1.23+ (which supports generics and the fluent interface required).
- **Generator Version**: Always use the latest GORM CLI version (`gorm.io/cli/gorm`) to ensure bug fixes, security, and improved support for advanced features.

## How Generation Wraps Around Typical GORM Workflows

The generated code complements and extends normal GORM usage without replacing it:

- **Querying**:
  - Generated query interfaces provide custom, type-safe methods based on your SQL templates.
  - They return results directly or return enhanced GORM interfaces for chaining.

- **Filtering and Updating**:
  - Field helpers define strongly typed predicates and setters.
  - Combine these with `Where`, `Set`, `Update`, and `Create` operations seamlessly.

- **Associations**:
  - Helpers manage `has one`, `has many`, `belongs to`, and `many2many` relationships.
  - Supports create, batch create, update, unlink, and delete operations on associations with strong compile-time checks.

- **Configuration**:
  - Per-package `genconfig.Config` allows precise control over generation behavior, including interface whitelisting, struct selection, and output paths.

## Best Practices for Using GORM CLI in Your Projects

- **Keep Models and Query Interfaces Together**: Place your interface definitions and corresponding models in the same package for easier code generation and clarity.
- **Use `genconfig.Config` for Customization**: Tune output directories, field type mappings, and interface selections to match your project’s structure and preferences.
- **Version Management**: Synchronize your GORM CLI and GORM library versions to avoid incompatibilities in generated code.
- **Leverage Associations**: Utilize generated helpers for managing complex data relationships safely and fluently.
- **Run Generation as Part of Build Pipelines**: Automate regeneration to keep your generated code up-to-date with model changes.

## Troubleshooting Common Scenarios

<AccordionGroup title="Common Integration Questions">
<Accordion title="Why does the generated code not update after model changes?">
Make sure you run `gorm gen` again after modifying your models or interfaces. By default, the generator reads all Go files under the input path and regenerates output.

Check your `OutPath` configuration in `genconfig.Config` to confirm where generated files are placed.
</Accordion>
<Accordion title="Can I generate code for only specific interfaces or structs?">
Yes. Use the `IncludeInterfaces`, `ExcludeInterfaces`, `IncludeStructs`, and `ExcludeStructs` fields in your `genconfig.Config`.

This allows fine-grained control to limit generation to selected code.
</Accordion>
<Accordion title="How do generated association helpers behave in real scenarios?">
Association helpers perform operations that mirror GORM’s association methods but with strong typing.

Use `Create`, `Update`, `Unlink`, and `Delete` methods on related fields to modify associations safely.

Refer to examples in the product overview under associations usage.
</Accordion>
</AccordionGroup>

---

## Summary Diagram of GORM CLI Integration

```mermaid
flowchart TD
  UserCode["User-defined Models & Query Interfaces"] -->|Input to| CLI["GORM CLI Generator"]
  CLI -->|Generates| GeneratedCode["Generated Type-safe Query APIs & Field Helpers"]
  GeneratedCode -->|Imports & Usage| AppCode["Application Code Using Generated APIs"]
  AppCode -->|Uses| GORM["GORM ORM (gorm.io/gorm)"]

  subgraph ""
    CLI
    GeneratedCode
  end

  AppCode --> DB["Database"]

  click CLI "getting-started/setup-intro/installing-cli" "Install GORM CLI"
  click GeneratedCode "getting-started/initial-usage/generating-code" "Generating Code"
  click AppCode "guides/workflows-real-world-usage/building-type-safe-queries" "Using Generated APIs"
```

---

## Next Steps

- Proceed to [Quickstart Workflow](/overview/architecture-usage-integration/quickstart-workflow) for hands-on guidance.
- Review [Core Features and Value Proposition](/overview/intro-value-core-concepts/core-features-and-value) to understand the full capabilities.
- Consult [Prerequisites & System Requirements](/getting-started/setup-intro/prerequisites) to ensure your environment is ready.


---

This page completes your understanding of how GORM CLI integrates with standard GORM projects, aligns generated code in your repository, and enhances your development workflow with type safety and convenient APIs.


---