---
title: "System Architecture"
description: "Visualize how GORM CLI operates—from taking user-defined interfaces and models as input, through the code generation pipeline, to producing type-safe APIs and helpers. This includes a mermaid diagram showing main flows: CLI → Parsing/Generation → Output → Developer Usage."
---

# System Architecture

Understand how GORM CLI transforms your Go interfaces and model structs into powerful, type-safe query APIs and field helpers through a streamlined and automated code generation pipeline. This page demystifies the entire lifecycle—from your input, through processing and generation, to final developer usage.

---

## Why This Matters

Imagine writing database queries that are fully type-checked and auto-completed by your IDE, along with ready-to-use helpers for filtering, updating, or associating records — all generated automatically from your existing Go code. GORM CLI makes this possible by parsing your Go interfaces with embedded SQL templates and your model structs, generating code that boosts developer productivity, reduces runtime errors, and makes APIs discoverable.

## The System Architecture: High-Level Workflow

GORM CLI operates as a command-line tool orchestrating a sequence of well-defined steps:

1. **CLI Invocation:** You initiate the generation by running the `gorm gen` command, specifying the path to your interfaces and models, and optionally an output directory.

2. **Parsing & Analysis:** The generator parses your Go source files, walking through abstract syntax trees (ASTs), to extract:
   - Query interfaces annotated with embedded SQL templates
   - Model structs representing database tables
   - Package-level generator configuration

3. **Code Generation Pipeline:** Based on the parsed information:
   - It applies inclusion/exclusion filters from any configuration
   - Generates type-safe query APIs for interfaces
   - Creates model-driven field helpers for struct fields and associations

4. **Writing Outputs:** Generated Go source files are formatted and written to the specified output directory, preserving relevant package structure.

5. **Developer Usage:** You import and use the generated code seamlessly in your application, benefiting from fluent, safe, and discoverable database APIs.

---

### Visual Flow Diagram

```mermaid
flowchart TD

  CLI["gorm gen Command Line Interface"] --> Parser["Parsing Go Source Files"]

  subgraph Parsing
    direction TB
    Parser --> AST["Abstract Syntax Tree (AST) Walk"]
    AST --> Interfaces["Extract Interfaces with SQL Annotations"]
    AST --> Structs["Extract Model Structs and Fields"]
    AST --> Configs["Load Generator Configuration (genconfig.Config)"]
  end

  Generator["Code Generation Pipeline"]
  Interfaces & Structs --> Generator
  Configs --> Generator

  Generator --> Formatter["Code Formatting & Validation"]
  Formatter --> Output["Write Generated Code to Output Directory"]

  Output --> Developer["Import & Use Generated APIs in Application"]

  %% Styling
  classDef component fill:#dae8fc,stroke:#6c8ebf,stroke-width:2px;
  class CLI,Parser,Generator,Formatter,Output,Developer component;

  %% Subgraph Title Style
  class Parsing stroke:#6c8ebf,stroke-width:1.5px,fill:#f4faff;
```

---

## Components Explained

### 1. CLI Invocation
- **What You Do:** Run the `gorm gen` command, specifying the input Go files or directories and optionally the output path.
- **Benefit:** Provides an easy and consistent way to trigger code generation without manual steps.
- **User Action Example:**

    ```bash
gorm gen -i ./examples -o ./generated
```

### 2. Parsing Go Source Files
- **Purpose:** Walk through your Go code to discover all the relevant interfaces and structs along with any package-level configuration.
- **What Happens Under the Hood:** Uses Go AST parsing to understand: method signatures, embedded SQL comments, struct fields, types, and associated tags.

### 3. Code Generation Pipeline
- **Filtering:** Applies any include/exclude filters configured via `genconfig.Config` to determine what to generate.
- **Dual Generation:**
  - **Interface-based Query APIs:** Generates methods corresponding to your interface definitions, embedding your SQL templates and binding parameters for type safety.
  - **Model-driven Field Helpers:** Generates strongly typed helpers for struct fields, supporting predicates, setters, and association operations.

### 4. Output Writing
- **Process:** The generated Go code goes through formatting (via `golang.org/x/tools/imports`) to ensure idiomatic style and correctness.
- **Outcome:** Files structured following your package layout, ready for immediate use or check-in.

### 5. Developer Usage
- **Goal:** Developers use generated types and methods directly in their application code, gaining compile-time safety, code completion, and reduced boilerplate.

---

## Practical Scenario: From Interface to Generated API

Consider a scenario where you define the following interface with embedded SQL in comments:

```go
// Query[T any] interface defines data retrieval methods
// with SQL templates binding parameters safely.
type Query[T any] interface {
  // SELECT * FROM @@table WHERE id=@id
  GetByID(id int) (T, error)

  // where("name=@name AND age=@age")
  FilterByNameAndAge(name string, age int)
}
```

When you run GORM CLI on this interface, it:

- Parses the SQL annotations
- Generates a struct implementing this interface
- Creates methods like `GetByID(ctx, id)` that execute the annotated SQL with parameters bound

This flow eliminates manual query writing and enforces type correctness.

---

## Tips for Success

- Organize interfaces and models within the same directory or package for smooth discovery.
- Use package-level `genconfig.Config` literals to control generation specifics (e.g., outputs, filtering).
- Leverage built-in SQL template DSLs (`@@table`, `@@column`, `@param`, `{{where}}`, `{{set}}`) for dynamic query logic.
- Regularly run the CLI after any interface or model changes to keep generated code up-to-date.

---

## Troubleshooting Common Snags

<AccordionGroup title="Common Issues and Solutions">
<Accordion title="No files generated after running CLI">
- Ensure your input path (-i flag) points to the directory or file containing interfaces/models.
- Verify that your interfaces and structs are properly exported (start with uppercase letters).
- Confirm that `genconfig.Config` filters are not excluding your intended files or types.
- Check CLI output logs for any parsing errors.
</Accordion>

<Accordion title="Generated code has invalid Go syntax">
- This usually indicates malformed SQL templates or method signatures.
- Review embedded SQL comments for correctness.
- Validate that all methods either return the expected result and error types.
- Run `go fmt` on your input source files to cleanse syntax.
</Accordion>

<Accordion title="Output directory structure is unexpected">
- The tool preserves relative package paths from your input.
- Use the `OutPath` field in your package-level `genconfig.Config` to customize output location.
</Accordion>
</AccordionGroup>

---

## Next Steps

To deepen your understanding and start using GORM CLI effectively:

- Visit [Feature Summary](../core-concepts-architecture/feature-overview) to explore detailed capabilities.
- Review [Target Audience & Use Cases](../what-is-gorm-cli/target-audience-use-cases) for practical scenarios.
- Try the [Quickstart Workflow](../../getting-started-examples/quickstart-workflow) for hands-on code generation.

---

Harness this architecture overview to visualize the power and flow behind GORM CLI, enabling you to generate highly reliable, efficient, and developer-friendly database access code effortlessly.


---

<Info>
The diagram above uses exact component names and flow steps based on the real CLI, parsing, and generation implementation inside GORM CLI's repository.
</Info>
