---
title: "Core Concepts & Terminology"
description: "Master the essential vocabulary: ‘Query Interface’, ‘SQL Template’, ‘Field Helper’, ‘Association Operations’, ‘Model-driven Generation’, and ‘genconfig.Config’. Each term is defined in the user’s context and linked to its practical application in GORM CLI."
---

# Core Concepts & Terminology

Welcome to the foundational page that will help you master the essential vocabulary underpinning GORM CLI’s code generation. This document breaks down key terms such as **Query Interface**, **SQL Template**, **Field Helper**, **Association Operations**, **Model-driven Generation**, and **genconfig.Config**, spotlighting their meaning and practical use in GORM CLI.

---

## Why These Terms Matter

Understanding these core concepts is crucial because GORM CLI revolves around generating powerful, type-safe database interaction code by connecting your Go models and query interfaces with this domain-specific vocabulary. Knowing these terms clears the path toward writing your interfaces and models in ways that unlock GORM CLI’s features, enabling you to safely and efficiently manage database operations with minimal boilerplate.

---

## Key Terminology Explained

### Query Interface
A **Query Interface** is a Go interface you define where each method comes with an SQL template comment describing a database query.

- **What It Does:** It enables GORM CLI to generate strongly-typed, safe query methods by reading your interface’s method signatures and templated SQL comments.
- **Why It Helps:** Instead of crafting raw SQL strings or ORM calls scattered around your code, you declare your queries once in clear, reusable methods.
- **Example:** 
  ```go
  type Query[T any] interface {
    // SELECT * FROM @@table WHERE id=@id
    GetByID(id int) (T, error)
  }
  ```
  This declares a method to fetch an entity by id, where GORM CLI generates the implementation behind the scenes.

### SQL Template
SQL templates within Query Interface method comments use special directives that allow dynamic, safe SQL generation.

- **Core Features:**
  - `@@table`: Automatically replaced with the model’s database table name.
  - `@param`: Binds Go method parameters to SQL safely.
  - `{{where}}`, `{{set}}`, `{{if}}`: Provide control flow for conditional SQL fragments.
  
- **User Benefit:** Flexibly construct dynamic queries without losing type safety or risking SQL injection.

- **Illustration:**
  ```sql
  // SELECT * FROM @@table
  // {{where}}
  //   {{if user.Name != ""}} name=@user.Name {{end}}
  // {{end}}
  SearchUsers(user User) ([]T, error)
  ```
  This query conditionally includes a WHERE clause based on the user’s name.

### Field Helper
A **Field Helper** is auto-generated code derived from your Go model structs, representing each field with a strongly-typed helper.

- **Purpose:** Makes writing filter, update, and association expressions fluent and discoverable.
- **Types:** Includes helpers for basic fields (e.g., `field.String`, `field.Number[int]`) and associations (`field.Struct[T]` for has-one/belongs-to, `field.Slice[T]` for has-many/many-to-many).
- **Real Example:**
  ```go
  generated.User.Name.Eq("Alice")        // Builds SQL `name = 'Alice'`
  generated.User.Pets.Create(generated.Pet.Name.Set("Fido"))  // Creates and associates pet
  ```

### Association Operations
These are special methods on association helpers designed to manage related data via create, update, unlink, or delete operations.

- **Supported Operations:**
  - `Create` / `CreateInBatch`: Insert and link related records.
  - `Update`: Modify associated records matching conditions.
  - `Unlink`: Dissociate records without deleting.
  - `Delete`: Remove associated records or join table rows.

- **Why It’s Important:**
  Manage nested, related entities in a clean, type-safe manner without manual foreign key manipulation.

- **Use Case:**
  ```go
  // Create a user and link pets
  gorm.G[User](db).
    Set(
      generated.User.Name.Set("alice"),
      generated.User.Pets.Create(generated.Pet.Name.Set("fido")),
    ).
    Create(ctx)
  ```

### Model-driven Generation
This refers to the automatic generation of field helpers directly from your Go model structs.

- **What Happens:** Every field, including associations, becomes a typed helper that you can use in queries and mutations.
- **Benefits:**
  - Saves time writing helper code.
  - Guarantees type correctness.
  - Makes your data model directly usable in fluent, expressive queries.

- **Example:** From `User` Go struct:
  ```go
  type User struct {
    ID    uint
    Name  string
    Pets  []*Pet
  }

  // Generates:
  var User = struct {
    ID   field.Number[uint]
    Name field.String
    Pets field.Slice[Pet]
  }{ /* initialized fields */}
  ```

### genconfig.Config
The `genconfig.Config` struct allows you to customize GORM CLI’s generation behavior on a package or file level.

- **Configurable Aspects:**
  - Output paths for generated files.
  - Whitelists or blacklists for interfaces and structs to include/exclude.
  - Custom field type mappings (e.g., map `sql.NullTime{}` to `field.Time{}`).
  - File-level vs package-level generation control.
  - Field name mappings to attach special helpers (e.g., JSON handling).

- **Example snippet:**
  ```go
  var _ = genconfig.Config{
    OutPath: "examples/output",
    FieldNameMap: map[string]any{
      "json": JSON{},
    },
    IncludeInterfaces: []any{"Query*"},
  }
  ```

- **Why Use It:** Tailor the generated code to fit your project needs, custom types, and workflows without manual code changes.

---

## How These Concepts Fit Together

Here’s how a typical flow utilizes these core concepts to deliver powerful type-safe code:

1. **Define your Go models.**
2. **Write Query Interfaces** with SQL templates expressing your app’s queries.
3. **Optionally provide `genconfig.Config`** to customize generation.
4. **Run GORM CLI** to generate:
    - Query API implementations from interfaces.
    - Field helpers from models.
5. **Use generated typed helpers and query APIs** in your app code with confidence in compile-time safety.

---

### Visual: Relationships Between Core Concepts

```mermaid
graph TD
  A[User's Go Models (structs)] -->|Generate| B[Field Helpers]
  C[Query Interfaces w/ SQL Templates] -->|Generate| D[Type-safe Query APIs]
  E[genconfig.Config] -->|Customizes| B
  E -->|Customizes| D
  B -->|Used in| F[Query APIs and Association Operations]
  D -->|Provides| F
```

---

## Practical Tips & Common Pitfalls

- **Always comment your query interface methods with correct SQL templates.** Omitting or misformatting these comments means no query code is generated.
- **Keep models and interfaces in sync.** Field helper generation depends on your current Go structs.
- **Use `genconfig.Config` wisely** to exclude deprecated interfaces or map custom types for better generation.
- **Be mindful of associations**: understand whether your relation is `has one`, `has many`, `belongs to`, or `many2many` to use association operations properly.
- **Avoid raw manual query building** if you want to leverage GORM CLI’s full type safety and clean abstractions.

---

## Summary

Mastering these terms equips you with the vocabulary and understanding to effectively harness GORM CLI:
- Write robust query interfaces backed by type-safe generated code.
- Use rich SQL templates for dynamic queries.
- Leverage generated field helpers to build queries and manage associations.
- Customize generation with `genconfig.Config` to fit your project’s unique needs.

Explore other documentation pages to see these concepts applied in practice:
- [Feature Summary](./feature-overview) for capabilities overview
- [Quickstart Workflow](./quickstart-workflow) to get hands-on tips
- [Using Model-Driven Field Helpers](./using-field-helpers) for usage examples
- [Customizing Generation](./generation-config) to dive deep into `genconfig.Config`

---

Ready to deepen your understanding? Let’s move on to see these key terms in action in the rest of the GORM CLI documentation.

---

## Additional Resources

- **Generated User helper example:** See the [user.go model and generated code examples](./examples/models/user.go) demonstrating how model-driven generation creates helpers.
- **Template-based queries example:** Explore Query interfaces with templated SQL in [examples/query.go](./examples/query.go).
- **Configuration customization:** Review `[examples/filters/twolevel/config.go]` and `[examples/filters/pattern/config.go]` for real-world `genconfig.Config` usage.

---

## Troubleshooting

<AccordionGroup title="Common Issues Relating to Core Concepts">
<Accordion title="Why am I not seeing generated query methods even after defining an interface?">
Ensure your interface methods have SQL templates in the comments. Without these, GORM CLI cannot generate implementations.
Also, check `genconfig.Config` to confirm that your interfaces aren’t excluded.
</Accordion>
<Accordion title="Field helpers are missing or incomplete after generation">
Verify your Go model structs are correctly defined and accessible to the generator. Confirm no build errors prevent parsing. Also, check for custom type mappings in `genconfig.Config` if you expect special handling.
</Accordion>
<Accordion title="How to customize generation only for specific models or interfaces?">
Use `genconfig.Config` fields like `IncludeInterfaces`, `ExcludeInterfaces`, `IncludeStructs`, and `ExcludeStructs` with patterns or literal types to control generation scope.
</Accordion>
</AccordionGroup>

---

For any issues beyond these, refer to the [Troubleshooting Common Issues](../../getting-started/troubleshooting-faq/common-issues) page or open an issue on the [GORM CLI GitHub repository](https://github.com/go-gorm/cli).

---

*End of Core Concepts & Terminology*