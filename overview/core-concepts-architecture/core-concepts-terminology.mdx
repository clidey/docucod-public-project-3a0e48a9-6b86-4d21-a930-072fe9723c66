---
title: "Core Concepts & Terminology"
description: "Breaks down the fundamental concepts—such as query APIs, field helpers, associations, templates, and configuration. Provides succinct definitions and links these ideas to how they manifest in generated code and workflow."
---

# Core Concepts & Terminology

Unlock the foundational building blocks that power GORM CLI’s powerful code generation capabilities. This guide breaks down essential concepts such as query APIs, field helpers, associations, templates, and configuration—providing clear definitions linked directly to how they manifest in your generated code and workflow.

---

## Understanding Query APIs

### What Are Query APIs?
Query APIs are the type-safe, interface-driven methods generated from your Go interface definitions annotated with SQL templates. They enable you to execute database operations with compile-time safety and fluent syntax, turning interface method declarations into concrete, expressive query functions.

### User Intent: What You Achieve
- Write clean, descriptive interfaces with SQL snippets.
- Get generated methods that return strongly typed results.
- Enjoy seamless context management—if a context parameter is omitted, it’s automatically injected.

### How They Show Up in Code
For example, when defining an interface method with a SQL comment:

```go
// SELECT * FROM @@table WHERE id=@id
GetByID(id int) (T, error)
```

GORM CLI generates a method:

```go
user, err := generated.Query[User](db).GetByID(ctx, 123)
```

This method runs a type-safe, parameter-bound query fetching a single user by ID.

---

## Exploring Field Helpers

### What Are Field Helpers?
Field helpers are generated helper structs mapped to your model’s individual fields. They abstract common filtering and update operations with fluent, discoverable APIs based on your model’s schema, ensuring type safety and reducing repetitive code.

### What You Can Do With Field Helpers
- Compose filters like `.Eq()`, `.Like()`, `.Between()` easily for queries.
- Construct update modifiers like `.Set()`, `.Incr()`, or even `.SetExpr()`.
- Perform association operations such as `Create()`, `Update()`, `Unlink()`, and `Delete()` directly on related models.

### Real Example
Given the `User` model with fields like `Name` and `Age`:

```go
// Filter users with age > 18
users, err := gorm.G[User](db).Where(generated.User.Age.Gt(18)).Find(ctx)

// Update user’s name
err := gorm.G[User](db).
  Where(generated.User.ID.Eq(1)).
  Set(generated.User.Name.Set("Alice")).
  Update(ctx)
```

These helpers empower you with concise and safe query building and updates.

---

## Associations: Linking Models with Confidence

### Association Types in GORM CLI
The generator recognizes and creates helpers tailored to your model’s associations:

- **Belongs To:** Reference to a parent (e.g., `User` belongs to `Company`).
- **Has One / Has Many:** Child relationships (e.g., `User` has many `Pets`).
- **Many to Many:** Complex relations via join tables (e.g., `User` speaks many `Languages`).
- **Polymorphic Associations:** Generic relations where associated entity varies (e.g., `Toy` polymorphically owned).

### Supported Operations
- Create/Batch Create associated records.
- Update associated data conditionally.
- Unlink relationships without deleting records.
- Delete associated records (with filtering support).

### Example Scenario
Creating a user with associated pets and languages:

```go
gorm.G[User](db).
  Set(
    generated.User.Name.Set("polyglot"),
    generated.User.Pets.Create(generated.Pet.Name.Set("Fido")),
    generated.User.Languages.CreateInBatch([]models.Language{{Code: "EN"}, {Code: "FR"}}),
  ).
  Create(ctx)
```

This creates the `User` and also inserts the related pet and language links with full compile-time guarantees.

---

## Templates: The Heart of Custom SQL

### What is Template-Based SQL?
Inside your query interface, you embed SQL queries using simple templates enhanced with directives that dynamically adapt SQL based on input parameters.

### Core DSL Constructs
| Directive  | Purpose                              | Example                                         |
|------------|------------------------------------|------------------------------------------------|
| `@@table`  | Replaced with the model’s table name | `SELECT * FROM @@table WHERE id=@id`            |
| `@@column` | Dynamic column binding              | `WHERE @@column=@value`                          |
| `@param`   | Binds Go parameters                 | `WHERE name=@user.Name`                          |
| `{{where}}`| Conditional WHERE clause            | `{{where}} age > 18 {{end}}`                     |
| `{{set}}`  | Dynamic UPDATE SET clause           | `{{set}} name=@name {{end}}`                      |
| `{{if}}`   | Conditional SQL fragments           | `{{if age > 0}} AND age=@age {{end}}`            |
| `{{for}}`  | Loops over collections              | `{{for _, tag := range tags}}...{{end}}`         |

### Why Use It?
- Flexibly express complex queries without losing type safety.
- Automatically bind parameters with zero boilerplate.
- Compose conditional logic naturally inside SQL comments.

### Example

```go
// Query interface method snippet:
//
// SELECT * FROM @@table
// {{where}}
//   {{if user.ID > 0}}
//     WHERE id=@user.ID
//   {{else if user.Name != ""}}
//     WHERE name=@user.Name
//   {{end}}
// {{end}}
QueryWith(user models.User) (T, error)
```

This compiles into an implementation that selects conditionally based on user input.

---

## GenConfig: Customizing Generation

### Purpose
`genconfig.Config` is an optional, powerful way to tailor code generation across packages or files. You control output paths, filtering interfaces and structs by patterns or types, and adjust field mappings.

### Typical Use Cases
- Restrict generation to interfaces matching `Query*` patterns.
- Override output directories on a per-package basis.
- Map Go types or struct tags (`gen:"json"`) to specific custom field helpers.
- Enable file-level configurations for granular control.

### Example

```go
var _ = genconfig.Config{
  OutPath: "examples/output",
  IncludeInterfaces: []any{"Query*"},
  FieldTypeMap: map[any]any{
    sql.NullTime{}: field.Time{},
  },
  FieldNameMap: map[string]any{
    "json": JSON{},
  },
}
```

This configuration limits generated interfaces to those starting with `Query`, uses a custom time field, and maps `gen:"json"` tags to the `JSON` field helper.

---

## Mapping Concepts to Your Workflow

The synergy between these core concepts empowers your workflow with GORM CLI:

1. **Define your data models** with GORM conventions.
2. **Create query interfaces** annotated with clear SQL templates.
3. **Optionally customize generation** using `genconfig.Config`.
4. **Run the CLI generator** to produce code containing field helpers and type-safe APIs.
5. **Write business logic** using generated methods, confidently knowing errors will catch at compile time.
6. **Use association helpers** to manage relationships effectively, reducing boilerplate and runtime errors.

---

## Quick Reference: Concepts to Generated Code

| Concept            | What It Produces                  | Usage Example                                  |
|--------------------|---------------------------------|------------------------------------------------|
| Query API          | Interface-based query methods    | `generated.Query[User](db).GetByID(ctx, 1)`   |
| Field Helper       | Typed field predicates & setters| `generated.User.Age.Gt(18)`                     |
| Associations       | Struct or slice field helpers   | `generated.User.Pets.Create(...)`              |
| Template SQL DSL   | Dynamic SQL embedded in comments| Conditional filtering and updates               |
| GenConfig          | Package/file generation filters | Control output and type mappings                |

---

## Practical Tips

- Use simple, readable SQL templates in your interfaces first.
- Leverage association helpers to manage related data without writing manual joins.
- Apply `genconfig.Config` to align field helpers with your domain types.
- Remember: context is auto-injected—omit `ctx` for simpler method signatures.

## Common Pitfalls to Avoid

- Avoid unexported fields if you expect field helpers generated.
- Template syntax errors can cause generation failures—test queries incrementally.
- Omitting return values or incorrect return signatures in interfaces will cause generation errors.
- Mismatched association declarations can generate incomplete or incorrect helpers.

---

## See Also

- [What is GORM CLI?](../product-intro/what-is-gorm-cli) — Introduction
- [Architecture Overview](../core-concepts-architecture/architecture-overview) — High-level workflow
- [Key Features at a Glance](../feature-spotlight/feature-highlights) — Capabilities summary
- [Writing Interfaces & Models](../../getting-started/first-run-generation/configuration-basics) — Practical setup
- [Customizing Code Generation](../../getting-started/configuration-validation/customizing-generation) — Deep config tuning

---

With this grounding in GORM CLI’s core concepts and terminology, you are equipped to efficiently design models, write expressive queries, and confidently harness automated code generation for your Go projects.