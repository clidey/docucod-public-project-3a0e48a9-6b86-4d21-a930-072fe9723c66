---
title: "Supported Features at a Glance"
description: "Quickly overview GORM CLI’s major capabilities: type-safe query API generation from interfaces, model-driven field helper generation, deep association support, JSON/custom field mapping, and template-based query authoring. Pinpoint which features solve your specific pain points."
---

# Supported Features at a Glance

Discover the core capabilities of GORM CLI that transform your Go projects with type-safe, interface-driven SQL generation and powerful model-driven field helpers. This page offers a rapid overview to help you identify which features align with your database development challenges and streamline your workflows.

---

## Embrace Type-Safety and Code Generation
GORM CLI uniquely bridges your Go interfaces and GORM models into a fluent, strongly typed API that eliminates runtime SQL errors and boosts developer productivity.

### What You Gain:
- **Compile-time Safety**: Generate fully typed query methods from Go interfaces with embedded SQL templates, catching errors before runtime.
- **Seamless Model Integration**: Field helpers derived from your model structs grant precise, expressive filters, updates, and relationship manipulations.
- **Deep Association Handling**: Manage complex relationships (has one, has many, belongs to, many2many, polymorphic) with clear, type-safe operations.
- **Powerful Template DSL**: Write expressive, conditional, and dynamic SQL directly in Go interface comments to generate flexible queries effortlessly.
- **Custom Field Mapping**: Extend with JSON or custom field helpers to adapt complex data types and behaviors.

---

## Key Capabilities at a Glance

### 1. Interface-Driven Type-Safe Query APIs
Write Go interfaces with method comments containing SQL templates. GORM CLI produces concrete implementations with:
- Typed method signatures aligning with your queries.
- Automatic parameter binding via templating rules.
- Support for conditional clauses, iteration, and dynamic columns.

**Example Interface:**
```go
// SELECT * FROM @@table WHERE id=@id
GetByID(id int) (T, error)

// UPDATE @@table
// {{set}}
//   {{if user.Name != ""}} name=@user.Name, {{end}}
//   {{if user.Age > 0}} age=@user.Age {{end}}
// {{end}}
// WHERE id=@id
UpdateUser(user User, id int) error
```

### 2. Model-Driven Field Helpers
Generate attribute helpers from your models for clear, expressive predicates and updates:
- **Basic Fields**: Strongly typed helpers for ints, strings, bools, timestamps, and nullable types.
- **Common operations**: Equality, range, LIKE, NULL checks, arithmetic increments/decrements.

**Usage Example:**
```go
generated.User.Name.Like("%admin%")      // WHERE name LIKE '%admin%'
generated.User.Age.Between(18,65)          // WHERE age BETWEEN 18 AND 65
generated.User.Score.IsNull()               // WHERE score IS NULL
```

### 3. Association Management with Full Semantics
Handle GORM associations natively in generated code with operations:
- **Create**: Insert and link related records in one step.
- **Update**: Modify associated rows matching conditions.
- **Unlink**: Clear foreign keys or remove join links without deleting data.
- **Delete**: Remove associated entries or join records.
- **Batch Linking**: Efficiently create or link multiple related items.

**Example Use Cases:**
```go
// Create User and pet
gorm.G[User](db).
  Set(
    generated.User.Name.Set("alice"),
    generated.User.Pets.Create(generated.Pet.Name.Set("fido")),
  ).
  Create(ctx)

// Unlink pets named 'fido'
gorm.G[User](db).
  Where(generated.User.ID.Eq(1)).
  Set(generated.User.Pets.Where(generated.Pet.Name.Eq("fido")).Unlink()).
  Update(ctx)
```

### 4. Advanced JSON and Custom Field Support
Map custom field types (e.g., JSON) to specialized helpers that generate dialect-specific SQL for complex operations.
- Customize mappings via `genconfig.Config.FieldNameMap`.
- Use the generated helpers for expressive querying on JSON fields.

**JSON Field Example:**
```go
// JSON field helper usage generates correct SQL per DB dialect
generated.User.Profile.Equal("$.vip", true)
```

### 5. Configurable Code Generation
Fine-tune generation with package-level configurations:
- Include or exclude specific interfaces and structs by pattern or type.
- Customize output paths and per-file generation.
- Map model fields to specialized helpers.

**Example Configuration:**
```go
var _ = genconfig.Config{
  OutPath: "examples/output",
  IncludeInterfaces: []any{"Query*"},
  FieldNameMap: map[string]any{"json": JSON{}},
}
```

---

## Why These Features Matter to You

- **Prevent Runtime SQL Errors:** Compile-time checking and typed APIs vastly reduce bugs.
- **Write Less Boilerplate:** Eliminate repetitive query code with interface-driven generation.
- **Gain Fluent API Control:** Navigate and manipulate fields and relations fluidly using generated helpers.
- **Adapt to Complex Data:** Handle JSON and polymorphic relations seamlessly.
- **Integrate with Existing Projects:** Configurable generation fits naturally into Go/GORM workflows.

---

## Real-World Workflow
1. **Define Query Interfaces:** Annotate your Go interfaces with SQL templates for queries and updates.
2. **Write or Use Models:** Structure your models with standard Go structs, including relations.
3. **Configure Generation:** Optionally add `genconfig.Config` to control output and mappings.
4. **Run Generator:** Use the CLI to generate query implementations and field helpers.
5. **Use Generated Code:** Call type-safe methods and use smart field helpers in your application logic.

---

## Practical Tips & Common Pitfalls

- **Keep SQL Templates Clean:** Use the provided template DSL syntax for clean, readable queries.
- **Map Complex Fields:** Use field mapping for JSON or unusual types to unlock expressive helpers.
- **Filter Carefully:** Use inclusion/exclusion patterns to control code generation scope and reduce noise.
- **Understand Association Semantics:** Know what Unlink vs Delete mean for your relationships.
- **Use Contexts:** Generated methods include context for request-scoped DB operations.

---

## Next Steps
- Dive into detailed [Example Workflows & Feature Highlights](/overview/feature-overview/feature-examples-and-workflows) to see these features in action.
- Explore configuration options in [Customizing Generation with genconfig](/guides/advanced-patterns/customizing-generation).
- Learn how to write queries in the [Template DSL Guide](/guides/advanced-patterns/template-dsl-guide).

---

Harness the full power of GORM CLI by leveraging its comprehensive type-safe query generation and model-driven helpers to build robust, maintainable Go applications with confidence.


---

<AccordionGroup title="Supported Feature Details">
<Accordion title="Type-Safe Query API Generation">
GORM CLI generates strongly typed Go implementations from your Go interface methods decorated with SQL templates. This removes the guesswork and error-prone nature of crafting queries manually.

Key aspects include parameter binding, conditional SQL, and dynamic selection, all integrated seamlessly with your code.

Refer to `examples/query.go` for real interface definitions that drive code generation.
</Accordion>
<Accordion title="Model-Driven Field Helpers">
From your Go structs representing database models, GORM CLI creates field helpers for intuitive predicate building and updates.

These helpers cover basic field types, nullable types, and timestamps.

They allow fluent, readable filters like `generated.User.Name.Eq("alice")` and updater expressions like `generated.User.Age.Incr(1)`.

This makes querying and updates more expressive and less error prone than raw SQL strings.
</Accordion>
<Accordion title="Associations and Relationship Management">
The generator produces helpers to manipulate associations in typesafe ways—creating, updating, unlinking, or deleting linked rows.

Operations respect the semantics of the underlying relation types. Developers get clear, consistent builder methods to compose complex operations.
</Accordion>
<Accordion title="JSON and Custom Field Support">
Customize how fields with complex types (like JSON) are handled by providing field mappings in `genconfig.Config`.

The generator produces helper methods that generate dialect-specific SQL to safely query these fields.

This ensures your application code remains consistent and database agnostic.
</Accordion>
<Accordion title="Template-Based SQL DSL">
The embedded template DSL supports conditionals (`{{if}}`), iterations (`{{for}}`), and helper directives like `@@table` and `@@column` to compose advanced queries.

This blend of Go templating with SQL empowers you to write flexible, reusable query logic compactly.
</Accordion>
</AccordionGroup>
