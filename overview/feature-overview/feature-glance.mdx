---
title: "Feature Quick View"
description: "A concise rundown of the essential capabilities: generating type-safe query APIs from interfaces with SQL templates, model-driven field helpers for filters and associations, support for complex association operations (create, update, unlink, delete), and CLI-driven configuration. Includes pointers to deeper docs and practical examples."
---

# Feature Quick View

Unlock the full power of GORM CLI by leveraging its essential features designed to generate robust, type-safe data access code for Go projects using GORM. This concise overview introduces the core capabilities you can expect, helping you quickly understand what the tool does and how these features benefit your development workflow.

---

## Essential Capabilities

### 1. Type-Safe Query APIs from Interfaces with SQL Templates

Write Go interfaces enriched with SQL template comments, and GORM CLI generates concrete, type-safe query methods. This approach ensures compile-time correctness for your database queries, reducing runtime errors and improving code discoverability.

- **Benefit:** Express complex SQL queries naturally while keeping type safety.
- **Example:**

  ```go
  type Query[T any] interface {
    // SELECT * FROM @@table WHERE id=@id
    GetByID(id int) (T, error)
  }
  ```

- Generated code lets you call `Query[User](db).GetByID(ctx, 123)` with confidence.


### 2. Model-Driven Field Helpers for Filters, Updates, and Associations

From your existing model structs, GORM CLI generates powerful field helpers that simplify building dynamic filters and updates with a fluent, strongly typed API.

- Support for common data types like ints, strings, `time.Time`, and SQL types with automatic wrapper mapping.
- Strongly typed association helpers to manage relationships cleanly.

- **Example:**

  ```go
  generated.User.Name.Like("%jinzhu%")  // name LIKE '%jinzhu%'
  gorm.G[User](db).Where(generated.User.Age.Gt(18)).Find(ctx)
  ```


### 3. Powerful Support for Complex Association Operations

Easily perform create, update, unlink, and delete operations on related records using generated association helpers, respecting GORM's association semantics.

- Operations include `Create()`, `CreateInBatch()`, `Update()`, `Unlink()`, and `Delete()`.
- Target has-one, has-many, belongs-to, and many-to-many relations with precise control.

- **Real-World Scenario:**

  Create a user along with multiple associated pets and languages seamlessly:

  ```go
  gorm.G[User](db).
    Set(
      generated.User.Name.Set("polyglot"),
      generated.User.Pets.CreateInBatch([]models.Pet{{Name: "fido"}, {Name: "rex"}}),
      generated.User.Languages.CreateInBatch([]models.Language{{Code: "EN"}, {Code: "FR"}}),
    ).
    Create(ctx)
  ```


### 4. CLI-Driven Configuration for Tailored Code Generation

GORM CLIâ€™s configuration system lets you customize output locations, file-level generation, selective inclusion/exclusion of interfaces and structs, and custom field helper mappings without any complex setup.

- Configure per package using `genconfig.Config` literals inside your Go source files.
- Support for shell-pattern-based whitelists and blacklists for interfaces and structs.
- Example config snippet:

  ```go
  var _ = genconfig.Config{
    OutPath: "examples/output",
    IncludeInterfaces: []any{"Query*"},
    FieldTypeMap: map[any]any{sql.NullTime{}: field.Time{}},
  }
  ```


## How These Features Work Together

By combining interface-driven query generation with model-based field helpers and flexible configuration, GORM CLI streamlines database access code creation, reducing boilerplate and improving reliability.

```mermaid
flowchart TD
  User["Developer writes interfaces & models"] --> CLI["GORM CLI: Command Line Tool"]
  CLI -->|Processes| Gen["Internal Generator"]
  Gen -->|Generates| Code["Type-safe Query API & Field Helpers"]
  Code -->|Used by| App["Your Application"]

  subgraph "Config & Filters"
    GenConfig["genconfig.Config declarations"]
  end

  GenConfig --> Gen

  classDef process fill:#cde6f7,stroke:#007ACC,stroke-width:2px,color:#004A75;
  class CLI,Gen process;
  class User,App fill:#e5f5e0,stroke:#4caf50,stroke-width:2px,color:#2e7d32;
  class GenConfig fill:#fff4e5,stroke:#f57c00,stroke-width:2px,color:#e65100;
```


## Real-World Use Cases

- **Safe API Creation:** Automatically generate query interfaces corresponding exactly to your SQL business logic.
- **Simplify Filtering Logic:** Use generated field helpers to build expressive WHERE clauses without manual SQL.
- **Manage Complex Relationships:** Leverage association helpers for multi-entity create/update workflows with clear semantics.
- **Custom Output Practices:** Organize generation output by package or file, customize helper types, and control generated scope via config.


## Tips for Success

- Use SQL template directives (`@@table`, `@param`, `{{where}}`, etc.) to craft dynamic, safe SQL.
- Declare fine-tuned `genconfig.Config` in the same package for tailored generation behavior.
- Familiarize yourself with generated helper APIs to accelerate filter and association manipulations.


## Getting Started with These Features

1. Define your query interfaces with embedded SQL templates.
2. Annotate or configure your models with `genconfig.Config` as needed.
3. Run the CLI generation command with input and output paths:

   ```bash
   gorm gen -i ./examples -o ./generated
   ```

4. Use the generated code in your application, enjoying type safety and API discoverability.


---

## Learn More

- Explore deeper architectural insights on the [System Architecture Overview](/overview/architecture-core-concepts/system-architecture).
- Understand fundamental concepts in [Core Concepts & Terminology](/overview/architecture-core-concepts/core-concepts-terminology).
- Discover configuration and usage workflows in [Getting Started: Code Generation](/guides/core-workflows/getting-started-generation).
- Master field helpers and associations in the [Best Practices & Advanced Patterns] guides.


<Tip>
Start with simple interface and model definitions, then incrementally add SQL templates and configuration for customized powerful code generation.
</Tip>

---