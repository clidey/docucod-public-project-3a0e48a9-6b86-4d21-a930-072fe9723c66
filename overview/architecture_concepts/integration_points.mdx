---
title: "Integration with GORM & Go"
description: "Understand how GORM CLI fits effortlessly into existing Go and GORM projects. Explore where generated code connects to your application, as well as how to invoke the tool from the CLI and incorporate custom configs for your models."
---

# Integration with GORM & Go

Effortlessly incorporate GORM CLI into your existing Go and GORM projects. This page guides you through how the generated code fits within your application, how to invoke the GORM CLI tool from the command line, and how to fine-tune code generation using custom configurations that adapt to your models and project structure.

---

## Why Integration Matters

Imagine you have a growing Go application that uses GORM for database operations. You want to add type-safe, template-driven query APIs and model field helpers without disrupting your current workflow. GORM CLI is designed to plug directly into your existing GORM setup — so instead of reinventing the wheel, you extend your current data access layers with minimal hassle.

This seamless integration accelerates development by eliminating error-prone manual SQL crafting and offers fluent, reliable, and idiomatic Go APIs generated directly from your codebase.

---

## How the Generated Code Connects to Your App

At its core, GORM CLI generates two valuable and complementary code artifacts:

- **Interface‑Driven Type-Safe Query APIs:** These are Go interface implementations automatically generated from your defined query interfaces (with embedded SQL templates in comments). They translate your interface method calls into precise, efficient SQL queries.

- **Model-Driven Field Helpers:** These provide strongly typed helpers for your model struct fields, enabling expressive filter predicates, update setters, and association handlers.

Together, these generated APIs integrate smoothly with `gorm.io/gorm`'s `*gorm.DB` usage, letting you write expressive, type-safe, and compile-time checked queries.

### Typical Usage Example

```go
// query_interfaces.go (user-defined interface with SQL templates)
type Query[T any] interface {
  // SELECT * FROM @@table WHERE id=@id
  GetByID(id int) (T, error)
}

// generated code usage
user, err := generated.Query[User](db).GetByID(ctx, 123)
```

Here, you simply call the generated API as you would any GORM query, with type safety and template-driven SQL behind the scenes.

---

## Invoking the Generator from CLI

To apply GORM CLI within your project, you run the code generator via the command line.

### Basic CLI Usage

```bash
gorm gen -i ./path/to/your/models -o ./path/to/generated
```

- `-i`: Input directory or file containing your Go models and query interfaces.
- `-o`: Output directory for generated Go files.

### What Happens?

- The tool parses the input directory.
- Discovers your Go models and interfaces.
- Generates type-safe query API implementations.
- Produces field helper structs and methods matching your models.

### Success Criteria

- Generated files appear under the output path with warnings for skipped or excluded items.
- Interfaces with SQL template comments are converted to concrete implementations.
- Generated models expose field helpers for predicates and associations.

<Tip>
You don’t need explicit configuration files to run the generator. Simply ensure your models and interfaces are in the targeted directory.
</Tip>


## Customizing Generation with genconfig.Config

While the CLI works out-of-the-box, you may need more control to fit complex projects or conventions. The configuration struct `genconfig.Config` lets you tailor generation behavior on a per-package or per-file basis by declaring a package-level variable.

### What Can You Customize?

- **Output Paths:** Direct generated code to custom directories.
- **Inclusion/Exclusion Filters:** Whitelist or blacklist interfaces and structs by name or patterns.
- **Field Mapping:** Map Go types or struct tags to custom field helper types.
- **File Level Scope:** Generate configuration just for a single file instead of whole packages.

### Example: Basic Config with Inclusion Filters

```go
package examples

import "gorm.io/cli/gorm/genconfig"

var _ = genconfig.Config{
  OutPath: "examples/output",
  IncludeInterfaces: []any{"Query*"},
  IncludeStructs:    []any{"User", "Account*"},
}
```

This configuration directs the generator to include only interfaces with names matching `Query*` and structs named `User` or starting with `Account`.

### How to Apply Your Config

Place your `genconfig.Config` variable in any Go file within the package or directory you want to customize. The generator automatically detects and applies these settings during the run.

<Tip>
Complex projects benefit from defining multiple `genconfig.Config` files spread across directories to manage granularity in code generation.
</Tip>

---

## Real-World Scenario: Combining CLI and Configuration

Suppose your project has legacy interfaces and models you do not want to generate for yet. Use the config filters to skip these while running the generator globally:

```go
package user

import "gorm.io/cli/gorm/genconfig"

var _ = genconfig.Config{
  ExcludeInterfaces: []any{"*Deprecated*"},
  ExcludeStructs:    []any{"*DTO"},
}
```

Run the generator:

```bash
gorm gen -i ./user -o ./user/generated
```

The generator will only process non-excluded items, safely integrating with your existing codebase.

---

## Best Practices and Tips

- **Start Simple:** Begin without configs to see auto-discovery in action, then add filtered configs as your project grows.
- **Keep Models and Queries Close:** Place query interfaces alongside models or within the same directory tree to simplify code discovery.
- **Review Generated Code:** Inspect the output to verify generated interfaces and helpers meet expectations.
- **Leverage Template DSL:** Use SQL templates in interface comments to write powerful custom queries benefiting from type safety.
- **Use Field Mapping for Custom Types:** Configure `FieldTypeMap` and `FieldNameMap` to extend helpers to custom Go types or tagged fields like JSON.

<Warning>
Invalid or conflicting configs may cause generation to silently skip models or interfaces. Always validate config patterns and inclusion lists.
</Warning>

---

## Troubleshooting Common Integration Issues

<AccordionGroup title="Common Issues and Solutions">
<Accordion title="Generated Code Not Appearing">
- Confirm the input directory contains Go files with interfaces or structs.
- Check for existing `genconfig.Config` that may exclude all items.
- Ensure no previous generated files prevent re-generation by inspection of generated file headers.
- Verify you are running the CLI with correct `-i` and `-o` paths.
</Accordion>
<Accordion title="Interface Methods Without Implementations">
- Make sure your interface methods have SQL templates documented in comments.
- Check method signatures comply with requirements (returning error or (T, error)).
- SQL templates should be valid and use the template DSL correctly.
</Accordion>
<Accordion title="Field Helpers Missing or Incorrect">
- Verify your model struct fields are exported.
- Use `gen:"tag"` annotations for custom field mappings.
- Confirm that your data types implement allowed interfaces like `driver.Valuer` or `sql.Scanner` if needed for custom types.
</Accordion>
<Accordion title="Config Not Being Applied">
- Check that your config variable is declared at package level.
- Validate that config files reside in the correct package/directory for scope.
- Confirm config field lists use exact or pattern matching as expected.
</Accordion>
</AccordionGroup>

---

## How This Page Fits in the Documentation

This guide forms a critical integration touchpoint that bridges the foundational understanding of GORM CLI (interfaces, models, templating) and the quick start/usage stages. It complements higher-level architecture diagrams and core concepts by focusing on actionable user workflows to bring GORM CLI into your Go projects with confidence.

---

## Next Steps

- Define your query interfaces with embedded SQL templates and models as shown here: [Defining Models and Query Interfaces](/getting-started/first-code-generation/defining-models-and-interfaces).
- Run the generator smoothly with [Running the Code Generator](/getting-started/first-code-generation/running-gorm-cli-gen).
- Learn how to leverage generated APIs expertly in [Validation and Quick Usage](/getting-started/first-code-generation/validation-and-quick-usage).


---

## Additional Resources

- [What is GORM CLI?](/overview/introduction_value/what_is_gorm_cli) — Understand core value.
- [Product Value and Use Cases](/overview/introduction_value/value_prop_use_cases) — Real development scenarios.
- [Core Concepts & Terminology](/overview/architecture_concepts/core_concepts) — Deep dive into query APIs and field helpers.
- [System Overview & Data Flow](/overview/architecture_concepts/system_overview_diagram) — Visual architecture.


<Source url="https://github.com/go-gorm/cli" paths={[{"path": "internal/gen/generator.go", "range": "1-462"}]} />
