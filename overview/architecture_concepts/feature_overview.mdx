---
title: "Key Features at a Glance"
description: "Quickly scan GORM CLI’s core capabilities—type-safe query generation, model field helpers, association handling, flexible configuration—so you can decide which features to explore first. Each feature connects to real-world developer needs."
---

# Key Features at a Glance

Discover the essential capabilities of GORM CLI, a powerful Go code generation tool designed to enrich your GORM projects with type-safe, fluent APIs. This page provides a rapid overview of core features such as type-safe query generation, model-driven field helpers, association management, and flexible configuration options—each crafted to address practical developer needs and common challenges.

---

## Why Explore These Features?

Imagine writing database queries in Go without worrying about runtime SQL errors or tedious manual mapping. GORM CLI empowers you to produce clean, maintainable, and error-resistant data access layers by generating code that precisely mirrors your model and query designs. This page helps you quickly identify which features best align with your project goals, so you can dive into detailed documentation or start using them right away.

---

## Core Features Overview

### 1. Type-Safe Query APIs from Go Interfaces

Define your queries using standard Go interfaces annotated with SQL templates. GORM CLI generates concrete, type-safe implementations that enforce correctness at compile time.

- **Benefit:** Eliminate SQL syntax mistakes and mismatched parameters before running your application.
- **Example:** Define a `GetByID(id int)` method with SQL in comments. Generated code safely queries by ID, returning the exact model type.

```go
// Your interface
type Query[T any] interface {
  // SELECT * FROM @@table WHERE id=@id
  GetByID(id int) (T, error)
}

// Usage
user, err := generated.Query[User](db).GetByID(ctx, 123)
```

### 2. Model-Driven Field Helpers

From your GORM model structs, generate helpers for fields that streamline filtering, updating, and ordering with intuitive, fluent APIs.

- **Benefit:** Compose complex query filters with strongly typed predicates and setter expressions.
- **Example:** Use generated predicates like `generated.User.Name.Like("%john%")` for precise conditions.

```go
gorm.G[User](db).
  Where(generated.User.Age.Between(18, 65)).
  Set(generated.User.Status.Set("active"))
  .Update(ctx)
```

### 3. Comprehensive Association Handling

GORM CLI understands your model relationships (has one, has many, belongs to, many-to-many) and generates helpers to perform association operations safely.

- **Supported Operations:** Create, batch create, update, unlink (remove links without deleting), and delete associated data.
- **Benefit:** Manage complex linked data effectively without error-prone manual joins or foreign key handling.

```go
// Create user with pets
gorm.G[User](db).
  Set(
    generated.User.Name.Set("alice"),
    generated.User.Pets.Create(generated.Pet.Name.Set("fido")),
  ).
  Create(ctx)
```

### 4. Flexible Configuration with `genconfig.Config`

Customize generation behavior with an optional config struct scoped at the package level.

- Set output paths.
- Include or exclude particular interfaces or structs.
- Map Go types or field tags to custom field helpers.

- **Benefit:** Fine-tune generated code to fit your codebase conventions and extend helper functionality.

```go
var _ = genconfig.Config{
  OutPath: "generated/",
  IncludeInterfaces: []any{"Query*"},
  FieldNameMap: map[string]any{"json": JSON{}},
}
```

---

## Real-World Developer Scenarios

- **Building a Robust Data Layer:** Write query interfaces once, generate safe APIs, and avoid repetitive boilerplate.
- **Filtering and Updates:** Use generated field helpers to write expressive criteria and update commands without errors.
- **Managing Relationships:** Create or unlink related records easily while preserving referential integrity.
- **Evolving Systems:** Modify model annotations or SQL templates, regenerate code, and maintain consistency.

---

## Common Usage Patterns

<AccordionGroup title="Type-Safe Query API Highlights">
<Accordion title="Defining Queries with SQL Templates">
Write SQL in comments on interface methods using a concise DSL. Bind parameters automatically and get type-safe implementations.
</Accordion>
<Accordion title="Context-Aware Method Signatures">
The generator automatically injects `context.Context` parameters if absent, fostering best practices in Go applications.
</Accordion>
<Accordion title="Return Types">
Methods return either error alone or (result, error), with strong typing matching your model structs.
</Accordion>
</AccordionGroup>

<AccordionGroup title="Field Helpers & Fluent API">
<Accordion title="Filters and Predicates">
Predicate methods like `.Eq()`, `.Like()`, `.Between()` allow for composing queries clearly and safely.
</Accordion>
<Accordion title="Updates">
Helpers support `Set()`, increment operations (e.g., `.Incr(1)`), and complex expressions for updates.
</Accordion>
<Accordion title="Ordering and Null Checks">
Field helpers also provide expressive syntax for ordering and handling null values in queries.
</Accordion>
</AccordionGroup>

<AccordionGroup title="Associations Management">
<Accordion title="Create and Link Related Data">
Use `.Create()` and `.CreateInBatch()` helpers to add related records during parent operations.
</Accordion>
<Accordion title="Update Associated Rows">
Helpers allow updates filtered by predicates on associated entities.
</Accordion>
<Accordion title="Unlink and Delete with Precision">
Clear relationships or delete associated rows selectively while respecting foreign key constraints.
</Accordion>
</AccordionGroup>

---

## Practical Tips

- Start by defining interfaces and models in the same package or directory to make generation seamless.
- Use SQL template directives like `@@table` and `@@column` for dynamic, reusable queries.
- Customize generation using `genconfig.Config` to fit project-specific requirements.
- Always maintain consistent model tagging to generate the most accurate and effective field helpers.

---

## Challenges and Troubleshooting

<AccordionGroup title="Common Pitfalls and Solutions">
<Accordion title="Missing Context Parameter in Methods">
The generator adds `context.Context` automatically; if you experience signature mismatches, ensure you don’t define the parameter manually in incompatible ways.
</Accordion>
<Accordion title="Interface or Struct Not Being Generated">
Check your `IncludeInterfaces` and `ExcludeInterfaces` filters in any `genconfig.Config` in your package or its parents.
</Accordion>
<Accordion title="Incorrect Field Helper Types">
Make sure your field tags and custom `FieldTypeMap` or `FieldNameMap` mappings are correctly configured and recognized.
</Accordion>
</AccordionGroup>

---

## Getting Started Preview

To begin exploring these features in depth, head to the [Defining Models and Query Interfaces](/getting-started/first-code-generation/defining-models-and-interfaces) page, then generate code with the [Running the Code Generator](/getting-started/first-code-generation/running-gorm-cli-gen) guide. For association handling details, see [Working with Associations: Patterns & Best Practices](/guides/advanced-use-cases/associations-best-practices).


---

## References and Related Documentation

- [What is GORM CLI?](/overview/introduction_value/what_is_gorm_cli) — foundational overview
- [Product Value and Use Cases](/overview/introduction_value/value_prop_use_cases) — understand the bigger picture
- [System Overview & Data Flow](/overview/architecture_concepts/system_overview_diagram) — see how these features fit into the architecture
- [Customizing Code Generation with genconfig](/guides/advanced-use-cases/customizing-generation) — extend and control generated code


---