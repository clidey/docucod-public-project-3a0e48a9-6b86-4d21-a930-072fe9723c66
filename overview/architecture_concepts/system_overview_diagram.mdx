---
title: "System Overview & Data Flow"
description: "Visualize how GORM CLI processes developer-written Go interfaces and models, creating generated code for query APIs and field helpers. See where input files, configs, and outputs fit into the workflow via a clear architecture (mermaid) diagram, illustrating integration with GORM."
---

# System Overview & Data Flow

Understand how the GORM CLI transforms your Go interfaces and model definitions into powerful, type-safe query APIs and model-driven helpers. This page visualizes the end-to-end workflow of the code generation process, detailing how input source files and configuration guide the output and highlighting the integration points with the GORM ORM library.

---

## Why This Matters

When you write interfaces and models in Go, GORM CLI automates creating robust, compile-time safe database query code. Knowing how your source code flows through the generator clarifies how to organize, configure, and troubleshoot your setup effectively.

This system overview illuminates what happens under the hood — but explained from the user’s perspective — showing you precisely how your inputs become generated APIs that you consume in your application.

---

## Inputs: Interfaces, Models, and Generation Config

Your workflow begins with:

- **Go interfaces**: Define methods with SQL templates in comments, describing how you want to query your database.
- **Go model structs**: Define your data models, including relationships and field metadata.
- **Optional genconfig.Config packages**: Customize generation behavior such as input filtering, output paths, and custom field mappings.

Together, these inputs provide the raw material for GORM CLI to create tailored code that matches your application's domain and data needs.

### Real Example
```go
// Interface example
// SELECT * FROM @@table WHERE id=@id
GetByID(id int) (T, error)

// Model example
type User struct {
    ID    uint
    Name  string
    Age   int
}

// Config example
var _ = genconfig.Config{
    OutPath: "generated",
    IncludeInterfaces: []any{"Query*"},
    ExcludeStructs: []any{"S3"},
}
```

These inputs live in your source folders, ready for generation.

---

## The Processing Steps

GORM CLI runs a clear, sequential pipeline to turn your inputs into usable Go code:

1. **Scan Inputs:** GORM CLI scans your specified input directory for interfaces, models, and configuration packages.
2. **Apply Filters:** Generation respects include/exclude patterns defined in configs, filtering interfaces and structs.
3. **Parse SQL Templates:** Interface methods with inline SQL templates are parsed for placeholders, conditional parts, and parameters.
4. **Analyze Models:** Model structs are inspected for fields, types, and GORM association tags.
5. **Generate Query APIs:** Implementations of interface methods are created with concrete, type-safe code invoking GORM.
6. **Generate Field Helpers:** Structured helpers for filters, updates, and associations are generated from models.
7. **Write Output:** Generated Go files are written to the configured output directory, preserving package structure.

---

## Outputs: Generated Code

The result is a set of Go source files you can consume directly in your projects:

- **Query API implementations:** Type-safe interfaces and structs for running your SQL template methods.
- **Field helpers:** Fluent, strongly typed helpers to filter, update, and manage model fields and associations.

These outputs seamlessly blend with the existing GORM library, surfacing a fluent API that compiles your database access patterns and catches errors at build time rather than runtime.

## Example Usage of Generated Code
```go
// Using generated query
user, err := generated.Query[User](db).GetByID(ctx, 123)

// Using generated field helpers
users, err := gorm.G[User](db).Where(generated.User.Age.Gt(18)).Find(ctx)
```

---

## Integration Points with GORM

The generated code leans on GORM’s core:

- Uses `*gorm.DB` instances for database interaction.
- Provides compile-time safe wrappers that generate GORM clauses.
- Supports common GORM features such as associations and expression building.

This tight integration means your generated APIs feel native to GORM users and fit naturally within existing GORM-based applications.

---

## Architecture Diagram

The following Mermaid diagram visually describes this data flow and architecture, following the path from your source files through GORM CLI processing to the generated output consumed by your app:

```mermaid
flowchart TD

    subgraph Inputs
      IFaces["Go Interfaces with SQL Templates"]
      Models["Go Model Structs"]
      Configs["genconfig.Configs"]
    end

    subgraph "GORM CLI Generator"
      Scanner["Scan Input Directory"]
      Filter["Apply Include/Exclude Filters"]
      ParseSQL["Parse SQL Templates"]
      AnalyzeModels["Analyze Models & Associations"]
      GenQueryAPI["Generate Query API Code"]
      GenFieldHelpers["Generate Field Helper Code"]
      WriteOutput["Write Generated Go Files"]
    end

    subgraph Outputs
      QueryAPI["Generated Query API (Go Files)"]
      FieldHelpers["Generated Field Helpers (Go Files)"]
    end

    App["Your Go Application"]
    GORM["GORM ORM library"]

    %% Input flow
    IFaces --> Scanner
    Models --> Scanner
    Configs --> Scanner

    %% Processing flow
    Scanner --> Filter --> ParseSQL --> GenQueryAPI
    Filter --> AnalyzeModels --> GenFieldHelpers

    GenQueryAPI --> WriteOutput
    GenFieldHelpers --> WriteOutput

    %% Output flow
    WriteOutput --> QueryAPI
    WriteOutput --> FieldHelpers

    QueryAPI --> App
    FieldHelpers --> App

    App --> GORM

    %% Styling
    classDef inputStyle fill:#def,stroke:#069,stroke-width:2px
    classDef processStyle fill:#f9f,stroke:#933,stroke-width:2px
    classDef outputStyle fill:#dfd,stroke:#393,stroke-width:2px
    class Inputs inputStyle
    class "GORM CLI Generator" processStyle
    class Outputs outputStyle
```

---

## Best Practices & Tips

- **Organize your codebase**: Keep query interfaces, models, and genconfig packages co-located or well structured for ease of scanning.
- **Use config to scope generation**: Control which interfaces and structs are included to avoid generating unwanted code.
- **Keep SQL templates readable**: Write clear comments with SQL and placeholders to improve maintainability.
- **Leverage generated helpers**: Use the generated fluent APIs for safer, easier database operations.
- **Regenerate often**: Integrate `gorm gen` into your build or deployment process to keep generated code in sync.

---

## Troubleshooting Common Issues

<AccordionGroup title="Troubleshooting Common Issues">
<Accordion title="No Output Generated">
- Ensure your input path contains interfaces and models.
- Check your Include/Exclude filters in genconfig.Config to confirm what is scanned.
- Verify you are running the CLI with the correct `-i` (input) flag.
</Accordion>
<Accordion title="Syntax Errors in Generated Code">
- Confirm your SQL templates are valid and placeholders correctly named.
- Avoid unsupported complex template directives.
- Validate associated models have GORM tags correctly declared.
</Accordion>
<Accordion title="Generated Code Not Imported Correctly">
- Make sure the output directory (`-o`) is included in your Go module's import path.
- Use consistent package names across generated files.
</Accordion>
</AccordionGroup>

---

## Next Steps

You are now ready to explore these related documentation pages to deepen your understanding and use of GORM CLI:

- [Defining Models and Query Interfaces](/getting-started/first-code-generation/defining-models-and-interfaces)
- [Running the Code Generator](/getting-started/first-code-generation/running-gorm-cli-gen)
- [Using Model-Driven Field Helpers](/guides/core-workflows/field-helper-generation)

These resources will help you transition from understanding the system internals to hands-on code usage and customization.

---

*End of System Overview & Data Flow*