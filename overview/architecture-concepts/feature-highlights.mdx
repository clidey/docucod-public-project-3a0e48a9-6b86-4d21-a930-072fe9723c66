---
title: "Feature Overview"
description: "Summarize the foundational features—such as type-safe query generation, field helpers for models, association operations, template-based SQL, and configuration flexibility—that make GORM CLI a compelling addition to GORM development."
---

# Feature Overview

Welcome to the Feature Overview of GORM CLI, where you'll discover the foundational capabilities that empower your GORM projects with type safety, streamlined querying, and rich model integrations.

## Unlocking Core Features for Safer, More Productive GORM Development

GORM CLI is designed to transform the way you interact with your database layers by generating type-safe query APIs and model-driven helpers. This page summarizes the critical features that make GORM CLI irresistible for Go developers working with GORM.

---

## 1. Type-Safe Query Generation from Interfaces

At the heart of GORM CLI is its ability to generate fully typed query APIs directly from Go interfaces annotated with SQL templates. Instead of manually writing boilerplate SQL queries or risking runtime errors, you define your query signatures and SQL snippets in Go interfaces. The CLI generates concrete implementations that:

- Enforce **compile-time type safety** to catch errors early
- Automatically inject a `context.Context` parameter for consistent cancellation and deadlines
- Support dynamic SQL through an elegant template DSL for control flow, conditional clauses, and iteration

### Example

```go
// Define queries with SQL templates in interface comments
 type Query[T any] interface {
   // SELECT * FROM @@table WHERE id=@id
   GetByID(id int) (T, error)

   // SELECT * FROM @@table WHERE name=@name AND age=@age
   FilterByNameAndAge(name string, age int) ([]T, error)
 }
```

The generated code lets you call these methods safely with real types tied to your models.

---

## 2. Model-Driven Field Helpers

GORM CLI generates strong-typed field helper structures from your model structs, enabling intuitive and fluent construction of filters, updates, ordering, and queries.

### Highlights

- Supports **basic types:** integers, floats, strings, bools, time.Time, and []byte.
- Recognizes named custom types and Scanner/Valuer implemented types.
- Generates **association helpers** for relationships including `has many`, `has one`, `belongs to`, and `many2many`.
- Provides chainable methods like `.Eq()`, `.Lt()`, `.Like()`, `.Set()`, or `.Incr()` to build expressive SQL predicates and updates.

### Example

```go
// Predicates on generated User fields
generated.User.ID.Eq(1)                 // id = 1
generated.User.Name.Like("%jinzhu%")  // name LIKE '%jinzhu%'
generated.User.Age.Between(18, 65)     // age BETWEEN 18 AND 65

// Updates
gorm.G[User](db).
   Where(generated.User.Name.Eq("alice")).
   Set(generated.User.Age.Incr(1), generated.User.Status.Set("active")).
   Update(ctx)
```

---

## 3. Association Operations with Compile-Time Safety

Managing complex relationships is effortless with generated helpers that encapsulate common association operations, all enriched with type safety.

Supported operations on associations include:

- `Create` and `CreateInBatch` — insert and link related records in one fluent call
- `Update` — conditionally update linked records
- `Unlink` — safely remove links by clearing foreign keys or join rows
- `Delete` — remove related rows with optional filters

### Usage Examples

```go
// Create new user with a pet
gorm.G[User](db).
  Set(
    generated.User.Name.Set("alice"),
    generated.User.Pets.Create(generated.Pet.Name.Set("fido")),
  ).
  Create(ctx)

// Unlink pets matching a condition
gorm.G[User](db).
  Where(generated.User.ID.Eq(1)).
  Set(generated.User.Pets.Where(generated.Pet.Name.Eq("fido")).Unlink()).
  Update(ctx)
```

The semantics respect association types ensuring safe and clear database operations.

---

## 4. Template-Based Dynamic SQL with Rich DSL

GORM CLI provides a powerful SQL template DSL inside your interface method comments for dynamic query generation:

| Directive   | Purpose                             | Example                                   |
|-------------|-----------------------------------|-------------------------------------------|
| `@@table`   | Resolves to the model's table name | `SELECT * FROM @@table WHERE id=@id`      |
| `@@column`  | Dynamic column binding             | `@@column=@value`                          |
| `@param`    | Binds Go method parameters         | `WHERE name=@user.Name`                    |
| `{{where}}` | Conditional WHERE clause           | `{{where}} {{if age > 0}} age > @age {{end}} {{end}}` |
| `{{set}}`   | Conditional UPDATE SET clause      | `{{set}} name=@name, age=@age {{end}}`   |
| `{{if}}`    | Conditional fragments              | `{{if user.Age > 18}} AND adult=1 {{end}}` |
| `{{for}}`   | Loop over collections              | `{{for _, tag := range tags}} tags LIKE concat('%', @tag, '%') OR {{end}}` |

This DSL empowers you to express flexible, complex SQL with full parameter safety and composability.

---

## 5. Configuration Flexibility with genconfig.Config

Although GORM CLI works out-of-the-box, it offers a config system to tailor generation to your project's needs.

### Customization features:

- **Output path overrides** to control generated code placement
- **Selective interface and struct filtering** using include/exclude patterns
- **Field mapping customization** to map Go types or `gen` tags to custom field helpers
- **File-level granular control** to limit config scope

### Example config

```go
var _ = genconfig.Config{
  OutPath:      "examples/output",
  FieldTypeMap: map[any]any{sql.NullTime{}: field.Time{}},
  FieldNameMap: map[string]any{"date": field.Time{}},
  IncludeInterfaces: []any{"Query*"},
  ExcludeInterfaces: []any{"*Deprecated*"},
}
```

This extensibility ensures GORM CLI adapts smoothly to diverse project demands.

---

## Why This Matters

GORM CLI seamlessly bridges your Go code models and SQL operations with compile-time guarantees and fluent APIs — freeing you from error-prone manual SQL crafting and boosting productivity through generated helpers.

By mastering these core features summarized here, you set the stage for safer, clearer, and more maintainable database access layers with GORM.

---

## What's Next?

Ready to dive deeper or get hands-on?

- Review the [System Architecture & Workflow]( /overview/architecture-concepts/system-overview-diagram) to understand how components interact.
- Explore [Core Concepts & Terminology]( /overview/architecture-concepts/concepts) for foundational definitions.
- Try the [Getting Started guides]( /getting-started/setup-basics/installation) to generate and use your first query APIs.

Together these provide a guided path from concept to practical implementation.

---

### Related Pages in This Section

- [What is GORM CLI?](/overview/product-intro-core/what-is-gorm-cli) — Understand the product purpose and user benefits.
- [Value Proposition & Use Cases](/overview/product-intro-core/core-value-proposition) — See real-world impact and ROI.
- [Target Audience](/overview/product-intro-core/target-audience) — Identify ideal users and scenarios.

---

Harness the power of GORM CLI’s features to create concise, readable, and reliable database code for your Go projects today!
