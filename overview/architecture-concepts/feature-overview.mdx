---
title: "Feature Overview"
description: "Summarizes the product's two main generators: Interface-driven, template-based Query APIs and Model-driven Field Helpers. Delivers a concise comparison between traditional and CLI-powered GORM workflows, emphasizing advantages for safety, code fluency, and maintainability."
---

# Feature Overview

Unlock the full power of GORM CLI through its two main generators: **Interface-driven, template-based Query APIs** and **Model-driven Field Helpers.** This page provides a concise but thorough summary of these core capabilities, showing how GORM CLI transforms the traditional GORM workflow into a type-safe, fluent, and maintainable code experience.

---

## Transforming Your GORM Workflow

Traditionally, using GORM involves writing raw queries and manually managing model fields, which can lead to repetitive code prone to runtime errors. GORM CLI revolutionizes this by generating compile-time safe, expressive APIs from your existing Go interfaces and model structs:

- **Interface-driven Query APIs:** Write Go interfaces with embedded SQL templates, and GORM CLI generates concrete, type-safe query implementations.
- **Model-driven Field Helpers:** From your struct fields, the CLI creates fluent helpers for building filter criteria, update setters, and association operations.

Together, these generators reduce boilerplate, prevent errors, and create a discoverable, IDE-friendly coding experience.

---

## What Does This Page Cover?

This page specifically summarizes the **Feature Overview** of GORM CLI — it contrasts legacy GORM patterns with CLI-powered workflows, details key advantages, and highlights best practices for leveraging GORM CLI’s two complementary generation engines.

It fits into the broader documentation navigation under "Architecture & Core Concepts", linking foundational knowledge with practical user benefits.

---

## Interface-Driven Query APIs: Type Safety Meets Flexibility

At the heart of GORM CLI lies the ability to author **Go interfaces annotated with SQL templates** that directly express query semantics. From these interfaces, the CLI produces fully type-safe implementations that embed:

- **SQL Templates:** Use intuitive placeholders (`@@table`, `@param`, `{{where}}`, `{{set}}`, etc.) to write flexible, conditional, and iterable SQL snippets inside comments.
- **Automatic Parameter Binding:** Placeholders in templates automatically bind to method parameters, eliminating manual query construction.

### Example Interface

```go
// Query defines common queries on User entities
// Commented SQL templates drive generation
//
type Query[T any] interface {
  // SELECT * FROM @@table WHERE id=@id
  GetByID(id int) (T, error)

  // Dynamic WHERE clause filtering users by name and age
  FilterByNameAndAge(name string, age int)  []T
}
```

### What Users Gain

- **Compile-time guarantees** that method signatures match their SQL templates, eliminating common bugs.
- **Concise and expressive queries** that are easier to maintain compared to raw SQL strings scattered in application code.
- **Built-in context injection**, so method calls are compatible with Go’s context-aware paradigms.

---

## Model-Driven Field Helpers: Fluent Filtering & Updates

GORM CLI extends your models with generated field helpers representing each column and association:

- **Basic Fields:** For standard Go types, fields such as `Name`, `Age`, or `CreatedAt` generate typed helpers like `Eq()`, `Like()`, `Between()` with convenient method chaining.
- **Associations:** Relations (`has one`, `has many`, `belongs to`, `many2many`) produce helpers supporting association-specific operations like `Create()`, `Update()`, `Unlink()`, and `Delete()` with compile-time safety.

### Practical Benefits

- Express complex filters and updates fluently and confidently:
  ```go
  gorm.G[User](db).
    Where(generated.User.Name.Like("%alice%"), generated.User.Age.Between(18, 65)).
    Update(ctx)
  ```

- Manage associations with clear semantics:
  ```go
  gorm.G[User](db).
    Set(generated.User.Pets.Create(generated.Pet.Name.Set("fido"))).
    Create(ctx)
  ```

- Automatic zero-value handling and expression support enhance update behaviors without verbose manual checks.

---

## Comparing Traditional vs. CLI-Powered Workflows

| Aspect                  | Traditional GORM                                                     | GORM CLI Generated Code                                              |
|-------------------------|--------------------------------------------------------------------|----------------------------------------------------------------------|
| Query Construction      | Raw SQL strings or chained GORM calls manual and error-prone      | Interface-defined, template-driven queries ensure correctness        |
| Parameter Safety        | Runtime errors from mismatched parameters                          | Compile-time safety with automatic parameter binding                  |
| Field Access            | String literals or manual struct fields                            | Generated field helpers with fluent, typed predicates                 |
| Association Operations  | Complex, repetitive manual code for create/update/unlink/delete   | Association helpers provide idiomatic, safe, and maintainable APIs    |
| Maintainability        | Scattered, redundant code; tricky refactoring                      | Centered definition in interfaces/models; code generated consistently |

---

## Key Advantages Summarized

- **Compile-Time Safety:** Catch SQL and API mismatches before runtime.
- **Fluent API:** Discoverable methods reduce cognitive load and errors.
- **Customizable Generation:** Fine-tune inclusion, exclusion, and field mapping through config.
- **Seamless Integration:** Works hand-in-hand with `gorm.io/gorm` for intuitive database interaction.
- **Maintenance Efficiency:** Reduce boilerplate and speed up refactoring.

---

## Real-World Scenario: Enhancing a User Management Backend

Imagine building a backend for user management:

1. Define query interfaces to cover common data access patterns.
2. Generate type-safe APIs for fetching and filtering users.
3. Use field helpers to perform complex updates and association management for user pets, languages, roles.

This approach eliminates bugs caused by manual SQL strings, enables IDE autocompletion, and speeds up development cycles.

---

## Getting Started Preview

1. **Write Query Interfaces & Models:** Compose your Go interfaces with annotated SQL templates and define models as usual.
2. **Run GORM CLI Generator:** Execute `gorm gen -i ./path/to/pkg -o ./generated` to generate code.
3. **Use Generated APIs:** Replace raw queries with fluent generated methods that reflect your domain logic.

For detailed steps, see the [Quickstart Workflow](/overview/integration-getting-started/quickstart-workflow) and [Building Type-Safe Queries with Interfaces](/guides/core-workflows/type-safe-queries).

---

## Tips & Best Practices

- Employ package-level `genconfig.Config` for fine-grained control over which interfaces and structs are included or excluded.
- Leverage field name/type mapping for specialized field helpers, e.g., JSON or SQL Null types.
- Write concise, clear SQL templates using the GORM CLI Template DSL for maintainability.
- Use association helpers to model complex relational operations instead of raw manual SQL.

---

## Troubleshooting Common Issues

- Verify that all interface methods specify proper SQL templates with matching return types.
- Ensure config patterns correctly include/exclude desired interfaces and structs.
- Update your Go version to 1.18+ to support generics required by GORM CLI.
- Use verbose output with the CLI for error details during generation.

---

## Further Exploration

This page links closely with:

- [System Architecture](/overview/architecture-concepts/system-architecture) for understanding component interactions.
- [Core Concepts & Terminology](/overview/architecture-concepts/core-concepts-terminology) for key definitions.
- [Quickstart Workflow](/overview/integration-getting-started/quickstart-workflow) for hands-on steps to begin.

Explore these to deepen your mastery of GORM CLI.

---

<style>
md-table {width: 100%; border-collapse: collapse;}
md-table th, md-table td {border: 1px solid #ddd; padding: 8px;}
md-table th {background-color: #f2f2f2; text-align: left;}
</style>