---
title: "System Architecture (with Diagram)"
description: "Visualize how GORM CLI operates—from consuming source code (models, interfaces, configs) to emitting generated code. A mermaid diagram illustrates data flows, major components, and the CLI-to-codegen process for maximum clarity."
---

# System Architecture (with Diagram)

Understand the internal workflow of GORM CLI by exploring how it transforms your source code into robust, type-safe query APIs and model-driven field helpers. This page visually breaks down the entire architecture—from intake of your Go models, interfaces, and configuration files, through the code generation process, to the output of ready-to-use Go code integrating with GORM.

---

## Why This Matters

Developers rely on GORM CLI to automate tedious, error-prone parts of database interaction code. Knowing the system architecture empowers you to better anticipate how your changes in models or interfaces impact code generation, troubleshoot effectively, and customize your usage with confidence.

---

## High-Level Workflow

At its core, GORM CLI operates as a Go code generator tightly coupled with your GORM projects. It orchestrates several components in a smooth pipeline, transforming source definitions into expressive, type-safe code.

### Core Components and Flow

```mermaid
flowchart TD

  %% Input Sources
  SRC["Source Code
(Models, Interfaces, Configs)"]
  CLI["GORM CLI
(Command Line Tool)"]

  %% Parsing and Analysis
  PARSER["Go Parser & AST Analyzer"]
  CFG["Configuration Resolver
(genconfig)"]

  %% Code Generation
  GEN["Code Generator Module"]
  FORMAT["Code Formatter
(gofmt, imports)"]

  %% Output
  OUTPUT["Generated Code
(Type-safe Query APIs,
Field Helpers, Association Helpers)"]

  %% Relationships
  SRC --> CLI
  CLI --> PARSER
  PARSER --> CFG
  CFG --> GEN
  GEN --> FORMAT
  FORMAT --> OUTPUT

  %% Annotations
  subgraph "Input"
    SRC
  end

  subgraph "Processing Pipeline"
    CLI --> PARSER
    PARSER --> CFG
    CFG --> GEN
    GEN --> FORMAT
  end

  subgraph "Output"
    OUTPUT
  end

  note right of SRC
    - Your model structs define database schema
    - Interfaces describe type-safe queries
    - Optional config tweaks generation details
  end

  note right of OUTPUT
    - Generated Go files integrate with gorm.io/gorm
    - Enable fluent, compile-time-safe DB interactions
  end

```

---

## Detailed Component Descriptions

### 1. Source Code

- **Models:** Define your database schema as Go structs. Fields and tags determine table columns and relationships.
- **Interfaces:** Write Go interfaces with SQL templating comments describing query methods, enabling type-safe data access APIs.
- **Configuration:** Optionally define `genconfig.Config` to customize file output paths, field mappings, and inclusion/exclusion rules.

### 2. GORM CLI Tool

The CLI ingests your code and executes the code generation pipeline. It accepts input paths and user options, providing straightforward commands like `gorm gen`.

### 3. Go Parser & AST Analyzer

This component parses Go source files, extracts Abstract Syntax Trees (AST), and identifies key elements:

- Models and their fields
- Interfaces and SQL annotations
- Relevant configurations

This precise extraction ensures accurate, context-aware codegen.

### 4. Configuration Resolver

Resolves and merges configuration settings from your source files and specified config objects, applying filters such as whitelists or type mappings to guide generation.

### 5. Code Generator Module

Synthesizes generated code based on parsed AST data and configuration:

- Creates type-safe query API implementations from interfaces
- Generates model-driven field helpers for filtering, updates, and associations
- Handles compilation of association operations (create, update, unlink, delete)

Uses templates to produce idiomatic Go that seamlessly plugs into your codebase.

### 6. Code Formatter

Runs `gofmt` and imports sorting on generated source files, ensuring clean, idiomatic, and ready-to-use code.

### 7. Generated Output

You receive Go source files containing:

- Strongly typed query interfaces and concrete implementations based on your defined queries
- Fluent field helpers for all model fields, enabling expressive filters and updates
- Association helpers supporting safe create/link/update/unlink/delete semantics

Your application uses these to reduce runtime errors, boost productivity, and maintain clean database interaction layers.

---

## Practical Example: Developer Workflow

Imagine you’re building a backend with GORM. Your source code contains models and an interface like:

```go
// models/user.go
package models

type User struct {
  ID   uint
  Name string
  Age  int
}

// queries.go
package examples

type Query[T any] interface {
  // SELECT * FROM @@table WHERE id=@id
  GetByID(id int) (T, error)
}
```

1. You run the CLI:

```bash
gorm gen -i ./examples -o ./generated
```

2. The CLI parses `models/user.go` and `queries.go`, applies any config overrides.
3. It generates `generated/query_gen.go` with:

```go
func Query[T any](db *gorm.DB) _QueryInterface[T] {
  // implementation
}

var User = struct {
  ID   field.Number[uint]
  Name field.String
  Age  field.Number[int]
}{
  // field helpers
}
```

4. In your app, you now call:

```go
user, err := generated.Query[models.User](db).GetByID(ctx, 42)
```

Offering compile-time guarantees and discoverable API.

---

## Tips for Success

- Define complete and accurate models and interfaces to maximize codegen value.
- Use `genconfig.Config` to tailor output structure and handle custom types.
- Regularly regenerate code after model or interface changes to keep your API fresh.
- Review generated code to understand the capabilities and customize queries.

---

## Troubleshooting

- If generated code is missing expected helpers, verify your model struct definitions and interface comments.
- Ensure configuration is loaded correctly (see config files or in-package overrides).
- Check for proper Go environment (`go` toolchain version 1.18+).
- Use verbose CLI logging to gather parsing and generation details.

---

## Next Steps

- Explore the [Core Concepts & Terminology](../core-concepts-terminology) to deepen understanding of GORM CLI’s language.
- Review [Getting Started with GORM CLI](../../guides/core-workflows/getting-started) for hands-on usage.
- Consult the [Configuring GORM CLI](../../getting-started/configuration-and-troubleshooting/configuring-generator) page to master generation customization.

---

By understanding the architecture depicted here, you can fully leverage GORM CLI’s power to create resilient, maintainable, and efficient Go applications that utilize GORM with confidence.
