---
title: "Core Concepts & Terminology"
description: "Defines essential terms such as Query APIs, Field Helpers, Associations, Template DSL, and Generation Configuration. Helps users quickly understand the fundamental building blocks needed to use GORM CLI effectively."
---

# Core Concepts & Terminology

Unlock a clear understanding of the fundamental building blocks that empower you to harness the full potential of GORM CLI. This page defines essential terms such as **Query APIs**, **Field Helpers**, **Associations**, **Template DSL**, and **Generation Configuration**, enabling you to get up to speed quickly and start generating type-safe, fluent database code with confidence.

---

## What You Will Learn

- What Query APIs are and how they let you build type-safe data queries
- How Field Helpers simplify working with model fields, updates, and filters
- The role and types of Associations for related data operations
- How the Template DSL enables powerful, flexible SQL generation inside Go interfaces
- The purpose and usage of Generation Configuration for customizing code output

---

## Query APIs: Your Type-Safe Gateway to Data Access

**Definition:** Query APIs are concrete, generated implementations of your Go interfaces that embed SQL templates within comments. They provide strongly typed methods to query or modify your data with compile-time safety.

**Purpose:** Instead of writing raw SQL strings scattered throughout your app, you declare query methods as Go interfaces. The generator converts these interfaces into real, type-safe Go methods that execute your templated SQL.

**Why It Matters:**
- Avoid runtime errors from malformed or mismatched SQL and parameters
- Enjoy IDE autocompletion and compile-time checks for query method signatures
- Maintain clean, organized data access abstractions

**Example:**

```go
// Query interface with SQL templating
type Query[T any] interface {
  // SQL comment with template
  // SELECT * FROM @@table WHERE id=@id
  GetByID(id int) (T, error)

  // Using conditional WHERE template
  // SELECT * FROM @@table
  // {{where}}
  //   {{if user.Name != ""}} name=@user.Name {{end}}
  //   {{if user.Age > 0}} AND age=@user.Age {{end}}
  // {{end}}
  QueryWith(user models.User) (T, error)
}
```

When generated, these become type-safe methods you call directly with your parameters.

---

## Field Helpers: Fluent, Model-Driven API Components

**Definition:** Field Helpers are generated Go variables and types that map directly to your GORM model structs’ fields, providing strongly typed predicate builders, setters, and association helpers.

**Purpose:** They simplify writing filters, updates, and association operations without manual SQL or string literals.

**Key Capabilities:**
- Express conditions (eg. equality, LIKE, IN) fluently
- Create or update fields with type-safe setters
- Access related models with generated Association Helpers

**Benefits:**
- Reduce boilerplate when building queries
- Avoid errors in field names or types
- Write expressive, readable code

**Example:**

```go
// Using generated field helpers
gorm.G[User](db).
  Where(generated.User.Age.Between(18, 65),
        generated.User.Name.Like("%john%"))
  .Find(ctx)

// Updates with setters
gorm.G[User](db).
  Set(generated.User.Name.Set("alice"),
      generated.User.IsAdult.Set(true))
  .Update(ctx)
```

---

## Associations: Managing Related Data Effortlessly

**Definition:** Associations define relationships between models (has one, has many, belongs to, many to many) and are represented in field helpers to operate on related rows safely.

**Core Association Types:**
- **Belongs To:** Foreign key on the current model pointing to a parent
- **Has One / Has Many:** Related child records managed by foreign keys
- **Many2Many:** Join table managing many-to-many relationships

**Operations Supported:**
- Create, batch create and link related entities
- Update related records conditionally
- Unlink (remove foreign key without deleting data)
- Delete associated records

**Why Use Association Helpers?**
- Maintain relational integrity cleanly
- Work with association data with compile-time checks
- Avoid manual queries for related rows

**Example:**

```go
// Create user with pets (has many)
gorm.G[User](db).
  Set(
    generated.User.Name.Set("alice"),
    generated.User.Pets.Create(generated.Pet.Name.Set("fido")),
  ).
  Create(ctx)

// Unlink pets where name = "fido"
gorm.G[User](db).
  Where(generated.User.ID.Eq(1)).
  Set(generated.User.Pets.Where(generated.Pet.Name.Eq("fido")).Unlink()).
  Update(ctx)
```

---

## Template DSL: Flexible SQL Embedded in Go Interfaces

GORM CLI introduces a powerful domain-specific language embedded inside interface method comments to flexibly define SQL queries.

**Core Directives:**
- `@@table` — Resolves to the model's table name
- `@@column` — Dynamic column binding
- `@param` — Bind Go method parameters to SQL parameters
- `{{where}}...{{end}}` — Optional, conditional WHERE clauses
- `{{set}}...{{end}}` — Optional, conditional SET clauses for UPDATE
- `{{if}}`, `{{else if}}`, `{{else}}`, `{{end}}` — Conditional SQL fragments
- `{{for}}...{{end}}` — Iterate over lists for dynamic conditions

**Example:**

```sql
-- Conditional WHERE based on user input
SELECT * FROM @@table
{{where}}
  {{if user.Name != ""}} name=@user.Name {{end}}
  {{if user.Age > 0}} AND age=@user.Age {{end}}
{{end}}
```

This DSL tightly integrates SQL flexibility and Go’s type system, yielding safe but dynamic query generation.

---

## Generation Configuration: Tailoring Your Generated Code

**Definition:** Generation Configuration (`genconfig.Config`) is a Go struct you define in your package that controls how the code generator behaves.

**Capabilities Include:**
- Setting output directory for generated files
- Mapping Go types to field helper types (e.g., for custom JSON handling)
- Whitelisting or blacklisting specific interfaces or structs for generation
- Applying configuration at file or package level

**Why Use Configuration?**
- Control what code is generated to keep your project clean
- Adapt field helpers to special types with custom logic
- Exclude deprecated interfaces or internal-only models

**Example:**

```go
var _ = genconfig.Config{
  OutPath: "examples/output",
  FieldTypeMap: map[any]any{
    sql.NullTime{}: field.Time{},
  },
  IncludeInterfaces: []any{"Query*"},
  IncludeStructs: []any{"User"},
}
```

---

## Putting It All Together: How These Concepts Drive Your Workflow

1. **Define your models** with standard GORM structs representing your entities.
2. **Write query interfaces** embedding SQL templates using the Template DSL.
3. **Set up generation configuration** to customize output file paths and type mappings.
4. **Run the generator**, producing Query API implementations and Field Helpers.
5. **Use generated types** to write concise, type-safe GORM queries and association operations.

This cohesive foundation makes your database access layer robust, clear, and efficient.

---

## Practical Tips

- Always define your SQL templates clearly and use the DSL directives to handle optional conditions and dynamic filters.
- Customize field helper generation for unsupported or special fields via `FieldTypeMap` in config.
- Use association helpers to enforce relational integrity and avoid error-prone manual joins.
- Leverage whitelisting and exclusion patterns in your configuration to focus generation on active interfaces and models.

---

## Troubleshooting Common Pitfalls

<AccordionGroup title="Common Issues with Core Concepts">
<Accordion title="Why is my generated Query API missing methods?">
Check your generation configuration whitelist and blacklist settings. If your interface names don’t match inclusion patterns, they won’t be generated.
</Accordion>
<Accordion title="How do I handle custom field types?">
Use the `FieldTypeMap` in your genconfig.Config to map unsupported Go types to existing or custom field helpers.
</Accordion>
<Accordion title="Template DSL logic doesn’t work as expected">
Ensure your `{{if}}` and other directives use valid Go template syntax and refer to parameters correctly. Debug by simplifying templates and verifying parameter passing.
</Accordion>
</AccordionGroup>

---

## Next Steps

Now that you understand these core concepts and terminology, proceed to:

- [Installation & Setup](/overview/integration-getting-started/installation-setup) to prepare your environment
- [Quickstart Workflow](/overview/integration-getting-started/quickstart-workflow) to generate your first code
- [Using Model-Driven Field Helpers](/guides/core-workflows/field-helpers) for in-depth field operations

Explore the broader GORM CLI ecosystem with confidence, empowered by these foundational building blocks.

---