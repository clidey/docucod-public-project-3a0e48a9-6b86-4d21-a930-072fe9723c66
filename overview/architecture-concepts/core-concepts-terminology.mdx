---
title: "Core Concepts & Terminology"
description: "Familiarize yourself with the domain language of GORM CLI: interface-driven query APIs, model-driven field helpers, associations (has one, has many, m2m, etc.), SQL template DSL, field mapping, and code generation rules. This page establishes essential mental models for effective usage."
---

# Core Concepts & Terminology

## Understanding the Language of GORM CLI

To effectively harness the power of GORM CLI, it is essential to become familiar with its core concepts and terminology. This foundational knowledge establishes the mental models necessary for efficient use of the tool and enables you to interpret generated code, configure your projects precisely, and write expressive queries. 

This page focuses on key domain language elements including interface-driven query APIs, model-driven field helpers, associations, the SQL template DSL, field mapping strategies, and the rules underlying code generation.

---

### Interface-Driven Query APIs

At the heart of GORM CLI's query generation is the concept of interface-driven, _type-safe_ query APIs. 

- **What It Means:** You define Go interfaces where each method is accompanied by a SQL template comment specifying the intended database operation.
- **Purpose:** These interfaces allow GORM CLI to generate concrete method implementations that return type-safe results and support rich query parameterization.

For example, defining a method `GetByID(id int) (T, error)` with a SQL comment like `SELECT * FROM @@table WHERE id=@id` produces a compiled, type-safe method to fetch records by ID.

This approach:
- Ensures compile-time safety on queries
- Improves discoverability of available queries through fluent APIs
- Allows precise control over SQL

---

### Model-Driven Field Helpers

In parallel to query APIs, GORM CLI generates model-driven _field helpers_ based on your Go struct models. These helpers represent fields and associations with rich, strongly-typed expressions:

- **Basic Fields:** Include primitive types like ints, strings, booleans, times, and supported named types implementing Scanner/Valuer.
- **Usage:** Field helpers enable fluent filters, setters (updates), ordering, and predicate constructions such as `generated.User.Name.Like("%example%")`.

The field helper mechanisms allow:
- Constructing SQL predicates and update sets in a strongly typed way
- Preventing common mistakes like column misnaming or mismatched types
- Expressing complex conditions succinctly

---

### Associations: The Backbone of Relationships

GORM CLI recognizes and generates specialized helpers for database associations defined on models. Each association type maps to specific helpers and behaviors:

- **belongs to:** Connects a child record to a parent; unlinking clears the foreign key; deleting removes associated rows.
- **has one / has many:** Indicate ownership; unlinking clears child foreign keys; deleting removes child rows.
- **many-to-many (m2m):** Represents many-to-many relations via join tables; unlinking/deleting affects only join rows.

Supported association operations are fully type-safe and support:
- Creating and linking associated rows (`Create`, `CreateInBatch`)
- Updating associated rows with filters
- Unlinking (removing foreign key links or join rows)
- Deleting associated rows or join rows

This enables sophisticated management of relationships in updates and creates while preserving data integrity.

---

### SQL Template DSL: Flexible, Safe SQL Generation

GORM CLIâ€™s SQL template DSL empowers you to write expressive SQL queries with built-in safety and dynamism:

| Directive   | Purpose                           | Example                                   |
|-------------|---------------------------------|-------------------------------------------|
| `@@table`   | Resolves to the model's table name | `SELECT * FROM @@table WHERE id=@id`      |
| `@@column`  | Binds dynamic column names       | `WHERE @@column=@value`                    |
| `@param`    | Maps Go function parameters      | `WHERE name=@user.Name`                    |
| `{{where}}` | Conditionals for WHERE clauses    | See example below                          |
| `{{set}}`   | Conditional SET clauses for UPDATE | See example below                         |
| `{{if}}`    | Conditional fragments            | `{{if @age > 0}} AND age=@age {{end}}`   |
| `{{for}}`   | Iteration over collections       | `{{for _, t := range tags}} ... {{end}}` |

```sql
-- Conditional WHERE clause example
SELECT * FROM @@table
{{where}}
  {{if name != ""}} name=@name {{end}}
  {{if age > 0}} AND age=@age {{end}}
{{end}}

-- Conditional UPDATE SET clause example
UPDATE @@table
{{set}}
  {{if user.Name != ""}} name=@user.Name, {{end}}
  {{if user.Age > 0}} age=@user.Age, {{end}}
{{end}}
WHERE id=@id
```

The template DSL allows you to express complex SQL logic in the interfaces transparently, enabling the generator to produce tailored query methods.

---

### Field Mapping and Code Generation Rules

The generator employs specific rules for transforming model fields into field helpers:

- **Basic Fields:** Recognized types like int, string, time.Time, and types implementing the required interfaces are wrapped with strongly-typed helpers (`field.String`, `field.Number[int]`, etc.).
- **Named Mappings:** You can customize field helpers by tagging fields with `gen:"tagName"` and configuring `FieldNameMap` for custom types (e.g., JSON helpers).
- **Associations:** Fields representing relationships (based on type signatures like slices or structs of other models) become association helpers like `field.Struct[T]` or `field.Slice[T]`.

Configuration options in `genconfig.Config` allow fine-grained control, including:
- Output directories
- Include/exclude lists for interfaces and structs
- Field type and name mappings for custom behavior

---

### Summarizing the Mental Models

| Concept                    | What It Means                                        | Why It Matters                                         |
|----------------------------|-----------------------------------------------------|-------------------------------------------------------|
| Interface-Driven Query APIs | Define SQL via Go interfaces with annotated methods | Generates type-safe query methods, improving safety  |
| Model-Driven Field Helpers  | Generate typed helpers for fields & associations     | Enables fluent, error-resistant SQL predicates & sets |
| Associations               | Treat relations explicitly with type-safe helpers   | Manage linked data reliably and expressively          |
| SQL Template DSL           | Write parameterized, conditional SQL inside methods | Embed rich SQL logic without losing safety             |
| Field Mapping Rules        | Control how fields translate into helpers & types   | Customize generation for your domain needs             |

---

### Practical Tips for Mastery

- **Start Simple:** Define interfaces with basic queries and gradually introduce templated SQL and associations.
- **Leverage Field Helpers:** Use generated field helpers to build queries and updates rather than raw SQL strings.
- **Use Configuration:** Customize generation with `genconfig.Config` to fit your project structure and preferred mappings.
- **Test Generated Code:** Validate generated methods to ensure templates and configs produce the expected behaviors.

---

This foundational lexicon and conceptual framework prepare you to dive deeper into using GORM CLI for productive, type-safe, and expressive data access layers.


---

## See Also

- [What is GORM CLI?](/overview/product-intro/what-is-gorm-cli): Introduction to the product and its core benefits.
- [System Architecture Overview](/overview/architecture-concepts/system-architecture): Visual workflow and component interaction in GORM CLI.
- [Primary Use Cases](/overview/product-intro/primary-use-cases): Key real-world scenarios demonstrating the primary features.
- [Template DSL Guide](/guides/advanced-usage/template-dsl-guide): Detailed explanation of writing SQL templates.

---

## Next Steps

After establishing these core concepts, proceed to:

- Define your Go model structs with thoughtfully designed associations.
- Create query interfaces with SQL template comments leveraging the DSL.
- Customize generation via `genconfig.Config` to optimize helper types.
- Run the generator and explore the rich, type-safe APIs produced.

This strategic journey will unlock the full productivity and safety benefits of GORM CLI.
