---
title: "Core Concepts & Terminology"
description: "Explains key terminology such as 'type-safe query API', 'model-driven field helper', 'association operations', 'SQL template DSL', and 'generation config'. Helps users quickly become fluent in the domain language and understand how these concepts impact their workflow."
---

# Core Concepts & Terminology

Welcome to the foundational page of GORM CLI documentation where we demystify the core terms and concepts you will regularly encounter. This page equips you with the precise vocabulary and understanding essential for fluently navigating the GORM CLI workflow and maximizing its powerful code generation capabilities.

---

## Unlocking the Language of GORM CLI

Before diving into usage or configuration, understanding the key concepts will empower you to write, customize, and troubleshoot generated code effectively. Each term below is introduced with clear explanations and practical context.

---

## 1. Type-Safe Query API

**What it is:**

A set of automatically generated Go interfaces and methods that represent your SQL queries in a type-safe manner.

**Why it matters:**

By defining queries as Go interface methods with embedded SQL templates, GORM CLI generates concrete implementations that guarantee compile-time type checking. This eliminates runtime SQL errors caused by mismatched parameters or inconsistent result types.

**Example:**

```go
// Your interface with SQL comments defines query patterns
 type Query[T any] interface {
  // SELECT * FROM @@table WHERE id=@id
  GetByID(id int) (T, error)

  // SELECT * FROM @@table WHERE @@column=@value
  FilterWithColumn(column string, value string) (T, error)
 }
```

The generator will produce methods like `GetByID` with exact parameter bindings and result types, so you can write:

```go
user, err := generated.Query[User](db).GetByID(ctx, 123)
```

and have full confidence in query correctness.

---

## 2. Model-Driven Field Helper

**What it is:**

Field helpers are generated strongly typed objects derived from your Go model structs, representing each column and association.

**Why it matters:**

These helpers enable fluent, discoverable expressions for building predicates, updates, and association operations without manually writing raw SQL or string-based queries.

**How it works:**

For basic column fields such as strings, ints, times:

```go
// generated field helpers for User struct
generated.User.Name.Eq("alice")     // WHERE name = 'alice'
generated.User.Age.Between(18, 65)  // WHERE age BETWEEN 18 AND 65
```

For associations (e.g., related pets or languages):

```go
// Create and associate a pet
gorm.G[User](db).
  Set(
    generated.User.Name.Set("alice"),
    generated.User.Pets.Create(generated.Pet.Name.Set("fido")),
  ).
  Create(ctx)
```

---

## 3. Association Operations

GORM CLI generates helpers to manage related data with semantic operations:

- **Create**: Insert and link new related records
- **Update**: Modify associated records matching conditions
- **Unlink**: Remove links without deleting data (e.g., set foreign keys NULL or remove join table entries)
- **Delete**: Delete associated records or join rows
- **CreateInBatch**: Batch create and associate multiple records

**Semantics vary by association type:**

| Type       | Unlink Behavior                  | Delete Behavior                    |
|------------|---------------------------------|----------------------------------|
| Belongs To | Clears parent FK (sets NULL)    | Deletes associated rows           |
| Has One/Many| Clears child FK                 | Deletes child rows                |
| Many2Many  | Removes join table entries only | Removes join table entries only  |

```go
// Example: unlinking pets from a user
gorm.G[User](db).
  Where(generated.User.ID.Eq(1)).
  Set(generated.User.Pets.Unlink()).
  Update(ctx)
```

---

## 4. SQL Template DSL

GORM CLI enables embedding SQL logic directly in Go interfaces using a simple yet powerful templating syntax. This creates dynamic, readable, and maintainable queries.

Key directives:

| Directive   | Purpose                                            | Example
|-------------|----------------------------------------------------|--------------------------------------------|
| `@@table`   | Resolves to the table name for the model           | `SELECT * FROM @@table WHERE id=@id`
| `@@column`  | Dynamic column name binding                         | `WHERE @@column=@value`
| `@param`    | Maps Go function parameters to SQL placeholders    | `WHERE name=@user.Name`
| `{{where}}` | Conditional WHERE blocks that expand if conditions | `{{where}} age > 18 {{end}}`
| `{{set}}`   | Conditional SET clauses for UPDATE statements      | `{{set}} name=@name {{end}}`
| `{{if}}`    | Include SQL fragments conditionally                 | `{{if age > 0}} AND age=@age {{end}}`
| `{{for}}`   | Loop over collections within SQL                    | `{{for _, tag := range tags}} ... {{end}}`

Example:

```sql
-- Conditional WHERE using DSL
SELECT * FROM @@table
{{where}}
  {{if name != ""}} name=@name {{end}}
  {{if age > 0}} AND age=@age {{end}}
{{end}}
```

This dynamic generation adapts SQL at runtime based on parameters.

---

## 5. Generation Config

GORM CLI supports flexible generation configuration through a Go struct `genconfig.Config` declared in your source package.

What you can customize:

- **Output path:** Specify where generated code files are written
- **Field type mapping:** Override which field helpers are generated for specific Go types
- **Field name mapping:** Map struct tags (e.g., `gen:"json"`) to custom helpers
- **Inclusion/exclusion rules:** Filter which structs or interfaces to generate code for
- **File level vs package level:** Control scope of config application

Example config snippet:

```go
var _ = genconfig.Config{
  OutPath: "examples/output",
  FieldTypeMap: map[any]any{
    sql.NullTime{}: field.Time{},
  },
  FieldNameMap: map[string]any{
    "json": JSON{},
  },
  IncludeInterfaces: []any{"Query*"},
  ExcludeInterfaces: []any{"*Deprecated*"},
}
```

This empowers granular control over generated code tailored to your project needs.

---

## Why These Concepts Matter

Together, these core concepts form the language and mechanisms that make GORM CLI a powerful tool for generating safe, concise, and expressive Go database access code. Understanding them: 

- Enables smooth transition from raw SQL to fluent, type-safe Go APIs
- Reduces bugs and maintenance overhead
- Allows advanced customization when simply generating default code is insufficient
- Facilitates integration with your existing GORM models and workflows

Keep this terminology handy as you explore the rest of the documentation.

---

## Next Steps

- Explore [How GORM CLI Works: Architecture Overview](/overview/architecture-concepts/architecture-overview) to understand the processing flow behind these concepts
- Try generating your first type-safe query interface in [Quick Start: From Models to Queries](/overview/quickstart-features/quickstart-workflow)
- Dive deeper into usage patterns with [Interface-Driven Query APIs](/guides/query-and-model-helpers/interface-driven-queries)

---

## Troubleshooting

<Tip>
**Common pitfall:** Forgetting to return an error as the last method result causes generation failures. Always ensure your query interface methods return `(T, error)` or `error` properly.
</Tip>

<Tip>
**Best practice:** Use configuration to exclude deprecated or unused interfaces to speed up generation and keep code clean.
</Tip>

---

By mastering these fundamental terms, your journey with GORM CLI will be efficient, productive, and enjoyable.

---

### Quick Reference Table

| Concept                  | Purpose                                   | Benefit                                     |
|--------------------------|-------------------------------------------|---------------------------------------------|
| Type-Safe Query API      | Generate compile-time verified queries    | Avoid runtime SQL errors, easy to call      |
| Model-Driven Field Helper| Generate column and association helpers   | Fluent, discoverable predicates & updates   |
| Association Operations   | Semantic management of related data       | Safe create, update, unlink, delete         |
| SQL Template DSL         | Write dynamic inline SQL templates         | Flexible, maintainable query logic           |
| Generation Config        | Customize generation behavior & output    | Tailored code matching project needs        |

---

### Code Examples

#### Basic Query Interface

```go
// Query interface definition
 type Query[T any] interface {
  // SELECT * FROM @@table WHERE id=@id
  GetByID(id int) (T, error)
 }
```

#### Using Generated Query

```go
u, err := generated.Query[User](db).GetByID(ctx, 123)
```

#### Field Helper Usage

```go
gorm.G[User](db).
  Where(generated.User.Age.Between(18, 65)).
  Find(ctx)
```

#### Association Operation Example

```go
gorm.G[User](db).
  Set(
    generated.User.Name.Set("alice"),
    generated.User.Pets.Create(generated.Pet.Name.Set("fido")),
  ).
  Create(ctx)
```

#### Generation Config Snippet

```go
var _ = genconfig.Config{
  OutPath: "generated",
  IncludeInterfaces: []any{"Query*"},
}
```

---

This concludes the core terminology necessary for mastering GORM CLI.


