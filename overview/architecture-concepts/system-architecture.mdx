---
title: "System Architecture"
description: "An overview diagram illustrating how GORM CLI, user-defined interfaces, models, configuration, and generated code integrate together. Clarifies the relationships between the code generator, field helpers, template interfaces, and GORM itself."
---

# System Architecture

## Understanding How GORM CLI Fits Together

The System Architecture page presents a comprehensive overview of how the various components of GORM CLI integrate and collaborate to deliver a powerful, type-safe code generation experience. It highlights the interactions between user-defined interfaces and models, configuration settings, the code generation engine, the resulting generated code, and how this all connects seamlessly with GORM itself.

---

## Why This Architecture Matters to You

Imagine you're crafting a robust Go application using GORM. You want to write expressive, compile-time safe queries with minimal boilerplate—but how do you bridge your business logic with database access cleanly, consistently, and safely? GORM CLI's architecture is designed precisely for that: it transforms your code annotations and model definitions into fully typed, intelligent query APIs and helpers.

Understanding this architecture helps you see the big picture and leverage the tool effectively, knowing how your interfaces, models, and generator configurations all contribute to your final code.

---

## Core Components of GORM CLI Architecture

### 1. User-Defined Interfaces

- **Purpose:** Define your SQL queries declaratively using Go interfaces with annotated SQL templates (comments).
- **Benefit:** Write your query intentions clearly once, and enjoy type-safe, generated implementations without manual SQL string handling.
- **Example:**
  ```go
  type Query[T any] interface {
    // SELECT * FROM @@table WHERE id=@id
    GetByID(id int) (T, error)
  }
  ```

### 2. User Models

- **Purpose:** Your Go struct models represent your database schema with explicit relationships (associations) and field types.
- **Benefit:** GORM CLI generates field helpers from these models which provide strongly typed predicate builders and association operations.
- **Example:**
  ```go
  type User struct {
    ID      uint
    Name    string
    Pets    []*Pet
    IsAdult bool `gorm:"column:is_adult"`
  }
  ```

### 3. Configuration (`genconfig.Config`)

- **Purpose:** Customize code generation behavior per package, including output paths, type mapping, inclusions/exclusions, and field helper customizations.
- **Benefit:** Fine-tune generation to precisely suit your project standards or special cases without modifying the CLI tool.
- **Example:**
  ```go
  var _ = genconfig.Config{
    OutPath: "generated",
    IncludeInterfaces: []any{"Query*"},
    FieldNameMap: map[string]any{
      "json": JSON{},
    },
  }
  ```

### 4. The Code Generator

- **Role:** The heart of GORM CLI that reads your interfaces, models, and config, then synthesizes:
  - Concrete implementations of query interfaces with type-safe SQL template bindings
  - Model-based field helpers for filtering, updating, and association operations
- **Outcome:** Generated Go code that is fluent, discoverable, and fully integrated with GORM's existing API.

### 5. Generated Code

- **Composition:**
  - **Query API Implementations:** Strongly typed methods implementing user-defined query interfaces with automatically bound parameters and SQL generation.
  - **Field Helpers:** Fluent predicate methods and association management helpers generated from your model definitions.

- **Benefit:** Drastically reduces boilerplate and potential runtime errors by shifting query validation and construction to compile time.

### 6. GORM Integration

- **How:** Generated code uses the official `gorm.io/gorm` package underneath to execute queries.
- **Benefit:** Leverages mature ORM capabilities while enhancing developer experience with type safety and expressiveness.

---

## Visualizing the Architecture

```mermaid
flowchart TD

    subgraph User Code
      Interfaces["User-Defined Query Interfaces"]
      Models["User Model Structs"]
      Config["Configuration (genconfig.Config)"]
    end

    subgraph GORM CLI
      Generator["Code Generator"]
    end

    subgraph Generated Code
      QueryAPI["Generated Query API Implementations"]
      FieldHelpers["Generated Model Field Helpers"]
    end

    subgraph ORM Layer
      GORM["GORM ORM (gorm.io/gorm)"]
      Database[("Database")]
    end

    Interfaces --> Generator
    Models --> Generator
    Config --> Generator
    Generator --> QueryAPI
    Generator --> FieldHelpers

    QueryAPI --> GORM
    FieldHelpers --> GORM
    GORM --> Database

    classDef userCode fill:#DDEEFF,stroke:#55AACC,stroke-width:2px;
    class User Code.Interfaces,User Code.Models,User Code.Config userCode;
    
    classDef genCode fill:#DFF5DD,stroke:#4CAF50,stroke-width:2px;
    class Generated Code.QueryAPI,Generated Code.FieldHelpers genCode;
    
    classDef orm fill:#FFF5DD,stroke:#FFC107,stroke-width:2px;
    class ORM Layer.GORM,ORM Layer.Database orm;

```

---

## Typical User Flow: From Your Code to Executable Queries

1. **Define your query interfaces** with rich comments describing your SQL templates.
2. **Write your Go model structs** to represent your database tables and relationships.
3. Optionally, **configure generation** using `genconfig.Config` to tailor output.
4. **Run the GORM CLI generator**, which parses your code and produces:
   - Implementation of your query interfaces providing fully typed query methods
   - Fluent model helpers for building filters, updates, and association commands
5. **Use the generated code** directly in your application for safe, expressive, and efficient data operations.
6. **At runtime, the generated code calls GORM internally**, which queries your database.

---

## Practical Tips for Success

- Keep your **query interfaces focused and descriptive**; clear method names linked to simple SQL templates enhance maintainability.
- Use **model associations carefully** so generated helpers accurately reflect your data relationships.
- Utilize the **configuration options** to exclude or include specific interfaces or structs, map special types, or direct output paths.
- Regularly **regenerate your code** after any interface or model change to keep the generated API consistent.

---

## Troubleshooting Common Issues

<AccordionGroup title="Troubleshooting Common Pitfalls related to System Architecture">
<Accordion title="Generated Code Does Not Match Interface Changes">
Ensure you regenerate the code after modifying query interfaces or models. The generator processes source code annotations at generation time—not at runtime.
</Accordion>
<Accordion title="Field Helpers Missing for Some Model Fields">
Check your struct tags and configuration map (e.g., `FieldNameMap`) to verify that custom or complex field types are supported by the generator.
</Accordion>
<Accordion title="Unexpected Query Behavior or SQL Errors">
Review the SQL templates in your interfaces carefully; the generator follows the template DSL strictly to produce the final queries. Validate placeholders and conditional clauses.
</Accordion>
</AccordionGroup>

---

## Next Steps

Explore the following documentation pages for practical guidance based on this architecture foundation:

- [System Architecture](#) - This page showing the big picture
- [Core Concepts & Terminology](/overview/architecture-concepts/core-concepts-terminology) - Understand fundamental terms inside GORM CLI
- [Installation & Setup](/overview/integration-getting-started/installation-setup) - How to install and set up the tool
- [Quickstart Workflow](/overview/integration-getting-started/quickstart-workflow) - Step-by-step to start generating and using code

Dive into real-world examples, configuration details, and advanced usage to leverage this architecture fully and streamline your development with GORM CLI.

---