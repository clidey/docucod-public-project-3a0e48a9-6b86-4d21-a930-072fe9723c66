---
title: "System Architecture Diagram"
description: "Visualize GORM CLI’s architecture: the user provides interface and model definitions, the CLI processes these with configurable generators, and outputs type-safe helpers and fluent APIs, seamlessly integrating with the GORM runtime. Understand the flow, key components, and code generation lifecycle through a mermaid diagram."
---

# System Architecture Diagram

## Visualizing the GORM CLI Architecture

Understanding the architecture of GORM CLI empowers you to maximize its value in your development workflow. This page walks you through a clear, step-by-step visualization of how GORM CLI transforms your interface and model definitions into powerful, type-safe query APIs and field helpers that integrate seamlessly with the GORM runtime.

---

### What Does This Architecture Show?

GORM CLI's architecture illustrates the journey your source code takes—from raw user inputs through a configurable, extensible code generation pipeline—culminating in generated Go code that dramatically improves type safety and productivity.

- **User Inputs:** Your Go interfaces decorated with raw SQL annotations and your model structs.
- **GORM CLI Generator:** Processes your inputs, applying configuration and templates.
- **Output Code:** Fluent, type-safe query APIs and field helpers tailored for seamless GORM integration.

This page focuses specifically on the major components and workflows within GORM CLI’s system, bridging your inputs directly to generated outputs.

---

### Core Components & Flow

```mermaid
flowchart TD

  subgraph User Environment
    Interfaces["User Go Interfaces\n(with SQL Templates)"]
    Models["User Model Structs"]
  end

  subgraph GORM CLI Generator
    Generator["GORM CLI Generator\n(Core Gen Logic)"]
    Config["Generation Configuration\n(genconfig.Config)"]
    Templates["Code Templates\n(p.go, gen.go templates)"]
  end

  subgraph Code Output
    Queries["Generated Query APIs\n(Type-safe Interface Impl)"]
    FieldHelpers["Generated Field & Association Helpers"]
  end

  subgraph Runtime Integration
    GORMRuntime["GORM Runtime\n(*gorm.DB & clauses)"]
  end

  Interfaces --> Generator
  Models --> Generator
  Config --> Generator
  Templates --> Generator

  Generator --> Queries
  Generator --> FieldHelpers

  Queries --> GORMRuntime
  FieldHelpers --> GORMRuntime

  note over Interfaces,Models: User writes Go code
  note over Generator: Processes inputs + config, applies templates
  note over Queries,FieldHelpers: Outputs auto-generated code
  note over GORMRuntime: Integrates with your DB operations

  classDef userInput fill:#f9f,stroke:#333,stroke-width:1px;
  classDef process fill:#9fcdff,stroke:#0366d6,stroke-width:2px;
  classDef output fill:#e8f0fe,stroke:#0366d6,stroke-width:2px;
  class Interfaces,Models userInput
  class Generator,Config,Templates process
  class Queries,FieldHelpers,GORMRuntime output

```

---

### User Journey & Value Delivered

#### 1. Author Interface & Model Code
You write Go interfaces with methods annotated by SQL templates, alongside your model structs representing your database schema.

#### 2. Configure Generation
Optionally customize which interfaces or structs to include/exclude, output directories, and field mappings using the `genconfig.Config` structure.

#### 3. Run the Generator
Invoke the CLI (`gorm gen -i ... -o ...`), which parses your code, applies templates, and generates Go source code:
- **Query APIs:** Type-safe implementations of your interface methods
- **Field Helpers:** Fluent, model-driven field and association setters and predicates

#### 4. Use the Generated Code
Incorporate the generated code in your application to write robust, compile-time checked queries and updates with GORM, reducing runtime errors and boosting developer efficiency.

---

### Practical Tips & Best Practices

- **Organize Your Interfaces & Models:** Keep compatible interfaces and models in the same packages or directories for simpler generation.
- **Leverage Configuration:** Use `Include`/`Exclude` filters and field mappings to control code scope and customize type handling.
- **Incremental Generation:** Rerun the generator as your application evolves, ensuring your query APIs stay in sync.
- **Combine Generated and Manual Code:** Generated code is safe to use alongside manually-written GORM code, providing a complementary, enhanced developer experience.

<Note>
For detailed usage examples, see the [Generating Type-Safe Query APIs](../features-quicktour/query-api-generation) and [Model-Driven Field & Association Helpers](../features-quicktour/model-field-helpers) pages.
</Note>

---

### Troubleshooting Common Scenarios

<AccordionGroup title="Common Questions & Troubleshooting">
<Accordion title="Why isn't my generated code reflecting certain interfaces or models?">
Make sure your `genconfig.Config` settings for `IncludeInterfaces` and `ExcludeInterfaces` or `IncludeStructs` and `ExcludeStructs` are configured correctly to include those definitions. The generator respects these filters strictly.
</Accordion>
<Accordion title="How do I customize the output directory for generated code?">
Set the `OutPath` property in your package-level `genconfig.Config` struct or specify the `-o` flag when running `gorm gen`.
</Accordion>
<Accordion title="What if my SQL templates cause generation errors?">
Ensure your SQL annotations in interface comments comply with the template DSL syntax, including correct use of placeholders (`@param`, `{{where}}` etc.). Use the generated error messages to pinpoint template issues.
</Accordion>
</AccordionGroup>

---

### Next Steps

- Dive deeper into how to write interfaces and models in [Defining Query Interfaces & Models](/getting-started/project-bootstrapping/writing-query-interfaces).
- Learn the generation workflow with hands-on instructions in [Running the Generator](/getting-started/project-bootstrapping/basic-generation-workflow).
- Explore how to leverage and customize generated APIs in your project in [Working with Generated APIs in Your Project](/guides/core-workflows/using-generated-apis).

Understanding this architecture is foundational to confidently using GORM CLI to build robust, maintainable, and type-safe database interactions.

---

### Additional Resources
- [What is GORM CLI?](../product-intro/what-is-gorm-cli) — product introduction
- [Value Proposition & Key Benefits](../product-intro/value-proposition) — why GORM CLI matters
- [Interface-Driven Query API Concepts](../../concepts/query-generation-templates/interface-driven-query-api) — background on query generation

---