---
title: "System Architecture"
description: "Understand how GORM CLI transforms Go interfaces and GORM models into type-safe APIs and helpers via a straightforward workflow. A mermaid diagram illustrates key components—from interface/model input, through CLI-driven generation, to seamless GORM integration—helping you visualize the product’s operational flow."
---

# System Architecture

## Visualizing How GORM CLI Transforms Your Code

The **System Architecture** page guides you through the streamlined flow of GORM CLI as it converts your Go query interfaces and GORM models into powerful, type-safe APIs. Understanding this architecture will help you grasp how your annotations and models become efficient, maintainable query code.

---

### Why This Matters

Imagine writing your database queries directly in Go interfaces with annotated SQL templates, and writing your data structures as GORM models. GORM CLI then acts as a dedicated engine that reads these inputs, processes the templates and models, and outputs ready-to-use, fully type-safe query APIs and field helpers.

This process eliminates error-prone raw SQL at runtime, boosts code readability, and improves developer productivity instantly.

---

## Overview: Core Components and Workflow

GORM CLI's architecture revolves around a few key elements connected through a simple, yet effective workflow:

- **Input Interfaces with SQL Templates**: You author Go interfaces describing your query methods, annotated with SQL templates in structured comments.

- **GORM Model Structs**: Your data models define the database schema and relationships.

- **Code Generation CLI**: The `gorm gen` command parses the interfaces and models, applies configuration, and generates concrete APIs.

- **Generated Code Outputs**: This includes type-safe query interfaces and helper structs for model fields and associations.

- **Seamless Integration with GORM ORM**: Generated code works naturally with the GORM ecosystem for reads and writes.

---

## Detailed Workflow

### 1. Input: Write Interfaces and Models

Users create Go interface types with SQL templates embedded in method documentation comments. Simultaneously, GORM struct models capture your database schema and entity relationships.

```go
// Query interface example
// SELECT * FROM @@table WHERE id=@id
GetByID(id int) (T, error)

// GORM model example
type User struct {
    gorm.Model
    Name string
    Age  int
}
```

### 2. CLI Invocation Triggers Parsing & Processing

Running `gorm gen -i ./examples -o ./generated` triggers the CLI's generator module. It:

- Parses Go source files, extracting interface methods and their SQL templates
- Parses struct types to understand fields and associations
- Applies configurations from any `genconfig.Config` present in the source

### 3. Code Generation

The generator compiles templates with the extracted SQL and struct metadata to produce:

- **Interface-driven Query APIs**: Methods that execute your annotated SQL in a type-safe manner, automatically binding parameters and returning well-typed results.

- **Model-driven Field Helpers**: Strongly typed fields and association helpers for fluent, safe query building and updates.

<br />

### 4. Output: Ready-to-Use Generated Go Code

This code leverages the existing GORM ORM foundation, enabling:

- Compile-time safety and discoverability for queries and updates
- Fluent API chaining on generated interfaces
- Support for complex associations and conditionals

### 5. Application Runtime Usage

Developers use the generated APIs seamlessly in their Go code, significantly reducing boilerplate, reducing risk of errors, and improving developer efficiency.

---

## Mermaid Diagram: System Architecture

```mermaid
flowchart TD

  subgraph Input
    Interfaces["Go Interfaces with SQL Templates"]
    Models["GORM Model Structs"]
  end

  CLICommand["`gorm gen` CLI Command"]

  subgraph Processing
    Parser["Code & AST Parser"]
    Config["genconfig.Config (optional)"]
    Generator["Code Generator"]
  end

  subgraph Output
    QueryAPIs["Generated Query Interfaces & Methods"]
    FieldHelpers["Generated Model Field & Association Helpers"]
  end

  subgraph Runtime
    GORMORM["GORM ORM Integration"]
    Application["User Application Code"]
  end

  Interfaces --> Parser
  Models --> Parser
  CLICommand --> Parser
  Parser --> Generator
  Config --> Generator
  Generator --> QueryAPIs
  Generator --> FieldHelpers
  QueryAPIs --> GORMORM
  FieldHelpers --> GORMORM
  GORMORM --> Application

  %% Styling
  classDef cluster fill:#f9f,stroke:#333,stroke-width:2px;
  class Input,Processing,Output,Runtime cluster;
```

This diagram maps the linear and logical progression from your source code and annotations to the final generated code that integrates with the GORM ecosystem.

---

## Practical Tips & Best Practices

- **Keep Your Interfaces Clean and Commented:** Ensure SQL templates in comments are valid and properly bind parameters.

- **Use `genconfig.Config` to Customize:** Control what interfaces or structs to include or exclude in generation for large projects.

- **Leverage Model Annotations:** Define associations, JSON mappings, or custom helpers to enrich generated code.

- **Run CLI Often:** Regenerate after model or interface changes to keep generated code in sync.

- **Start Simple, Then Expand:** Begin with basic queries and models, then use associations and advanced template directives as your project grows.

---

## Common Pitfalls and Troubleshooting

<AccordionGroup title="Common Challenges in Using GORM CLI System Architecture">
<Accordion title="Missing Generated Methods or Fields">
Check your interface method comments for correct SQL template syntax. Missing or malformed templates cause methods to be skipped in generation.
</Accordion>
<Accordion title="Incorrect or Unresolved Imports During Generation">
Ensure your input paths and module imports are correct. The generator resolves imports for type detection and helper mapping.
</Accordion>
<Accordion title="Unexpected Exclusion of Interfaces or Structs">
Verify your `genconfig.Config` filters. Inclusion/exclusion patterns can unintentionally filter out components.
</Accordion>
<Accordion title="Runtime Integration Errors with Generated Code">
Regenerate code each time models or interfaces change. Confirm your GORM ORM version is compatible and imports are correct.
</Accordion>
</AccordionGroup>

---

## Next Steps

Explore related documentation to deepen your understanding and start using GORM CLI effectively:

- [What is GORM CLI?](../introduction-value/product-overview) — Gain foundational understanding of the tool’s purpose and benefits.
- [Who Should Use GORM CLI?](../introduction-value/audience-usecases) — Identify if this tool fits your needs.
- [Quickstart & Typical Workflow](../../features-workflows/quickstart-workflow) — Hands-on guidance to generate your first code.
- [Generating and Using Model Field Helpers](../../core-workflows/guide-field-helpers) — Learn to use generated helpers to improve query fluency.

---

By mastering the system architecture, you'll unlock confident, smooth use of GORM CLI, transforming your Go database interaction to a safer, more productive experience.
