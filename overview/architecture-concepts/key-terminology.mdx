---
title: "Key Concepts and Terminology"
description: "Defines core terms such as Query Interface, Field Helpers, Association Operations, SQL Templates, Predicate API, and Model-Driven Generation. Helps users build intuition for the product vocabulary and what each term means in the context of GORM CLI workflows."
---

# Key Concepts and Terminology

Welcome to the foundational glossary for GORM CLI. This page introduces and clearly defines the core terms you'll encounter as you work with GORM CLI’s code generation workflow. Understanding these concepts will deepen your intuition and help you quickly navigate the product’s capabilities.

---

## Understanding GORM CLI Vocabulary

Whether you're writing query interfaces or generating helpers for your models, GORM CLI relies on a consistent, clear vocabulary. Here are the key terms you'll use when describing and working with generated code:

### Query Interface
A **Query Interface** is a Go interface that defines database query methods using annotated SQL templates in method comments. 

- **What it is:** An interface with method signatures accompanied by SQL or templated SQL in comments.
- **Purpose:** Enables you to write expressive, type-safe queries that the generator will convert to concrete implementation code.
- **User intent:** Define structured access to your data without manual SQL concatenation or error-prone query building.

Example snippet from a Query Interface:
```go
// Query defines methods to find or update users
type Query[T any] interface {
  // SELECT * FROM @@table WHERE id=@id
  GetByID(id int) (T, error)
  
  // UPDATE @@table
  // {{set}}
  //   {{if user.Name != ""}} name=@user.Name, {{end}}
  // {{end}}
  // WHERE id=@id
  UpdateUser(user User, id int) error
}
```

### Field Helpers
**Field Helpers** are strongly typed, model-driven code constructs generated from Go model structs.

- **What they are:** Objects representing a model’s database column, with methods to build SQL predicates and set/update values.
- **Purpose:** Provide a fluent, discoverable, and type-safe API for building queries and updates.
- **Example:** For a user model's `Age` field, you get `generated.User.Age.Eq(18)` (equals 18) or `generated.User.Age.Incr(1)` (increment by 1).

Example field helper usage:
```go
// Find users older than 18
users, err := gorm.G[User](db).Where(generated.User.Age.Gt(18)).Find(ctx)

// Update user's name
gorm.G[User](db).
  Where(generated.User.ID.Eq(1)).
  Set(generated.User.Name.Set("alice")).
  Update(ctx)
```

### Association Operations
GORM CLI generates helpers for managing **associations** (relationships) in your models like has-one, has-many, belongs-to, and many-to-many.

- **Supported operations:** Create, CreateInBatch, Update, Unlink, Delete
- **What Unlink means:** Removes foreign key links without deleting rows (e.g., setting FK to NULL).
- **Why important:** Provides compile-time safe ways to manage associated data along with parents, reducing risk of errors.

Example association operation:
```go
// Create user with new pet
gorm.G[User](db).
  Set(
    generated.User.Name.Set("alice"),
    generated.User.Pets.Create(generated.Pet.Name.Set("fido")),
  ).
  Create(ctx)

// Unlink pets from user
gorm.G[User](db).
  Where(generated.User.ID.Eq(1)).
  Set(generated.User.Pets.Unlink()).
  Update(ctx)
```

### SQL Templates
SQL Templates are annotated SQL statements embedded in interface method comments with a simple templating DSL to allow conditional, iterative, and parameterized query-building.

- **What:** Plain SQL lines combined with DSL directives like `{{where}}`, `@@table`, `@param`, `{{if}}`, `{{for}}`.
- **Purpose:** Write natural SQL queries that are parsed and converted into Go code implementing those queries.
- **Benefit:** You maintain close control over raw SQL while gaining automatic parameter binding and safety.

Example SQL template snippet:
```sql
SELECT * FROM @@table
{{where}}
  {{if user.Name != ""}} name=@user.Name {{end}}
  {{if user.Age > 0}} AND age=@user.Age {{end}}
{{end}}
```

### Predicate API
The **Predicate API** describes the set of methods on field helpers used to generate SQL conditions or expressions.

- **Examples:** `.Eq()`, `.Gt()`, `.Like()`, `.Between()`, `.IsNull()`, and more.
- **Use case:** Easily create where conditions without manual SQL string construction.

Example usage:
```go
db.Where(generated.User.Age.Gt(18).And(generated.User.Name.Like("%alice%")))
```

### Model-Driven Generation
This is the core design principle where your Go structs (models) steer the automatic generation of all field and association helpers.

- **What:** Models drive generation of strongly typed fields, namespaces, and relation APIs.
- **Why:** Avoids duplicative manual coding and ensures APIs are always in sync with your data model.
- **Outcome:** Fluent type-safe APIs for filtering, updating, ordering, and association management.

---

## How These Concepts Fit Together

To put it all in a workflow context:

- You define your **data models** as Go structs.
- You write **query interfaces** that describe the queries you want, using SQL templates.
- GORM CLI analyzes your code and generates:
  - Concrete implementations of query interfaces,
  - Model-driven **field helpers** to build predicates and setters,
  - **Association helpers** to support linked data operations.

Together, these components form a unified, type-safe API layer for your database operations using GORM.

---

## Practical Examples to Build Your Intuition

| Concept              | Description                              | Example Code Snippet                                  |
|----------------------|------------------------------------------|------------------------------------------------------|
| Query Interface      | Interface with templated SQL             | `GetByID(id int) (T, error)` with `SELECT * FROM @@table WHERE id=@id`|
| Field Helpers        | Generated field predicates & setters    | `generated.User.Age.Between(18, 65)`                 |
| Association Ops      | Actions on related models                 | `.Pets.Create(generated.Pet.Name.Set("fido"))`    |
| SQL Templates        | DSL-annotated raw SQL queries             | `{{where}} {{if user.Name != ""}} name=@user.Name {{end}} {{end}}`|
| Predicate API        | Methods for SQL condition building        | `.Eq()`, `.Gt()`, `.Like()`, `.IsNull()`             |
| Model-Driven Gen     | Using structs to generate helpers         | `User` struct drives `generated.User` field helpers  |

---

## Common Pitfalls & Best Practices

- **Always document your query interface methods with SQL templates.** Missing SQL comments mean no generated implementation.
- **Use `@@table` instead of hardcoding table names** to keep code generic and flexible.
- **Leverage model-driven helpers where possible** rather than constructing raw SQL manually.
- **Be explicit and consistent with method signatures** to ensure generated code compiles without surprises.
- **Understand association semantics for unlink versus delete.** Use unlink to break links without deletion.

---

## Next Steps

- Explore the [Product Purpose and Value](../product-intro-value/product-purpose) page to learn why these concepts matter.
- Review [Writing Type-Safe Queries from Interfaces](../../guides/core-workflows/writing-type-safe-queries) to deepen your use of Query Interfaces and SQL Templates.
- Learn how to apply Field Helpers practically with [Using Field Helpers for Filters & Updates](../../guides/core-workflows/using-field-helpers).
- Understand relational management with [Association Operations](../../guides/core-workflows/association-operations).

---