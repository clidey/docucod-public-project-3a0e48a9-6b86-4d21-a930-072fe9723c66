---
title: "System Architecture Overview"
description: "A high-level explanation of how GORM CLI operates, supported by a simple mermaid diagram: from code and model input, through code generation, to developer-facing output. Shows core components, generation workflow, and the relationship between user code, the generator, and GORM."
---

# System Architecture Overview

## Unlock the Power Behind GORM CLI

GORM CLI transforms your Go projects by generating type-safe, intuitive database interfaces derived directly from your codebase. This page walks you through the high-level architecture that makes this possible—from your input models and interfaces, through the generation engine, to the developer-friendly APIs you use every day.

### Why It Matters

Understanding GORM CLI's architecture empowers you to align your development workflow with the generator's design:

- **Maximize productivity** by knowing how your code triggers generation
- **Optimize configuration** by understanding where to influence behaviors
- **Troubleshoot effectively** when output deviates from expectations

## How GORM CLI Works: A Broad View

At its core, GORM CLI is a code generator that takes your Go model structs and query interfaces and produces fluent, type-safe APIs that integrate seamlessly with GORM.

### Input — Your Code Forms The Foundation

You write two key things:

- **Model structs:** These define your database schema with types and relationships
- **Query interfaces:** These annotated interfaces contain SQL templates expressing how to query your data

This declarative input lays out your domain and how you want to interact with it.

### Processing — The Generator Transforms Your Code

The GORM CLI generator parses your code and:

- Analyzes models to build **field helpers** — strongly typed predicates and setters for filters and updates
- Reads query interfaces with their SQL template comments to produce **type-safe query methods**
- Resolves associations (has one/many, belongs to, many2many) into **association helpers**

### Output — Developer-Facing APIs

The result is a set of generated Go packages with:

- **Fluent query builders** that let you express filters and updates with compile-time safety
- **Association operations** to create, update, unlink, or delete related objects conveniently
- **Template-based query methods** reflecting your custom SQL logic

All of this integrates naturally with your existing GORM DB instances.

## High-Level System Architecture

```mermaid
flowchart TD
  A["Developer Source Code"] -->|Provide| B["GORM CLI Generator"]
  B -->|Generate| C["Generated APIs & Helpers"]
  C -->|Used in| D["Go Application with GORM"]

  subgraph Input
    A
  end

  subgraph Generation
    B
  end

  subgraph Output
    C
    D
  end

  %% Label Descriptions
  click A "examples/models/user.go" "User Models source"
  click B "internal/gen" "Generator implementation"
  click C "examples/output" "Generated code output"
  click D "README.md" "Usage with GORM"

  classDef inputStyle fill:#f9f,stroke:#333,stroke-width:2px;
  classDef genStyle fill:#bbf,stroke:#333,stroke-width:2px;
  classDef outputStyle fill:#bfb,stroke:#333,stroke-width:2px;

  class A inputStyle
  class B genStyle
  class C,D outputStyle

  %% Explanatory Notes
  note right of A:::inputStyle
    Models define structure,
    Query interfaces
    define fetch/update logic
  end

  note right of B:::genStyle
    Parses code to
    generate type-safe
    query and field helpers
  end

  note right of C:::outputStyle
    Fluent APIs for
    predicates, setters,
    and association handling
  end

  note right of D:::outputStyle
    Integrate into
    your Go project
    with GORM DB
  end
```

## Core Components

| Component               | Role                                                                                      |
|------------------------|-------------------------------------------------------------------------------------------|
| **Developer Source**    | Your declared Go structs and SQL-annotated interfaces forming the specification          |
| **Generator Engine**    | The GORM CLI tool that scans your code and produces the generated source code              |
| **Generated Code**      | Fluent, type-safe Go packages exposing query methods, field helpers, and association helpers|
| **Integration Layer**   | Your application importing generated packages, interacting with GORM for runtime data access|

## Developer Workflow

1. **Define Models & Queries**
   - Write your domain models with GORM tags and optional `gen` annotations
   - Define query interfaces with SQL templates embedded in comments

2. **Run GORM CLI Generator**
   - Execute `gorm gen` with configuration if needed
   - The generator reads source files and emits the corresponding API code

3. **Use Generated APIs in Code**
   - Import generated packages
   - Write type-safe queries and updates leveraging field helpers and associations

4. **Build & Run**
   - Build your project as usual
   - Enjoy compile-time guarantees and expressive database operations

## Practical Example of Flow

```plaintext
+-----------------------+
| models/user.go        |
| - User struct         |
| - Associations        |
+-----------+-----------+
            |
            V
+-----------------------+
| examples/query.go      |
| - Query interface      |
| - SQL templates       |
+-----------+-----------+
            |
            V
+-----------------------+
| GORM CLI Generator     |
| - Parses models &      |
|   queries             |
| - Generates code      |
+-----------+-----------+
            |
            V
+-----------------------+
| examples/output        |
| - User helpers         |
| - Query implementations|
+-----------+-----------+
            |
            V
+-----------------------+
| Go application         |
| - Calls generated APIs |
| - Runs with GORM DB    |
+-----------------------+
```

## Best Practices to Align with Architecture

- **Organize your models and queries clearly** in the same or neighboring packages to ease generator discovery.
- **Annotate query interfaces richly** with SQL templates to leverage full generation capabilities.
- **Customize generation config** (`genconfig.Config`) to control output paths, inclusions, and field mappings.
- **Leverage associations consistently** in your models to get full support for related data operations.

## Troubleshooting & Tips

<AccordionGroup title="Common Issues and Solutions">
<Accordion title="Generated Code Not Found or Incomplete">
Ensure you've run the generator with the correct input directories and config. Verify your model and query files are included or not excluded unintentionally.
</Accordion>
<Accordion title="Association Helpers Missing">
Check that your model associations are correctly declared with GORM tags. The generator depends on these to create helpers.
</Accordion>
<Accordion title="Template Queries Not Working as Expected">
Review the SQL template syntax carefully; missing directives or parameters can cause generation errors.
</Accordion>
<Accordion title="Type Mismatches on Generated Fields">
Confirm that your config includes necessary `FieldTypeMap` entries for custom or nullable types.
</Accordion>
</AccordionGroup>

---

This architectural overview clarifies the journey from your annotated code to powerful, type-safe data access APIs. By understanding this foundation, you can harness GORM CLI to build robust and maintainable Go applications effortlessly.


---

## Next Steps

Continue your learning with these related pages:

- [What is GORM CLI?](overview/intro-product-value-core-concepts/what-is-gorm-cli) — Understand GORM CLI's purpose and core capabilities
- [Key Features & Value Proposition](overview/intro-product-value-core-concepts/key-features-and-value) — Explore value-driven features in detail
- [Quickstart & Main Workflow](overview/architecture-workflows-integration/quickstart-and-primary-workflow) — See how to get started with code generation quickly

Explore these to expand from architecture into hands-on usage and configuration.


---

## Source Links

- [Model Definitions Example](examples/models/user.go)
- [Query Interfaces Example](examples/query.go)
- [Generator Implementation](internal/gen)
- [Generated Code Output Sample](examples/output)


<Check>
Make sure to regularly review your generation config and source definitions to keep your generated APIs aligned with your evolving domain model.
</Check>


---