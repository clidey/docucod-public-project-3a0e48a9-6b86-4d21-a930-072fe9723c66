---
title: "Who Should Use GORM CLI? — Use Cases & Integrations"
description: "Defines the target audience such as Go developers using GORM, projects requiring type-safe database queries, and teams seeking to streamline query authoring and maintenance. Describes integration touchpoints with GORM, and outlines use case scenarios that benefit most from the CLI."
---

# Who Should Use GORM CLI? — Use Cases & Integrations

## Unlock Fluent, Type-Safe Database Operations in Your Go Projects

GORM CLI is designed specifically for Go developers who use GORM and want to elevate their database interactions with type-safe, compile-time checked, and discoverable APIs. Whether you are building new applications or enhancing existing ones, GORM CLI streamlines query authoring, maintenance, and integration.

---

## Target Audience

- **Go Developers Using GORM:** If you already leverage GORM for your ORM needs, GORM CLI fits naturally into your workflow, extending GORM’s capabilities with generated code.

- **Projects Requiring Type-Safe Database Queries:** Teams prioritizing compile-time safety, reduced runtime errors, and easier refactoring benefit immensely.

- **Teams Focused on Productivity and Maintainability:** GORM CLI reduces boilerplate and manual query management, enabling teams to write and evolve queries faster and more reliably.

- **Users Needing Clean Separation Between Query Definitions and Implementations:** By defining SQL templates in interfaces, teams enjoy modular, testable query specifications.

---

## Why GORM CLI Integrates Seamlessly with GORM

GORM CLI’s generated APIs and helpers build directly on GORM’s fluent APIs and conventions:

- **Type-Safe Query Interfaces:** Define your queries as Go interfaces with annotated SQL templates. GORM CLI generates concrete implementations that integrate seamlessly with `*gorm.DB`, preventing common mistakes.

- **Model-Driven Field Helpers:** Your model structs generate predicate and setter helpers for fields and associations, making filter, update, and association logic clean and idiomatic.

- **Association Operation Support:** GORM CLI supports complex association behaviors (has one, has many, belongs to, many2many), enabling create, update, unlink, and delete operations with compile-time safety.

- **Context-Aware Generation:** The CLI tool respects context injection and idiomatic Go error handling.

- **Configuration-Driven:** Customizable via `genconfig.Config` for inclusion/exclusion filters, output path overrides, and type mapping to suit your project conventions.

---

## Use Case Scenarios Where GORM CLI Excels

- **Rapid Query API Development:** Quickly define domain-specific queries as interfaces and generate robust, type-safe APIs.

- **Refactoring & Scaling Existing GORM Projects:** Extract existing queries into interfaces; generate and enforce consistent patterns across large codebases.

- **Building Modular Microservices:** Encapsulate database logic in generated interfaces, enabling clear contracts in microservice ecosystems.

- **Complex Filter & Update Logic:** Leverage template-based SQL DSL to handle conditional, dynamic queries with type-safe parameter binding.

- **Advanced Associations Handling:** Execute complex operations on relations safely without verbose or error-prone manual code.

- **Teams Needing Strong Type Guarantees:** Replace fragile string-based queries with compiler-checked API methods to catch bugs early.

---

## Integration Touchpoints and Workflow

The GORM CLI fits naturally into your development lifecycle, cycling user code and generated code:

1. **Define Go Interfaces with SQL Templates:** Using Go interfaces in your package, annotate query methods with SQL comments using GORM CLI’s templating DSL.

2. **Define Your Model Structs:** Models define database schema and associations.

3. **Run the Generator:** Use the CLI command `gorm gen -i ./path -o ./generated` to scan input, apply filters/overrides, and emit generated Go files.

4. **Use Generated APIs:** Import generated packages and leverage type-safe query methods and field helpers directly with your `*gorm.DB` instances.

5. **Iterate:** Modify interfaces/models to evolve queries, and regenerate code safely and efficiently.

---

## Real-World Example

Imagine a team building a social app needing complex user queries:

```go
// UserQuery interface with typed SQL in comments
type UserQuery[T any] interface {
  // SELECT * FROM @@table WHERE id=@id
  GetByID(id int) (T, error)

  // SELECT * FROM @@table WHERE @@column=@value
  FilterWithColumn(column string, value string) (T, error)

  // Dynamic query with conditional filter
  // SELECT * FROM @@table
  // {{where}}
  //   {{if @user.Name != ""}} name=@user.Name {{end}}
  // {{end}}
  Search(user User) ([]T, error)
}
```

After generation, the team uses:

```go
genUserQuery := generated.UserQuery[models.User](db)
user, err := genUserQuery.GetByID(ctx, 42)  // compile-time checked
users, err := genUserQuery.Search(ctx, models.User{Name: "alice"})
```

This reduces manual SQL and ensures queries conform to models and database schema.

---

## Benefits at a Glance

- **Compile-Time Type Safety:** Catch errors during build rather than runtime.
- **Reduced Boilerplate:** Let generator produce complex query code.
- **Maintainable Queries:** Centralize query logic in Go interfaces with strong typing.
- **Productivity Increase:** Faster iteration with template-driven SQL and automatic helper generation.
- **Seamless GORM Compliance:** Maintain idiomatic Go patterns and GORM compatibility.

---

## Troubleshooting & Considerations

- Ensure your queries are properly annotated in interface comments for generation.
- Use configuration files (`genconfig.Config`) to control which interfaces and structs are included/excluded.
- Regenerate code after any interface or model changes to keep code in sync.
- Generated code assumes Go 1.18+ with generics support.

---

## Next Steps

- Explore the [Quickstart & Primary Workflow](/overview/architecture-workflows-integration/quickstart-and-primary-workflow) for how to set up and run the generator smoothly.
- Learn details of [System Architecture Overview](/overview/architecture-workflows-integration/system-architecture) to deepen understanding of how GORM CLI operates internally.
- See [Use the Generated APIs](/getting-started/first-usage-configuration/using-generated-code) for practical coding examples.

---

For detailed reference and installation instructions, visit the [GORM CLI GitHub repository](https://github.com/go-gorm/cli).