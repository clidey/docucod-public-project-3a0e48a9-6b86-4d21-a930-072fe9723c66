---
title: "Quick Feature Overview"
description: "Scan the major features of GORM CLI—from type-safe query API generation, model-driven field helpers, rich association support, to DSL-powered templates and configurable code generation. Each feature is explained briefly for rapid orientation."
---

# Quick Feature Overview

Discover the major capabilities of GORM CLI — a powerful tool designed to elevate your Go projects by generating type-safe query APIs and model-driven field helpers that seamlessly integrate with GORM. This page provides a rapid orientation on key features, helping you grasp what GORM CLI brings to your data access layer and how it propels productivity and code safety.

---

## Unlock Type-Safe Query APIs from Interfaces

At the heart of GORM CLI is automated generation of **interface-driven, type-safe query APIs**. By simply defining Go interfaces with SQL templates embedded in method comments, you get concrete implementations that provide fluent, compile-time safe database querying.

- Write methods with **SQL templates** and parameter binding.
- Get **auto-generated implementations** with type safety, reducing runtime errors.
- Use **context-aware method signatures** for seamless integration.

### Example
```go
// Define interface with SQL template in comment
// SELECT * FROM @@table WHERE id=@id
GetByID(id int) (T, error)
```

Generated usage:
```go
user, err := generated.Query[User](db).GetByID(ctx, 123)
```

---

## Model-Driven Field Helpers for Expressive Queries

GORM CLI generates rich field helpers based on your Go model structs. These helpers simplify building filters, updates, ordering, and managing associations with a strongly typed, discoverable API.

- Supports fundamental Go types and common database types.
- Enables expressive predicates like `Eq()`, `Like()`, `Between()`, and more.
- Facilitates zero-value updates and expression-based setters.

### Example
```go
// Predicate examples
generated.User.ID.Eq(1)                 // WHERE id = 1
generated.User.Name.Like("%jinzhu%") // WHERE name LIKE '%jinzhu%'

// Update example
gorm.G[User](db).
  Where(generated.User.Name.Eq("alice")).
  Set(generated.User.Age.Incr(1)).
  Update(ctx)
```

---

## Rich Association Support with Compile-Time Safety

Managing related data is effortless with GORM CLI’s automatically generated association helpers. They handle various relationship types—`belongs to`, `has one`, `has many`, and `many2many`—with direct support for common operations.

Supported operations:
- **Create**, **CreateInBatch**: Add new related records and link them automatically.
- **Update**: Modify associated data with optional filtering.
- **Unlink**: Remove association links without deleting data.
- **Delete**: Remove associated rows or join table entries as appropriate.

### Semantics by association type:
- *Belongs to*: Unlink clears parent FK, delete removes associated rows.
- *Has one/has many*: Unlink clears child FK, delete removes child rows.
- *Many2many*: Unlink/delete remove join rows only; actual records remain.

### Example
```go
// Create user and pets
gorm.G[User](db).
  Set(
    generated.User.Name.Set("alice"),
    generated.User.Pets.Create(generated.Pet.Name.Set("fido")),
  ).
  Create(ctx)

// Unlink a pet
gorm.G[User](db).
  Where(generated.User.ID.Eq(1)).
  Set(generated.User.Pets.Unlink()).
  Update(ctx)
```

---

## Template-Driven SQL Queries for Flexibility and Safety

Write expressive SQL templates inside interface comments using GORM CLI’s SQL Template DSL. This system safely binds Go parameters into dynamic SQL, enabling complex conditional logic, iteration, and dynamic updates without sacrificing type safety.

Key directives:
- `@@table`, `@@column`: Dynamic table and column injection.
- `@param`: Parameter binding with Go variables.
- `{{where}}` and `{{set}}`: Build conditional clauses.
- `{{if}}`, `{{for}}`: Embed logic inside queries.

### Example
```go
// SELECT * FROM @@table
// {{where}}
//   {{if user.Name != ""}} name=@user.Name {{end}}
// {{end}}
SearchUsers(user User) ([]T, error)
```

Generated methods handle parameter binding and produce safe, efficient SQL.

---

## Configurable and Extensible Code Generation

Tailor generation to your project’s needs with optional configuration via `genconfig.Config`. Control output paths, include or exclude specific interfaces and structs, customize field helper mappings, and fine-tune generation behavior.

- Supports **field type and name mapping** for custom helpers (e.g., JSON handlers).
- Enables **whitelisting/blacklisting** of interfaces and struct types.
- Configurations apply package-wide or at file-level granularity.

### Example
```go
var _ = genconfig.Config{
  OutPath: "examples/output",
  FieldNameMap: map[string]any{
    "json": JSON{},
  },
  IncludeInterfaces: []any{"Query*"},
}
```

---

## Why You Should Care

These features combine into a solution that delivers:
- **Compile-time safety**, preventing SQL errors before runtime.
- **Improved developer productivity** with discoverable APIs.
- **Seamless GORM integration** while enhancing flexibility and control.
- **Simplified management of associations and complex queries**.

With GORM CLI, you spend less time debugging SQL and more on building features.

---

## Next Steps

- Explore the [Getting Started guides](/getting-started/setup-basics/installation) to install and run GORM CLI.
- Dive into the [Core Concepts & Terminology](/overview/architecture-concepts/core-concepts-terminology) to align your understanding.
- See hands-on usage in [Primary Use Cases](/overview/product-intro/primary-use-cases).
- Customize your generation with detailed examples from [Customizing Code Generation](/guides/advanced-usage/customizing-generation).

Make your GORM usage safer, faster, and more expressive today with GORM CLI.

---

## References

- [What Is GORM CLI?](/overview/product-intro/what-is-gorm-cli)
- [Value Proposition & Target Audience](/overview/product-intro/value-proposition-and-audience)
- [Primary Use Cases](/overview/product-intro/primary-use-cases)
- [Template DSL Guide](/guides/advanced-usage/template-dsl-guide)
- [Integration with GORM](/overview/architecture-concepts/integration-with-gorm)


---

## Quick Recap Table

| Feature                 | What It Does                                      | User Benefit                              |
|-------------------------|-------------------------------------------------|------------------------------------------|
| Type-Safe Query APIs    | Generate robust query methods from interfaces    | Safe, discoverable query methods          |
| Model-Driven Field Helpers | Create predicates, setters, and query builders  | Fast and accurate data filtering & updates |
| Association Support      | Manage linked models with create/update/unlink/delete | Simplified relational data workflows       |
| Template SQL DSL         | Embed safe SQL templates with logic               | Flexible, powerful custom query generation |
| Configurable Generation  | Customize output, mappings, filtering             | Fits any project’s needs                     |

---

By focusing on these key features, this page helps you understand the core strengths that will transform how you interact with databases in Go.

---

## Code Snippets Summary

```go
// Query interface example
GetByID(id int) (T, error)

// Predicate example
generated.User.Name.Like("%jinzhu%")

// Association example
generated.User.Pets.Create(generated.Pet.Name.Set("fido"))

// Template DSL example
// SELECT * FROM @@table
// {{where}}
//   {{if user.Name != ""}} name=@user.Name {{end}}
// {{end}}
```

Use these snippets as a stepping stone towards implementing robust and maintainable data access in your GORM projects.
