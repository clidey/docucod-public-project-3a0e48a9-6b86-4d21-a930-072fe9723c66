---
title: "What is GORM CLI?"
description: "An introduction to GORM CLI, describing its purpose as a code generator for GORM projects that produces type-safe, fluent APIs and model-driven helpers. This page positions the tool in the ecosystem and articulates GORM CLI’s value, enabling users to assess relevance for their Go development needs."
---

# What is GORM CLI?

## Unlock Type-Safe, Fluent APIs for Your GORM Projects

GORM CLI is a powerful code generation tool designed specifically for Go developers using the GORM ORM. It automatically produces type-safe, fluent APIs and model-driven helpers that streamline database interaction, improve code safety, and accelerate development.

### Why GORM CLI Matters

- **Eliminate Boilerplate:** Automatically generate query APIs and helpers based on your own models and interface definitions, cutting down on repetitive coding.
- **Ensure Compile-Time Safety:** With generated type-safe methods, avoid common runtime errors due to SQL mismatches or bad parameter usage.
- **Boost Development Speed:** Write interface-driven SQL templates once and get complete, ready-to-use APIs and helpers.
- **Model-Driven Helpers:** Benefit from helpers reflecting your structs’ fields and associations, making filters, updates, and relational operations seamless.

### Who Should Use This?

GORM CLI is ideal for Go developers and teams who:

- Build complex, data-centric applications with GORM
- Want fluent, discoverable, and maintainable database code
- Need strong compile-time guarantees to reduce bugs
- Prefer a model-centric approach to database operations


---

## What is GORM CLI?

In essence, GORM CLI is a **code generator** that creates two primary types of code artifacts:

1. **Type-safe Query APIs**: Generated from Go interface definitions annotated with SQL templates, these APIs provide strongly typed and readable functions to perform database queries.
2. **Model-driven Field Helpers**: Based on your Go struct models, these helpers facilitate constructing filters, updates, and working with associations intuitively and safely.

This dual-generation approach ensures your database interactions are both fluent and checked by the compiler, enabling better developer ergonomics and reduced runtime errors.

Unlike handwritten query code, GORM CLI automatically reflects your model structures and query intentions, eliminating repetitive manual coding while maintaining full control through interface design.


---

## Core Purpose and Ecosystem Position

GORM CLI fills a crucial gap in the Go + GORM ecosystem: it **connects your static model types and SQL queries** through automated generation to deliver **fluent, type-safe APIs** that integrate seamlessly with `gorm.io/gorm`.

By adopting GORM CLI, you leverage idomatic Go interfaces and SQL templating alongside your models to get expressive, maintainable data access code without losing the power or expressiveness of raw SQL.

This tool sits alongside GORM as a complementary utility enhancing developer productivity and code quality.


---

## Key Features & Capabilities

- **Interface-Driven Query Code Generation**  
  Write Go interfaces with embedded SQL templates, and GORM CLI produces concrete implementations with type-safe query methods.

- **Model-Driven Field Helper Generation**  
  Generate strongly typed field helpers from your structs (`field.String`, `field.Number[int]`, `field.Struct[OtherModel]`, `field.Slice[OtherModel]`) to build filters, update setters, and association handlers.

- **Association Operations Fully Supported**  
  Create, batch create, update, unlink, and delete associated records with compile-time guarantees respecting model relationships (`has one`, `has many`, `belongs to`, `many2many`, including polymorphic).

- **Customizable Generation via Config**  
  Tune generation outputs through package-level `genconfig.Config` with options like output directories, inclusion/exclusion patterns, and custom field mappings.

- **Template SQL Domain-Specific Language (DSL)**  
  Write SQL with directives like `@@table`, `@@column`, `@param`, and Go conditional blocks (`{{if}}`, `{{for}}`) inside comments to declaratively define queries.

- **Seamless Integration With GORM**  
  Generated code returns GORM builders and integrates naturally with GORM’s query chains for further composability.


---

## Real-World Examples

### From Interface to Generated Query Method

Define your query interface with embedded SQL:

```go
// Query interface with SQL template comment
type Query[T any] interface {
  // SELECT * FROM @@table WHERE id=@id
  GetByID(id int) (T, error)

  // where("name=@name AND age=@age") - partial template
  FilterByNameAndAge(name string, age int)
}
```

Then generate code:

```bash
gorm gen -i ./examples -o ./generated
```

Finally, call the fluent, type-safe API:

```go
user, err := generated.Query[User](db).GetByID(ctx, 123)
users, err := generated.Query[User](db).FilterByNameAndAge("Alice", 30).Find(ctx)
```

### Model-Driven Field Helpers for Fluent Filters & Updates

For struct fields such as `User.Name string` and `User.Age int`, GORM CLI generates helpers:

```go
generated.User.Name.Like("%jinzhu%")           // WHERE name LIKE '%jinzhu%'
generated.User.Age.Between(18, 65)               // WHERE age BETWEEN 18 AND 65
gorm.G[User](db).Where(generated.User.Name.Eq("alice")).Update(ctx)
```

### Powerful Association Operations

Handle associations directly with syntactic helpers:

```go
gorm.G[User](db).
  Set(
    generated.User.Name.Set("alice"),
    generated.User.Pets.Create(generated.Pet.Name.Set("fido")),
  ).
  Create(ctx)

// Update a pet named "fido" linked to user with ID=1
gorm.G[User](db).
  Where(generated.User.ID.Eq(1)).
  Set(
    generated.User.Pets.Where(generated.Pet.Name.Eq("fido")).Update(generated.Pet.Name.Set("rex")),
  ).
  Update(ctx)
```


---

## Why Should You Care?

### Benefits

- **Compile-Time Query Safety**: Your queries and updates are validated via Go’s type system, reducing runtime SQL errors.
- **Productivity Gains**: Generate fully typed APIs instead of hand-writing conversions and boilerplate SQL wrappers.
- **Maintainability**: Changes in models or query interfaces propagate automatically to generated code, keeping implementations in sync.
- **Expressiveness**: Write raw-SQL-like templates with Go-friendly syntax and embed complex logic without sacrificing readability.
- **Full GORM Ecosystem Compatibility**: Generated code integrates smoothly with existing GORM workflows.

### Common Use Cases

- Building backend services with complex domain models requiring safe, clean data access
- Teams enforcing strong contract adherence in data layer code via typed interfaces
- Projects needing flexible SQL templating combined with object-oriented field helpers
- Applications with rich associations benefitting from automated CRUD operations with linked records

### Before and After

| Without GORM CLI                            | With GORM CLI                            |
|-------------------------------------------|-----------------------------------------|
| Handwritten SQL strings prone to errors   | Generated safe, typed query methods     |
| Manual mapping between structs and queries| Auto-generated helpers aligned to models|
| Repetitive and error-prone boilerplate   | Single source of truth in interfaces    |
| Difficult maintenance on updates/change   | Changes reflected by regeneration       |


---

## Getting Started Preview

### Quick Start Steps

1. **Define your Go interfaces** with SQL templates and your data models in the same or nearby package.
2. **Run the generator CLI** with your interfaces as input and specify an output directory.
3. **Use the generated packages in your code**, calling type-safe, fluent query and update methods.

### Prerequisites

- Go 1.18 or later (for generics support)
- Existing GORM project with models defined as Go structs

### Next Steps

- Explore the [Quickstart & Primary Workflow](https://docs.example.com/overview/architecture-workflows-integration/quickstart-and-primary-workflow) to get hands-on
- Learn how to customize generation with [genconfig.Config](https://docs.example.com/guides/advanced-usage-best-practices/customizing-generation)
- Discover how to work with [Field Helpers](https://docs.example.com/guides/using-generated-apis/field-helpers-basics) and [Associations](https://docs.example.com/guides/using-generated-apis/working-with-associations)


---

## Helpful Tips

- Organize your query interfaces reflecting domain logic; the generator will handle the rest.
- Use `genconfig.Config` to tailor generated code precisely to your project structure.
- Combine generated APIs with GORM’s flexibility for complex query composition.
- Explore and leverage template DSL directives for crafting dynamic queries efficiently.


---

For more details, visit the [GORM CLI GitHub repository](https://github.com/go-gorm/cli) to review examples, source code, and installation instructions.


---

### Code Illustration: Simple Flow from Interface to Usage

```go
// Define interface
// SELECT * FROM @@table WHERE id=@id
interface Query[T any] {
  GetByID(id int) (T, error)
}

// Generate with CLI
$ gorm gen -i ./models -o ./generated

// Use generated API
user, err := generated.Query[User](db).GetByID(ctx, 42)
```

This pattern empowers your Go programs with intuitive, safe, and maintainable data access layers.
