---
title: "Quick Start & Typical Workflow"
description: "Follow a step-by-step path: define your interfaces and models, run the generator, and harness the new API. Designed for users who want value quickly, this guide streamlines first-time setup and integration into your repo."
---

# Quick Start & Typical Workflow

Welcome to your streamlined path for leveraging GORM CLI to rapidly generate type-safe query APIs and model-driven helpers for your GORM projects. This guide walks you through a clear, step-by-step workflow: from defining your interfaces and models, running the generation command, to using the freshly generated code in your repository.

---

## Why This Guide Matters

Jumpstart your journey with GORM CLI by focusing on what you want to achieve: safe, fluent, and maintainable database operations generated directly from your Go code. This walkthrough eliminates guesswork and setup barriers, allowing you to unlock the full benefits of automated code generation quickly and confidently.

---

## Step 1: Define Your Query Interfaces and Models

The foundation of GORM CLI’s generation process lies in your Go interfaces, annotated with SQL templates, and your data models represented as Go structs.

### Create Your Interface with Embedded SQL

Write interfaces where each method’s comment contains a raw SQL template or DSL that references your model’s table and parameters.

```go
// examples/query.go
package examples

type Query[T any] interface {
  // SELECT * FROM @@table WHERE id=@id
  GetByID(id int) (T, error)

  // where("name=@name AND age=@age")
  FilterByNameAndAge(name string, age int)

  // Additional queries using templating ...
}
```

This interface defines methods your generated code will implement, ensuring type-safe queries with parameter binding and compile-time validation.

### Define Your Models

Ensure your models are defined as Go structs with exported fields. Use struct tags sparingly to inform generation (e.g., JSON or custom field helpers).

```go
// examples/models/user.go
package models

type User struct {
  gorm.Model
  Name string
  Age  int
}
```

---

## Step 2: Run the Generator Command

With your interfaces and models ready, execute the CLI command to generate your code artifacts.

```bash
gorm gen -i ./examples -o ./generated
```

- `-i` points to the directory containing your interfaces and models
- `-o` specifies where generated files will be placed, defaulting to `./g`

The command analyzes your files, processes structured SQL templates, and creates fluent, type-safe APIs alongside field helper declarations.

<Tip>
Use a specific output directory (`-o`) inside your project, e.g., `./generated`, to keep generated code organized and separate from handwritten code.
</Tip>

---

## Step 3: Explore and Use Generated Code

The generation produces two key assets:

- **Query APIs**: Concrete implementations of your interfaces exposing strongly typed methods.
- **Field Helpers**: Model-driven helpers for building expressive predicates, updates, and association operations.

### Example: Query Usage

```go
// SELECT * FROM users WHERE id=123
u, err := generated.Query[User](db).GetByID(ctx, 123)

// SELECT * FROM users WHERE age > 18
users, err := gorm.G[User](db).Where(generated.User.Age.Gt(18)).Find(ctx)
```

These generated methods enable fluent and error-resistant query construction, eliminating common pitfalls in raw SQL usage.

### Example: Model Field Helpers

Field helpers simplify predicates and updates:

```go
gorm.G[User](db).
  Where(generated.User.Name.Eq("alice")).
  Set(
    generated.User.Age.Incr(1),        // Increment age by 1
    generated.User.Status.Set("active"),
  ).
  Update(ctx)
```

---

## Understanding the Typical Workflow

This section expands on the user journey by laying out the overarching flow:

1. **Write your Go interfaces and model structs** with embedded SQL templates.
2. **Run `gorm gen` CLI** to generate code reflecting your definitions.
3. **Use the generated fluent APIs and helpers** in your project to perform queries, updates, and associations with compile-time safety.
4. **Iterate on your interfaces/models** and regenerate as your application evolves.

This cycle supports clean code maintenance and safe database interaction.

<Tip>
While your first interfaces can be simple, you can leverage advanced templating constructs (`{{where}}`, `{{set}}`, conditionals, and loops) to handle complex queries as your needs grow.
</Tip>

---

## Practical Tips for Success

- **Start small**: Define basic queries and models to verify generation works smoothly.
- **Check generated code**: Peek at the output for understanding and debugging.
- **Use context parameters**: Methods inject `context.Context` automatically if omitted.
- **Keep interfaces thin**: One method per query for clarity and maintainability.
- **Leverage configuration files (`genconfig.Config`)** for customization.

---

## Common Pitfalls & Troubleshooting

- **Missing interface input**: The generator requires `-i` flag pointing to interface files.
- **Paths & output**: Ensure output directory permissions and path references are correct.
- **Invalid SQL templates**: Carefully check embedded SQL comment syntax to avoid generation errors.

If issues arise, refer to the [Troubleshooting Common Issues](/getting-started/quickstart-validation/troubleshooting-common-issues) guide.

---

## Next Steps

Once you're comfortable with this quick start workflow, explore the following documentation pages to deepen your understanding and extend capabilities:

- [First Code Generation](/getting-started/quickstart-validation/first-code-generation): Detailed initialization guide.
- [Generating and Using Model Field Helpers](/guides/core-workflows/guide-field-helpers): Expand helpers beyond basics.
- [Working with Associations in Generated Code](/guides/advanced-patterns/guide-associations): Master relation management.
- [Template-Driven Query Interfaces](/guides/advanced-patterns/guide-sql-templates): Harness full SQL template power.
- [Customizing Generation with genconfig.Config](/guides/advanced-patterns/guide-genconfig): Tailor generation to project needs.

---