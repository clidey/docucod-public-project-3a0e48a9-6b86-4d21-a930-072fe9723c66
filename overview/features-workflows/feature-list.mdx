---
title: "Key Features at a Glance"
description: "A concise feature summary: type-safe query APIs from Go interfaces, model-driven field helpers for robust CRUD and association workflows, template-based SQL, strong GORM integration, and extensibility through configuration. Each feature explained through practical value."
---

# Key Features at a Glance

Explore a concise overview of GORM CLI’s standout features, designed to empower Go developers with robust, type-safe database APIs and model-driven helpers. This page highlights the core capabilities—from type-safe query generation based on interfaces, to model-driven field helpers, template-powered SQL queries, deep GORM integration, and highly extensible, configuration-driven customization. Each feature is presented with a practical focus on what it enables you to accomplish.

---

## Type-Safe Query APIs from Go Interfaces

GORM CLI transforms your plain Go interfaces decorated with SQL templates into fully type-safe query APIs. By authoring methods as Go interface declarations with embedded SQL snippets, you unlock compile-time safety and autocompletion benefits.

- **Write Interfaces, Not Boilerplate:** Define your database queries declaratively as interfaces with annotated SQL comments.
- **Compile-Time Validation:** Catch errors early by validating parameters and results at compile time.
- **Context Auto-Injection:** Even if your method signature omits `context.Context`, GORM CLI adds it seamlessly.
- **Dynamic and Conditional SQL:** Use directives like `{{where}}`, `{{set}}`, and conditional templating for flexible, dynamic queries.

*Example:*
```go
// Go interface with templated SQL
// SELECT * FROM @@table WHERE id=@id
GetByID(id int) (T, error)
```

*Outcome:* Concrete implementations provide strongly typed methods like `GetByID(ctx, 123)` returning your model directly.

---

## Model-Driven Field Helpers for Robust CRUD and Associations

Harness GORM CLI’s ability to generate strongly typed field helpers from your Go models. These helpers support predicates, setters, and association operations that integrate naturally with GORM’s fluent API.

- **Predicates and Setters:** Easily construct SQL predicates (`Eq`, `Like`, `Between`) and update setters (`Set`, `Incr`) tailored for each field type.
- **Type Safety in Updates and Filters:** Avoid runtime errors by building queries with compiler-checked field references.
- **Association Support:** Manage has-one, has-many, belongs-to, and many-to-many records with helper operations like `Create`, `Update`, `Unlink`, and `Delete`.
- **Batch Operations:** Create or link multiple related records in batch with operations like `CreateInBatch`.

*Example:*
```go
gorm.G[User](db).
  Where(generated.User.Name.Eq("alice")).
  Set(
    generated.User.Age.Incr(1),
    generated.User.Pets.Create(generated.Pet.Name.Set("fido")),
  ).
  Update(ctx)
```

*Outcome:* Seamless, expressive CRUD and association workflows that reduce boilerplate and improve clarity.

---

## Template-Based SQL Queries

Write expressive, dynamic SQL-like templates directly in your Go interface comments. GORM CLI parses these templates, injecting parameters and conditional logic to produce flexible but type-safe query implementations.

- **Directives like `@@table`, `@@column`:** Simplify table and column substitutions.
- **Conditionals & Iterations:** Use `{{if}}`, `{{where}}`, `{{set}}`, and `{{for}}` to include logic and loops inside SQL.
- **Parameter Binding:** Link Go method parameters to SQL parameters automatically and safely.

*Example SQL Template:* 
```sql
-- Update user info conditionally
UPDATE @@table
{{set}}
  {{if user.Name != ""}} name=@user.Name, {{end}}
  {{if user.Age > 0}} age=@user.Age {{end}}
{{end}}
WHERE id=@id
```

*Outcome:* Fully generated methods that handle complex queries with safer and clearer syntax than handwritten SQL strings.

---

## Strong Integration with GORM Ecosystem

GORM CLI is designed to work seamlessly with the GORM ORM, enhancing your existing workflows without friction.

- **Generics-based APIs:** Leverage Go 1.18+ generics for model-specific query interfaces.
- **Alignment with GORM’s Fluent API:** Generated code works fluently with `gorm.G[T](db)` queries and applies expressions consistently.
- **Automatic Binding of Associations:** Helper fields understand GORM’s association types and provide idiomatic operations.

*Example:*
```go
user, err := generated.Query[User](db).GetByID(ctx, 123)
```

*Outcome:* A unified developer experience linking generated type-safe APIs with the power and flexibility of GORM.

---

## Extensibility Through Configuration

Customize generation with the optional `genconfig.Config` struct declared in package files. Configuration influences what interfaces and structs are included, output paths, and how fields map to custom helpers.

- **Control Generation Scope:** Use include/exclude patterns for interfaces and structs.
- **Custom Field Type Mapping:** Override default field helper types for special Go types or custom behaviors.
- **Output Path Overrides:** Direct generated code to package-specific directories.
- **File-Level Granularity:** Choose whether configuration applies to single files or entire packages.

*Example Configuration Snippet:* 
```go
var _ = genconfig.Config{
  OutPath: "examples/output",
  FieldTypeMap: map[any]any{
    sql.NullTime{}: field.Time{},
  },
  FieldNameMap: map[string]any{
    "json": JSON{},
  },
  IncludeInterfaces: []any{"Query*"},
}
```

*Outcome:* Tailored generation that fits your project needs and coding standards perfectly.

---

## Why These Features Matter

Together, these key features empower Go developers to:

- **Write Less Boilerplate:** Shift from manual SQL and verbose GORM code to declarative, generated APIs.
- **Gain Confidence:** Prevent runtime errors related to SQL or mismatched parameters through compile-time checks.
- **Improve Maintenance:** Easily evolve database queries and models with minimal manual refactoring.
- **Enable Rich Query Logic:** Use templating to express complex, dynamic SQL conditions clearly.
- **Streamline Collaboration:** Shared generated APIs produce consistent query patterns, improving team productivity.

---

## Getting Started Preview

To experience these features:

1. Define your query interfaces and models.
2. Optionally add a `genconfig.Config` for customization.
3. Run `gorm gen` pointing to your interface files.
4. Use the generated packages in your application with type safety and better discoverability.

_Eager to dive deeper? Explore the quickstart workflow and integration guides linked below._

---

## Related Documentation Links
- [What is GORM CLI?](../intro-and-value/what-is-orm-cli) – Introduction to the core product
- [Business Value & Use Cases](../intro-and-value/business-value-use-cases) – Why these features are essential
- [Generating Type-Safe Query APIs](../../guides/core-workflows/generate-type-safe-queries) – Hands-on with queries
- [Generating Model-driven Field Helpers](../../guides/core-workflows/generate-field-helpers) – Create robust field helpers
- [Customizing Code Generation](../../guides/advanced-usage-patterns/customizing-generation) – Harness the configuration
- [Integration with GORM & Go Ecosystem](../features-workflows/integration-gorm-ecosystem) – See generated code in action

---

Unlock the full potential of your Go and GORM projects by mastering these foundational features. This page equips you with essential knowledge that sets the stage for efficient, reliable, and expressive database interactions.

---