---
title: "Feature Overview"
description: "Get a snapshot of what sets GORM CLI apart: from generating type-safe queries and field helpers to handling complex associations and template-based SQL. Learn how these features save you time and prevent runtime SQL errors."
---

# Feature Overview

Discover what makes GORM CLI an essential tool for Go developers working with GORM. This page highlights the standout features of GORM CLI â€” from generating type-safe query interfaces and model-driven field helpers to managing complex associations and leveraging powerful template-based SQL. Understand how these capabilities streamline your workflow, catch errors early, and accelerate development.

---

## Why GORM CLI's Features Matter

Imagine writing database access code where you never have to worry about misspelled SQL clauses, incorrect types, or unclear method signatures. GORM CLI bridges Go's static typing with flexible SQL templates to deliver exactly that: compile-time safety and an intuitive API tailored to your project.

By automating critical parts of query generation and model manipulation, it saves you manual effort and prevents runtime SQL errors that can cause costly debugging sessions.

---

## Core Feature Highlights

### 1. Type-Safe Query APIs Generated from Interfaces

Write Go interfaces with SQL templates embedded in method comments, and GORM CLI generates concrete, fully typed implementations for you.

- **Benefit:** Enjoy compile-time validation of your queries ensuring parameter correctness and preventing SQL injection risks.
- **Use Case:** Define methods like `GetByID(id int)` with an SQL template comment, then call `generated.Query[User](db).GetByID(ctx, 123)` in your code with confidence.


Example:
```go
// Interface with SQL template comment
// SELECT * FROM @@table WHERE id=@id
GetByID(id int) (T, error)
```

### 2. Model-Driven Field Helpers for Fluent Query Building

From your Go struct models, the CLI generates field helper variables that help compose filters, updates, ordering, and association operations with strong typing.

- **Benefit:** Write expressive, discoverable query conditions without manually specifying column names or worrying about type mismatches.
- **Use Case:** Use generated predicates like `generated.User.Age.Between(18, 65)` in your queries for safer and cleaner code.

Example predicates and updates:
```go
generated.User.Name.Like("%jinzhu%")  // WHERE name LIKE '%jinzhu%'
gorm.G[User](db).Where(generated.User.Age.Gt(18)).Find(ctx)
```

### 3. Comprehensive Association Operations

Manage relationships with compile-time safe helpers for associations such as has one, has many, belongs to, and many-to-many.

- **Benefit:** Perform creations, updates, unlinking, deletion, and batch operations on related entities with consistent and error-free code.
- **Use Case:** Create a new user with their pets or languages in a single composite call.

Example:
```go
gorm.G[User](db).
  Set(
    generated.User.Name.Set("alice"),
    generated.User.Pets.Create(generated.Pet.Name.Set("fido")),
  ).
  Create(ctx)
```

### 4. Template-Based SQL DSL for Flexible Queries

Write SQL with placeholders and control structures inside interface method comments, and the generator produces type-safe code.

- **Benefit:** Dynamically build queries based on conditional parameters without complex manual query strings.
- **Use Case:** Use `{{if}}`, `{{where}}`, and `{{set}}` directives inside comments to conditionally include SQL WHERE clauses or UPDATE sets.

Example snippet:
```sql
-- UPDATE @@table
-- {{set}}
--   {{if user.Name != ""}} name=@user.Name, {{end}}
--   {{if user.Age > 0}} age=@user.Age {{end}}
-- {{end}}
-- WHERE id=@id
```

### 5. Configurable Generation via genconfig.Config

Customize generation behaviors such as output directories, field type mappings, and interface or struct filters using package-level configs.

- **Benefit:** Tailor generated code to project conventions or advanced use cases without manual editing.

Example:
```go
var _ = genconfig.Config{
  OutPath: "examples/output",
  FieldNameMap: map[string]any{"json": JSON{}},
  IncludeInterfaces: []any{"Query*"},
}
```

---

## Practical Benefits

- **Prevent Runtime Errors:** Generate code that catches SQL mistakes and type mismatches at compile time.
- **Boost Productivity:** Automate repetitive query and helper code generation to focus on core business logic.
- **Code Consistency:** Maintain uniform query patterns and field access across large teams and codebases.
- **Flexibility:** Use template DSLs to craft sophisticated queries while preserving type safety and readability.
- **Association Management:** Simplify complex related data modifications with well-defined association helpers.

---

## Real-World Workflow Snapshot

1. **Write Interfaces and Models:** Define interfaces with annotated SQL and relevant Go structs.
2. **Run CLI Tool:** Execute `gorm gen -i ./yourpkg -o ./generated` to produce generated code.
3. **Use Generated APIs:** Import and invoke type-safe query methods and field helpers for your database operations.

---

## Tips for Success

- Always keep your models and query interfaces in sync to ensure generated helpers reflect your schema accurately.
- Use the template-based query features for complex, dynamic filtering needs to replace manually constructed SQL.
- Leverage the association helpers for batch operations to improve transactional integrity and reduce boilerplate.
- Configure generation selectively with `genconfig.Config` to maintain output directories and apply type mappings consistently.

---

## Troubleshooting Common Issues

<AccordionGroup title="Troubleshooting Feature-Related Problems">
<Accordion title="Generated Code Not Updating">
Ensure your CLI command includes the correct input path (`-i`) and output directory (`-o`). Check for syntax errors in your interface SQL comments or missing required fields.
</Accordion>
<Accordion title="Type Mismatches in Generated Helpers">
Verify that your model struct fields use supported Go types or properly mapped custom types with `genconfig.Config` FieldTypeMap and FieldNameMap.
</Accordion>
<Accordion title="Association Operations Not Working as Expected">
Double-check association definitions in your models (has one, many-to-many) and confirm usage patterns align with generated helper methods.
</Accordion>
</AccordionGroup>

---

## Next Steps

Explore how these feature highlights fit into real workflows by visiting:

- [Quick Start & Typical Workflow](/overview/features-workflows/quickstart-workflow) for a hands-on guide.
- [Working with Associations in Generated Code](/guides/advanced-patterns/guide-associations) for deeper insight into managing relations.
- [Template-Driven Query Interfaces](/guides/advanced-patterns/guide-sql-templates) to master SQL templating DSL.
- [Customizing Generation with genconfig.Config](/guides/advanced-patterns/guide-genconfig) for advanced configuration.

For a conceptual understanding, review our [System Architecture](/overview/architecture-concepts/architecture-diagram) and [Key Concepts & Terminology](/overview/architecture-concepts/core-concepts) documentation.

---