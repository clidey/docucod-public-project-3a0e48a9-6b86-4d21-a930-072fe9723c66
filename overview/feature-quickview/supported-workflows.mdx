---
title: "Supported Workflows & Scenarios"
description: "Outlines common user journeys such as writing a query interface, defining models, running the code generator, and consuming generated APIs. Maps features to real-world developer workflows like composing complex queries or working with model associations."
---

# Supported Workflows & Scenarios

Welcome to the practical heart of GORM CLI: the Supported Workflows & Scenarios page. Here, we break down the main user journeys you will undertake with GORM CLI, guiding you through writing type-safe query interfaces, defining your data models, running the code generator, and ultimately consuming the generated APIs in real-world applications. This page connects core features to actual developer workflows, helping you leverage GORM CLI to streamline complex queries, manage model associations, and more.

---

## Unlocking Developer Workflows with GORM CLI

### Writing Query Interfaces: From Intent to API

The entry point for developers is defining clear, intention-driven query interfaces using Go generics. GORM CLI empowers you to express SQL operations declaratively through interface methods annotated with SQL templates. For example, interfaces like `Query[T any]` capture common database retrieval and update patterns, enabling your generated code to deliver **type-safe, fluent APIs** that are easy to call with confidence.

**Key Focus:**
- Methods map directly to SQL queries, like `GetByID(id int) (T, error)`
- Template directives like `@@table` and `@param` bind your Go method parameters to SQL safely
- Supports conditional SQL using DSL features like `{{where}}` and `{{set}}`

**Typical Use Case:**
You want to fetch a user by ID or run complex filtered queries while maintaining compile-time type checks and strong discoverability in your IDE.

```go
// Example method with SQL template in interface
// SELECT * FROM @@table WHERE id=@id AND name=@name
GetByID(id int, name string) (T, error)
```


### Defining Models: The Foundation of Generated APIs

Your Go structs describe the models that correspond to database tables. GORM CLI analyzes these to generate **field helpers** that mirror each column and association, making operations like filters, updates, and joins fluent and type-safe.

**Associations Supported:**
- has one
- has many
- belongs to
- many to many (including polymorphic)

**Example:**
The `User` model contains a broad set of associations which GORM CLI converts into convenient helpers like `User.Pets.Create(...)` or `User.Languages.CreateInBatch(...)` to manage related data smoothly.

```go
// snippet from User model
Pets []*Pet
Languages []Language `gorm:"many2many:UserSpeak"`
```

Your generated code does not just reflect fields but also operational patterns for updating, creating, unlinking, or deleting associations with compile-time guarantees.

### Running the Code Generator: Automate Interface & Helper Creation

Once your interfaces and models are defined, GORM CLI generates code with a single command:

```bash
gorm gen -i ./examples -o ./generated
```

This step parses your input code, applies any inclusion/exclusion rules from your `genconfig.Config`, and outputs:
- Concrete implementations for your interface queries
- Structs with field helpers for filters, updates, and associations

You can customize generation behavior via config flags or package-level configuration files to tailor output to your project structure.

### Consuming Generated APIs: Fluent, Safe, and Powerful

The final workflow is integrating generated APIs into your application. This is where productivity and safety amalgamate:

- Type-safe query calls that are autocompleted in your editor
- Chainable filter and update helpers with compile-time validation
- Association operations like batch creates and conditional deletes

**Practical examples:**

```go
// Retrieve user by ID
user, err := generated.Query[models.User](db).GetByID(ctx, 123)

// Update a user's pet name where user's ID = 1
err = generated.Query[models.User](db).Where(generated.User.ID.Eq(1)).
  Set(
    generated.User.Pets.Where(generated.Pet.Name.Eq("fido")).Update(generated.Pet.Name.Set("rex")),
  ).
  Update(ctx)

// Create a new user and link languages in batch
gorm.G[models.User](db).
  Set(
    generated.User.Name.Set("polyglot"),
    generated.User.Languages.CreateInBatch([]models.Language{{Code: "EN"}, {Code: "FR"}}),
  ).
  Create(ctx)
```

### Mapping Features to Developer Scenarios

| Workflow Stage          | Key Features & Benefits                 | Real-World Scenario                                     |
|-------------------------|---------------------------------------|--------------------------------------------------------|
| Define Query Interfaces | Template DSL for dynamic SQL           | Build safe, flexible custom queries                     |
| Define Models           | Field helpers & association semantics  | Generate helpers for complex relations                  |
| Code Generate           | Config-driven output                  | Adapt to project needs with inclusion/exclusion rules  |
| Consume APIs            | Type-safe, fluent, discoverable APIs  | Fast development of CRUD & association logic           |

---

## Best Practices & Tips

- **Start with simple queries and models**, then grow your interfaces and models as your application complexity increases.
- **Leverage your model definitions fully** — GORM CLI auto-generates helpers for all basic fields and associations, eliminating boilerplate.
- **Use `genconfig.Config` carefully**: include/exclude interfaces or structs to optimize generated code and avoid clutter.
- **Write interface comments clearly** with SQL template DSL for predictable query generation.
- **Manage associations confidently** with generated helpers handling create, update, unlink, and delete operations, including conditional filters.

## Common Pitfalls & Troubleshooting

<AccordionGroup title="Troubleshooting Support Workflows">
<Accordion title="Generated Methods Not Found">
Check your interface method signatures and make sure SQL templates are correctly formatted in comments. Missing or malformed comments can prevent generation.
</Accordion>
<Accordion title="Association Helpers Missing">
Ensure your model struct properly defines associations with supported GORM tags (e.g., `gorm:"many2many"`). Also verify your `genconfig.Config` does not exclude those structs.
</Accordion>
<Accordion title="Confusing Conditional SQL Template Logic">
Review your use of directives like `{{where}}` and `{{set}}`. Conditional SQL must have clearly defined conditions and proper parameter bindings.
</Accordion>
</AccordionGroup>

---

## Summary

This page aligns GORM CLI's core features with your developer workflows:
- Writing expressive query interfaces with SQL templating
- Defining rich and accurate data models
- Running the generator for tailored output
- Consuming fluent, type-safe APIs that simplify complex operations

These workflows form the backbone of efficient, safe Go and GORM integration, empowering you to build robust data access layers quickly and with confidence.

---

## See Also
- [What is GORM CLI?](/overview/product-intro-and-value/what-is-gorm-cli)
- [Value Proposition & Key Benefits](/overview/product-intro-and-value/value-proposition)
- [Defining Models & Query Interfaces](/getting-started/your-first-code-generation/defining-models-interfaces)
- [Using the Generated APIs in Your Application](/guides/core-workflows/using-generated-apis)
- [Customizing Code Generation with genconfig](/guides/advanced-usage/customizing-generation)


## Visual Workflow Overview

```mermaid
flowchart TD

  WriteQueryInterface["Write Query Interface with SQL Templates"] --> DefineModels["Define Models & Associations"]
  DefineModels --> RunGenerator["Run Code Generator (gorm gen)"]
  RunGenerator --> ConsumeAPIs["Consume Generated Type-Safe APIs"]
  ConsumeAPIs --> BuildApp["Build & Deploy Application"]

  subgraph Configuration
    RunGenerator --> ConfigOptions["Customize with genconfig.Config"]
  end

  BuildApp --> FeedbackLoop["Iterate & Refine Interfaces/Models"]
  FeedbackLoop --> WriteQueryInterface

  classDef startend fill:#f96,stroke:#333,stroke-width:2px;
  classWriteQueryInterface,BuildApp startend;
```

---

Diving into these workflows equips you to harness GORM CLI’s full potential — transforming your Go data access into a fluent, safe, and maintainable experience.