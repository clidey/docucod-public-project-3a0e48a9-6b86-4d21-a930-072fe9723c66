---
title: "Value Proposition & Key Benefits"
description: "Outlines why developers and teams should use GORM CLI. Focuses on compile-time safety, faster development, expressive and fluent APIs, and integration with GORM idioms. Describes key differentiators such as model-driven helpers and SQL template-based queries."
---

# Value Proposition & Key Benefits

## Unlock Compile-Time Safety and Maximize Developer Productivity

GORM CLI revolutionizes how Go developers interact with databases by generating type-safe, interface-driven query APIs combined with model-driven field helpers. This powerful tool ensures that your database queries are not only expressive and fluent but also checked at compile time—eliminating a vast class of runtime errors.

### Why Choose GORM CLI?

- **Compile-Time Safety:** Catch query errors early by leveraging Go's type system, reducing costly debugging efforts.
- **Expressive Query APIs:** Build sophisticated database queries effortlessly with intuitive, fluent, and discoverable methods.
- **Seamless GORM Integration:** Enjoy a native extension of GORM that respects its idioms and workflows without intrusive learning curves.
- **Model-Driven Helpers:** Automatically generated field and association helpers save you from repetitive boilerplate code.
- **Customizable & Extensible:** Fine-tune generation behavior with configuration files, including custom field mappings and interface inclusion/exclusion.

### Designed for Developers and Teams Who:

- Want strict type safety in database operations to avoid query bugs.
- Seek faster implementation cycles with generated, ready-to-use query interfaces.
- Prefer an expressive API that reads like natural Go code for both queries and data manipulations.
- Use GORM as their primary ORM and want tooling that complements and enhances it.

---

## What Is GORM CLI’s Value Proposition?

GORM CLI is a code generation tool tailored to Go developers working with GORM. By transforming your model structs and interface-based SQL templates into concrete, strongly typed Go APIs, it helps you write safer and cleaner database code.

At its core, it addresses the tedious, error-prone task of handcrafting SQL queries and field selectors in Go. By generating these APIs:

- You gain **compile-time guarantees**—your code won’t compile if types don't line up.
- You access **fluent, discoverable APIs** that guide you through query building and updates.
- You leverage your existing Go types and interfaces, ensuring idiomatic code.

Its dual generation engines produce:

- **Query APIs from Interfaces:** Define your queries declaratively via SQL templates in Go interface methods. GORM CLI generates the concrete implementations with full parameter binding and error checking.
- **Field Helpers from Models:** Your model structs become the basis for strongly typed field helpers covering filtering, sorting, updates, and associations.

This combination lets you write less boilerplate and more business logic, cutting the time between idea and working code.

---

## Key Differentiators & Benefits

### 1. **Compile-Time Safety That Saves Hours**
- Prevent SQL errors and data type mismatches before running.
- Catch invalid method calls or incorrect parameter types during compilation.

### 2. **Fluent and Discoverable APIs for Queries & Updates**
- Leverage generated methods representing your queries with clear signatures.
- Use generated fields and association helpers for readable and composable expressions.

### 3. **Model-Driven Helpers That Understand Your Data**
- Field helpers respect GORM tags and idioms.
- Support for basic types, named types implementing Scanner/Valuer, and complex associations.

### 4. **Powerful Template-Based SQL DSL**
- Write familiar SQL with embedded Go template directives.
- Dynamically construct conditional WHERE and SET clauses.

### 5. **Seamless Integration & Configuration**
- Hand-off generated packages integrated naturally alongside your GORM-based data layer.
- Custom configuration for output paths, included interfaces and structs, and custom field mapping.

---

## Concrete Examples of Value for Developers

### Example: Safer Queries with Interface-Driven APIs
Instead of writing raw SQL or check-strings, you define expressive interface methods annotated with SQL templates:

```go
// Query interface method
// SELECT * FROM @@table WHERE id=@id
GetByID(id int) (User, error)
```

Which generates type-safe code you can call like:

```go
user, err := generated.Query[User](db).GetByID(ctx, 123)
```

Errors in SQL parameter usage or mismatched return types are caught when you build.

---

### Example: Fluently Update Data with Helpers
Use generated field helpers to express updates clearly and safely:

```go
gorm.G[User](db).
  Where(generated.User.Name.Eq("alice")).
  Set(
    generated.User.Age.Incr(1),
    generated.User.Role.Set("active"),
  ).
  Update(ctx)
```

No string concatenations or error-prone manual column referencing.

---

### Example: Manage Associations Safely and Clearly
Handle complex relational links with concise, generated APIs:

```go
gorm.G[User](db).
  Set(
    generated.User.Name.Set("polyglot"),
    generated.User.Languages.CreateInBatch([]models.Language{{Code: "EN"}, {Code: "FR"}}),
  ).
  Create(ctx)
```

This creates a user and links languages atomically with full type safety.

---

## Why Should You Care?

### Accelerate Development with Confidence
By shifting error detection to compile-time and automating repetitive query code, GORM CLI dramatically increases your productivity.

### Improve Code Maintainability
Generated APIs reduce manual boilerplate, making your codebase cleaner, easier to read and maintain.

### Reduce Risk of Runtime Failures
Avoid subtle bugs caused by invalid SQL or mismatched types that only manifest during runtime.

### Align With Go and GORM Best Practices
GORM CLI extends your existing GORM workflow naturally, without forcing new paradigms or complex abstractions.

### Gain Flexibility with Customizable Generation
Control which interfaces or structs participate in generation, and adapt the helpers for your domain-specific needs.

---

## Getting Started Preview

Starting to use GORM CLI begins with defining your data models and query interfaces in your Go project. You then run the `gorm gen` command, which scans your code to generate strongly typed APIs.

Prerequisites:
- Go 1.18+ (for generics support)
- Your models defined as Go structs (ideally with GORM tags)
- Query interfaces with method comments containing SQL templates

Explore the next step in the workflow by visiting [Defining Models & Query Interfaces](/getting-started/your-first-code-generation/defining-models-interfaces) or dive into the [Quick Start Guide](/overview/product-intro-and-value/what-is-gorm-cli).

---

## Practical Tips

- Use GORM CLI’s field helpers to target updates and filters precisely while avoiding SQL injection risks.
- Leverage association helpers to express complex relationships with clear operation semantics: create, update, unlink, and delete.
- Utilize the built-in template SQL DSL directives like `{{where}}`, `{{set}}`, `{{if}}`, and `{{for}}` to write dynamic queries while keeping type safety.
- Configure generation inclusions/exclusions via `genconfig.Config` to maintain focus on the data models important to your application.

## Common Pitfalls to Avoid

- Forgetting to include `context.Context` in your interface method signatures—GORM CLI will add it automatically if missing.
- Not keeping your model definitions and query interfaces in sync, which could cause mismatches.
- Overcomplicating SQL templates—keep your queries declarative and simple for better maintainability.

---

Embrace the power of GORM CLI to bring reliability, speed, and clarity to your Go data access code today.

---