---
title: "What is GORM CLI?"
description: "A high-level explanation of GORM CLI, focusing on what it brings to Go and GORM development. Emphasizes interface-driven, type-safe code generation for both queries and field helpers. Frames the tool as a productivity and correctness enhancer for database workflows."
---

# What is GORM CLI?

## Unlocking Productivity and Reliability for Go and GORM Developers

GORM CLI is a powerful code generation tool designed specifically to enhance your experience working with Go and the GORM ORM. It creates interface-driven, type-safe query APIs alongside model-driven field helpers, elevating your database workflows with compile-time safety and expressive, discoverable interfaces.

### Why GORM CLI Matters to You

- **Type Safety in Your Queries:** Say goodbye to runtime SQL errors with compile-time verified query interfaces.
- **Fluent and Discoverable API:** Navigate queries and data manipulations with clear, chainable method calls.
- **Boosted Productivity:** Automate repetitive code generation to focus more on business logic.
- **Robust Support for Associations:** Manage relational data with safety and semantics tailored to your model.
- **Seamless GORM Integration:** Build on familiar tools with an enhanced, type-aware generation process.

### Who Should Read This?

Developers building Go applications that use GORM for data persistence who want to increase confidence in database interactions through enhanced type safety and productivity gains.

---

## Introducing GORM CLI: What It Is and What It Does

At its core, GORM CLI is a **code generator** that ingests your Go model structs and SQL interface definitions (with embedded SQL templates) to produce two main outputs:

- **Type-safe query APIs:** Concrete implementations of your interfaces that check your SQL queries at compile time, preventing mismatches and typos.
- **Model-driven field helpers:** Rich, generated field helpers that encapsulate filters, setters, and association operations for your GORM models.

This combination provides a fluent, discoverable, and robust API surface for executing queries and performing CRUD operations with full compile-time guarantees on correctness.

### What Problems Does GORM CLI Solve?

Working directly with raw SQL or generic GORM calls can invite subtle bugs from mismatched query parameters, mistyped column names, or forgotten association handling. GORM CLI addresses these by:

- Guaranteeing SQL syntax correctness relative to your Go interfaces.
- Enforcing data types and field usage through generated helpers.
- Simplifying complex association operations into easy-to-understand methods.

### How Does It Fit Into Your Workflow?

You define your queries as Go interfaces annotated with SQL templates, alongside your usual GORM model structs. GORM CLI then:

- Parses your interfaces and models.
- Generates strongly-typed Go code with query implementations and field helpers.
- Enables you to use these generated APIs directly in your application code—turning raw SQL interfaces into safe, convenient, and maintainable APIs.

---

## Core Features of GORM CLI

### 1. Type-Safe Query API

Generate concrete implementations from interfaces with SQL comments directly expressing the SQL logic. Your parameters bind safely, and method signatures enforce correct return types.

**Example:**
```go
// Define your query interface with inline SQL
 type Query[T any] interface {
   // SELECT * FROM @@table WHERE id=@id
   GetByID(id int) (T, error)
 }
```
Generating this provides you a type-safe method:
```go
u, err := generated.Query[User](db).GetByID(ctx, 123)
```
This generates correct SQL with parameter binding and returns strongly-typed data.

---

### 2. Model-Driven Field Helpers

From your model structs, GORM CLI creates field helpers for filters, updates, ordering, and associations. These helpers are type-aware and fluent, enabling clear, expressive CRUD operations.

**Example predicates:**
```go
generated.User.Name.Like("%jinzhu%")     // name LIKE '%jinzhu%'
generated.User.Age.Between(18, 65)     // age BETWEEN 18 AND 65
```
**Usage with GORM:**
```go
gorm.G[User](db).
  Where(generated.User.Age.Gt(18)).
  Find(ctx)
```

---

### 3. Comprehensive Association Management

Handle complex relations with semantic operations like Create, Update, Unlink, Delete, and CreateInBatch for belongs-to, has-one, has-many, and many-to-many associations.

**Example:**
```go
// Create user with associated pets
gorm.G[User](db).
  Set(
    generated.User.Name.Set("alice"),
    generated.User.Pets.Create(generated.Pet.Name.Set("fido")),
  ).
  Create(ctx)
```

Operations respect association semantics, such as "unlink" for clearing foreign keys or removing join rows in many-to-many relations.

---

### 4. Template-Based SQL DSL

Write your SQL directly inside interface method comments using the GORM CLI template DSL. This supports dynamic conditions, parameter binding, iteration, and complex SQL building with clarity and safety.

**Example SQL Template:**
```go
// SELECT * FROM @@table
// {{where}}
//   {{if user.Name != ""}} name=@user.Name {{end}}
//   {{if user.Age > 0}} AND age=@user.Age {{end}}
// {{end}}
SearchUsers(user User) ([]T, error)
```

This enables flexible, readable, parameter-bound query definitions integrated seamlessly into your Go interfaces.

---

## Why Should You Use GORM CLI?

### Compile-Time Safety
Errors that would surface only at runtime in normal GORM usage now get caught at compile time, eliminating a whole class of bugs.

### Increased Developer Productivity
The automation of query and helper code generation reduces tedious boilerplate and frees developers to focus on logic.

### Maintainable and Readable Code Base
Generated query APIs follow your interface design, improving clarity and easing onboarding.

### Rich Association Handling
Manage complex relational data with simple, intention-expressive calls, respecting correct FK semantics transparently.

### Seamless Integration
Designed to fit directly within your existing GORM projects, requiring only Go 1.18+ with generics and no drastic workflow changes.

---

## Getting a Quick Glimpse: Typical Workflow

1. **Define Models and Queries**
Place your Go structs and interfaces (with SQL templates) in the same package or directory.

2. **Generate Code**
Run the generator:
```bash
gorm gen -i ./examples -o ./generated
```
3. **Use Generated API**
Invoke query methods and use field helpers in your app:
```go
user, err := generated.Query[User](db).GetByID(ctx, 123)
users, err := gorm.G[User](db).Where(generated.User.Age.Gt(18)).Find(ctx)
```

See step-by-step guides in related documentation to deepen your mastery.

---

## Practical Tips

- **Annotate All Queries:** Comment your interface methods with SQL templates to get full code generation benefits.
- **Leverage Field Helpers:** Use generated predicates and setters to build queries and updates with clarity.
- **Plan Associations Clearly:** Model your relationships properly to unlock comprehensive association helper generation.
- **Use Configuration for Customization:** Customize generation output by defining package-level genconfig.Config.

---

## Troubleshooting Highlights

- Ensure Go 1.18+ is installed to support generics.
- Place your interfaces and models in the same accessible package or directory.
- Use the CLI `-i` flag to point to the correct directory containing interfaces.
- If generated files are missing fields or methods, check inclusion/exclusion filters in genconfig.

---

GORM CLI empowers you to turn raw SQL-development pain points into streamlined, safe, and highly productive workflows—helping you ship bug-free, maintainable database code faster.

Explore further documentation on [Value Proposition & Key Benefits](/overview/product-intro-and-value/value-proposition) and [Using the Generated APIs in Your Application](/guides/core-workflows/using-generated-apis) to continue your journey.
