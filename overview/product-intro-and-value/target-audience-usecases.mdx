---
title: "Who Should Use GORM CLI?"
description: "Describes the ideal users: Go developers using GORM, teams seeking type-safety, API discoverability, or faster development cycles. Highlights use cases like rapidly building data-access layers, enforcing query safety, and integrating advanced model associations."
---

# Who Should Use GORM CLI?

GORM CLI is expertly crafted for Go developers leveraging the power of [GORM](https://gorm.io) who want to elevate their development with type-safe, expressive, and discoverable data-access layers. This page outlines the ideal users, the scenarios where GORM CLI shines, and why integrating it into your workflow will accelerate development while enhancing safety and maintainability.

---

## Empowering Go Developers with GORM

If you write Go applications that interact with databases through GORM, GORM CLI is designed to transform how you build your data layer:

- **Individual Go Developers** who want compile-time safety and fluent query APIs
- **Backend Engineers** tasked with building robust, type-safe database integrations
- **API Teams** seeking discoverable and consistent access patterns for complex queries
- **Project Leads and Architects** wanting to enforce query correctness and reduce runtime bugs


## Why You Should Care: Real-World Use Cases

### Rapidly Build Type-Safe Query APIs
Traditional SQL or ORM usage in Go often leads to brittle queries prone to runtime errors and unclear semantics.
With GORM CLI, you write simple Go interfaces annotated with SQL templates. The tool generates fully type-safe, idiomatic APIs:

- Write a method with a clear SQL comment
- Generate concrete implementations that enforce parameter types at compile time
- Avoid SQL injection and syntax errors upfront

**Example:**

```go
// Define the query interface
// SELECT * FROM @@table WHERE id=@id
GetByID(id int) (User, error)
```

The generated method guarantees correct binding and SQL generation without manual code.


### Enforce Query Safety and Maintainability
When your application grows, query logic scattering can cause hard-to-trace bugs and inconsistent usage.
GORM CLI centralizes query definitions as interfaces with templated SQL, minimizing duplication with:

- Single source of truth for your queries
- Clear SQL templates with contextual Go parameter bindings
- Built-in support for dynamic conditions, iteration, and templating logic


### Discoverable, Fluent APIs for Developers
The generated code provides field helpers and model-driven constructs that surface available fields and associations clearly.
Users benefit from:

- IDE autocomplete and documentation
- Explicitly typed fields and predicates
- Intuitive chaining for advanced conditions


### Advanced Model Associations with Safety
Managing complex relationships like has-many, belongs-to, and many-to-many often requires verbose manual coding.
GORM CLI generates expressive helpers for creating, updating, unlinking, and deleting associated data — all with compile-time checks.


## Common Scenarios Where GORM CLI Excels

| Use Case                                               | Benefit                                                         |
| ------------------------------------------------------ | --------------------------------------------------------------- |
| Building a robust backend with complex data models     | Safer queries with compile-time checks reduce bugs             |
| Rapid iteration on data access layers                   | Write interfaces and generate updated APIs quickly             |
| Enforcing consistent query patterns across teams       | Interfaces document expected queries and parameters            |
| Integrating association-heavy models with GORM         | Seamless, type-safe association helpers to manage relations    |
| Optimizing performance with templated SQL and filters  | Use template DSL for flexible, dynamic queries                  |


## Before and After: What Changes With GORM CLI

| Aspect                  | Before                              | After (With GORM CLI)                                             |
|------------------------|-----------------------------------|-----------------------------------------------------------------|
| Query Implementation   | Manual SQL strings, prone to errors | Interface-defined queries; compile-time SQL template validation |
| Type Safety            | Weak, runtime errors common        | Strongly typed parameters and results enforced at compile time  |
| Model Field Helpers    | Manual or missing                  | Generated fluent, type-safe field predicates and setters        |
| Association Management | Tedious and error-prone           | Automated, type-checked CRUD operations for complex relations   |


## What Outcomes Can You Expect?

- **Reduced Runtime Failures:** Catch query and binding issues early
- **Faster Development:** Automate boilerplate and focus on business logic
- **Improved Code Readability:** Self-documenting interfaces and generated helpers
- **Better Collaboration:** Shared query interfaces standardize data access

---

## Getting Started Preview

Integrating GORM CLI into your workflow is straightforward:

<Steps>
  <Step title="Write Query Interfaces">
    Define Go interfaces with methods and embed SQL templates as comments.
  </Step>
  <Step title="Prepare Your Models">
    Define your data model structs with clear field and association declarations.
  </Step>
  <Step title="Run GORM CLI Generator">
    Use the CLI to generate type-safe query APIs and model-driven field helpers.
  </Step>
  <Step title="Use Generated Code">
    Import and invoke your generated APIs for compile-safe database operations.
  </Step>
</Steps>

### Prerequisites

- Familiarity with Go and GORM
- Basic understanding of Go generics (Go 1.18+)
- SQL knowledge to write query templates

### Next Steps

- Explore the ["What is GORM CLI?" documentation](/overview/product-intro-and-value/what-is-gorm-cli) to understand core concepts and value.
- Review example queries and generated code to see GORM CLI in action.
- Follow the [Getting Started guides](/getting-started/your-first-code-generation/defining-models-interfaces) for detailed setup steps.

---

<Info>
  GORM CLI’s power lies in empowering developers to build safer, faster, and more maintainable database layers with Go and GORM. This page helps you self-validate if GORM CLI aligns with your goals and workflows.
</Info>

---

## Additional Resources

- [Value Proposition & Key Benefits](/overview/product-intro-and-value/value-proposition)
- [Quickstart: Generating Type-Safe APIs](/guides/core-workflows/quickstart-generating-type-safe-apis)
- [Working with Field Helpers](/guides/core-workflows/field-helper-basics)
- [Handling Associations With Helpers](/guides/core-workflows/association-guides)

---

<script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js" />
  
{/* Optional Mermaid diagram not required here but keep for extensibility */}