---
title: "Integration & Ecosystem Fit"
description: "Understand how GORM CLI integrates seamlessly with GORM, works with Go generics (Go 1.18+), and how its outputs fit into existing Go project workflows. Learn about minimal dependencies and how configuration adapts the tool for diverse projects."
---

# Integration & Ecosystem Fit

Seamless integration is a cornerstone of GORM CLI’s design. This page helps you understand how GORM CLI fits naturally into your existing Go projects with GORM, leverages Go generics introduced in Go 1.18, and operates with minimal external dependencies. You'll also learn how configuration options adapt the tool to diverse project structures and workflows.

---

## Why Integration Matters

When adopting code generation tools, it is critical that the outputs integrate smoothly with the rest of your application and development environment. GORM CLI’s generated code is crafted to feel like native GORM code, preserving the GORM idiomatic style and conventions. This results in a frictionless experience from writing interfaces, generating code, to consuming APIs.

By fully embracing Go's generic types, GORM CLI enables highly type-safe, reusable APIs without sacrificing readability or maintainability. The minimal dependency footprint and customizable configuration let you tailor the integration to your project’s unique layout and needs.

---

## Core Integration Points

### 1. Native GORM Compatibility

The code generated by GORM CLI is built on top of the official `gorm.io/gorm` package:

- Generated query APIs wrap native `*gorm.DB` instances.
- Field helpers expose typed predicates compatible with GORM's query builder.
- Association helpers apply GORM’s conventions for relation operations like create, update, unlink, and delete.

This ensures that your generated APIs slot into any existing GORM-powered code seamlessly — no adapter layers or translation are required.

**Example:**
```go
// Using generated Query API with a native GORM DB
user, err := generated.Query[User](db).GetByID(ctx, 123)

// Using field helpers with the generic G ORM interface
gorm.G[User](db).Where(generated.User.Age.Gt(18)).Find(ctx)
```

### 2. Leveraging Go Generics (Go 1.18+)

GORM CLI requires Go 1.18 or later and leverages generics extensively:

- All generated interfaces are defined as generic types parameterized by your model type `T`.
- Methods on generated query interfaces adopt generic type parameters to support any compatible struct type.

This approach delivers compile-time type safety without boilerplate, making your API intuitive and flexible.

<Tip>
Ensure your development environment and build pipeline use Go 1.18 or newer to utilize GORM CLI’s generated code.
</Tip>

### 3. Minimal and Transparent Dependencies

GORM CLI itself depends chiefly on GORM and standard Go packages:

- Generated code imports only essential dependencies such as `gorm.io/gorm`, GORM’s `clause` package for advanced SQL expressions, and GORM CLI’s own `field` package for field helpers.
- There is no runtime dependency on the CLI tool — generated code is self-contained and requires no additional runtime installs.

This keeps your application lightweight and easy to maintain.

---

## Configuration and Adaptability

### Package-Level Generation Configurations

You can fine-tune how GORM CLI generates code via package-level `genconfig.Config` values:

- **OutPath**: Customize output directory per package.
- **Include/Exclude Filters**: Whitelist or blacklist certain interfaces or structs from generation.
- **FieldTypeMap and FieldNameMap**: Map Go types or named struct tags to custom field helpers.
- **FileLevel Flag**: Choose generation granularity (per file or per package).

Example configuration snippet:

```go
var _ = genconfig.Config{
    OutPath: "generated",
    IncludeInterfaces: []any{"Query*"},
    FieldNameMap: map[string]any{
        "json": JSON{},
    },
}
```

### Directory and File Structure Awareness

GORM CLI processes input from a specified path, recursively scanning Go files and applying applicable configurations. It preserves your codebase’s directory hierarchy in the generated output, enabling intuitive organization and smooth integration with your existing project.

### Integration with Build and CI/CD

Generated code can be easily integrated into your build process:

- Invoke `gorm gen` as part of pre-build scripts or CI pipelines.
- Store generated code within your repository or generate on-demand.
- Configuration files can be committed alongside source code to ensure reproducibility.

---

## Putting It All Together: An Integration Flow

```mermaid
flowchart TD

  A[Write Query Interfaces & Models] --> B[Run `gorm gen` CLI Tool]
  B --> C[Parse Interfaces & Config]
  C --> D[Generate Type-Safe APIs & Helpers]
  D --> E[Check Output Directory Structure]
  E --> F[Import Generated Code in Project]
  F --> G[Use Generated Queries & Helpers with GORM]

  subgraph User Workflow
    G --> H[Develop Application Logic]
    H --> I[Test & Deploy
  end

  style User Workflow fill:#f5faff,stroke:#78a7e2,stroke-width:2px

```

This workflow highlights how GORM CLI sits as a natural bridge between your source code and runtime application, simplifying database operations while fitting comfortably within Go and GORM’s ecosystem.

---

## Troubleshooting and Best Practices

<AccordionGroup title="Troubleshooting Integration Issues">
<Accordion title="I get import errors with the generated code">
Ensure your `OutPath` is correctly included in your module’s `go.mod` or your IDE’s module paths. Regenerate code after configuration changes.
</Accordion>
<Accordion title="My project uses custom types and the generators don’t recognize them">
Use `FieldTypeMap` and `FieldNameMap` in your `genconfig.Config` to map your custom types to appropriate field helpers.
</Accordion>
<Accordion title="The CLI fails to generate when using complex directory structures">
Check `FileLevel` flag in your config. Setting it to `true` restricts generation to individual files, which may help avoid conflicts.
</Accordion>
</AccordionGroup>

<Tip>
Keep your query interfaces and models organized logically by package to leverage granular configuration and maintain clarity in your generated outputs.
</Tip>

---

## Next Steps

To deepen your integration, explore the following documentation:

- [System Architecture Overview](/overview/architecture-and-concepts/system-architecture) — understand internal flows and components
- [Core Concepts & Terminology](/overview/architecture-and-concepts/core-concepts-and-terminology) — grasp key abstractions and DSL
- [Generating Type-Safe Query APIs](/guides/core-workflows/generating-type-safe-queries) — practical guide to defining and generating APIs
- [Using Field Helpers and Building Filters](/guides/core-workflows/field-helpers-and-filters) — get the most from model-driven helpers

Integrating GORM CLI into your Go project means less boilerplate, safer database queries, and a faster development cycle — with outputs designed to blend naturally into your existing GORM ecosystem.

---