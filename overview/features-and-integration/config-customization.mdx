---
title: "Configuration & Customization Essentials"
description: "Get a quick introduction to the key configuration mechanisms available via genconfig.Config. Learn what you can customize (output paths, field mappings, inclusions/exclusions) and how configuration powers advanced workflows—all designed to keep the developer experience flexible and powerful."
---

# Configuration & Customization Essentials

## Empower Your Code Generation with Flexible Configuration

Unlock full control over how GORM CLI generates your type-safe query APIs and model-driven field helpers by mastering the `genconfig.Config` configuration options. This page guides you through the central configuration mechanism — enabling you to specify output paths, customize field mappings, and filter generation targets with precision. These capabilities adapt the generator’s behavior to suit complex project needs and advanced workflows while preserving developer experience simplicity.

---

## What Is `genconfig.Config`?

`genconfig.Config` is a user-declarable Go struct that acts as the cornerstone for customizing code generation on a per-package basis. By embedding a package-level literal of this config type, you instruct the generator how to behave for that package or directory.

With `genconfig.Config`, you tailor aspects like:

- Where generated files should be placed
- How specific fields map to custom wrappers or helpers
- Which interfaces and structs to include or exclude from generation

Rather than rigid, global settings, this localized and composable approach keeps the developer's control intuitive and powerful.

---

## Core Configuration Options and What You Can Customize

### Output Path Override: `OutPath`

Control exactly where the generated code lands by setting `OutPath`. This overrides the CLI command-line `-o` flag for files in the same package as the config. For example:

```go
var _ = genconfig.Config{
  OutPath: "examples/output",
}
```

This is invaluable for organizing generated files separately from source code.

### Field Mappings: `FieldTypeMap` and `FieldNameMap`

Custom field handling is essential when working with special database types or custom types.

- `FieldTypeMap` maps Go type instances to generator wrapper types. The generator uses this to infer imports and method calls automatically.

- `FieldNameMap` maps `gen` tag names in struct fields to wrapper types, allowing you to control behavior based on field annotations.

Example:

```go
var _ = genconfig.Config{
  FieldTypeMap: map[any]any{
    sql.NullTime{}: field.Time{},
  },
  FieldNameMap: map[string]any{
    "date": field.Time{},
    "json": JSON{},
  },
}
```

This setup ensures that fields tagged with `gen:"date"` or of type `sql.NullTime` use the special `field.Time` wrapper in generated code.

<Tip>
Mapping field types or names maximizes query and update helper correctness and improves integration with special data types like JSON.
</Tip>

### File versus Package Level Scope: `FileLevel`

By default, config applies to the whole package. Set `FileLevel: true` to restrict the config to only the single source file where it appears. This allows fine-grained control when multiple configurations co-exist in one package.

### Selective Generation via Inclusion/Exclusion Filters

Efficiently narrow your generated targets using these selectors:

- `IncludeInterfaces` and `ExcludeInterfaces`: Whitelist or blacklist interface types to generate query APIs for.
- `IncludeStructs` and `ExcludeStructs`: Control which struct types get model-driven field helpers.

Selectors support:

- Shell-style patterns (e.g., `"Query*"`, `"User"`)
- Fully qualified type literals (e.g., `models.User{}`)

Example to generate only interfaces starting with "Query":

```go
var _ = genconfig.Config{
  IncludeInterfaces: []any{"Query*"},
}
```

Use exclusion lists similarly to ignore deprecated or irrelevant types.

<Tip>
Whitelist selectors have precedence: if an inclusion slice is non-empty, exclusion lists are ignored.
</Tip>

---

## How Configuration Powers Advanced Workflows

Imagine a large project with many models and custom types where generated code needs to be placed in a specific directory hierarchy, or only certain query interfaces should be built to reduce compilation times. These scenarios are directly enabled through the configuration's scoped control and filtering.

**Example Scenario:**

You want to:
- Output generated code to `./generated` instead of default
- Map `sql.NullTime` and `gen:"date"` tags to use `field.Time` helpers
- Generate query APIs only for interfaces named `Query*`

Config:

```go
var _ = genconfig.Config{
  OutPath:          "generated",
  FieldTypeMap:     map[any]any{sql.NullTime{}: field.Time{}},
  FieldNameMap:     map[string]any{"date": field.Time{}},
  IncludeInterfaces: []any{"Query*"},
}
```

The generator will respect this and produce focused, high-quality code tailored to your project.

---

## Practical Tips & Best Practices

- **Prefer FieldNameMap over FieldTypeMap**: The generator prioritizes field name tags, which provides greater flexibility.
- **Use selectors consistently**: Stick to shell-style patterns or type literals to avoid confusion.
- **Manage multiple configs carefully**: When using `FileLevel: true`, ensure no conflicting rules overlap across files.
- **Keep output paths organized**: Separate generated code into dedicated folders to prevent unwanted version control noise.

---

## Common Pitfalls and Troubleshooting

<Warning>
- If no generated files appear where expected, verify your inclusion/exclusion rules.
- Configuration conflicts can silently filter out all targets. When in doubt, simplify selectors.
- Misconfigured field maps can produce incorrect or uncompilable generated code.
- Remember `FileLevel` config applies only to the defining file, which may cause apparently missing generation in sibling files.
</Warning>

Use the CLI with clear logging (`gorm gen -i ./interfaces -o ./output`) to verify generation paths.

---

## Getting Started Preview

To begin customizing generation:

1. Add a `genconfig.Config` literal in the same package as your models and query interfaces.
2. Use `OutPath` to set output folder.
3. Define field mappings for any special types.
4. Optionally, filter interfaces and structs with include/exclude slices.

Example minimal starter config:

```go
package mypkg

import (
  "database/sql"
  "gorm.io/cli/gorm/field"
  "gorm.io/cli/gorm/genconfig"
)

var _ = genconfig.Config{
  OutPath: "generated",
  FieldTypeMap: map[any]any{
    sql.NullTime{}: field.Time{},
  },
}
```

Proceed to run the CLI with your interfaces and models, and inspect the generated code.

---

## See Also

- [Feature Overview at a Glance](/overview/features-and-integration/feature-tour) — Understand how configuration fits in with generation features
- [Integration with GORM and Your Project](/overview/features-and-integration/integration-points) — See how generated code works with GORM
- [Basic Configuration](/getting-started/first-steps/initial-configuration) — Learn how to set up initial configurations and CLI commands
- [Advanced Field Helper Configuration](/guides/real-world-patterns/advanced-field-config) — For deep dives into custom field mappings


---

## Summary Diagram: Configuration Impact on Generation Workflow

```mermaid
flowchart TD
  subgraph User Package
    SrcFiles["Source Files with genconfig.Config"]
    ConfigLiteral["genconfig.Config Literal"]
  end

  subgraph GORM CLI Generator
    Parser["Parse Go AST"]
    ExtractConfig["Extract Config from Literals"]
    FilterTarget["Apply Include/Exclude Filters"]
    MapFields["Map Fields Using FieldTypeMap & FieldNameMap"]
    CodeGen["Generate Code with Customized Output"]
    Format["Format and Write Files"]
  end

  SrcFiles --> Parser
  Parser --> ExtractConfig
  ExtractConfig --> FilterTarget
  FilterTarget --> MapFields
  MapFields --> CodeGen
  CodeGen --> Format

  ConfigLiteral --> ExtractConfig

  Format --> GeneratedOutput["Generated Files in OutPath"]

  classDef config fill:#f9f,stroke:#333,stroke-width:2px;
  ConfigLiteral config;
```

This diagram summarizes how your configuration literals in source files are extracted and influence code generation filtering, field mapping, and final output.

---

Unlock powerful, tailored code generation in your GORM projects today by leveraging `genconfig.Config` — your gateway to a flexible, efficient, and maintainable codebase.
