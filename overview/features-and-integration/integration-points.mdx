---
title: "Integration with GORM and Your Project"
description: "See how GORM CLI code fits naturally with the widely-used GORM library. Understand integration points, compatibility guarantees, setup steps, and how generated code interoperates seamlessly with existing GORM-based models and queries."
---

# Integration with GORM and Your Project

Unlock the full power of GORM CLI by understanding how it seamlessly integrates with the well-established GORM ORM library. This page guides you through the key integration points, compatibility essentials, and practical steps to incorporate the generated code into your existing Go projects using GORM.

---

## Why Integration Matters

GORM CLI is designed to complement and extend GORM, the popular Go ORM, by generating type-safe, fluent query APIs and model-driven field helpers that plug directly into GORM’s DB objects. This integration provides:

- **Type Safety:** Eliminate runtime query errors with compile-time checks.
- **Discoverability:** Fluent APIs make your queries and updates intuitive.
- **Boilerplate Reduction:** Generate repetitious CRUD and filtering code automatically.
- **Compatibility:** Work seamlessly alongside GORM models, associations, and query builders.

Understanding these integration points lets you leverage GORM CLI without changing your fundamental database access patterns.

## Core Integration Points

GORM CLI’s generated outputs interact with GORM through several natural touchpoints:

### 1. Generated Query Interfaces Wrap *gorm.DB

Each generated query interface method receives a `*gorm.DB` and returns enriched query builders or executes statements. This means you can mix-and-match GORM CLI code with handcrafted GORM operations effortlessly.

### 2. Model-Driven Field Helpers Use GORM Column & Clause Structures

Field helpers correspond to model fields and generate GORM expressions (e.g., `clause.Column`) used in conditions and updates. This lets generated code build queries compatible with GORM’s query syntax and extensions.

### 3. Association Helpers Utilize GORM Association Semantics

Generated helpers for relationships (has one, has many, belongs to, many2many) produce operations like Create, Update, Unlink, and Delete that work within GORM’s association handling, maintaining foreign key constraints and join tables safely.

### 4. Compatibility with Existing Models

GORM CLI expects your Go model structs to be standard GORM model definitions. It reads your model fields, GORM tags, and associations directly, ensuring generated code reflects your database schema faithfully.

---

## Getting Started with Integration: A Practical Workflow

Follow these actionable steps to incorporate GORM CLI generated code into your project using GORM.

### Step 1: Define Your Models as Usual

Maintain your models as idiomatic GORM structs, including tags and associations.

```go
package models

import "gorm.io/gorm"

type User struct {
  gorm.Model
  Name      string
  Age       int
  Pets      []Pet `gorm:"foreignKey:UserID"`
}

type Pet struct {
  gorm.Model
  Name   string
  UserID uint
}
```

### Step 2: Create Query Interfaces with Template SQL

Declare interfaces representing your queries. Use SQL templates in method comments for flexible, type-safe query code generation.

```go
package examples

type UserQuery[T any] interface {
  // SELECT * FROM @@table WHERE id=@id
  GetByID(id uint) (T, error)

  // SELECT * FROM @@table WHERE age > @minAge
  Adults(minAge int) ([]T, error)
}
```

### Step 3: Generate Code with GORM CLI

Run the CLI command pointing to your interfaces and models.

```bash
gorm gen -i ./examples -o ./generated
```

This produces generated query APIs and model helpers fully compatible with GORM.

### Step 4: Use Generated APIs in Your Application

Combine generated code with your existing GORM `*gorm.DB` instances to perform type-checked queries and association operations.

```go
import (
  "context"
  "gorm.io/gorm"
  "yourproject/generated"
  "yourproject/models"
)

func ExampleUsage(db *gorm.DB, ctx context.Context) error {
  // Use Query interface
  userQuery := generated.UserQuery[models.User](db)

  user, err := userQuery.GetByID(ctx, 123)
  if err != nil {
    return err
  }

  // Use Field helpers for conditions
  adults, err := userQuery.Adults(ctx, 18)
  if err != nil {
    return err
  }

  // Example association create
  err = gorm.G[models.User](db).
    Set(
      generated.User.Name.Set("alice"),
      generated.User.Pets.Create(generated.Pet.Name.Set("fido")),
    ).
    Create(ctx)

  return err
}
```

This workflow preserves all GORM features while adding compile-time safety and rich API discoverability.

---

## Compatibility Guarantees and Considerations

- Generated code wraps the latest stable `gorm.io/gorm` versions, guaranteeing compatibility.
- Both generated query interfaces and helper structs expect GORM models formatted normally.
- Associations respect GORM semantics; unlink and delete behave as expected by setting FKs or clearing join tables.
- Field helpers map basic Go types to GORM columns, including support for `sql.Scanner` and `driver.Valuer` interfaces.
- You can customize FieldTypeMap and FieldNameMap via generation config to handle special or custom fields.

<Note>
Avoid modifying generated files directly. Instead, update your interfaces or models and regenerate to keep code in sync.
</Note>

---

## Common Integration Pitfalls and How to Avoid Them

### 1. Missing Context in Generated Methods

GORM CLI automatically adds `context.Context` if absent in method signatures. Passing contexts properly is crucial for request cancellation and deadlines.

### 2. Mismatching Model Tags or Structure

If your GORM models use unconventional tags or struct embeddables, generated code might not correspond perfectly. Keep models idiomatic to ensure smooth generation.

### 3. Association Operation Errors

Unlink and Delete actions on associations differ by relation type. Make sure to check expected semantics in your association helpers.

### 4. Conflicting Package Paths in Multi-Module Environments

Ensure module paths and package imports align to avoid issues in generated import statements and interface resolutions.

---

## Visualizing the Integration Flow

```mermaid
flowchart TD

  UserInput["Define GORM Models & Query Interfaces"] --> CLI["Run GORM CLI Code Generation"]
  CLI --> GeneratedCode["Generated Query APIs & Field Helpers"]
  GeneratedCode --> GORM["Seamless Integration with GORM *gorm.DB"]
  GORM --> Application["Use in Application Code"]

  subgraph ""
    direction LR
    GeneratedCode -->|Uses| Models["GORM Models"]
    Application -->|Invokes| GeneratedCode
    Application -->|Passes| GORM
  end

  click CLI "README.md" "See Quick Start and Configuration"
  click Models "https://gorm.io/docs/models.html" "GORM Model Definitions"
  click GeneratedCode "/overview/features-and-integration/feature-tour" "Explore Generated API Features"
  click GORM "https://gorm.io/docs/" "Official GORM Documentation"
```

---

## Next Steps

- Visit the [Feature Overview at a Glance](/overview/features-and-integration/feature-tour) to deepen your understanding of generated APIs.
- Explore the [Configuration & Customization Essentials](/overview/features-and-integration/config-customization) page to tailor generation to your needs.
- Check out the [Generating Field Helpers from Models Guide](/guides/essential-workflows/model-driven-field-helpers) for more on association operations.

---

Harness the power of GORM CLI with full confidence that your existing GORM workflows are enhanced, not disrupted, empowering you to write safer, clearer, and more maintainable database code in Go.


---