---
title: "System Architecture"
description: "Visualize the key components of GORM CLI with a mermaid diagram. Understand how code generation, CLI invocation, model/interface parsing, and output helpers interact in the tool’s workflow. See where user code, configuration, and generated files fit in."
---

# System Architecture

Explore the key components and workflow of GORM CLI that power its powerful code generation and type-safe APIs. This page visually maps how input source code, user configurations, and CLI commands interact to produce generated code, helping you understand where to focus when using or extending the tool.

---

## Why Visualize the System Architecture?

Understanding GORM CLI’s architecture helps you gain clarity on how your inputs — such as interface definitions, model structs, and configuration directives — flow through the generation pipeline. This insight is valuable when troubleshooting, customizing the generation process, or contributing to the project.

---

## Overview of Core Components

At its core, GORM CLI involves the following essential components working in concert:

- **User Code & Configuration**: Your Go source files defining models, query interfaces with SQL templates, and optional `genconfig.Config` settings
- **CLI Invocation**: The command you run (`gorm gen`) that triggers the generation process
- **AST Parsing & Model Extraction**: Internal parser walks your Go code to extract interfaces, models, methods, fields, and comments
- **Code Generation Engine**: Applies templates to generate two complementary code sets — type-safe query API implementations and model-driven field helpers
- **Output Helpers**: Save the generated Go code files to your specified output directory while maintaining package structure

---

## Workflow Explained

When you run the GORM CLI generator, the process unfolds as follows:

1. **Input Specification**: You specify input directories or files containing your Go source code, including your models and interfaces.
2. **File Scanning & Parsing**: The tool recursively scans files, parsing each with the Go parser to obtain Abstract Syntax Trees (AST).
3. **Interface and Struct Analysis**: Extracts metadata:
   - Interfaces defining SQL templated query methods
   - Structs representing your GORM models with fields and relations
4. **Configuration Resolution**: Loads any `genconfig.Config` found within packages, applying rules for inclusion/exclusion and custom type mappings.
5. **SQL Template Processing**: Reads SQL comments on interface methods to understand query structures, parameters, and conditional clauses.
6. **Code Generation**: Using templates, it generates:
   - Concrete interface implementations with type-safe SQL execution
   - Fluent field helpers for all model fields and associations
7. **Output Saving**: Writes generated files preserving relative package paths into your output folder.

---

## System Architecture Diagram

```mermaid
flowchart TD

  subgraph User Inputs
    UC1["Go Source Code: Models & Interfaces"]
    UC2["genconfig.Config (optional)"]
  end

  subgraph CLI Invocation
    CLI["Run 'gorm gen' Command"]
  end

  subgraph Parsing & Processing
    Parser["AST Parser & Analyzer"]
    ConfigLoader["Configuration Resolver"]
    SQLExtractor["Extract SQL Templates from Method Docs"]
  end

  subgraph Code Generation
    Generator["Code Generation Engine"]
    TemplateEngine["Template Renderer (pkgTmpl)"]
  end

  subgraph Output
    FileWriter["Write Generated Go Files"]
  end

  CLI --> Parser
  UC1 --> Parser
  UC2 --> ConfigLoader
  Parser --> SQLExtractor
  Parser --> ConfigLoader
  SQLExtractor --> Generator
  ConfigLoader --> Generator
  Generator --> TemplateEngine
  TemplateEngine --> FileWriter

  FileWriter -->|Generated APIs| OutputDir["Output Directory"]

  note right of UC1
    - Go structs with fields and tags
    - Interfaces with SQL comments
  end

  note right of ConfigLoader
    - Include/Exclude filters
    - Field type/name mappings
  end

  classDef component fill:#def,stroke:#333,stroke-width:1px
  class UC1,UC2,CLI,Parser,ConfigLoader,SQLExtractor,Generator,TemplateEngine,FileWriter,OutputDir component

```

---

## Practical Example

Imagine you have the following elements in your project:

- Model structs like `User` with numerous fields and relations
- An interface `Query[T any]` with SQL templated methods such as `GetByID` and `UpdateInfo`
- Optional generation configuration defining field mapping and output paths

When you execute the CLI:

```bash
gorm gen -i ./examples -o ./generated
```

GORM CLI will:

- Parse `./examples` recursively,
- Interpret your models and their fields,
- Process `Query` interface methods extracting SQL templates,
- Apply configuration to customize generation,
- Generate code files with strongly typed query APIs and field helpers,
- Write them under `./generated` maintaining package structure.

This flow ensures your development experience is streamlined with type-safe, fluent API interactions backed by compile-time checked SQL.

---

## Tips & Best Practices

- **Organize Code Clearly**: Define models and query interfaces in well-structured packages for smooth parsing.
- **Leverage `genconfig.Config`**: Customize output paths and mapping for special field types to enhance code ergonomics.
- **Write Clear SQL Templates**: Use the SQL templating DSL in method comments to enable powerful, flexible query generation.
- **Validate Output**: Always check generated code for consistency against your expectations.

---

## Troubleshooting Common Issues

<AccordionGroup title="Common Troubleshooting Topics">
<Accordion title="Parsing Failures or Missing Methods">
Ensure your interfaces are properly defined with SQL templates as comments. Parsing depends on clear documentation and Go syntax correctness.
</Accordion>
<Accordion title="Configuration Ignored or Not Applied">
Confirm your `genconfig.Config` is declared at package level in the correct files and formats. The generator automatically discovers these during file processing.
</Accordion>
<Accordion title="Output Files Not Generated as Expected">
Check your CLI command arguments for correct input and output paths. Review any Include/Exclude filters in your config that may restrict generation.
</Accordion>
<Accordion title="Code Formatting Errors in Output">
Make sure you use a compatible Go version (>=1.18) and the generator has proper permissions to write and format files.
</Accordion>
</AccordionGroup>

---

## Next Steps

Ready to dive deeper into GORM CLI? Explore these related documentation pages:

- [Product Introduction & Value](/overview/what-is-gorm-cli/product-introduction) — Understand core product benefits and features
- [Target Audience & Use Cases](/overview/what-is-gorm-cli/audience-use-cases) — Identify ideal users and how they leverage GORM CLI
- [Getting Started: Your First Generation with GORM CLI](/guides/core-workflows/getting-started) — Follow a hands-on tutorial from model to generated code


---

Harness this architectural insight to master GORM CLI and boost your Go + GORM development experience with robust, type-safe query APIs and maintainable code generation workflows.
