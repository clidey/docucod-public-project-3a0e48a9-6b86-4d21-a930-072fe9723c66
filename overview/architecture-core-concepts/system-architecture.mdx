---
title: "System Architecture Overview"
description: "A mermaid diagram and narrative walkthrough outlining the principal workflow: how query interfaces and model structs are analyzed and turned into type-safe APIs and field helpers. Shows the major components (CLI entrypoint, code generator, field/helper mapping, output) and how user code flows into generated code."
---

# System Architecture Overview

Explore the primary workflow powering the GORM CLI code generation process. This overview reveals how user-defined query interfaces and model structs are analyzed, transformed, and synthesized into strongly typed, type-safe query APIs and rich field helper structs, enabling fluent and safe interaction with your database.

---

## Unlocking Type Safety: From User Code to Generated APIs

At its core, the GORM CLI generator processes your source code—specifically, Go interfaces annotated with SQL templates and your domain model structs—and produces two main outputs:

- **Type-safe Query APIs**: Concrete implementations of your interface methods, exposing fluent, compile-time checked database queries.
- **Field Helpers**: Typed field and association helpers derived from your model structs, powering filters, updates, and association operations.

This architecture tightly integrates model metadata and query intent directly from your code, ensuring your database access code is concise, expressive, and less error-prone.

---

## How the System Works: Major Components & Workflow

```mermaid
flowchart TD

  CLIEntry[gorm CLI Entrypoint - main.go] -->|Invokes command| GenCmd[Code Generator Command - "gen"]
  GenCmd -->|Processes input| CodeGenEngine[Generator Engine - gen.go & generator.go]

  subgraph Input Sources
    UserCode[User Code
(Query Interfaces + Model Structs)]
  end
  UserCode -->|AST Parsing & Extraction| CodeGenEngine

  CodeGenEngine -->|Analyzes & maps| FieldHelperMapping[Field & Helper Mapping]
  CodeGenEngine -->|Generates| GeneratedCode[Generated Query APIs & Helpers Output]

  GeneratedCode -->|Used by| DeveloperApp[User Application]

  classDef component fill:#f9f,stroke:#333,stroke-width:2px;
  class CLIEntry,GenCmd,CodeGenEngine,FieldHelperMapping,GeneratedCode component;
```

### Component Highlights

- **CLI Entrypoint (main.go)**: The command line starts here. It registers the `gen` command using Cobra, which triggers the code generation.

- **Code Generator (`gen` command)**: Configures input and output directories, then instantiates `Generator` to traverse your source files.

- **Generator Engine (`generator.go`)**: Parses Go source files to extract interfaces and structs. It applies configured filters and mappings, preparing abstract syntax trees (AST) representing your query interfaces and models.

- **Field & Helper Mapping**: Converts model struct fields—including basic and association fields—into corresponding typed helpers (`field.Number`, `field.Struct`, `field.Slice`, etc.), facilitating builders for filters and updates.

- **Generated Code Output**: Using templated code generation (`template.go`), produces Go source files with concrete implementations of query methods and declarations of field helpers.

- **User Application**: You consume the generated strongly typed APIs and helpers directly in your business logic, unlocking type safety and productivity.

---

## User Code Flow Explained

1. **Writing Query Interfaces & Models**

  You define query interfaces with SQL templating comments for custom queries alongside model structs proving the domain schema.

  ```go
  type Query[T any] interface {
    // SELECT * FROM @@table WHERE id=@id
    GetByID(id int) (T, error)
  }

  type User struct {
    ID   uint
    Name string
    Age  int
  }
  ```

2. **Triggering Code Generation**

  Run the CLI tool specifying input package path and output directory:

  ```bash
  gorm gen -i ./examples -o ./generated
  ```

  The generator traverses your interfaces and structs, applying configured field type mappings and filters.

3. **Generation Process**

  - **AST Parsing** identifies interfaces and their methods.
  - **SQL Template Extraction** parses SQL fragments from method comments.
  - **Field Helper Mapping** inspects model fields to generate typed predicates, setters, and association helpers.
  - **Output Rendering** composes ready-to-use Go source files based on templates.

4. **Using Generated APIs**

  Consume the generated APIs and helpers seamlessly:

  ```go
  u, err := generated.Query[User](db).GetByID(ctx, 123)
  users, err := gorm.G[User](db).Where(generated.User.Age.Gt(18)).Find(ctx)
  ```

---

## Why This Matters: Impact of the Architecture

- **Type Safety at Compile Time**: The generation pipeline guarantees your queries adhere strictly to your model types and constraints.

- **Unified Code Base**: Your domain models and query interfaces live together, reducing code duplication and ensuring consistency.

- **Configurable & Extensible**: Supports custom field mappings (e.g., JSON helpers), inclusion/exclusion filters, and flexible output paths via config.

- **Invisible Complexity**: The CLI and generator abstract the parsing, mapping, and code synthesis — developers write familiar Go interfaces and structs.

- **Error Minimization**: SQL fragment annotations catch errors early with generated code rather than runtime failures.

---

## Best Practices & Tips

- **Keep Your Interfaces Simple**: Define interfaces with clear SQL templates and concise methods.

- **Use Configuration to Control Generation Scope**: Use `genconfig.Config` to limit scaffolding to essential interfaces and structs.

- **Maintain Consistent Naming**: Follow field naming conventions to maximize helper generation.

- **Leverage Association Helpers**: Use generated association helpers to reliably manage related entities (Create, Update, Unlink, Delete).

- **Incrementally Adopt**: Start with a small set of interfaces/models, then expand to cover your domain.

---

## Troubleshooting Common Issues

<AccordionGroup title="Troubleshooting Generation Issues">
<Accordion title="Input Path Errors">
If the `-i` input path is incorrect or missing, generation will fail with a descriptive error. Ensure the path points to the directory or Go files with your interfaces and models.
</Accordion>
<Accordion title="Missing SQL Annotations or Syntax Errors">
Methods lacking proper SQL template comments will cause generation or runtime issues. Verify your method docs contain valid templates with placeholders.
</Accordion>
<Accordion title="Field Mapping Omissions">
If custom types are not generating helpers, ensure you include them in `FieldTypeMap` or `FieldNameMap` within `genconfig.Config`.
</Accordion>
<Accordion title="Output Permission Problems">
The CLI might fail creating files if output directories are inaccessible or lack permissions. Use accessible folders or adjust permissions.
</Accordion>
</AccordionGroup>

---

## Next Steps

- [Getting Started: Code Generation](/guides/core-workflows/getting-started-generation): Dive into the practical workflow for generating your first APIs.
- [Working With Basic Fields](/guides/best-practices-patterns/working-with-basic-fields): Learn how to fully leverage generated field helpers.
- [Writing Template-Based Queries](/guides/best-practices-patterns/template-based-queries): Master SQL template DSL for custom query scenarios.


---

For the full CLI source and generator internals, see the [GORM CLI repository on GitHub](https://github.com/go-gorm/cli).

---

## References

- `main.go`: CLI entrypoint registering the `gen` command.
- `internal/gen/gen.go`: Cobra command definition and flags for code generation.
- `internal/gen/generator.go`: Core engine parsing input files, applying configs, and generating output.
- `internal/gen/template.go`: Template for producing Go source files from parsed metadata.

---