---
title: "Architectural Overview"
description: "Provides a visual and narrative explanation of the tool’s architecture: how source interfaces and models are ingested, processed, and converted into generated field helpers and query APIs. Includes a mermaid diagram summarizing the data flow and major components."
---

# Architectural Overview

Unlock a clear, high-level understanding of how GORM CLI transforms your Go interfaces and models into powerful, type-safe query APIs and model-driven field helpers. This page walks you through the core architecture and data flow behind the scenes, empowering you to grasp how your source code is parsed, processed, and generates the final code you use.

---

## Why This Matters

Before you dive into writing your interfaces or struct definitions, it helps to see how GORM CLI works under the hood. Understanding the architectural flow enables you to better anticipate how your code changes affect generation results, debug potential issues, and customize your generation configuration effectively.

Imagine writing a query interface and model once, and then GORM CLI reliably and repeatedly produces exactly the type-safe APIs and field helpers you need, with no surprises. That's the power unlocked by knowing what happens inside.

---

## High-Level Architecture: From Source to Generated Code

At its core, GORM CLI executes a streamlined, multi-stage workflow:

1. **Source Input** — Your Go code files defining query interfaces and GORM models.
2. **Parsing and AST Inspection** — The tool reads Go source files, analyzes interfaces, methods, and structs using Go's parser and AST.
3. **Configuration Application** — Package-level configs like `genconfig.Config` refine how files and types are included, excluded, or mapped.
4. **Code Model Construction** — Metadata is extracted to build structured representations of interfaces, methods, structs, and fields.
5. **Template-Driven Code Generation** — Uses embedded templates to convert metadata into concrete Go code for query APIs and field helpers.
6. **Formatting and Output** — Runs imports processing and formatting to produce idiomatic, ready-to-use Go source files.

This pipeline runs via the `gen.Generator` orchestrator, centralizing reading, processing, and generation tasks.

```mermaid
flowchart TD
  subgraph Source Input
    A1[Go Interfaces]
    A2[Go Models (Structs)]
    A3[Package-level Config (genconfig.Config)]
  end
  
  subgraph Parsing & Analysis
    B1[Parse Go Files & Build AST]
    B2[Identify Interfaces and Methods]
    B3[Identify Structs and Fields]
    B4[Apply Config Filters & Mapping]
  end

  subgraph Code Model Construction
    C1[Extract Metadata for Interfaces]
    C2[Extract Metadata for Methods]
    C3[Extract Metadata for Struct Fields]
    C4[Construct Unified In-memory Model]
  end

  subgraph Generation
    D1[Render Query API Code via Templates]
    D2[Render Field Helper Code via Templates]
  end

  subgraph Output
    E1[Format & Fix Imports]
    E2[Write Generated Go Files]
  end

  A1 & A2 & A3 --> B1
  B1 --> B2 & B3 & B4
  B2 & B3 & B4 --> C1 & C2 & C3
  C1 & C2 & C3 --> C4
  C4 --> D1 & D2
  D1 & D2 --> E1
  E1 --> E2

  classDef source fill:#d6eaff,stroke:#3399ff,stroke-width:2px;
  class A1,A2,A3 source;
  classDef parse fill:#d2f8d2,stroke:#33aa33,stroke-width:2px;
  class B1,B2,B3,B4 parse;
  classDef model fill:#fff4cc,stroke:#ccaa00,stroke-width:2px;
  class C1,C2,C3,C4 model;
  classDef gen fill:#fde2e2,stroke:#cc3333,stroke-width:2px;
  class D1,D2 gen;
  classDef output fill:#e7e7f7,stroke:#6666cc,stroke-width:2px;
  class E1,E2 output;
```

---

## Key Components Explained

### 1. Source Input

- **Go Interfaces:** Define the method signatures adorned with SQL templates inside comments. These drive the generation of type-safe query methods.
- **Go Models:** Struct types representing your database tables, including fields and associations, used to generate strongly typed field helpers.
- **Configuration:** Optional package-level `genconfig.Config` values customize output locations, inclusion/exclusion rules, and type mappings.

### 2. Parsing & Analysis

- The generator parses Go source files to construct an abstract syntax tree (AST).
- It walks the AST to locate interfaces and structs.
- Applies filters and inclusions from config files to determine what to generate.
- Extracts method comments to parse SQL templates and method signatures.

### 3. Code Model Construction

- For each interface and method, the generator builds a detailed internal representation capturing parameters, return types, and SQL logic.
- For each struct and field, it determines field types, database column names, and any special generation tags.
- Combines this into a unified model that serves as the single source of truth for template rendering.

### 4. Template-Driven Code Generation

- Uses Go `text/template` files embedded in the codebase.
- These templates generate:
  - **Query API implementations:** Concrete methods that execute SQL with full type safety and context awareness.
  - **Field helpers:** Strongly typed helpers for predicates, setters, and association operations.

### 5. Formatting and Output

- Newly generated Go files are formatted according to Go standards.
- Imports are automatically managed and optimized.
- Results are saved to user-specified output locations.

---

## Practical Example: Workflow From Your Perspective

1. You write a `Query[T]` interface with SQL templating comments and your `User` struct with GORM annotations.
2. You configure an optional `genconfig.Config` to customize generation.
3. Running `gorm gen` scans your source files.
4. The generator:
   - Parses your interface, detecting methods and extracting SQL templates.
   - Parses your model structs, noting fields and associations.
   - Applies your configuration rules.
   - Generates query API code with type-safe method implementations.
   - Generates field helper structs with predicate and update methods.
5. You then consume the generated code with confidence it’s complete, idiomatic, and type-safe.

---

## Tips & Best Practices

- **Organize interfaces and models clearly:** Group related interfaces and models together for coherent package structure.
- **Leverage configuration:** Use `genconfig.Config` to tailor output paths, include/exclude patterns, and custom field mappings.
- **Keep SQL templates expressive yet simple:** Use the template DSL to include optional filters and dynamic SQL fragments to maximize flexibility.
- **Run generation frequently:** Integrate `gorm gen` in your build or development workflow to catch issues early.

---

## Troubleshooting Common Issues

<AccordionGroup title="Troubleshooting & Guidance">
<Accordion title="No generated files appear after running the generator">
Check your `genconfig.Config` filters (IncludeInterfaces, ExcludeInterfaces). If your interfaces or structs are excluded by pattern or config, no code will be generated. Remove or adjust filters accordingly.
</Accordion>
<Accordion title="Methods in generated code are missing or incomplete">
Ensure your interface method comments follow the SQL templating DSL precisely. The generator parses comments to build implementations. Invalid or missing templates prevent generation.
</Accordion>
<Accordion title="Output directory is incorrect or files are misplaced">
Verify the `OutPath` in your `genconfig.Config` or command-line arguments. By default, output lands relative to the package location or your override.
</Accordion>
</AccordionGroup>

---

## Next Steps

Now that you understand the architecture, explore these pages to get hands-on and deepen your mastery:

- [What is GORM CLI?](./what-is-gorm-cli) — Learn the basics and value propositions.
- [Quickstart & Basic Workflow](./quickstart-workflow) — Get started writing interfaces and generating code.
- [Configuring the Generator](../../getting-started/configuration-troubleshooting/configuring-generator) — Customize your generation process.

---

Dive deeper, leverage the architecture, and enjoy productive, type-safe database development with GORM CLI.
