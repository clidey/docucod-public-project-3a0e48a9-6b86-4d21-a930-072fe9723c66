---
title: "Core Concepts and Terminology"
description: "Clarify essential terms and structures: interface-driven queries, field helpers, associations, SQL template DSL, generation configuration, and type-safety. Provide short definitions and explain how these elements relate to everyday GORM development."
---

# Core Concepts and Terminology

Welcome to the foundational guide for understanding the essential terms and structures that drive your experience with GORM CLI. This page unpacks the key concepts you'll encounter regularly—interface-driven queries, field helpers, associations, the SQL template DSL, generation configuration, and type-safety—helping you grasp how these components interconnect to supercharge your GORM development.

---

## Interface-Driven Queries

At the heart of GORM CLI lies a powerful paradigm: writing plain Go interfaces representing your database queries, enriched by SQL templates in method comments. These interfaces don't execute SQL themselves—they declare *what* you want in a type-safe manner.

**What you achieve:**

- **Compile-time safety**: Your query method signatures enforce type correctness, catching errors before runtime.
- **Clear intent**: Methods like `GetByID(id int) (User, error)` express exactly the operation being performed.
- **Seamless generation**: The CLI tool turns your annotations into concrete, ready-to-use query implementations.

**Example:**

```go
// Query[T any] is a generic interface for querying a model
// SELECT * FROM @@table WHERE id=@id
GetByID(id int) (T, error)
```

This approach lets you write SQL close to your Go code, maintaining strong type bindings throughout.

---

## Field Helpers

GORM CLI generates *field helpers* for your model structs — typed wrappers for each database column that simplify writing filters, updates, and managing associations.

**Benefits for your workflow:**

- Intuitive, fluent APIs for common predicates like `Eq`, `Like`, `Between`, etc.
- Clear, readable query construction without string-based raw SQL.
- Strong typing avoids mistakes and guides you with autocompletion.

**Example usage:**

```go
// Filter users with name like 'jinzhu' and age between 18 and 65
users, err := gorm.G[User](db).
  Where(generated.User.Name.Like("%jinzhu%")).
  Where(generated.User.Age.Between(18, 65)).
  Find(ctx)
```

For updates and creates, these helpers enable setting field values or expressions with confidence:

```go
gorm.G[User](db).
  Set(
    generated.User.Name.Set("alice"),
    generated.User.Age.Incr(1),
  ).
  Update(ctx)
```

---

## Associations

Handling related records is complex in ORM contexts, but GORM CLI simplifies this with generated association helpers corresponding to your model relationships.

**Supported association types:**
- `belongs to`
- `has one` / `has many`
- `many2many` (including polymorphic)

**Operations you can perform safely:**
- `Create` and `CreateInBatch` to insert and link related entities
- `Update` to modify associated rows with optional conditions
- `Unlink` to remove links without deleting data
- `Delete` to fully remove associated records or join rows

**Example:** Create a new user with pets linked

```go
gorm.G[User](db).
  Set(
    generated.User.Name.Set("alice"),
    generated.User.Pets.Create(generated.Pet.Name.Set("fido")),
  ).
  Create(ctx)
```

This approach enforces **compile-time safety**, ensuring association operations correspond precisely to your schema and usage intent.

---

## SQL Template DSL

GORM CLI leverages a *SQL template Domain Specific Language (DSL)* within your interface method comments to describe custom SQL queries with flexibility and safety.

**Key placeholders and directives:**

| Directive   | Purpose                              | Example                                   |
|-------------|------------------------------------|-------------------------------------------|
| `@@table`   | Resolves to the model's table name | `SELECT * FROM @@table WHERE id=@id`      |
| `@@column`  | Bind dynamic column names           | `WHERE @@column=@value`                    |
| `@param`    | Map Go parameters to SQL parameters | `WHERE name=@user.Name`                    |
| `{{where}}` | Conditional WHERE clause builder     | `{{where}} age > 18 {{end}}`               |
| `{{set}}`   | Conditional SET clause for UPDATE    | `{{set}} name=@name {{end}}`               |
| `{{if}}`    | Conditional SQL fragments            | `{{if age > 0}} AND age=@age {{end}}`     |
| `{{for}}`   | Loop over collections                | `{{for _, tag := range tags}} ... {{end}}`|

**Example:**

```sql
// SELECT * FROM @@table
// {{where}}
//   {{if user.ID > 0}}
//     WHERE id=@user.ID
//   {{else if user.Name != ""}}
//     WHERE name=@user.Name
//   {{end}}
// {{end}}
QueryWith(user User) (T, error)
```

This DSL lets you write expressive, maintainable SQL templates embedded inline with Go code and enjoy automatic parameter binding and code generation.

---

## Generation Configuration

You don’t need to configure the generation process to get started, but when your project grows, you may want to customize how the CLI tool generates code.

**Flexible configurations via `genconfig.Config` include:**

- Specify output directory for generated files with `OutPath`
- Customize field helper types for special Go types via `FieldTypeMap` and `FieldNameMap`
- Scope generation to specific interfaces or structs with whitelists (`Include*`) or blacklists (`Exclude*`)
- Choose if configuration applies to the whole package or just individual files

**Example configuration snippet:**

```go
var _ = genconfig.Config{
  OutPath: "examples/output",
  FieldTypeMap: map[any]any{
    sql.NullTime{}: field.Time{},
  },
  FieldNameMap: map[string]any{
    "json": JSON{},
  },
  IncludeInterfaces: []any{"Query*"},
}
```

This gives you granular control to tailor generation behavior without changing your core model or interface definitions.

---

## Type-Safety Throughout

A cornerstone of GORM CLI’s value is its commitment to **compile-time type safety**. By generating APIs derived from your strongly typed interfaces and model definitions, you avoid common pitfalls like:

- Runtime SQL errors due to mismatched parameters
- Incorrect field references
- Broken association handling

Your generated code forms a fluent API that integrates directly with GORM’s internals, keeping your project both idiomatic and robust.

---

## How These Concepts Work Together in Everyday Development

Imagine you’re building a backend service that manages users and their pets. Instead of writing raw SQL queries embedded in code, you define:

1. **Model structs** representing your database schema.
2. **Query interfaces** with SQL templates describing how to fetch or modify data.
3. **Generation configurations** to adapt to your project’s needs.

Run the CLI generator, and it produces:

- Type-safe query methods you can call directly, like `generated.Query[User](db).GetByID(ctx, 123)`.
- Field helpers like `generated.User.Name.Like("%jinzhu%")` facilitating complex filters.
- Association helpers that let you create users and their pets in a single, safe call.

This workflow eliminates guesswork and empowers your team to write database code confidently and efficiently.

---

## Next Steps

Explore how these core concepts are implemented in practice:

- [Getting Started: Generate Your First Query API](/guides/core-workflows/getting-started) guides the initial code generation process.
- [Model-Driven Field Helpers: Filters, Updates & Associations](/guides/core-workflows/field-helper-basics) dives into using and customizing field helpers.
- [Template-Based Queries: From Interface to Custom SQL](/guides/advanced-patterns/template-sql-workflows) expands on writing your own SQL templates for complex queries.

Understanding these building blocks sets the foundation for maximizing GORM CLI's potential in your projects.

---

## Related Documentation

- [What is GORM CLI? (Introduction)](/overview/product-intro/what-is-gorm-cli)
- [Key Features at a Glance](/overview/product-intro/core-features-overview)
- [Generation Configuration and Filtering](/concepts/extensibility-templates-config/generation-configuration)
- [Type Safety and Fluent API Concepts](/concepts/core-architecture/type-safety-and-api-design)

---