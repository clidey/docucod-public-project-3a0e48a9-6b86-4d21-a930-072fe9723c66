---
title: "Integration with GORM and Go Tooling"
description: "Understand how GORM CLI-generated code plugs directly into standard GORM workflows and Go project structures. Learn how configuration, dependencies, and output management support modern development pipelines."
---

# Integration with GORM and Go Tooling

Unlock the full potential of GORM CLI by seamlessly integrating its generated code with your existing GORM setup and Go project workflows. This page guides you through how generated query APIs and model-driven field helpers fit naturally into standard GORM usage patterns, highlighting configuration considerations, dependency management, and the layout of generated output.

---

## Why Integration Matters

GORM CLI generates type-safe, interface-driven query APIs and model-based field helpers that are designed to work hand-in-hand with GORM, the popular Go ORM. Rather than imposing a completely new paradigm, the generated code acts as a powerful extension: enhancing your existing GORM queries with compile-time safety and fluent helpers.

### Benefits

- **Type Safety:** Generated APIs offer precise method signatures that catch SQL and parameter mismatches early.
- **Fluent APIs:** Field helpers enable building expressive filters, updates, and association operations.
- **Minimal Disruption:** Integrates smoothly into typical GORM workflows without requiring drastic changes.
- **Consistency:** Leverages your existing models and interfaces, ensuring all generated code aligns with your domain.

---

## How Generated Code Fits into GORM Workflows

At the core, your Go project continues to use the standard `*gorm.DB` object for database operations. GORM CLI-generated types wrap around this core object, injecting your custom, type-safe query methods and field helpers.

### User Flow Example

1. **Define Query Interfaces & Models:** You write Go interfaces with SQL comments and model structs.
2. **Run GORM CLI Code Generator:** Use the CLI to generate query API implementations and helpers.
3. **Use Generated APIs with GORM DB:** Invoke generated methods by passing in your `*gorm.DB` instance.

Here is a typical usage snippet:

```go
// Import generated package, e.g. "generated"
user, err := generated.Query[models.User](db).GetByID(ctx, 123)

// Using generated field helpers in GORM filters
users, err := gorm.G[models.User](db).
  Where(generated.User.Age.Gt(18)).
  Find(ctx)
```

> The generated `Query[T]` interface extensions wrap the GORM database handle while exposing your strong, SQL-template-driven methods.

---

## Managing Generated Output

By default, GORM CLI's generated code is placed in an output directory (e.g., `./g`) separate from your handwritten source files. This separation facilitates:

- **Clear project boundaries** between generated and handwritten code
- **Easy inclusion/exclusion in version control**
- **Integration with Go tooling** such as `go mod`, `go test`, and IDEs

The output directory is configurable through the CLI flag `-o` or programmatic config.

### Typical Directory Layout

```
/your-project
  /models
    user.go
  /queries
    query.go
  /generated
    user_gen.go        # model-driven field helpers
    query_gen.go       # generated query interface implementations
```

Be sure to add the generated directory to your Go module’s source if it’s not at the root, so that imports resolve cleanly.

---

## Configuration and Dependency Considerations

GORM CLI generates code that imports your existing model packages and depends on the standard GORM library (`gorm.io/gorm`). Ensure your project:

- Uses Go Modules (`go.mod`) to manage dependencies
- Has compatible versions of GORM and GORM CLI (requires Go 1.18+ for generics)
- Configures `genconfig.Config`, if needed, to customize output directories and field mappings

### Simplified Dependency Flow

- Your handwritten models (e.g., `models.User`) define the schema and associations
- Generated query APIs and helpers depend on these models and GORM packages
- Your main application imports generated code alongside the models and GORM

This layered dependency promotes modular and maintainable codebases.

---

## Working Example: Using Generated Code in a Go Project

Suppose you have the following:

```go
// models/user.go
package models

type User struct {
  gorm.Model
  Name string
  Age  int
}

// queries/query.go
package queries

type Query[T any] interface {
  // SELECT * FROM @@table WHERE id=@id
  GetByID(id int) (T, error)
}
```

After running the generator:

```bash
gorm gen -i ./queries -o ./generated
```

You can then write:

```go
import (
  "context"
  "yourproject/generated"
  "yourproject/models"
  "gorm.io/gorm"
)

func ExampleUsage(db *gorm.DB) {
  ctx := context.Background()

  user, err := generated.Query[models.User](db).GetByID(ctx, 123)
  if err != nil {
    panic(err)
  }
  fmt.Println(user.Name)

  users, err := gorm.G[models.User](db).
    Where(generated.User.Age.Gt(18)).
    Find(ctx)
  if err != nil {
    panic(err)
  }
  fmt.Println("Found", len(users), "adult users")
}
```

This illustrates how produced code integrates cleanly with your application.

---

## Best Practices and Tips

- **Keep models and interfaces colocated:** This improves clarity and code generation accuracy.
- **Manage generated code carefully:** Use `.gitignore` or explicit commits for generated code as appropriate.
- **Leverage configuration:** Use `genconfig.Config` to tailor output and type mappings.
- **Test generated APIs:** Incorporate tests to verify generated query behaviors.
- **Use Go tooling:** IDEs, linters, and formatting tools will work with generated Go source if structured properly.

---

## Common Pitfalls and Troubleshooting

<AccordionGroup title="Common Integration Issues">
<Accordion title="Missing or Incorrect Imports in Generated Code">
Generated code depends on correct import paths.

- Verify your Go module paths and package names match expectations.
- Use `genconfig.Config` to adjust OutPath or package scoping if needed.
- Ensure interfaces and models are in accessible packages.
</Accordion>
<Accordion title="Generated Code Not Found by Go Module">
If Go tools can't find your generated code:

- Confirm that the output directory is inside your Go module or explicitly referenced.
- Add the generated output directory to your module's source if outside.
- Run `go mod tidy` to refresh dependencies.
</Accordion>
<Accordion title="Version or Compatibility Errors">
- Ensure Go version 1.18+ is used.
- Use compatible versions of GORM and GORM CLI.
- Regularly update dependencies with `go get -u`.
</Accordion>
</AccordionGroup>

---

## Summary Diagram: How Generated Code Integrates

```mermaid
flowchart TD
  A[Developer Code: Models & Query Interfaces] --> B[GORM CLI Generator]
  B --> C[Generated Code: Query APIs & Field Helpers]
  C -.-> D[GORM Package (gorm.io/gorm)]
  D --> E[Database]
  F[Your Application Code] -->|Uses| C
  F -->|Uses| D
  E -- Data --> F

  style B fill:#f9f,stroke:#333,stroke-width:2px
  style C fill:#bbf,stroke:#333,stroke-width:2px
  style D fill:#bfb,stroke:#333,stroke-width:2px
```

### Explanation:
- Your handwritten models and query interfaces input into the GORM CLI generator.
- The generator produces typed query API implementations and model field helpers.
- Your application consumes the generated code along with the base GORM package.
- The GORM package manages database interactions, maintaining your usual workflows.


---

## Next Steps

- Explore the [Quickstart & Typical Workflow](/overview/real-world-integration-use-cases/quickstart-and-workflow-overview) for hands-on setup.
- Dive into [Core Concepts and Terminology](/overview/system-architecture-core-concepts/core-concepts-and-terminology) for foundational understanding.
- Learn advanced patterns in the [Guides](/guides).

> Start by defining query interfaces together with your models, generate your code with the CLI, then seamlessly integrate the output into your GORM-powered Go applications for safer, efficient data access.

---