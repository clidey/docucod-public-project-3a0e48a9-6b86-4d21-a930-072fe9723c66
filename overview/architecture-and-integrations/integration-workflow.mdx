---
title: "Integration & Workflow with GORM"
description: "Understand the typical developer workflow: defining models/interfaces, running the CLI generator, and consuming the generated code with GORM. Outlines seamless integration, automation points, and how generation fits in standard Go projects."
---

# Integration & Workflow with GORM

Discover the typical developer journey to seamlessly integrate GORM CLI-generated code with GORM in your Go projects. This guide breaks down the step-by-step workflow from defining your data models and query interfaces, running the CLI code generator, to utilizing the generated type-safe APIs and field helpers in your application â€” enabling fluent, compile-time safe database operations with minimal boilerplate.

---

## Why This Matters

GORM CLI is designed to empower Go developers working with GORM by automating the creation of type-safe, expressive query and update APIs rooted in your native Go models and interfaces. By understanding how the generation fits into your GORM project structure and the developer workflow, you accelerate development, avoid common runtime errors, and maintain a smooth, idiomatic Go coding experience.


## Typical Developer Workflow

### 1. Define Your Models and Query Interfaces

Begin by declaring your GORM models as Go structs and your query interfaces embedding SQL templates in method comments. Models represent your database tables with rich field definitions and associations, while query interfaces specify common database operations in a type-safe, expressive manner.

**Example:**

```go
// models/user.go
package models

type User struct {
    gorm.Model
    Name string
    Age  int
}

// queries/query.go
package queries

type Query[T any] interface {
    // SELECT * FROM @@table WHERE id=@id
    GetByID(id int) (T, error)

    // where("name=@name AND age=@age")
    FilterByNameAndAge(name string, age int)
}
```

This model and interface define how you intend to read and filter user data using strongly typed methods.

---

### 2. Run the GORM CLI Generator

With your interfaces and models in place, invoke the GORM CLI generator via the `gorm gen` command, targeting the package or file containing your interfaces.

```bash
gorm gen -i ./queries -o ./generated
```

- `-i` specifies the input directory or file containing your Go interfaces with SQL annotations.
- `-o` defines the output directory for the generated Go code.

Behind the scenes, the CLI tool parses your interfaces and models, applying configuration options if any, and generates:

- **Query APIs:** Concrete implementations of your interfaces that return type-safe query builders.
- **Field Helpers:** Statically typed column and association helpers for constructing filters, updates, and associations.


---

### 3. Consume the Generated Code in Your GORM Project

Import and use the generated APIs alongside your GORM DB instance to perform queries and mutations with concise, fluent syntax and compile-time safety.

**Sample usage:**

```go
// SELECT * FROM users WHERE id=123
user, err := generated.Query[User](db).GetByID(ctx, 123)

// SELECT * FROM users WHERE age > 18
users, err := gorm.G[User](db).Where(generated.User.Age.Gt(18)).Find(ctx)
```

This approach leverages generated helpers, avoiding string-based SQL and reducing the chance for runtime errors.

---

## Key Integration Points

### Seamless Integration with GORM `*gorm.DB`

- All generated APIs require a `*gorm.DB` instance as the starting point.
- The generated query interfaces embed the underlying GORM constructs, allowing you to chain additional GORM operations freely.

### Automation via CLI

- The CLI generator discovers your interfaces and models automatically, respecting any optional package-level `genconfig.Config` declarations to customize generation paths and behavior.

### Model-Driven Field Helpers

- Generated constants and structs like `generated.User.Name` provide type-safe methods (`Eq`, `Like`, `Set`, etc.) for building predicates and updates.
- Association helpers simplify complex relational operations such as creating, batch linking, unlinking, and deleting related entities.

### Query Interface-Based SQL Generation

- SQL templates embedded in interface comments enable flexible, dynamic query generation that adapts to method parameters and contextual filters.
- The generator supports DSL features like conditional `WHERE` clauses, iteration across collections, and parameter binding.

---

## Developer Workflow Summary

```mermaid
flowchart TD
  A[Define Models & Query Interfaces] --> B[Run CLI Generator (gorm gen)]
  B --> C[Generated Query APIs & Field Helpers]
  C --> D[Use APIs with GORM *gorm.DB]
  D --> E[Perform Type-Safe Queries & Updates]
  E --> F[Cleaner Code & Fewer Runtime Errors]

  subgraph CLI Generation
    B
    C
  end

  subgraph Application Usage
    D
    E
    F
  end
```

This flow embodies the clean separation between your handwritten specifications and the generated, tested code facilitating the safest database interactions.

---

## Best Practices & Tips

- **Keep models and query interfaces close:** Organize models and interfaces within the same package or directory to simplify code generation.
- **Leverage `genconfig.Config` for customization:** Use package-level config files to fine-tune output directory, type mappings, inclusion/exclusion filters, and naming.
- **Regenerate code after model changes:** Always rerun `gorm gen` after updating your models or queries to keep generated code in sync.
- **Use generated helpers for all DB operations:** To fully benefit from type safety and compile-time checks, avoid raw SQL or dynamic string conditions where possible.

---

## Troubleshooting

<AccordionGroup title="Common Issues and Solutions">
<Accordion title="Generated Code Not Found or Missing Methods">
- Ensure you run `gorm gen` with correct flags (`-i` input, `-o` output).
- Verify that your interfaces include SQL template comments correctly.
- Confirm that the package where generation happens is imported properly.
</Accordion>

<Accordion title="Compilation Errors After Model Changes">
- Re-run the generator to regenerate helper fields and methods.
- Check for inconsistencies or unsupported field types in models.
</Accordion>

<Accordion title="Runtime Errors: Unhandled SQL Conditions">
- Confirm that your SQL templates use supported DSL directives.
- Validate parameter names match method signatures.
- Use clear error logs from GORM and generator output.
</Accordion>
</AccordionGroup>

---

## Next Steps

- Explore the [First Code Generation Workflow](https://docs.gorm.io/getting-started/first-codegen-workflow/prepare-models-interfaces) to deepen your understanding of defining models and queries.
- Dive into [Using the Generated Code](https://docs.gorm.io/getting-started/first-codegen-workflow/using-generated-code) for advanced usage patterns.
- Customize generation with [Basic Configuration Options](https://docs.gorm.io/getting-started/first-codegen-workflow/basic-configuration-options).

Start integrating GORM CLI into your development cycle today and unlock type-safe, agile database operations with GORM.

<Source url="https://github.com/go-gorm/cli" paths={[{"path":"README.md","range":"1-320"},{"path":"internal/gen/gen.go","range":"1-75"},{"path":"examples/query.go","range":"1-87"}]} />