---
title: "Quickstart Workflow"
description: "Presents a high-level workflow: define query interfaces and models, generate code, and use the resulting APIs in a working project. Includes representative code snippets to illustrate the complete development loop."
---

# Quickstart Workflow

## Jumpstart Your GORM CLI Integration

Embarking on your GORM CLI journey is straightforward and powerful. This page walks you through the complete high-level flow of using GORM CLI to create robust, type-safe database query APIs and field helpers for your Go projects. From defining clean, annotated query interfaces and models, to generating code, then finally integrating that code into your application â€“ you'll gain confidence in a workflow that saves time, reduces bugs, and scales smoothly.

---

## 1. Define Query Interfaces and Models

### Focus on Intent: Write Interfaces That Represent Queries

Begin by writing Go interfaces that express the data access methods your application needs. Each interface method carries SQL templates embedded in Go comments, specifying the exact query logic with placeholders bound to method parameters.

For example, a simple generic query interface might look like this:

```go
// examples/query.go
package examples

type Query[T any] interface {
  // GetByID fetches a record by its unique ID
  // SELECT * FROM @@table WHERE id=@id
  GetByID(id int) (T, error)

  // FilterByNameAndAge returns records filtered by name and age
  // where("name=@name AND age=@age")
  FilterByNameAndAge(name string, age int) ([]T, error)
}
```

### Define Your Models

Next, declare your GORM model structs with fields representing your database schema. This serves as the blueprint to generate field helpers, making queries fluent and type-safe.

```go
// examples/models/user.go
package models

type User struct {
  ID   uint
  Name string
  Age  int
}
```

Together, these form the core input for the code generator.

---

## 2. Generate Code Using GORM CLI

### Run the CLI Command

With your interfaces and models defined (usually in the same directory or package), run the GORM CLI code generator:

```bash
gorm gen -i ./examples -o ./generated
```

- `-i` points to the input directory/file with your query interfaces.
- `-o` specifies the output directory where generated code will be placed (default is `./g`).

### What Happens Behind the Scenes

The generator parses your interfaces, extracts SQL templates from method comments, and processes your model structs to create:

- **Type-safe Query APIs** based on your annotated interfaces.
- **Strongly typed Field Helpers** for model fields and associations.

The generated code offers fluent methods for querying, filtering, updating, and managing associations, all with compile-time validation.

---

## 3. Use the Generated APIs in Your Application

After generation, import the generated package and start invoking your queries with type safety and improved developer ergonomics.

### Example Usage

```go
package main

import (
  "context"
  "fmt"

  "gorm.io/gorm"
  "examples/generated"
  "examples/models"
)

func main() {
  var db *gorm.DB // Assume db is initialized and connected
  ctx := context.Background()

  // Use generated Query interface for User
  q := generated.Query[models.User](db)

  // Fetch a user by ID
  user, err := q.GetByID(ctx, 123)
  if err != nil {
    fmt.Println("Error fetching user:", err)
    return
  }
  fmt.Printf("Found user: %+v\n", user)

  // Filter users by name and age
  users, err := q.FilterByNameAndAge(ctx, "jinzhu", 25)
  if err != nil {
    fmt.Println("Error filtering users:", err)
    return
  }
  fmt.Printf("Filtered users: %+v\n", users)
}
```

### Fluent Use of Field Helpers

You can also use generated field helpers to build complex queries or updates:

```go
// Find users with age greater than 18
adultUsers, err := gorm.G[models.User](db).
  Where(generated.User.Age.Gt(18)).
  Find(ctx)

// Update user's name by ID
err := generated.Query[models.User](db).
  UpdateUser(ctx, models.User{Name: "newname"}, 1)
```

The generated APIs simplify everyday ORM operations while enforcing safety and discoverability.

---

## Why This Workflow Matters

- **Eliminate Boilerplate:** Write concise query interfaces and models only. Let the generator handle the repetitive code.
- **Catch Runtime Issues Early:** Compile-time safety in queries prevents mistakes often found only at runtime.
- **Maintain Fluent, Readable Code:** Generated helpers allow expressive code reflecting your domain logic clearly.
- **Scale Confidently:** Patterns supported for associations, complex filters, and updates help grow your app without messy manual SQL.

---

## Tips for Success

- Place interfaces and models carefully, ideally in the same package or close folders, to allow the generator to find and link them properly.
- Use the built-in SQL template DSL to embed sophisticated query logic inside comments, keeping Go method signatures clean and meaningful.
- Customize generation via `genconfig.Config` if needed for output paths or type mappings.
- Run the `gorm gen` command every time you modify query interfaces or model definitions to keep generated code up to date.

---

## Common Pitfalls & Troubleshooting

<AccordionGroup title="Quickstart Troubleshooting">
<Accordion title="The generator doesn't find my interfaces or models">
Check your input path (`-i`) correctness and ensure interfaces and models are exported and properly annotated.
</Accordion>
<Accordion title="Compilation errors after generation">
Ensure your interfaces return an error type as the last return value. Every SQL method must follow expected method signature patterns.
</Accordion>
<Accordion title="Generated code conflicts or import issues">
Verify import paths and package organization. Use config overrides to adjust output paths or type mappings if necessary.
</Accordion>
</AccordionGroup>

---

## Next Steps

- Head to **Installation & Setup** for environment requirements and initial installation.
- Explore the **Integration with GORM** page to deepen your knowledge of combining generated APIs with your GORM workflows.
- Dive into **Guide: Getting Started with GORM CLI** for a detailed hands-on tutorial.

---

## Summary Diagram: Workflow Overview

```mermaid
flowchart TD
  A[Define Query Interfaces
and Models] --> B[Run GORM CLI Generator
(gorm gen command)]
  B --> C[Generated Code
(Query APIs and Field Helpers)]
  C --> D[Use Generated APIs
in App Code]
  D --> E[Benefits: Type Safety,
Fluent API, Less Boilerplate]
```

---