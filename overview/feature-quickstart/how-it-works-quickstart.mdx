---
title: "How It Works: Quick Start"
description: "Follow the essential workflow: define query interfaces and models, run the generator command, and start using the generated APIs. Get a step-by-step primer designed for rapid onboarding and immediate productivity."
---

# How It Works: Quick Start

Welcome to the essential workflow guide for getting started rapidly with GORM CLI. This page walks you through the fundamental steps to define your query interfaces and models, run the generation command, and start leveraging the generated, type-safe APIs in your Go projects. Designed as a step-by-step primer, this guide ensures you achieve immediate productivity with minimal setup.

---

## Why Follow the Quick Start Workflow?

Many users come to GORM CLI seeking a fast and reliable way to generate maintainable, type-safe database access code. This page distills the core workflow into three decisive actions, empowering you to start coding with confidence:

- **Define:** Craft your query interfaces with SQL templates and structure your models for code generation
- **Generate:** Run the CLI generator and produce idiomatic Go binding code
- **Use:** Call the generated query APIs and field helpers, eliminating runtime surprises

By focusing tightly on these steps, you cut through complexity and realize the benefits of compile-time safety and enhanced developer experience right away.

---

## 1. Define Query Interfaces and Models

The very first step is to establish your data models and query interfaces that describe the operations you want to perform on your database.

- **Models:** Define your struct types modeling database tables. Their fields become the foundation for type-safe field helpers that simplify building queries and updates.
- **Query Interfaces:** Write Go interfaces with methods annotated by SQL templates in method comments. These templates describe SQL statements with parameters bound to method inputs.

Example:

```go
// In your models package or directory
package models

import "gorm.io/gorm"

type User struct {
    gorm.Model
    Name string
    Age  int
}
```

```go
// Define your query interface with SQL templates
package examples

type Query[T any] interface {
    // SELECT * FROM @@table WHERE id=@id
    GetByID(id int) (T, error)

    // where("name=@name AND age=@age")
    FilterByNameAndAge(name string, age int) ([]T, error)
}
```

This declarative approach allows GORM CLI to generate strongly typed API methods easily discoverable and safe to call.

**Best Practices:**

- Keep query interfaces co-located with the models if possible
- Use the SQL template DSL (`@@table`, `@param`, `{{where}}`, etc.) to express dynamic queries clearly

---

## 2. Run the Generator Command

Once your interfaces and models are ready, use the `gorm gen` CLI tool to produce the generated Go code.

The CLI command requires:

- `-i` or `--input`: path to the Go package or file containing your interfaces and models
- `-o` or `--output`: destination directory for the generated code

Example:

```bash
gorm gen -i ./examples -o ./generated
```

This process parses your Go code, reads SQL templates, extracts interface and struct metadata, and writes complementary implementations and field helpers.

**What Happens Under the Hood:**

- Interfaces with SQL templates become concrete Go structs with methods executing queries
- Models become structs with strongly typed fields and association helpers

**Tips:**

- The output directory defaults to `./g` if not specified.
- You can include per-package configuration in a `genconfig.Config` to fine-tune generation behavior (e.g., filtering which interfaces to include).

---

## 3. Start Using Generated APIs

After generation, your development experience changes:

- Call generated query APIs by importing the output package
- Use the fluent and type-safe methods to build and run queries
- Use model-driven field helpers for filters, updates, and complex association operations

Example usage:

```go
import (
    "context"
    "gorm.io/gorm"
    "generated" // your generated package
    "models"    // your models package
)

func exampleUsage(db *gorm.DB) error {
    ctx := context.Background()

    // Query a user by ID
    user, err := generated.Query[models.User](db).GetByID(ctx, 123)
    if err != nil {
        return err
    }

    // Filter users by name and age
    users, err := generated.Query[models.User](db).FilterByNameAndAge(ctx, "jinzhu", 25)
    if err != nil {
        return err
    }

    // Use field helpers with GORM's standard methods
    adults := []models.User{}
    err = gorm.G[models.User](db).
        Where(generated.User.Age.Gt(18)).
        Find(ctx, &adults)
    if err != nil {
        return err
    }

    return nil
}
```

This approach dramatically reduces errors, improves code discoverability, and maintains close sync with your models.

---

## Troubleshooting Common Quick Start Issues

<AccordionGroup title="Troubleshooting Quick Start">
<Accordion title="Generator Command Fails or Does Nothing">
Check that your input path actually contains interfaces with SQL templates and models.  
Make sure the CLI tool is properly installed (`go install gorm.io/cli/gorm@latest`).

Use verbose or debug logging if needed to confirm files are processed correctly.
</Accordion>

<Accordion title="Generated Code Does Not Compile">
Confirm that your interfaces have correctly annotated SQL comments.

Check for missing dependencies or import path mismatches.

Verify any custom configuration doesn't exclude important files.
</Accordion>

<Accordion title="Generated Methods Are Missing or Incomplete">
Review your SQL templates to ensure they are complete and include parameters.

Interfaces must return either an error or a pair (result, error) with the last return type as `error`.

See the detailed documentation on [Core Concepts & Terminology](../concepts-architecture-flow/core-concepts-terminology) for refining your interfaces.
</Accordion>
</AccordionGroup>

---

## Summary

Following this Quick Start workflow enables you to rapidly adopt GORM CLI and realize the benefits of a fluent, type-safe ORM layer with minimal overhead.

By defining your data access patterns declaratively and generating code, you improve safety, maintainability, and developer velocity.

Ready to dive deeper? Explore related documentation to master configuration, advanced SQL template usage, and association management.

---

## Next Steps

- Review [Value Proposition & Key Benefits](../introduction-core-value/value-proposition-benefits) to understand the strategic advantages
- Explore [Core Concepts & Terminology](../concepts-architecture-flow/core-concepts-terminology) for detailed understanding of underlying patterns
- Visit [Integration Points](../concepts-architecture-flow/integration-points) for how to embed the generated code in your real-world projects
- Try out example projects in the `examples` directory of the repository

---

## Additional Resources

- Official Repository: [https://github.com/go-gorm/cli](https://github.com/go-gorm/cli)
- Documentation Home: See the sidebar for comprehensive guides and concepts

---

## Quick Reference

| Step                   | Command / Code Example                                                |
|------------------------|----------------------------------------------------------------------|
| Define Interfaces      | `type Query[T any] interface { /* SQL template comments */ }`       |
| Define Models          | `type User struct { gorm.Model; Name string; Age int }`             |
| Run Generator         | `gorm gen -i ./examples -o ./generated`                             |
| Use Generated Code    | `generated.Query[User](db).GetByID(ctx, 123)`                       |

Make GORM CLI your cornerstone for safe, productive, and elegant Go ORM workflows.

---
