---
title: "GORM Integration and Compatibility"
description: "Describes how the generated code seamlessly extends GORM, including support for Go generics, custom field mappings, and SQL dialect nuances. Clarifies system requirements and supported GORM features."
---

# GORM Integration and Compatibility

## Unlock Seamless Extension of GORM with Modern Go Features

GORM CLI's generated code is purpose-built to integrate flawlessly with the popular GORM ORM for Go, extending its capabilities while embracing the power of Go generics. This tight coupling means you get type-safe, expressive query APIs and model-driven field helpers that fit naturally into your existing GORM codebase without friction.

### Why This Matters to You

If you're using GORM to manage your database models and queries, GORM CLI enriches your developer experience by generating strongly typed, discoverable APIs. This eliminates bugs from mistyped fields or mismatched query parameters and games up productivity by reducing boilerplate code.

### What You Will Learn on This Page

- How GORM CLI-generated code extends and augments GORM
- Details on Go generics usage for type safety
- Custom field mappings empowering expressive queries
- Handling nuances of diverse SQL dialects
- System requirements essential for compatibility
- Supported GORM features that work seamlessly with generated code

---

## Extending GORM Naturally with Generated Code

### Leveraging Go Generics for Type Safety and Flexibility

GORM CLI uses Go generics extensively to generate interfaces and implementations that are fully type-safe across your models. For example, each generated query interface and its struct implementation are generic over the model type `T`, enabling compile-time validation of query parameters and return types.

```go
func {{.Name}}[T any](db *gorm.DB, opts ...clause.Expression) {{$IfaceName}}Interface[T] {
  return {{$IfaceName}}Impl[T]{
    Interface: gorm.G[T](db, opts...),
  }
}
```

This pattern tightly integrates with GORM's own generic API, ensuring fluent, discoverable query building while eliminating manual type assertions.

### Custom Field Mappings Empower Expressive Queries

The generated code maps your Go model fields to specialized field helper types designed for type-safe predicates and setters. This mapping supports:

- Basic Go types like `int`, `string`, `bool`, and `time.Time`
- Nullable SQL types like `sql.NullInt64`
- Complex fields, including embedded structs and slices for associations
- Custom field helpers for JSON and other special column types

Field mapping honors your `genconfig.Config` settings, letting you:

- Override default mappings for particular Go types
- Assign field helpers by struct tag (`gen:"json"`)
- Customize how fields appear and behave in queries

```go
var _ = genconfig.Config{
  FieldTypeMap: map[any]any{
    sql.NullTime{}: field.Time{},
  },
  FieldNameMap: map[string]any{
    "json": JSON{},
  },
}
```

### Handling SQL Dialect Nuances

Generated field helpers and query builders adapt to different database dialects to produce correct SQL. For example, the JSON helper field generates dialect-specific JSON comparison expressions that vary between MySQL, SQLite, and Postgres.

This abstraction frees you from worrying about SQL syntax differences—write queries once and rely on the generated API to handle dialect-specific quirks.

### Supported GORM Features in Generated Code

- **Type-Safe Query APIs:** Use custom-defined interfaces with SQL templates, which GORM CLI converts to strongly typed implementations
- **Model-Driven Field Helpers:** Utilize field helpers for filtering, updates, ordering, and association operations
- **Advanced Association Operations:** Create, update, unlink, or delete related association records with compile-time correctness
- **Context Auto Injection:** Methods automatically receive `context.Context` even if omitted
- **Integration with Clause Expressions:** Supports GORM’s `clause.Expression` for fine-grained query building

### System Requirements and Compatibility

- **Go version:** 1.18 or later (to support generics)
- **GORM version:** Compatible with GORM v2 and its generic API layer (`gorm.G[T]`)
- **SQL Drivers:** Supports any SQL dialect officially supported by GORM, including MySQL, PostgreSQL, SQLite, and others

### Practical Example

Using generated code with GORM feels intuitive and natural:

```go
// Using generated query interface
user, err := generated.Query[models.User](db).GetByID(ctx, 123)

// Using generated field helpers for strong typing
users, err := gorm.G[models.User](db).
  Where(generated.User.Age.Gt(18)).
  Find(ctx)

// Performing association create with type safety
err = gorm.G[models.User](db).
  Set(
    generated.User.Name.Set("alice"),
    generated.User.Pets.Create(generated.Pet.Name.Set("fido")),
  ).
  Create(ctx)
```

This tight synergy with GORM's idioms leads to safer, cleaner, and more productive code shortly after generation.

---

## Troubleshooting & Best Practices

<Tip>
Ensure your development environment uses Go 1.18+ and GORM v2 for smooth integration.
</Tip>

<Tip>
Always declare `genconfig.Config` in the same package as your models or interface to customize code generation behavior.
</Tip>

<Warning>
Be cautious with custom field helper implementations to maintain compatibility with all supported SQL dialects.
</Warning>

<Info>
Use the generated field helpers rather than raw strings to build query predicates — this prevents SQL injection and syntax errors.
</Info>

---

## Summary

The "GORM Integration and Compatibility" page clarifies how GORM CLI-generated code builds upon your existing GORM setup by injecting type safety, Go generics support, and advanced field and association helpers. It details the system prerequisites and highlights the breadth of supported GORM features extended by the generation process.

## Next Steps

- Explore the [Feature Highlights](./feature-highlights) page to understand core features at a glance.
- Review [How GORM CLI Works](../core-concepts/how-gorm-cli-works) for deep insight into the generation workflow.
- Consult the [Generation Configuration](../generation-configuration/genconfig-overview) guide to tailor integration for your project.

---

## Visual Overview Diagram

```mermaid
flowchart TD
  subgraph GORM_CLI_Generation
    SrcModels["Go Model Structs"] -->|Parse Fields| GeneratorProcess
    SrcInterfaces["Query Interfaces with SQL Templates"] -->|Parse Methods| GeneratorProcess
    GeneratorProcess["GORM CLI Generator Core"] --> GeneratedCode
  end

  subgraph Generated_Code
    GeneratedCode["Generated Field Helpers & Query APIs"] -->|Extend| GORMLib["GORM ORM (gorm.io/gorm)"]
  end

  Database[("SQL DB
MySQL/Postgres/SQLite")]

  GORMLib -->|Executes queries| Database

  GeneratedCode -.->|Supports| DialectSupport"SQL Dialect Nuances"

  style GORM_CLI_Generation fill:#E3F2FD,stroke:#1976D2,stroke-width:2px;
  style Generated_Code fill:#C8E6C9,stroke:#388E3C,stroke-width:2px;
  style Database fill:#FFF3E0,stroke:#F57C00,stroke-width:2px;
```

---

## References & Related Documentation

- [GORM CLI Overview & Feature Highlights](/overview/features-overview/feature-highlights) — See comprehensive features in action
- [GORM CLI Quickstart & Core Workflows](/guides/core-workflows/quickstart-generate) — Begin generating type-safe code
- [Generation Configuration](/concepts/generation-configuration/genconfig-overview) — Customize field mapping and output
- [Template-Based Queries](/guides/advanced-patterns/template-based-queries) — Craft fluent, template-driven SQL interfaces
- Official repository: [https://github.com/go-gorm/cli](https://github.com/go-gorm/cli)


---

This page positions you to harness the combined power of GORM CLI and GORM in your Go projects, unlocking safer, faster, and more maintainable database interactions.