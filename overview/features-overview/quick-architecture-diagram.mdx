---
title: "Reference Architecture Diagram"
description: "Provides a mermaid diagram mapping CLI invocation to generated code, showing how interfaces, configs, and templates interact to produce helpers and APIs. Aids in visualizing how GORM CLI fits into the dev workflow."
---

# Reference Architecture Diagram

Visualizing how GORM CLI translates your Go interfaces and configurations into powerful, type-safe query APIs and model-driven field helpers is key to mastering its use. This diagram illustrates the end-to-end flow from CLI invocation through parsing, templating, and code generation, helping you understand how your input maps directly to generated helpers and APIs.

---

## Why This Matters

Understanding the transformations GORM CLI performs empowers you to organize your source files and configure generation precisely. It reveals where your interfaces, SQL templates, and generation configs influence the output. This clarity leads to smoother debugging, better configuration, and more efficient development.

---

## Overview of the Code Generation Flow

At a high level, the GORM CLI processes proceed as follows:

1. **Invoke CLI Command (`gorm gen`)**
   - You specify the input interface or package path (`-i`) and optional output directory (`-o`).

2. **Source Code Parsing and Configuration Discovery**
   - The generator parses your Go source files to extract:
     - Interfaces with raw SQL annotations
     - Structs for model field helpers
     - Package-level `genconfig.Config` configurations

3. **SQL Template Interpretation**
   - Method comments containing SQL templates are parsed and rendered into Go code snippets
   - Placeholders like `@@table`, `@param`, and `{{where}}` directives are processed

4. **Code Generation**
   - Using parsed interfaces, methods, models, and configs, the generator produces:
     - **Type-safe Fluent Query APIs:** Methods that return strongly typed results, wrapping raw SQL.
     - **Model-Driven Field Helpers:** Typed helpers for model fields that enable expressive queries and safe updates.

5. **Output Files**
   - Generated code is written to your chosen output directory, ready for import and use in your Go projects.

---

## Detailed Architecture Diagram

```mermaid
flowchart TD

  CLI[gorm gen CLI] -->|Start code generation| InputSource["Go Source Files"]

  subgraph Parsing
    InputSource --> ParseAST[Parse Go AST]
    ParseAST --> ExtractInterfaces[Extract Interfaces with SQL annotations]
    ParseAST --> ExtractStructs[Extract Model Structs]
    ParseAST --> ExtractConfigs[Extract genconfig.Config]
  end

  subgraph SQL_Templating
    ExtractInterfaces --> InterpretSQL[Parse & Render SQL Templates]
  end

  subgraph Code_Generation
    InterpretSQL --> GenerateQueryAPIs[Generate Type-Safe Query APIs]
    ExtractStructs --> GenerateFieldHelpers[Generate Model Field Helpers]
    ExtractConfigs --> ApplyConfigs[Apply Configuration Filters & Maps]
    ApplyConfigs --> GenerateQueryAPIs
    ApplyConfigs --> GenerateFieldHelpers
  end

  subgraph Output
    GenerateQueryAPIs --> WriteFiles[Write Generated Go Files]
    GenerateFieldHelpers --> WriteFiles
  end

  WriteFiles --> Finished[Generation Complete]

  %% Styling
  classDef cli fill:#f9f,stroke:#333,stroke-width:2px;
  class CLI cli;
  classDef parse fill:#bbf,stroke:#333,stroke-width:1px;
  class Parsing parse;
  classDef templ fill:#dfd,stroke:#333,stroke-width:1px;
  class SQL_Templating templ;
  classDef gen fill:#ffd,stroke:#333,stroke-width:1px;
  class Code_Generation gen;
  classDef output fill:#fbf,stroke:#333,stroke-width:1px;
  class Output output;

  class CLI;
  class Parsing;
  class SQL_Templating;
  class Code_Generation;
  class Output;

```

---

## How This Fits Into Your Development Workflow

- You write **Go interfaces** defining query methods with embedded SQL templates in method comments.
- You optionally write **generation configs** (`genconfig.Config`) to control scope, output paths, and type mappings.
- You maintain your **struct models** as usual.
- When you run `gorm gen`, the tool parses, interprets templates, and generates:
  - Fluent, type-safe query API implementations
  - Model field helpers for building queries and updates
- You import the generated package in your app to write safe, expressive database code.

---

## Practical Tips and Common Pitfalls

- **Always provide the input path (`-i`) clearly pointing to interface definitions.**
- **Use `genconfig.Config` to include or exclude interfaces and structs to fine-tune generation scope, avoiding unwanted files.**
- **Understand that SQL template comments drive method implementation â€” writing correct templates ensures correct generated code.**
- **Generated code respects custom type mappings for complex fields (e.g., JSON or time wrappers). Configure these via FieldTypeMap and FieldNameMap.**
- **Ensure your Go source compiles properly before code generation to avoid parsing errors.**

<Tip>
Familiarize yourself with how placeholders like `@@table` and `@param` map your Go models and method parameters to SQL in templates; this is the core integration point.
</Tip>

<Warning>
Misconfigured include/exclude filters in `genconfig.Config` can cause interfaces or structs to not generate any code.
</Warning>

---

## Next Steps

- Explore the [How GORM CLI Works](/overview/core-concepts/how-gorm-cli-works) page to understand detailed internals of parsing and generation.
- Review the [Architecture Overview](/overview/core-concepts/architecture-overview) for a broader high-level system map.
- Try defining query interfaces with samples from the [Quickstart](/getting-started/core-workflow-quickstart/prepare-models-interfaces).
- Experiment with generation config options to tailor output to your project structure.

---

## For More Information

See the following documentation for context and deeper dives:

- [What is GORM CLI?](/overview/product-intro/what-is-gorm-cli)
- [Why Use GORM CLI?](/overview/product-intro/value-proposition)
- [Who Should Use GORM CLI & Typical Use Cases](/overview/product-intro/target-audience-use-cases)

---

## Summary
This visual reference demystifies the flow from CLI invocation to generated Go code for query APIs and field helpers. It pinpoints how your input interfaces, structs, and config guide the SQL template parsing and code generation steps.

Use this knowledge to optimize your source structure and troubleshoot generation issues effectively.

---