---
title: "Product Introduction & Value"
description: "GORM CLI is a powerful code generation tool that delivers interface-driven, type-safe query APIs and fluent field helpers for GORM model manipulation. By automating the creation of robust and discoverable APIs, it dramatically reduces boilerplate and increases developer confidence through compile-time safety."
---

# Product Introduction & Value

## Unlock Interface-Driven, Type-Safe Query APIs for GORM Models

GORM CLI is a robust code generation tool designed to empower Go developers by generating interface-driven, type-safe query APIs and fluent field helpers tailored for GORM model manipulation. It dramatically streamlines your development workflow by automating boilerplate code generation while delivering compile-time safety that dramatically boosts confidence and productivity.

### Why GORM CLI Matters to You

- Automates creation of strong, discoverable APIs that match your models and query interfaces
- Eliminates repetitive code, saving time and reducing human error
- Enforces type safety using Go's generics to catch bugs early during compilation
- Provides fluent field helpers for filters, updates, and association operations
- Seamlessly integrates with your existing GORM projects without intrusive changes

Whether you’re building CRUD services, complex query layers, or managing associations efficiently, GORM CLI unlocks a new level of developer experience and reliability.

## What Exactly Is GORM CLI?

At its core, GORM CLI takes your handwritten Go interfaces annotated with SQL template comments and your GORM model structs, then generates two key pieces:

1. **Typed Query APIs:** Concrete implementations of your interfaces with optimized, type-safe SQL query methods.
2. **Field Helpers:** Strongly typed helpers for model fields, supporting predicates (e.g., Eq, Like), updates, and association operations.

This setup liberates you from manual SQL construction and error-prone string-based queries. Your code becomes easier to read, maintain, and refactor.

## How GORM CLI Works for You

- You define your query interfaces in Go, leveraging familiar Go generics and SQL template comments.
- Your models remain pure GORM structs.
- Run `gorm gen` pointing to your interface files.
- GORM CLI generates the query code in your output directory.
- Use the generated code directly to perform safe, expressive queries with autocompletion and compile-time checks.

This workflow is straightforward yet impactful for medium to large codebases relying on GORM.

## Key Features & Capabilities

### Typed Query APIs from Interfaces
- Define interfaces with SQL templates as Go method comments.
- Generate concrete implementations supporting context injection, parameter binding, and dynamic clauses.
- Example:
  ```go
  type Query[T any] interface {
    // SELECT * FROM @@table WHERE id=@id
    GetByID(id int) (T, error)

    // UPDATE @@table SET name=@user.Name WHERE id=@id
    UpdateUser(user User, id int) error
  }
  ```

Safe, natural Go functions backed by SQL templating.

### Model-driven Field Helpers
- Generate fluent, typed helpers for fields and associations.
- Perform common predicates like `Eq`, `Between`, `Like`, and `IsNull`.
- Compose updates, increments, and expression-based sets fluently.
- Manage associations with operations like Create, Update, Unlink, and Delete with full type safety.

Example:
```go
gorm.G[User](db).
  Where(generated.User.Age.Gt(18)).
  Set(
    generated.User.Name.Set("alice"),
    generated.User.Pets.Create(generated.Pet.Name.Set("fido")),
  ).
  Update(ctx)
```

### Configurable Generation
- Customize output paths, included/excluded interfaces or structs.
- Map Go types and struct tags to specific field helpers.
- Fine-tune generation scope and behavior via package-level `genconfig.Config`.

### Association Operations
- Supports Has One, Has Many, Belongs To, and Many-to-Many associations.
- Operations honor foreign key semantics (unlink sets to NULL, delete removes rows).
- Batch-create and batch-link associated entities.

## Real-World Value & Use Cases

### Save Development Time by Avoiding Boilerplate
Manual query implementation is tedious and error-prone. GORM CLI frees you from writing raw SQL and repetitive CRUD logic by generating exact match code, letting you focus on business logic.

### Achieve Compile-Time Safety
Catch SQL errors and interface contract mismatches early in your development cycle through strong typing and generics.

### Gain Discoverability and Intuitive APIs
Generated code includes field helpers and query methods with autocompletion, helping developers understand query options and reducing mistakes when building complex queries.

### Manage Complex Associations Safely
Perform create, update, unlink, or delete operations on relational data with intuitive, type-safe APIs that understand your schema's relationships.

### Reduce Runtime Errors
Avoid runtime surprises with compile-time validation, explicit parameter binding, and safe SQL templating.

## Typical Workflow: From Interface to Generated API

1. **Define your Query Interface in Go**
   - Write methods annotated with your SQL templates.
   - Use placeholders like `@@table`, `@param`, and DSL directives like `{{where}}`.

2. **Run the Generator**
   - Execute `gorm gen -i ./path/to/interfaces -o ./generated`
   - The CLI processes interfaces and models, generating Go source files.

3. **Integrate & Use**
   - Import the generated package.
   - Use type-safe query methods like `generated.Query[User](db).GetByID(ctx, 123)`.
   - Compose dynamic predicates using field helpers like `generated.User.Age.Between(18, 35)`.

## Quick Example

```go
// Define query interface
// File: examples/query.go

type Query[T any] interface {
  // SELECT * FROM @@table WHERE id=@id
  GetByID(id int) (T, error)

  // UPDATE @@table SET name=@user.Name WHERE id=@id
  UpdateUser(user User, id int) error
}

// Run generator:
$ gorm gen -i ./examples -o ./generated

// Use generated code
user, err := generated.Query[User](db).GetByID(ctx, 123)
if err != nil {
  log.Fatal(err)
}

// Perform updates
err = generated.Query[User](db).UpdateUser(ctx, User{Name: "newname"}, 123)
```

## Tips & Best Practices

- Use package-level `genconfig.Config` to customize generation.
- Leverage field and association helpers for clearer query construction.
- Write SQL templates thoughtfully using the provided DSL to maximize flexibility.
- Keep interfaces and models in sync to avoid generation mismatches.

## Common Pitfalls & Troubleshooting

<AccordionGroup title="Common Issues with GORM CLI">
<Accordion title="Missing Output or Generated Code Not Found">
Ensure you specify the `-i` input path correctly pointing to the Go interface files. The generator only processes files matching inclusion rules.
</Accordion>
<Accordion title="Type Safety Compile Errors After Generation">
Verify your interface method signatures comply with the expected return types (error must be the last return value). Review generated code for mismatches.
</Accordion>
<Accordion title="Association Operations Not Working as Expected">
Check your models’ GORM association tags and ensure you generate field helpers with a matching config. Association semantics differ based on relation types.
</Accordion>
</AccordionGroup>

## Next Steps

- See [Your First Code Generation](/getting-started/first-run-configuration/your-first-generate) to start with tutorials.
- Deep dive into [Field Helpers and Associations](/guides/real-world-examples/working-with-field-helpers) for advanced usage.
- Explore [Configuring the Generator](/concepts/customization-integration/generator-config-concept) for customization.

---

By focusing on user intent—effortless, safe, and discoverable queries—GORM CLI transforms GORM model management, empowering developers to build reliable database interactions with less code and greater confidence.
