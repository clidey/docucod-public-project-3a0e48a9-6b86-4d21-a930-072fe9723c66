---
title: "Target Audience & Use Cases"
description: "Designed for Go developers using GORM who need safer, more maintainable data access layers, GORM CLI is ideal for projects demanding customized queries, strong typing, and advanced association handling. It caters to teams seeking rapid iteration, reduced manual errors, and seamless integration with existing GORM codebases."
---

# Target Audience & Use Cases

GORM CLI is purpose-built for Go developers who use the GORM ORM and demand safer, more maintainable data access layers. This tool empowers you to generate type-safe, interface-driven query APIs and rich, model-based field helpers that streamline your interaction with your database.

Whether you’re working on a solo project or part of a team, GORM CLI's focus on strong typing, advanced association handling, and flexible customization ensures you can iterate rapidly while significantly reducing manual coding errors.

---

## Who Should Use GORM CLI?

- **Go Developers Using GORM**: If you rely on GORM for your database ORM and want to enhance your code with compile-time safety and discoverable APIs, this tool is for you.

- **Teams Seeking Maintainability**: For teams building production-grade applications that require consistent, maintainable, and testable data access code.

- **Projects with Complex Queries & Associations**: If your project includes customized SQL queries, dynamic conditions, or advanced association manipulations—like batch creates, unlinking, and deletes—GORM CLI simplifies these with generated, type-safe APIs.

- **Developers Embracing Strong Typing**: You value catching errors during compilation rather than runtime, and want your database queries and updates to be statically checked and easy to understand.

---

## Why You Should Care

### Safer & More Maintainable Code
Manually writing SQL queries or ORM query code often leads to subtle bugs and runtime errors. GORM CLI spotlights these issues early by generating code aligned with your Go types and interface contracts.

### Rapid Iteration with Less Manual Effort
By writing Go interfaces with SQL templates, you get powerful query and update functions generated automatically. You no longer need to handcraft boilerplate or synchronization code between your models and queries.

### Seamless Integration with Existing GORM Projects
Leverage your current models and GORM setups while enriching them with a fluent, strongly typed, code-generated API that is idiomatic and easy to adopt.

### Advanced Association Handling
Manage complex relations (such as has-many, belongs-to, many-to-many) with generated helper fields and methods for create, update, unlink, delete, and batch operations—all with compile-time safety.

---

## Real-World Use Cases

### 1. Custom Query APIs with Type Safety
You define a Go interface method with embedded SQL templates—for example, a method to fetch users by dynamic filters. GORM CLI generates a concrete type-safe method matching your SQL parameters and return types.

#### Example:
```go
// Define your interface with SQL template
// SELECT * FROM @@table WHERE id=@id
GetByID(id int) (User, error)
```
Using the generated API ensures any misuse (e.g., passing wrong types or missing parameters) is caught before you run your application.

### 2. Enhanced Field Helpers for Filtering and Updates
Generated models provide helpers like `generated.User.Age.Between(18, 65)` or `generated.User.Name.Like("%admin%")` that you compose fluently in GORM queries.

This eradicates magic strings and eases advanced filtering with strongly typed predicates.

### 3. Managing Complex Associations
When your data model includes relationships, you can use generated helpers to create or update associated entities inline with parents, unlink them cleanly, delete associated rows, or batch insert related records.

Example:
```go
gorm.G[User](db).
  Set(
    generated.User.Name.Set("alice"),
    generated.User.Pets.Create(generated.Pet.Name.Set("fido")),
  ).
  Create(ctx)
```
This ensures all association operations obey your schema and constraints with ease.

### 4. Dynamic Queries With Custom SQL Templates
Write expressive SQL templates in your interfaces with conditionals, loops, and variable placeholders:

```go
// UPDATE @@table
// {{set}}
//   {{if user.Name != ""}} name=@user.Name, {{end}}
//   {{if user.Age > 0}} age=@user.Age, {{end}}
// {{end}}
// WHERE id=@id
UpdateUser(user User, id int) error
```
GORM CLI parses this and generates efficient, type-safe update methods respecting your business logic.

---

## Benefits: Before and After Using GORM CLI

| Aspect                         | Before GORM CLI                     | After GORM CLI                         |
|--------------------------------|-----------------------------------|-------------------------------------|
| Query implementation            | Manual SQL string crafting, prone to errors | Auto-generated, type-safe query APIs | 
| Association management          | Verbose, error-prone manual code  | Fluent, reusable, and safe helpers
| Code correctness                | Runtime errors from typos or mismatched params | Compile-time error detection         |
| Development speed              | Slower due to boilerplate and debugging | Faster iterations with fewer manual steps |
| Integration                    | Disjointed manual integration     | Seamless with existing GORM models and workflows |

---

## Common Scenarios Where GORM CLI Excels

- Building domain-specific query layers with custom SQL
- Writing batch operations combining parent and child records
- Enforcing strict, consistent typings across your data access
- Safely evolving complex relational schemas
- Reducing time spent on repetitive CRUD query code

---

## Getting Started Preview

To start benefiting from GORM CLI’s type safety and generation, you begin by defining your query interfaces along with model structs in Go. Then, run the `gorm gen` command pointing at your interface source files:

```bash
gorm gen -i ./path/to/interfaces -o ./generated
```

This will generate strongly typed APIs and field helper files under the output directory you specify.

### Prerequisites
- Your project uses Go 1.18 or higher (for generics support)
- Models and query interfaces are defined in Go
- GORM ORM is already integrated in your project

### Next Steps
- Define interfaces with SQL templates reflecting your app’s querying needs
- Explore `Target Audience & Use Cases` alongside [Product Introduction & Value](../getting-started-core/overview-intro) to understand the big picture
- Dive into setup and configuration guides for installation and quick validation

---

GORM CLI transforms your GORM experience by generating reliable, maintainable, and powerful code that scales with your application complexity. It puts type safety and speed at the core of your data access layer.

---

For a deeper introduction, see [Product Introduction & Value](/overview/getting-started-core/overview-intro) and explore [Feature Highlights](/overview/getting-started-core/overview-feature-quicklook).