---
title: "Primary Use Cases"
description: "See where GORM CLI fits in real-world development. Review core use cases such as generating query APIs from interfaces, creating field helpers for models, working efficiently with associations, and automating repetitive SQL tasks to streamline your workflow."
---

# Primary Use Cases

Discover how GORM CLI fits into your real-world Go development workflow by exploring its core use cases. This page highlights how to leverage GORM CLI to generate type-safe query APIs from raw SQL interfaces, create expressive field helpers for your models, handle associations with ease, and automate repetitive SQL tasks — all designed to streamline your database interactions and boost developer productivity.

---

## Generating Query APIs from Interfaces

GORM CLI’s unique strength lies in transforming your well-defined Go interfaces into concrete, type-safe query implementations.

### What You Achieve
- **Write raw SQL with Go interface methods**: Embed SQL templates directly in Go method comments, with parameter binding and conditional logic.
- **Get automatic implementations**: GORM CLI generates the underlying code to execute your queries with compile-time safety.
- **Use fluent, discoverable APIs**: Interact with your database through generated interfaces offering rich, intuitive methods.

### Real Example
Consider the `Query[T any]` interface in `examples/query.go`, where methods like `GetByID`, `FilterWithColumn`, or `UpdateInfo` embed SQL templates using placeholders and Go template directives.

```go
// examples/query.go

// GetByID query data by id and return it as struct
//
// SELECT * FROM @@table WHERE id=@id AND name = "\@name"
GetByID(id int) (T, error)

// SELECT * FROM @@table WHERE @@column=@value
FilterWithColumn(column string, value string) (T, error)

// UPDATE @@table
//  {{set}}
//    {{if user.Name != ""}} name=@user.Name, {{end}}
//    {{if user.Age > 0}} age=@user.Age, {{end}}
//    {{if user.Age >= 18}} is_adult=1 {{else}} is_adult=0 {{end}}
//  {{end}}
// WHERE id=@id
UpdateInfo(user models.User, id int) error
```

### Why It Matters
Instead of manually writing boilerplate SQL and binding logic, you centralize query definitions in interfaces. This reduces errors, makes queries easier to maintain, and leverages Go’s type system for safer database operations.

---

## Creating Field Helpers for Models

GORM CLI also generates expressive field helpers from your Go model structs, enabling concise and type-safe query building.

### What the Helpers Do
- **Typed field objects** for each column abstract SQL predicates and setters.
- Support predicates like `Eq`, `Like`, `Between`, `IsNull`, and setters including `Set`, `Incr`, or complex expressions.
- Provide **compiled knowledge of field types and names**, directly aligned with your struct definitions.

### Real-World Usage
Given a model like:

```go
// models/user.go

// User model example
 type User struct {
    ID        uint
    Name      string
    Email     string
    Age       int
    Status    string
    CreatedAt time.Time
 }
```

GORM CLI generates corresponding fields to use in queries:

```go
// Examples
generated.User.Name.Eq("alice")      // Filters WHERE name = "alice"
generated.User.Age.Between(18, 65)     // WHERE age BETWEEN 18 AND 65
generated.User.Score.IsNull()          // WHERE score IS NULL
```

### Benefits
- Cleaner code without raw strings.
- Compile-time type checking for all predicates and value setters.
- Enhanced discoverability through IDE autocomplete.

---

## Efficiently Working With Associations

Managing associations is traditionally complex, but GORM CLI generates helpers that simplify these operations.

### Supported Operations
- **Create, CreateInBatch:** Create and associate related records.
- **Update:** Modify associated records with optional filtering.
- **Unlink:** Remove links without deleting records (e.g., set foreign keys to NULL or delete join rows for many2many).
- **Delete:** Delete associated records cleanly.

### Usage Patterns

```go
// Creating a user with an associated pet
gorm.G[User](db).
  Set(
    generated.User.Name.Set("alice"),
    generated.User.Pets.Create(generated.Pet.Name.Set("fido")),
  ).
  Create(ctx)

// Updating a user's pet named "fido"
gorm.G[User](db).
  Where(generated.User.ID.Eq(1)).
  Set(generated.User.Pets.Where(generated.Pet.Name.Eq("fido")).
    Update(generated.Pet.Name.Set("rex")),
  ).
  Update(ctx)

// Unlinking a user's pets without deleting
gorm.G[User](db).
  Where(generated.User.ID.Eq(1)).
  Set(generated.User.Pets.Unlink()).
  Update(ctx)
```

### Why This Matters
You avoid writing error-prone manual association queries. Instead, work with high-level, strongly-typed operations that respect your data model relationships.

---

## Automating Repetitive SQL Tasks

GORM CLI’s template-based SQL in interface comments is powerful for automating complex, repetitive SQL operations.

### Template DSL Highlights
- `@@table` and `@@column` for dynamic table and column references.
- `@param` bindings for safe parameter injection.
- `{{where}}`, `{{set}}`, `{{if}}`, and `{{for}}` constructs for expressive, conditional query logic.

### Benefit for Developers
- Write SQL once in interfaces - safer, cleaner, and more maintainable.
- Automatically generate correct code with parameter binding and context injection.
- Support complex conditional queries and updates without losing type-safety.

### Example Snippet
```go
// UpdateUser user with conditional fields
// UPDATE @@table
// {{set}}
//   {{if user.Name != ""}} name=@user.Name, {{end}}
//   {{if user.Age > 0}} age=@user.Age, {{end}}
// {{end}}
// WHERE id=@id
UpdateUser(user User, id int) error
```

---

## Summary
This page bridges GORM CLI’s technical capabilities with your practical goals:
- Generate query APIs effortlessly from SQL-annotated interfaces.
- Use generated field helpers for legible, safe database operations.
- Handle associations with high-level, declarative operations.
- Automate repetitive and complex SQL tasks through templated interfaces.

By mastering these use cases, you will maximize the efficiency, safety, and clarity of your database code within Go projects using GORM.

---

## Getting Started
To try these use cases, begin by writing your SQL-annotated interfaces and structs, then run the generator CLI:

```bash
gorm gen -i ./examples -o ./generated
```

Check the [Running the Generator](/getting-started/first-code-gen/running-generator) and [Using the Generated Code](/getting-started/first-code-gen/first-use) pages next for detailed instructions on integrating the generated code seamlessly.

---

## Related Documentation
- [What is GORM CLI?](/overview/product-intro/what-is-gorm-cli): Understand the product vision and architecture.
- [Template DSL: Building Expressive, Safe SQL](/guides/advanced-usage/template-dsl-guide): Deep dive into SQL template syntax.
- [Managing Associations](/guides/advanced-usage/advanced-associations): Learn advanced association operations.
- [Quick Feature Overview](/overview/feature-glance/quick-feature-overview): Feature summaries to contextualize use cases.

---

## Tips & Best Practices
- Define interfaces near related models to simplify context and imports.
- Use configuration (`genconfig.Config`) to customize output and behavior.
- Combine field helpers with query interfaces for maximum type safety.
- Leverage template conditionals for dynamic query generation without sacrificing readability.

---

Your journey from writing simple SQL queries to fully type-safe, maintainable database code starts here with GORM CLI’s powerful use cases.

---

<Info>
Explore the 'examples/query.go' file to see a comprehensive example of query interfaces using SQL templates.
</Info>

<Info>
See 'README.md' for additional examples that bridge usage scenarios and code samples.
</Info>
