---
title: "Who Should Use GORM CLI & Typical Use Cases"
description: "Identifies the ideal users—Go developers building applications with GORM, teams seeking safety and maintainability, and projects needing advanced model and association handling. Highlights fitting scenarios like CRUD microservices, SaaS backends, and complex relational data flows."
---

# Who Should Use GORM CLI & Typical Use Cases

## Unlocking Type-Safe Database Access for Go Developers with GORM

GORM CLI is tailored for Go developers building robust applications using GORM who seek safety, maintainability, and high developer productivity. It empowers teams managing complex models, relational associations, and dynamic queries to generate type-safe, discoverable APIs that integrate seamlessly into their workflows.

### Ideal Users

- **Go Developers & Backend Engineers:** Working with GORM in Go projects, who want to minimize runtime errors with compile-time safety.
- **Teams Focused on Maintainability:** Collaborative groups aiming to reduce boilerplate and prevent bugs from SQL string manipulation.
- **Developers Managing Complex Data Models:** Those handling advanced associations such as many-to-many, polymorphic relations, and dynamic filtering.
- **Projects Requiring Customizable Queries:** Developers who write raw SQL or templated SQL inside Go interfaces but want types and helper generation for safer access.

### Typical Use Cases

GORM CLI shines in many realistic development scenarios where type-safe database code makes a measurable difference:

#### 1. CRUD Microservices
Build small to medium microservices with precise and safe database operations. Developers define query interfaces with embedded SQL templates, generating concise and strongly typed query methods.

```go
// Define raw SQL interface
// SELECT * FROM @@table WHERE id=@id
GetByID(id int) (T, error)

// Generate and use typed APIs
user, err := generated.Query[User](db).GetByID(ctx, 123)
```

#### 2. SaaS Backend Platforms
Handle user roles, complex filters, and relational data (e.g., organizations, teams, permissions) with safety and discoverability.

- Manage entity relationships with automatic field helpers and association operations, such as creating or unlinking related records.
- Write custom SQL templates for flexible business logic embedded in method comments.

#### 3. Complex Relational Data Flows
Applications involving many-to-many relationships, polymorphic associations, and nested updates benefit from GORM CLI’s model-driven field helpers and type-safe APIs:

- Safely create, update, and unlink associated entities (pets and toys, user languages, friends).
- Compose fluent filter, update, and query helpers generated from your models.

### Why GORM CLI Fits Your Project

- **Strong Typing with Generics:** Avoid runtime SQL mistakes by generating compile-time type checks.
- **Custom Query Templates:** Write raw SQL with a specialized template DSL, and have GORM CLI generate the interface implementations for you.
- **Model and Field Helpers:** Simplify filters, updates, and association operations with idiomatic, fluent APIs.
- **Seamless GORM Compatibility:** Integrates directly with GORM’s DB instances to empower your existing workflows instantly.

### Real-World Example

Consider a backend managing users and their pets for a marketplace app:

```go
// 1. Define interface with a templated query
// SELECT * FROM @@table WHERE id=@id
GetByID(id int) (User, error)

// 2. Use generated query inside business logic
user, err := generated.Query[User](db).GetByID(ctx, userID)
if err != nil {
    // handle error
}

// 3. Update user and their pets atomically with associations helpers
err = gorm.G[User](db).
    Where(generated.User.ID.Eq(userID)).
    Set(
      generated.User.Name.Set("Alice"),
      generated.User.Pets.CreateInBatch([]models.Pet{{Name: "Rex"}, {Name: "Max"}}),
    ).
    Update(ctx)
```

This workflow leads to more maintainable, bug-resistant code with less boilerplate.

### Common Pitfalls Addressed

- Avoid stringly-typed queries and manual SQL parameterization errors.
- Prevent mismatch between struct fields and database columns using model-driven code generation.
- Handle associations, such as many-to-many and polymorphic links, with type safety.

### Summary Table of Use Cases

| Use Case               | Description                                   | Benefits Provided                        |
|------------------------|-----------------------------------------------|------------------------------------------|
| CRUD Microservices     | Efficient basic read/write for entities       | Type safety, faster development          |
| SaaS Backends          | Complex domain models with roles and filters  | Strong associations, advanced queries    |
| Complex Relational Data| Managing polymorphic/ many2many associations  | Fluent, safe association operations      |

---

## Getting Started Preview

### Quickstart Highlights

- Write simple Go interfaces with raw SQL templates in comments.
- Define your models in Go structs annotated for GORM.
- Run the GORM CLI generator to produce type-safe query APIs and model helpers.

### Prerequisites

- Go 1.18+ with generics support.
- Existing GORM project or familiarity with GORM concepts.

### Next Steps

Visit the [Quickstart: Generate Type-Safe APIs](../guides/core-workflows/quickstart-generate) page for a detailed walkthrough to start generating and using GORM CLI code today.

---

## Additional Resources

- [What is GORM CLI?](./what-is-gorm-cli) — Introduction and core purpose.
- [Why Use GORM CLI?](./value-proposition) — Primary benefits and value.
- [Key Features at a Glance](../features-overview/feature-highlights) — Explore core capabilities.
- [Using Generated APIs: First Query](../../getting-started/core-workflow-quickstart/using-generated-code) — Example usage guide.

<Tip>
For teams managing multiple complex Go models with rich associations, GORM CLI drastically reduces boilerplate while improving compile-time guarantees and developer productivity.
</Tip>