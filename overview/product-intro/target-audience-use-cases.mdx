---
title: "Who Should Use GORM CLI?"
description: "Identify the ideal users of GORM CLIâ€”from Go developers seeking type-safe queries to architects automating code workflows. Explore common scenarios and project types where GORM CLI delivers maximum impact."
---

# Who Should Use GORM CLI?

Discover if GORM CLI is the right tool for your Go project by exploring who benefits most from its powerful code generation capabilities. Whether you're a Go developer looking to write safer, more maintainable database queries, or an architect designing automated workflows to generate type-safe code, this page helps you identify how GORM CLI fits your needs.

---

## Unlocking Efficiency for Go Developers

GORM CLI shines for developers who want to bridge the gap between raw SQL power and Go's type safety. It enables you to write SQL templates alongside familiar Go interfaces and generates the implementation code for you, elevating your productivity and code quality.

### Ideal Users:

- **Backend Go Developers:** Improve data query reliability by generating type-safe, fluent query APIs from annotated interfaces.
- **API Developers:** Quickly produce maintainable database operations without manual boilerplate.
- **Library and Framework Authors:** Integrate generated APIs into tools requiring declarative database access.

### Typical Use Scenario

Imagine defining a set of query methods in an interface with embedded SQL templates. Instead of writing repetitive query logic by hand, you run `gorm gen` to produce strongly typed methods that seamlessly integrate with your `gorm.DB` instances. This dramatically reduces runtime errors and speeds up development.

---

## Empowering Architects and Automation Experts

If your role involves designing workflows and automating code generation in large Go projects, GORM CLI delivers flexible configuration and extensibility.

### Why It Matters to You:

- **Automation of Repetitive Code:** Configure GORM CLI via package-level `genconfig.Config` or command-line flags to automate generation across multiple packages.
- **Consistency Across Codebases:** Guarantee uniform query API styles and type safety in team or organizational projects.
- **Integration in CI/CD Pipelines:** Easily embed GORM CLI as part of your build and deployment process to prevent drift between Go models and query code.

---

## Projects and Scenarios Where GORM CLI Maximizes Impact

- **Complex Domain Models:** Projects with rich domain models that involve associations (has one, has many, many2many) benefit from GORM CLI's ability to create association helpers and scoped queries.
- **Microservices with Data Access Layers:** Generate tailored query APIs per service with clean abstractions.
- **Codebases Needing Type Safety:** Prevent subtle runtime bugs through compile-time type checking on queries.
- **Teams Emphasizing Maintainability:** Centralize query logic in interfaces and keep implementations consistent and readable.

---

## Before and After GORM CLI Adoption

- Without GORM CLI, developers manually write SQL, risking typos and mismatched data types, resulting in fragile code that's hard to refactor or audit.
- After adopting GORM CLI, the generated code ensures all queries are type-safe, discoverable through fluent APIs, and seamlessly integrated with GORM's ORM capabilities.

### Concrete Example

```go
// Define interface with embedded SQL template
// SELECT * FROM @@table WHERE id=@id
GetByID(id int) (T, error)

// Run generator command
gorm gen -i ./examples -o ./generated

// Use generated query method
user, err := generated.Query[User](db).GetByID(ctx, 123)
```

This workflow eliminates manual SQL execution coding, replacing it with robust, type-safe invocations.

---

## Practical Tips for Choosing GORM CLI

- You should use GORM CLI if you want:
  - Compile-time validation of SQL query parameters and return types.
  - To leverage Go generics for reusable, interface-driven data access.
  - Seamless integration with existing GORM models and associations.
  - Configuration flexibility to customize field mappings and output paths.

- Avoid if:
  - Your project does not use Go 1.18+ (generics).
  - Your database access requirements do not benefit from generated type-safe helpers.

---

## Getting Started Preview

Kick off with a simple interface describing your queries and models defined as Go structs. Then run `gorm gen` with the appropriate flags to generate your type-safe API.

```bash
gorm gen -i ./path/to/interfaces -o ./path/to/generated
```

Make sure you have:
- Go 1.18 or newer installed.
- Your model structs and query interfaces properly annotated with SQL templates.

For detailed onboarding, visit the [First Code Generation](../getting-started/first-usage/first-code-generation) and [Using Generated APIs](../getting-started/first-usage/using-generated-apis) guides.

---

## Related Documentation & Resources

- [What is GORM CLI?](../overview/product-intro/what-is-gorm-cli) - Comprehensive introduction and core concepts.
- [Quick Feature Tour](../overview/product-intro/quick-feature-tour) - Snapshot of key functionalities.
- [First Code Generation Guide](../guides/getting-started-workflows/first-generation) - Step-by-step tutorial.
- [Associations Guide](../guides/advanced-patterns-integration/associations-in-depth) - Deep dive into association helpers.
- [SQL Template DSL](../guides/advanced-patterns-integration/template-sql-dsl) - How to write dynamic and type-safe SQL templates.
- Community and repository: [GORM CLI GitHub](https://github.com/go-gorm/cli)

---

Embark on a journey where your Go projects gain unmatched type safety, maintainability, and automation with GORM CLI tailored to your needs. Whether crafting queries manually or architecting complex database layers, GORM CLI aligns perfectly with your goals.