---
title: "Who Should Use GORM CLI?"
description: "Understand who benefits most from GORM CLI—from Go backend engineers building with GORM, to teams seeking safer, easier data access and migrations. Explore common scenarios where automated API and helper generation supercharges productivity."
---

# Who Should Use GORM CLI?

GORM CLI is a powerful productivity booster designed specifically for Go backend engineers and teams working with GORM. This page helps you understand exactly who benefits most from GORM CLI, focusing on how it seamlessly automates and enhances data access, migrations, and API creation.

---

## Unlock Productivity for Individual Developers and Teams

Imagine you're a Go developer managing complex database models with GORM. Writing boilerplate CRUD operations, crafting SQL queries by hand, and coordinating database migrations can slow you down. GORM CLI lifts this burden by generating type-safe, idiomatic Go code directly from your interfaces and models. It transforms your manual tasks into automated flows, letting you focus on the unique logic of your application.

Whether you're working solo or with a team, the benefits of safety, clarity, and speed scale with your project size and complexity.

---

## Who Benefits Most?

### 1. Go Backend Engineers Building with GORM

* **Why you?**
  - You build Go services that use GORM as the main ORM.
  - You want to reduce runtime errors and increase compile-time safety.
  - You seek a fluent, discoverable, and consistent API for database operations.

* **How GORM CLI helps:**
  - Generates type-safe query APIs from your predefined interfaces.
  - Produces model-driven field helpers for filters, updates, and associations.
  - Automatically handles complex associations (has-one, has-many, belongs-to, many-to-many, polymorphic) with dedicated helpers.
  - Removes guesswork by creating strongly typed code mirroring your DB schema.


### 2. Teams Focusing on Safer and Easier Data Access

* **Why you?**
  - Collaboration demands consistency and safety in how data access is implemented across team members.
  - You want to avoid duplicated query logic and reduce manual testing overhead.
  - Your development velocity benefits from tooling that enforces standards.

* **How GORM CLI helps:**
  - Centralizes query interfaces and generation, ensuring everyone codes against the same contract.
  - Provides fluent APIs with compile-time checks reducing runtime surprises.
  - Streamlines migrations and association handling keeping codebases maintainable.

---

## Common Scenarios Where GORM CLI Supercharges Productivity

### Scenario: Generating Type-Safe Query APIs

You write Go interfaces decorated with SQL templates for your queries. GORM CLI generates concrete implementations that embed your SQL logic with safety and correctness:

```go
// Sample interface method comment defines SQL template
// SELECT * FROM @@table WHERE id=@id
GetByID(id int) (T, error)
```

Usage after generation:

```go
user, err := generated.Query[User](db).GetByID(ctx, 123)
```

The query is fully typed, with parameters bound correctly, enabling quick, error-resistant access.


### Scenario: Managing Complex Associations Automatically

Say your `User` model includes associations like `Pets` and `Languages`. Instead of handcrafted SQL or ORM calls, use the generated helpers:

```go
gorm.G[User](db).
  Set(
    generated.User.Name.Set("alice"),
    generated.User.Pets.Create(generated.Pet.Name.Set("fido")),
    generated.User.Languages.CreateInBatch([]models.Language{{Code: "EN"}, {Code: "FR"}}),
  ).
  Create(ctx)
```

This example creates a user, links pets and languages, and handles foreign keys and join tables transparently.


### Scenario: Safe Updates and Filtering with Field Helpers

Complex queries with conditional filters and updates become simple and safe using generated field helpers:

```go
// Update user age and mark adult
query.UpdateUser(ctx, User{Name: "jinzhu", Age: 20}, 1)

// Filter users with age between 18 and 30
users, err := gorm.G[User](db).
  Where(generated.User.Age.Between(18, 30)).
  Find(ctx)
```

Field helpers generate expressive predicates that prevent mistakes like column typos or SQL injection.

---

## Why Should You Care?

- **Save Development Time:** Automate repetitive code generation, freeing time for business logic.
- **Improve Code Quality:** Reduce bugs with compile-time type checks and uniform APIs.
- **Scale Collaboration:** Teams share a clear, consistent contract for database interactions.
- **Handle Complex Data Models:** Polymorphic and many-to-many associations supported out of the box.

---

## Getting Started Preview

To begin leveraging GORM CLI, you simply:

- Define your Go models with GORM struct tags.
- Write query interfaces with SQL templates as Go interface methods.
- Run the CLI generator to produce the typed code.
- Integrate the generated code to access your database safely and fluently.

For detailed onboarding, see the [Getting Started guide](https://github.com/go-gorm/cli#quick-start) and the [Product Introduction](overview/product-intro/what-and-why).

---

## Practical Tips for Success

- **Start Small:** Begin with core models and queries to build confidence before generating for larger codebases.
- **Keep Interfaces Clear:** Use descriptive method names and concise SQL for better generated code clarity.
- **Leverage Association Helpers:** Model your relationships accurately to unlock batch operations and linkage semantics.
- **Use Configuration:** Customize generation with `genconfig.Config` to fit your project’s specific needs.

---

## Troubleshooting Common Challenges

<AccordionGroup title="Common Pitfalls & How to Avoid Them">
<Accordion title="Mismatch Between Models and Interfaces">
Ensure your Go struct fields and interface query parameters align perfectly. Inconsistencies can cause generation errors or runtime bugs.
</Accordion>
<Accordion title="Incorrect SQL Templates or Placeholders">
Always verify your SQL templates follow the supported directives like `@@table`, `@param`, and `{{where}}`. Misplaced or misspelled placeholders break generation.
</Accordion>
<Accordion title="Handling Polymorphic Associations">
Model polymorphic relations carefully using GORM tags as shown in the example `User` struct to enable correct helper generation.
</Accordion>
</AccordionGroup>

---