---
title: "What is GORM CLI?"
description: "Discover the purpose and advantages of GORM CLI. Learn how it enables the generation of type-safe query APIs and field helpers directly from your Go interfaces and model structs, providing compile-time safety and a fluent API for database operations."
---

# What is GORM CLI?

GORM CLI is a powerful code generation tool designed to enhance your GORM-based Go projects by automatically generating type-safe query APIs and model field helpers. By integrating seamlessly with your Go interfaces and model structs, GORM CLI eliminates runtime errors through compile-time safety and provides a fluent, easy-to-use API tailored for robust database interactions.

---

## Unlocking Type Safety and Fluent Database Access

Imagine writing database queries with the confidence that every filter, update, and association operation matches your Go types — no guesswork, no fragile string-based SQL, just intuitive code that the compiler verifies for you. GORM CLI turns this vision into reality by generating your query APIs directly from Go interfaces annotated with SQL templates and your model structs.

- Generate **type-safe query methods** from your Go interfaces that embed raw SQL.
- Create **strongly-typed field helpers** mapped from your model structs for filtering, updating, ordering, and managing associations.
- Gain **compile-time validation**, catching errors before your code runs.
- Use a **fluent and discoverable API** to write database operations clearly and efficiently.

### Who Benefits?

GORM CLI empowers Go developers building applications with GORM who want safer, cleaner, and more maintainable data access layers. If you define your database models and want to write precise, expressive queries without losing type safety, this tool fits naturally into your workflow.

---

## The Essence of GORM CLI

### What Exactly Is GORM CLI?

GORM CLI is a command-line tool that processes your Go source code to generate two complementary code sets:

1. **Interface-Driven Query APIs**: Transform raw SQL methods described in Go interfaces, annotated with SQL templates, into concrete, type-safe Go methods.
2. **Model-Driven Field Helpers**: Generate ready-to-use field helper objects based on your model structs for building filters, updates, and association operations.

This dual approach bridges the gap between raw SQL flexibility and Go’s strong typing, providing a developer experience that is both powerful and safe.

### What Problems Does It Solve?

- **Runtime errors from string-based SQL**: By using Go’s compile-time checks, it avoids common bugs caused by typos or type mismatches.
- **Complexity in building queries**: Automatically generate helpers that simplify query construction with expressive methods.
- **Manual mapping burden**: Eliminates tedious and error-prone code writing for common query and update patterns.

### How Does It Work Conceptually?

GORM CLI scans your Go code to:

- Read SQL templates embedded in interface method comments.
- Extract structs representing database models.
- Produce strongly typed Go code that you can call directly to interact with the database.

This generation happens before compiling your application, embedding compile-time safety and reducing developer overhead.

---

## Key Features & Capabilities

### 1. Interface-Driven, Type-Safe Query APIs

Write Go interfaces with SQL query templates in comments to define the exact queries you want. Upon generation, you receive concrete Go methods ensuring:

- All parameters bind correctly with names and types.
- Query methods return results typed exactly as your Go models.

#### Example
```go
// Interface definition with SQL template
 type Query[T any] interface {
   // SELECT * FROM @@table WHERE id=@id
   GetByID(id int) (T, error)
 }
```

Generate and use:
```go
user, err := generated.Query[User](db).GetByID(ctx, 123)
```

### 2. Model-Driven Field Helpers

From your Go model structs, GORM CLI generates helpers that allow concise, fluent query building.

- Helpers for basic fields support predicates like `Eq`, `Lt`, `Between`.
- Support for filters, updates, and ordering.
- Association helpers for related models (has one, belongs to, many2many).

#### Example
```go
generated.User.Name.Like("%jinzhu%")      // name LIKE '%jinzhu%'
generated.User.Age.Between(18, 65)          // age BETWEEN 18 AND 65
```

### 3. Rich Association Operations

Operate on related data efficiently with type-safe methods:

- Create and associate new entities.
- Update related rows matching conditions.
- Unlink associations without deleting data.
- Delete associated rows or join table entries.
- Batch create and link associations.

#### Example
```go
gorm.G[User](db).
  Set(
    generated.User.Name.Set("alice"),
    generated.User.Pets.Create(generated.Pet.Name.Set("fido")),
  ).
  Create(ctx)
```

### 4. SQL Template DSL for Flexible Queries

Your interface method comments can contain a robust, templated SQL DSL with directives like `@@table` for table name, `@param` for parameters, and conditional clauses.

This template DSL supports:
- Dynamic WHERE and SET clauses.
- Iteration over collections.
- Conditional SQL fragments based on parameters.

#### Example Template
```sql
SELECT * FROM @@table
{{where}}
  {{if user.Name != ""}} name=@user.Name {{end}}
  {{if user.Age > 0}} AND age=@user.Age {{end}}
{{end}}
```

---

## Why Should You Care About GORM CLI?

### The Impact on Your Development

- Eliminate risks from runtime SQL errors by leveraging compile-time type checks.
- Accelerate development with generated, discoverable query APIs.
- Reduce boilerplate and focus on business logic.
- Ensure consistent and maintainable database access patterns across teams.

### Common Use Cases

- Generating complex, reusable query APIs for large projects.
- Managing CRUD operations with compile-time safe association helpers.
- Building query interfaces with dynamic filters driven by user input.
- Extending database interactions with custom SQL templates while retaining type safety.

### Before and After

| Without GORM CLI                      | With GORM CLI                                            |
|------------------------------------|---------------------------------------------------------|
| Manually build SQL strings          | Write Go interfaces with SQL templates and generate code|
| Risk of typos and mismatches        | Compiler enforces correctness and type safety           |
| Boilerplate updates and filters     | Fluent field helpers auto-generated for updates/filters |
| Manual association management       | Type-safe association operations with clear semantics   |

### Measurable Benefits

- Significant reduction in query-related bugs.
- Faster onboarding via generated, discoverable APIs.
- Efficient batch operations and flexible filtering.

---

## Getting Started Preview

Using GORM CLI is straightforward and integrates seamlessly:

1. **Prepare your interfaces and models**
   - Define Go interfaces with SQL templates in comments.
   - Define your model structs for code generation.

2. **Run the generator**

```bash
gorm gen -i ./examples -o ./generated
```

3. **Use the generated code**

```go
// Query user by ID
user, err := generated.Query[User](db).GetByID(ctx, 123)

// Use model helpers for filtering
users, err := gorm.G[User](db).Where(generated.User.Age.Gt(18)).Find(ctx)
```

### Prerequisites

- Go 1.18+ (for generics support).
- GORM installed and configured in your project.

### Next Steps

Explore detailed guides on:

- Writing SQL template interfaces
- Understanding generated field helpers
- Managing associations effectively
- Customizing generation via configuration

---

## Additional Resources

See these sections for deeper insight:

- [Getting Started Guide](#)
- [Working with Field Helpers and Predicates](#)
- [Managing Associations In-Depth](#)
- [Customizing Generation with genconfig](#)

---

By embracing GORM CLI, you elevate your Go project’s database layer with confidence, clarity, and efficiency.

---