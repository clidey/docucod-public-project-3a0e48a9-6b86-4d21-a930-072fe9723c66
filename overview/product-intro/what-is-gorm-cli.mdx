---
title: "What is GORM CLI?"
description: "An introduction to GORM CLI, covering its purpose as a code generation tool for building type-safe, interface-driven query APIs and model-driven field helpers on top of the GORM ORM. Learn why this CLI dramatically improves safety, discoverability, and productivity for database development in Go."
---

# What is GORM CLI?

## Unlock Safer and More Productive Database Development in Go

GORM CLI is a specialized code generation tool designed to enhance your GORM ORM projects by creating **type-safe**, **interface-driven query APIs** and **model-driven field helpers** automatically. It transforms your Go interfaces with embedded SQL templates and your model structs into a fluent, discoverable, and compile-time safe API for database operations.

Key benefits of using GORM CLI include:
- **Eliminates runtime errors** by catching SQL query mistakes at compile time
- Provides **intelligent code generation** that creates convenient helpers for filtering, updating, and managing associations
- Increases **developer productivity** by making database code easier to write, read, and maintain
- Seamlessly **integrates with GORM**, so you don’t lose the power and flexibility of your existing ORM

### Who Should Use GORM CLI?
- Go developers building database-driven applications with GORM
- Teams aiming to enforce stricter type safety in their database querying
- Projects looking to automate query and helper code generation to minimize manual SQL and boilerplate

---

## What Is GORM CLI?

At its core, GORM CLI is a **code generator** that parses Go interface definitions annotated with raw SQL or templated SQL comments and your model structs to produce two complementary sets of code:

1. **Type-safe Query Interfaces**: From your declared Go interfaces containing SQL templates, GORM CLI generates concrete, strongly typed query implementations. These interfaces empower developers to express database queries in pure Go, catching errors early and facilitating auto-completion in IDEs.

2. **Model-driven Field Helpers**: From your GORM model structs, the CLI generates helper types and functions that represent your model's fields and associations. These helpers are designed for filters, updates, ordering, and association management with compile-time guarantees.

Together, these components create a **fluent, discoverable API** fronting your database that feels natural to the Go developer while offering a level of safety and expressiveness beyond handwritten SQL or raw ORM calls.

What sets GORM CLI apart is its focus on:
- **Type safety** at compile time, eliminating many common SQL errors.
- **Interface-driven design** where you write expressive query interfaces and annotations rather than raw SQL strings scattered through your codebase.
- **Model-awareness** that understands GORM associations deeply, generating tailored helpers for complex relations.

---

## Key Features & Capabilities

### 1. Type-Safe Query APIs from Interfaces
- Write Go interfaces with comments containing SQL or template DSL.
- GORM CLI parses these and generates type-safe implementations.
- Example:

```go
// SELECT * FROM @@table WHERE id=@id
GetByID(id int) (T, error)
```

Generates a method to query by ID, enforcing type-safe parameters and results.

### 2. Model-Driven Field Helpers
- Converts model struct fields into strongly typed helpers for building queries.
- Supports filters (e.g., `Eq`, `Between`, `Like`), updates, and ordering.
- Example predicates:

```go
generated.User.Name.Like("%jinzhu%")    // WHERE name LIKE '%jinzhu%'
generated.User.Age.Between(18, 65)      // WHERE age BETWEEN 18 AND 65
```

### 3. Association Operations with Strong Guarantees
- Full support for common association types: `has one`, `has many`, `belongs to`, `many2many`, and polymorphic associations.
- Allows operations like Create, Update, Unlink, Delete, and batch operations with type safety.
- Example:

```go
gorm.G[User](db).
    Set(
        generated.User.Name.Set("alice"),
        generated.User.Pets.Create(generated.Pet.Name.Set("fido")),
    ).
    Create(ctx)
```
This creates a new `User` and a related `Pet` in one atomic operation.

### 4. SQL Template DSL Support
- Flexible SQL generation via a DSL embedded in interface comments.
- Supports dynamic columns, conditional `WHERE` and `SET` clauses, and loops.
- Common directives include `@@table`, `@param`, `{{where}}`, `{{set}}`, `{{if}}`, and `{{for}}`.

---

## Why Should I Care?

### Primary Benefits
- **Eliminate runtime SQL errors**: Generate query code that is checked during compilation.
- **Accelerate development**: Reuse interfaces and models to auto-generate common query logic.
- **Improved readability & discoverability**: The generated API surfaces model fields and query options that IDEs can auto-complete.
- **Handle complex associations effortlessly**: Manage relationships through typed helpers, simplifying code complexity.

### Common Use Cases
- Developing REST APIs with complex querying and filtering.
- Generating boilerplate CRUD and association operations automatically.
- Building multi-tenant or modular applications with configurable query interfaces.
- Migrating raw SQL queries into type-safe, maintainable Go interfaces.

### Before and After GORM CLI
| Without GORM CLI                                    | With GORM CLI                                          |
| ------------------------------------------------- | ----------------------------------------------------- |
| Handcrafted SQL prone to errors and vulnerabilities| Compile-time safety with auto-generated query methods |
| Manually building query conditions with strings   | Fluent, type-safe field helpers and predicates        |
| Scattered raw SQL templates with poor discoverability| Centralized, interface-driven queries with templates |

---

## Getting Started Preview

To start using GORM CLI, the process generally looks like this:

1. **Define Query Interfaces**
   Write Go interfaces in your project with SQL or templated SQL in comments.

2. **Define Your Models**
   Use your GORM model structs as usual.

3. **Run the Code Generator**
   Invoke the CLI with your interfaces.

4. **Use the Generated APIs**
   Consume generated query methods and helpers with full typing in your application.

Example snippet of generating code:

```bash
gorm gen -i ./examples -o ./generated
```

and using generated query:

```go
u, err := generated.Query[User](db).GetByID(ctx, 123)

users, err := gorm.G[User](db).Where(generated.User.Age.Gt(18)).Find(ctx)
```

<Check>
Ensure you have Go 1.18+ installed since GORM CLI leverages Go generics.
</Check>

For detailed installation and full getting started instructions, visit the [Installing GORM CLI](../../getting-started/setup-basics/installation) page.

---

## Examples: Code You Write vs. Code Generated

### Writing Query Interface
```go
// Define your query interface
// SQL templates go inside the comments
// The CLI generates type-safe implementations automatically

type Query[T any] interface {
  // SELECT * FROM @@table WHERE id=@id
  GetByID(id int) (T, error)

  // WHERE name=@name AND age=@age
  FilterByNameAndAge(name string, age int)
}
```

### Defining Your Model
```go
type User struct {
  gorm.Model
  Name string
  Age  int
}
```

### Using Generated Code
```go
// Query user by ID, types enforce safety
user, err := generated.Query[User](db).GetByID(ctx, 123)

// Filter users by name and age
users, err := generated.Query[User](db).FilterByNameAndAge("jinzhu", 25).Find(ctx)
```

### Manage Associations
```go
// Add a pet to an existing user
err := gorm.G[User](db).
  Where(generated.User.ID.Eq(1)).
  Set(generated.User.Pets.Create(generated.Pet.Name.Set("fido"))).
  Update(ctx)
```

---

## Tips & Best Practices

- Annotate your Go interfaces clearly with desired SQL or conditional templates to maximize safety and flexibility.
- Define model associations properly to benefit from generated helpers for complex relationship management.
- Use `genconfig.Config` for advanced customization such as custom field mappings or scoped generation.

## Common Pitfalls & Troubleshooting

- Make sure your SQL templates in interface comments compile correctly—errors in templating will cause generation to fail.
- Do not forget to include your interfaces and model directories correctly in the CLI `-i` input path.
- Your methods must have at most two return values: data and error, with error required as the last.

For troubleshooting, see [Troubleshooting Common Issues](../../getting-started/troubleshooting-validation/troubleshooting).

---

Harness GORM CLI today to elevate your Go database workflows with confidence, safety, and expressive power.
