---
title: "What is GORM CLI?"
description: "GORM CLI is a code generation tool that automates the creation of type-safe, interface-driven query APIs and model-based field helpers for GORM-powered Go projects. Its primary value is providing compile-time safety and a discoverable API, dramatically reducing boilerplate and common query errors."
---

# What is GORM CLI?

## Unlocking Type-Safe, Efficient Database Queries for Go Projects

At its core, **GORM CLI** is a powerful code generation tool designed specifically for Go developers using the GORM ORM framework. It transforms your Go interfaces and model structs into fully type-safe, interface-driven query APIs along with model-based field helpers. This means you get an expressive, compile-time checked query layer that drastically reduces the routine and error-prone parts of database interaction.

### Why GORM CLI Matters to You

Imagine you are building a Go application with complex database queries. Traditionally, writing raw SQL queries inside your code risks runtime errors, typos, and maintenance headaches. GORM CLI eliminates these pain points by generating strict, discoverable APIs from your annotated interfaces and models — ensuring that your database queries are verified before you even run your program.

This not only strikes down bugs early but accelerates development with a fluent, auto-completable API tailored exactly to your schema and query intentions.

---

## What Does GORM CLI Do?

### Definition
GORM CLI takes Go code as input — specifically, interfaces decorated with SQL templates and model definitions — and generates two complementary layers:

- **Type-safe Query APIs**: Methods generated from your Go interfaces with embedded SQL templates provide strongly typed, reusable query functions.

- **Model-based Field Helpers**: Auto-generated helpers for your model structs that simplify filters, updates, and association operations with compile-time safety.

### The Problem It Solves
Developers often struggle with:

- Writing safe, reusable SQL queries without risking syntax or binding errors.
- Dealing with verbose and duplicated query boilerplate.
- Managing complex association operations safely.

GORM CLI automates these through code generation, ensuring queries are:

- **Safe**: Catch invalid queries and parameter usage at compile time.
- **Discoverable**: Clear APIs with meaningful method signatures.
- **Efficient**: Less boilerplate and manual stitching of queries.

### What Makes GORM CLI Unique?

- **Integration with GORM**: Seamless compatibility with GORM’s fluent APIs.
- **Template DSL Support**: SQL queries within interfaces use a powerful templating DSL enabling dynamic conditions, iteration, and binding.
- **Field and Association Helpers**: Generate helpers for every model field and relationship, including many common association operations with type safety.
- **Configurable Generation**: Use package-level config to fine-tune output paths, included/excluded interfaces and structs, and custom field mappings.


---

## How GORM CLI Works: A High-Level View

You provide:
- Go interfaces containing method signatures with SQL-like annotations in comments.
- Go structs defining your database models.

GORM CLI processes this input, parsing the Go AST, extracting interfaces and structs, and applying configuration rules. It then applies templates to generate:

- Concrete implementations of your query interfaces with type-safe methods.
- Field helper variables aligned to your models’ columns for expressive queries and updates.

The generated code integrates into your project, letting you write queries like this:

```go
u, err := generated.Query[User](db).GetByID(ctx, 123)
users, err := gorm.G[User](db).Where(generated.User.Age.Gt(18)).Find(ctx)
```

Behind the scenes, the CLI uses **cobra** for the CLI interface, **Go parser packages** to parse input, and **text/templates** to generate Go code files.

---

## Key Features & Why They Matter

- **Type-Safe Query APIs**
  - Write Go interfaces with SQL templates; get generated implementations that enforce correct parameters and result types.
- **Model-Driven Field Helpers**
  - Generate strongly typed helpers for querying and updating fields, including predicates (e.g., `Eq`, `Like`, `Between`) and association operations.
- **Association Operations with Safety**
  - Create, update, unlink, and delete related records with helpers tailored to your model’s relations, avoiding broken FK errors.
- **Template-Based SQL DSL**
  - Write flexible SQL statements using directives like `@@table`, `@param`, `{{where}}` for conditional clauses, enabling more dynamic queries while retaining safety.
- **Configurable Generation**
  - Customize inclusion of interfaces and structs, output directories, and field mappings via `genconfig.Config`.

---

## Real-World Example

Define an interface method:

```go
// SELECT * FROM @@table WHERE id=@id
GetByID(id int) (T, error)
```

The generator creates a type-safe API method:

```go
u, err := generated.Query[User](db).GetByID(ctx, 123)
```

This executes a query:

```sql
SELECT * FROM users WHERE id=123;
```

...safely mapping parameters and result types, catching compile-time errors if incorrect.

Similarly, model-driven helpers like:

```go
generated.User.Age.Between(18, 65)
```

help write expressive queries without raw SQL strings.

---

## Getting Started Preview

1. Define your interfaces with SQL templates and your model structs.
2. Run the CLI command:

```bash
gorm gen -i ./your_package -o ./generated
```

3. Import and use generated APIs in your Go code for safer, cleaner database queries.

For detailed setup, see the **Installation & Setup** and **Quickstart Workflow** guides.

---

## Summary
GORM CLI empowers Go developers building on GORM with automated, compile-time safe query APIs and model helpers. It reduces errors, accelerates development, and enhances readability through generated code that mirrors your database models and query intentions.

Explore the rest of the documentation to dive deeper into installation, configuration, and advanced usage patterns.

---