---
title: "What is GORM CLI?"
description: "Discover how GORM CLI accelerates development by generating type-safe query APIs and field helpers. Learn how it unifies model-driven and interface-driven code generation to provide safe, fluent, and maintainable database access in Go projects."
---

# What is GORM CLI?

## Accelerate Go Project Development with Type-Safe, Model-Driven Database Access

GORM CLI is a powerful command-line tool designed to seamlessly generate type-safe query APIs and field helpers for your Go projects using GORM. By unifying model-driven and interface-driven code generation, it provides you with a fluent, safe, and maintainable way to interact with your database — eliminating runtime errors, improving developer productivity, and making your code more robust.

---

### Why GORM CLI Matters to You

Imagine writing database queries that are verified at compile-time rather than discovered through runtime errors. GORM CLI unlocks this, letting you define your queries as Go interfaces annotated with SQL templates and models annotated with generation hints. It then generates:  

- **Type-safe query APIs** driven from Go interfaces with raw SQL annotations that directly reflect your business logic
- **Field helpers** automatically generated from your models, providing intuitive, strongly typed abstractions for filters, updates, ordering, and associations

This combination enables you to write database code that is not only expressive and concise but also fully checked for correctness before you run it.

---

## What Exactly Does GORM CLI Do?

At its core, GORM CLI is a code generator that processes your Go project’s model structs and Go interfaces annotated with SQL templates. Using its `gen` command, it scans your source files to produce:

- A fluent, type-safe API that transforms your SQL annotations into method implementations
- Auto-generated field helper structs and functions that simplify complex query composition and CRUD operations

This way, you never have to manually write repetitive, error-prone boilerplate SQL handling code. Instead, rely on generated types and methods that guide you through database operations effortlessly.

---

## Key Features of GORM CLI

- **Interface-driven Query Generation:** Write Go interfaces with embedded SQL templates in method comments. GORM CLI generates concrete implementations that provide type-checked database access methods.

- **Model-driven Field Helpers:** Your Go structs become sources for generating rich, strongly-typed field helpers including predicates, setters, and association operations.

- **Comprehensive Association Support:** Strongly-typed creation, update, unlink, and deletion operations for `has one`, `has many`, `belongs to`, and `many2many` relationships.

- **Configurable Output & Inclusion:** Fine-tune generation with the `genconfig.Config` settings for custom output directories, inclusion/exclusion patterns, and field-mapping rules.

- **SQL Template DSL:** Use sophisticated SQL templating directives (`@@table`, `{{where}}`, `{{set}}`, `{{if}}`, `{{for}}`) in interface method comments to express dynamic queries flexibly yet safely.

---

## Real-World Example: From Interface to Query

Define your query interface with SQL templates as Go interface methods,

```go
// example: Query interface
 type Query[T any] interface {
   // SELECT * FROM @@table WHERE id=@id
   GetByID(id int) (T, error)

   // where("name=@name AND age=@age")
   FilterByNameAndAge(name string, age int)
 }
```

Define your model struct,

```go
 type User struct {
   ID   uint
   Name string
   Age  int
 }
```

Generate code with:

```bash
gorm gen -i ./examples -o ./generated
```

Use the generated code simply:

```go
// Fetch user by id
u, err := generated.Query[User](db).GetByID(ctx, 123)

// Filter users by name and age
users, err := generated.Query[User](db).FilterByNameAndAge("jinzhu", 25).Find(ctx)
```

---

## Why Should You Care? Benefits & Use Cases

- **Error Reduction:** Detect SQL or parameter mismatches at compile time rather than during runtime.

- **Productivity Gains:** No manual query implementation or field helper coding; focus on core business logic instead.

- **Fluent Queries:** Code completion & discoverability in your IDE make complex query construction intuitive.

- **Association Mastery:** Manage complex object graphs with ease by using generated association operations.

- **Maintainability:** Changes in your models or queries automatically propagate to generated code, reducing drift.

### Ideal Use Cases

- Large Go projects with frequent database operations needing high assurance.
- Teams adopting code generation to standardize data access layers.
- Developers seeking a blend of raw SQL power with type safety and fluency.

---

## Getting Started with GORM CLI Gen Command

### Quick Overview

The primary entrypoint for code generation is the `gen` command of the GORM CLI tool.

Use:

```bash
gorm gen -i <input-path> -o <output-path>
```

- `-i`: Path to Go file or directory containing interfaces with SQL template annotations
- `-o`: Output directory for generated code (defaults to `./g`)

### Example

```bash
gorm gen -i ./examples -o ./generated
```

This command scans all source files within `./examples` to generate the query APIs and field helpers into `./generated`.

### Important Tips

- Your interfaces must have SQL templates defined in their method comments for generation.
- Generation respects configuration files for customizing output paths and inclusion.
- Generated code supports context-aware query execution, automatically injecting `context.Context` if missing.

---

## Common Pitfalls & Troubleshooting

- **Missing `-i` Input Flag:** The input path for interfaces is required. Without it, generation will fail.

- **No Methods with SQL Templates:** Ensure interface methods are properly documented with SQL template DSL syntax.

- **Output Path Overlaps:** Watch for configs overriding output paths; ensure your `-o` flag matches expected directories.

- **Compilation Errors After Generation:** Verify your models and interfaces strictly follow type requirements and use supported Go types.

- **Association Handling Misuse:** Understand semantic differences for `Unlink` vs. `Delete` operations on associations.

For detailed troubleshooting, consult the [Quick Validation & Troubleshooting guide](/getting-started/first-usage/troubleshooting-validation).

---

GORM CLI brings compile-time safety and fluency to interacting with your database in Go. By generating from your interfaces and models, it turns boilerplate into intuitive, discoverable APIs — enabling your developers to focus on writing confident, maintainable data access code.

Start your journey with GORM CLI today and transform how your Go projects talk to databases.


---

## Related Documentation

- [Feature Highlights at a Glance](/overview/product-intro/quick-feature-tour)
- [Your First Code Generation: From Models to APIs](/guides/getting-started-workflows/first-generation)
- [Field Helpers: Filtering, Updates, and Expressions](/guides/getting-started-workflows/field-helpers-basics)
- [Managing Associations: Best Practices & Scenarios](/guides/advanced-patterns-integration/associations-in-depth)
- [SQL Template DSL: Writing Dynamic, Type-Safe Queries](/guides/advanced-patterns-integration/template-sql-dsl)
- [Custom Generation Rules & Field Mapping](/guides/advanced-patterns-integration/customization-configs)


---

## See Also

- Official GORM CLI GitHub repository: [https://github.com/go-gorm/cli](https://github.com/go-gorm/cli)
- `gorm gen` source code and options internalized via `main.go` and `internal/gen/gen.go`

---