---
title: "Who Should Use GORM CLI?"
description: "Defines the ideal audience: Go developers using GORM who want more safety, productivity, and maintainability in their data access layers. Outlines primary use cases including building robust query APIs, simplifying filter/update logic, and scaling complex model relationships."
---

# Who Should Use GORM CLI?

## Unlock Safer, More Productive Data Access for Go Developers Using GORM

GORM CLI is designed specifically for Go developers who want to elevate their data layer with **type safety**, **fluency**, and **maintainability** without sacrificing control. If you use GORM in your projects, this tool empowers you to generate robust, intuitive APIs that simplify how you interact with your database, helping you avoid common pitfalls and boilerplate.

---

## Perfect For:

- **Go developers building complex query APIs** that demand precision and compile-time checks to catch errors early.
- Teams aiming to **reduce runtime errors** in SQL queries by using interface-driven, template-based code generation.
- Projects requiring **clean, concise filter and update logic** that adapts fluidly as business requirements evolve.
- Applications scaling to handle **complex model relationships and associations** while maintaining code clarity.

---

## Primary Use Cases

### 1. Building Robust, Type-Safe Query APIs

GORM CLI converts your simple Go interfaces annotated with SQL templates into fully typed query methods. This lets you:

- Write flexible, reusable query methods using Go generics.
- Avoid manual SQL string concatenation and injection risks.
- Gain auto-completion and compile-time validation in your IDE.

**Example:**

```go
// Your interface method with embedded SQL
// SELECT * FROM @@table WHERE id=@id
GetByID(id int) (T, error)

// Use the generated API
user, err := generated.Query[User](db).GetByID(ctx, 123)
```

### 2. Simplifying Filters and Update Logic

Using SQL template DSL with conditional clauses (`{{if}}`, `{{where}}`, `{{set}}`), you can express complex filtering and updates declaratively:

- Compose filters based on inputs without boilerplate.
- Write dynamic WHERE clauses that adapt to provided parameters.
- Update fields conditionally based on input struct values.

This vastly improves clarity and reduces error-prone manual SQL.

### 3. Handling Complex Model Relationships at Scale

GORM CLI generates **model-driven field helpers** for:

- Basic fields (strings, ints, times) with methods for predicates (`Eq`, `Like`, `Between`, etc.)
- Associations such as `belongs to`, `has many`, `many2many` as strongly typed helpers
- Operations on associations with compile-time safety: create, update, unlink, delete, batch operations

This enables fluent, safe updates and queries involving related models.

**Example:**

```go
gorm.G[User](db).
  Set(
    generated.User.Name.Set("alice"),
    generated.User.Pets.Create(generated.Pet.Name.Set("fido")),
  ).
  Create(ctx)
```

---

## Why GORM CLI Fits Your Needs

- **Compile-time Safety:** Catch SQL errors and type mismatches early.
- **Increased Productivity:** Generate boilerplate code automatically, freeing you for business logic.
- **Maintainability:** Clean, declarative interfaces and generated helpers make your codebase easier to evolve.
- **Scalability:** Built to support complex model relations and growing application demands.

---

## Getting Started Preview

Start by defining your query interfaces with SQL templates alongside your model structs. Use the `gorm gen` command to generate type-safe query methods and field helpers automatically.

```bash
gorm gen -i ./your_query_and_model_package -o ./generated
```

Use the generated APIs directly in your app for safer, clearer data access.

For detailed steps, see [Your First Code Generation](/getting-started/configuration-first-usage/first-generation-run).


---

## Tips & Best Practices

- Always keep your query interfaces clear and well-documented with SQL templates to maximize clarity.
- Use conditional template clauses to write adaptable and concise filters or update statements.
- Leverage association helpers for creating and modifying related data atomically.
- Start with simple queries and progressively add complexity as your needs grow.

## Common Scenarios & Pitfalls

- Forgetting to mark the input interface file (`-i`) as required in the CLI results in an error.
- Misaligned method return types or missing error returns will cause code generation to failâ€”always follow the interface conventions.
- Conditional SQL templates must be syntactically correct and tested.


---

For more details on the overall product features and value, see [What is GORM CLI?](/overview/product-intro/value-proposition).

Explore next:

- [Getting Started: Your First Code Generation](/getting-started/configuration-first-usage/first-generation-run)
- [Working With Basic Fields](/guides/best-practices-patterns/working-with-basic-fields)
- [Working With Associations](/guides/best-practices-patterns/associations-and-relations)

---

Empower your GORM projects with safer, faster, and more maintainable data access using the GORM CLI tool tailored for Go developers who demand reliability and clear abstractions.