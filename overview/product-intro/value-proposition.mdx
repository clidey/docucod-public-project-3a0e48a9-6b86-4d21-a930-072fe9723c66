---
title: "Why Use GORM CLI?"
description: "Understand the main benefits: type safety, API discoverability, reduction of boilerplate SQL, and a more fluent development experience. Describes how GORM CLI accelerates GORM workflows and reduces runtime bugs."
---

# Why Use GORM CLI?

Discover how GORM CLI empowers you with type safety, intuitive API discoverability, and a fluent development experience that dramatically reduces boilerplate SQL and runtime bugs. This documentation explains why GORM CLI is essential for accelerating your GORM-based workflows and improving code quality.

---

## Unlocking the Benefits: Type Safety and Fluent APIs

In modern application development, bugs and inefficiencies often arise from error-prone manual SQL construction and invisible runtime errors. GORM CLI addresses these challenges head-on by automatically generating type-safe query APIs and model-driven helpers tailored to your Go application's data models.

### What You Gain with GORM CLI

- **Compile-Time Safety:** Errors that would normally emerge only at runtime, such as misspelled columns or mismatched query parameters, are caught during compilation. This ensures robustness before deployment.
- **API Discoverability:** Intuitive, well-structured generated APIs allow you to navigate query building and update operations with autocomplete and clear method signatures.
- **Reduced Boilerplate:** Automatically generate complex query methods and field helpers from your interfaces and models—slashing repetitive code.
- **Fluent Development Experience:** Seamless chaining and strong typing transform GORM queries into concise, expressive calls aligned with your domain models.

---

## What is GORM CLI and What Problems Does It Solve?

GORM CLI is a code generation tool designed for Go projects using the GORM ORM. It translates Go interfaces annotated with expressive SQL templates and your defined model structs into:

- **Interface-driven, type-safe query APIs** that reflect your SQL queries as methods with native Go signatures.
- **Model-driven helpers** that wrap fields and associations for fluent filtering, updating, and association management.

This solves the core problems developers face when writing raw SQL or dynamic queries:

- Prevents runtime errors caused by wrong SQL or mismatched query parameters.
- Eliminates the need for manually writing redundant CRUD queries.
- Provides compile-time guarantees and code completions, speeding up development.

---

## Key Features and How They Benefit You

### 1. Type-Safe Query APIs from Interfaces
Define your queries declaratively using Go interfaces with embedded SQL templates. GORM CLI generates concrete, type-safe implementations you can call directly, like:

```go
// Define interface with SQL template comments
type Query[T any] interface {
  // SELECT * FROM @@table WHERE id=@id
  GetByID(id int) (T, error)
}

// Usage
u, err := generated.Query[User](db).GetByID(ctx, 123)
```

**Benefit:** Your queries become discoverable, IDE-friendly, and checked at compile time.


### 2. Model-Driven Field Helpers
Generate field helpers from your models to simplify filtering, updating, and association operations:

```go
// Filters
generated.User.Name.Eq("alice")             // WHERE name = 'alice'
generated.User.Age.Between(18, 65)          // WHERE age BETWEEN 18 AND 65

// Updates
gorm.G[User](db).
  Where(generated.User.Name.Eq("alice")).
  Set(generated.User.Age.Incr(1)).
  Update(ctx)
```

**Benefit:** Write expressive and safe queries using domain fields rather than raw strings.


### 3. Safe and Fluent Association Operations
Manipulate related data with generated association helpers that mirror your model relationships:

- Create and link related records
- Update associated rows conditionally
- Unlink and delete associated data safely
- Batch create associations

Example:

```go
gorm.G[User](db).
  Set(
    generated.User.Name.Set("alice"),
    generated.User.Pets.Create(generated.Pet.Name.Set("fido")),
  ).
  Create(ctx)
```

**Benefit:** Manage complex associations with compile-time safety and clear semantics.


### 4. Configurable Code Generation
Tailor generation with `genconfig.Config`:

- Customize output paths
- Map Go types to custom field helpers (e.g. custom JSON serializers)
- Whitelist or blacklist structs and interfaces

---

## Real-World Scenario: From Interface to Type-Safe Queries

Imagine you want to fetch a user by ID, filter users by name and age, and update user info safely. With GORM CLI, you simply:

1. Write an interface defining the queries with SQL templates.
2. Define your `User` struct with standard GORM annotations.
3. Run `gorm gen` to generate strong, type-safe APIs.
4. Use generated methods directly in your code with confidence.

Example interface:

```go
type Query[T any] interface {
  // SELECT * FROM @@table WHERE id=@id
  GetByID(id int) (T, error)

  // where("name=@name AND age=@age")
  FilterByNameAndAge(name string, age int)
}
```

Usage:

```go
user, err := generated.Query[User](db).GetByID(ctx, 123)
users, err := generated.Query[User](db).FilterByNameAndAge("Alice", 25).Find(ctx)
```

---

## Practical Tips and Best Practices

- **Define interfaces clearly:** Use SQL comment templates with placeholders `@@table`, `@param` for safe param binding.
- **Leverage model annotations:** Use Go struct tags like `gen:"json"` to map fields to custom helpers.
- **Configure selectively:** Use `genconfig.Config` to control which interfaces and structs are generated.
- **Consistent package structure:** Keep your model and query interfaces close for straightforward generation.
- **Use association helpers:** Manage related data declaratively to avoid foreign key inaccuracies.

---

## Common Pitfalls and Troubleshooting

- Forgetting to include `ctx context.Context` parameters may cause generator to automatically inject them—always check method signatures.
- Incorrectly formatted SQL templates: ensure placeholders and DSL directives ({{where}}, {{set}}) follow syntax.
- Missing inclusion in `genconfig.Config` can exclude interfaces or structs from generation.

For detailed troubleshooting, see the "Troubleshooting Common Issues" page.

---

## Getting Started Preview

To quickly adopt GORM CLI:

1. Ensure Go 1.18+ is installed (due to generics).
2. Install CLI using:

```bash
go install gorm.io/cli/gorm@latest
```

3. Create your model structs and corresponding query interfaces with SQL templates.
4. Run the generator:

```bash
gorm gen -i ./yourpackage -o ./generated
```

5. Import and use the generated code immediately.

For an end-to-end guide, refer to the "Defining Models and Query Interfaces" and "Generating Type-Safe APIs" documentation.

---

Explore how GORM CLI transforms your GORM development experience by bringing compile-time safety, discoverability, and productivity into your workflow.

---

## Additional Resources
- [Official GitHub repository](https://github.com/go-gorm/cli)
- See "What is GORM CLI?" for an introductory overview
- Refer to "How GORM CLI Works" for deeper architecture insights
- Consult "Template-based Queries" for mastering SQL DSL in comments

---

Harness the power of generated, type-safe GORM APIs today to write safer, cleaner, and more maintainable database code.


---