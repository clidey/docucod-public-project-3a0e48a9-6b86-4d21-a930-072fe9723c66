---
title: "What is GORM CLI?"
description: "Understand the purpose of GORM CLI: a code generator that enhances the GORM ORM by producing type-safe, interface-driven query APIs and model-driven field helpers. Discover how it ensures compile-time safety for database queries and unleashes a fluent, discoverable API for reads and writes."
---

# What is GORM CLI?

## Unlock Type-Safe, Fluent Database Access with GORM CLI

GORM CLI is a powerful command-line tool designed to elevate your experience with GORM — the Go ORM. It automatically generates type-safe, interface-driven query APIs alongside model-based field helpers. This combination ensures your database queries are verified at compile time and provides a fluent, intuitive way to build read and write operations.

### Why GORM CLI Matters to You
Today’s database access often suffers from fragile string-based queries prone to runtime errors. GORM CLI transforms this by:

- **Guaranteeing compile-time safety:** Catch potential query errors before they happen.
- **Generating discoverable APIs:** Use strongly-typed methods and fields for every model.
- **Reducing boilerplate:** Automate tedious query constructs and updates.

Ideal for Go developers working with GORM, this tool lets you focus on your business logic, confident that your data layer is reliable and easy to maintain.

---

## What Is GORM CLI?

GORM CLI is a code generator that transforms your Go interfaces and model structs into concrete, fully-typed query APIs and field helpers.

At its core, it does two things:

- **Generates query APIs from Go interfaces with embedded SQL templates:** Define interface methods with raw SQL as comments, and GORM CLI produces implementations that are fully type-checked and integrated with GORM’s `*gorm.DB`.

- **Generates field helpers from your model structs:** For every field (basic types, nullable types, and associations), GORM CLI creates helper types that support filters, updates, associations, and more — enabling fluent and safe query building.

Together, these generators eliminate the guesswork and fragile string concatenation common in SQL, letting you interact with your models more naturally and securely.

### What Problem Does It Solve?

Without GORM CLI, constructing queries involves manual string building or working directly with GORM’s low-level APIs — both error-prone and verbose. You risk SQL injection mistakes, incorrect column names, or mistyped queries.

GORM CLI solves this by lifting query generation into your Go compile step. It ensures:

- **Correctness:** Query methods match your interface signatures.
- **Consistency:** Field helpers correspond exactly to your models.
- **Discoverability:** IDE auto-completion guides you through the API.

### What Makes GORM CLI Unique?

- **Interface-driven SQL templates:** Write declarative, readable raw SQL in Go interface comments, including templating control flow like conditionals and loops.
- **Compile-time checked generation:** The tool parses your models and interfaces deeply, ensuring your custom SQL and generated code remain consistent.
- **Powerful model field helpers:** Basic fields and complex associations generate strongly typed helpers, supporting filter predicates, update setters, and batch association operations.
- **Flexible configuration:** Use `genconfig.Config` to tailor inclusion patterns, output locations, and custom field mappings.

---

## How Does GORM CLI Work (Overview)?

1. **You declare Go interfaces with SQL template comments and Go structs as your models.**

2. **Run `gorm gen` with paths to your interfaces and models.**

3. **GORM CLI parses your Go files using Go's AST, extracts interfaces, methods, and structs, and analyzes field types and associations.**

4. **It generates type-safe query method implementations and strongly typed field helper variables using Go generics and idiomatic GORM patterns.**

5. **You import and use the generated packages in your code, invoking queries through fluent, auto-completed APIs.**

```go
// Example of using generated query API
user, err := generated.Query[User](db).GetByID(ctx, 123)

// Using generated field helpers in queries
users, err := gorm.G[User](db).Where(
    generated.User.Age.Gt(18),
    generated.User.Name.Like("%smith%"),
).Find(ctx)
```

This generates safer, clean database access that scales with your models and queries.

---

## Key Features Highlighted in This Overview

- **Interface-driven SQL template parsing:** Embed SQL with Go's templating to define parameterized, conditional, or iterative queries.
- **Model-driven field helpers:** Generate filter and setter helpers automatically, including support for nullable types and custom mappings.
- **Full association support:** Automatically handle one-to-one, one-to-many, many-to-many, and polymorphic relations with dedicated API helpers for create, update, unlink, and delete.
- **Support for inline filtering and updating:** Build complex queries using generated fluent APIs for both reads and writes.
- **Configurable generation through code:** Use a `genconfig.Config` instance to customize output paths, include or exclude interfaces or structs, and map fields to custom helper types.

---

## Real-World Example of GORM CLI in Action

Imagine you have a `User` model and want a method to get a user by ID safely. Without GORM CLI, you might string together raw SQL or query clauses manually.

With GORM CLI:

```go
// Your interface
// SELECT * FROM @@table WHERE id=@id
GetByID(id int) (User, error)
```

After generation:

```go
user, err := generated.Query[User](db).GetByID(ctx, 123)
```

For field predicates:

```go
users, err := gorm.G[User](db).
    Where(generated.User.Age.Gt(18)).
    Find(ctx)
```

These APIs are strongly typed, with IDE support and compiler checks ensuring correctness.

---

## What’s Next?

To dive deeper, explore these topics:

- [Value Proposition & Target Audience](../value-prop-target-audience): Who benefits most from GORM CLI?
- [Key Features at a Glance](../key-features-at-a-glance): Detailed feature set overview.
- [Quickstart & Typical Workflow](../../integration-use-cases/quickstart-and-workflow-overview): How to start generating and using code immediately.
- [Using the Generated Query APIs and Field Helpers](../../core-workflows/using-generated-apis): Best practices for leveraging generated code.

---

<Tip>
Start by defining simple query interfaces and models in your Go packages. Then generate code with `gorm gen`. This incremental approach ensures quick wins and mastery over time.
</Tip>

<Note>
No configuration is required to get started, but you can customize generation with package-level `genconfig.Config` instances for fine-grained control.
</Note>
