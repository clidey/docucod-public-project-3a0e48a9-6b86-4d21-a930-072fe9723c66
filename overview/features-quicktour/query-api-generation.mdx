---
title: "Generating Type-Safe Query APIs"
description: "Explore how to define Go interfaces with SQL templates and employ GORM CLI to generate concrete, type-safe query methods. See examples of translating developer intent into runtime-safe SQL operations."
---

# Generating Type-Safe Query APIs

## Unlock Compile-Time Safety and Expressive SQL with Go Interfaces and GORM CLI

GORM CLI empowers you to define query intentions declaratively by writing Go interfaces annotated with SQL templates. Using these interfaces, it generates concrete, type-safe query methods that provide a fluent and discoverable API, transforming your developer intent into efficient, runtime-safe SQL operations.

### Why This Matters
Writing raw SQL queries or dynamic query builders often introduces runtime errors and cumbersome code maintenance. By generating type-safe query APIs directly from your Go interfaces, you gain compile-time validation, improved readability, and seamless integration with your existing GORM models. This page guides you through the process of defining these interfaces and generating your type-safe queries quickly and reliably.

---

## What Are Type-Safe Query APIs?
Type-safe query APIs are Go interface methods decorated with SQL templates that precisely describe database operations. GORM CLI translates these into fully typed concrete implementations. Instead of writing raw SQL strings throughout your codebase, you use strongly typed methods whose signatures, parameters, and return types are validated by the compiler.

At their core, you define an interface with methods annotated by SQL comments. The methods represent SQL operations (SELECT, UPDATE, FILTER, etc.) that operate on your model types. The GORM CLI tool reads these interfaces and generates Go code that executes the intended queries safely.

### Core Benefits
- **Compile-Time Safety:** Method parameter types and results align strictly with your models, eliminating common runtime SQL errors.
- **Clear Developer Intent:** SQL templates in comments make each method's purpose explicit while the generator handles plumbing.
- **Seamless GORM Integration:** Generated APIs use GORM's fluent builders behind the scenes, preserving flexibility.
- **Dynamic SQL Support:** Complex conditional query parts and template directives ensure expressive query generation.

---

## Key Features and Capabilities

### 1. Interface-Driven Query Methods
- Write Go interfaces with methods describing intended queries.
- Annotate methods with SQL or DSL templates in comments.

Example Interface:
```go
// Query defines type-safe query methods with SQL templates
type Query[T any] interface {
  // SELECT * FROM @@table WHERE id=@id
  GetByID(id int) (T, error)

  // SELECT * FROM @@table WHERE @@column=@value
  FilterWithColumn(column string, value string) (T, error)

  // Conditional WHERE clauses example
  QueryWith(user models.User) (T, error)

  // UPDATE with conditional SET clause
  UpdateInfo(user models.User, id int) error

  // Filtering multiple users
  Filter(users []models.User) ([]T, error)

  // Simple predicate filter method
  FilterByNameAndAge(name string, age int)

  // Time range filtering
  FilterWithTime(start, end time.Time) ([]T, error)
}
```

### 2. SQL Template DSL Support
Use GORM CLI's rich template DSL to embed dynamic SQL logic inside method comments:
- `@@table`, `@@column` placeholders for table and column names
- `@param` for safely binding Go method parameters as SQL params
- `{{where}}`, `{{set}}` for building conditional WHERE and SET clauses
- `{{if}}`, `{{else}}`, `{{for}}` for control flow inside queries

Example SQL Template:
```sql
SELECT * FROM @@table
{{where}}
  {{if user.ID > 0}}
    WHERE id=@user.ID
  {{else if user.Name != ""}}
    WHERE name=@user.Name
  {{end}}
{{end}}
```

This allows combining static SQL with dynamic conditions to generate efficient, safe SQL queries.

### 3. Automated Context Injection
All generated methods automatically include a `context.Context` parameter if you don't explicitly declare one, ensuring consistent support for context-aware database operations.

### 4. Dual Generation Workflow
- **Query API Generator:** Converts your SQL-annotated interfaces into concrete typed query methods.
- **Field Helper Generator:** Simultaneously, your model structs produce strongly typed field helpers used to build predicates and updates.

Together, these enable fluent, expressive queries with zero runtime SQL string mistakes.

### 5. Fluent API Usage Example
Once generated, use the type-safe query API seamlessly:
```go
// Fetch user by ID
user, err := generated.Query[User](db).GetByID(ctx, 123)

// Filter users by name and age
users, err := generated.Query[User](db).FilterByNameAndAge("jinzhu", 25).Find(ctx)

// Update user info conditionally
err = generated.Query[User](db).UpdateInfo(ctx, User{Name: "jinzhu", Age: 20}, 1)
```

These methods shield you from manual SQL concatenation and parameter mistakes.

---

## Why Should You Care?

Type-safe query APIs radically reduce runtime errors related to querying the database. Gone are the days of string-concatenated queries prone to SQL injection or typos in column names. Instead, you gain:

- **Reliability:** Compile-time checking of query parameters and return results.
- **Productivity:** Write simple interface definitions instead of verbose query builders.
- **Readability:** Clear contract-based query definitions that document themselves.
- **Maintainability:** Centralized query definitions make refactors and audits straightforward.

Consider the difference:

| Without GORM CLI                         | With GORM CLI                                  |
|---------------------------------------|----------------------------------------------|
| Raw SQL string scattered across code  | Single interface method describing intent    |
| Manual parameter binding               | Compiler enforces parameter types and presence|
| Hard to refactor or search             | Interfaces with methods make code discoverable|

ROI flows directly as less debugging and fewer production bugs.

---

## Step-by-Step Guide to Generating Your Query APIs

<Steps>
<Step title="Step 1: Define Your Query Interface with SQL Templates">
Create a Go interface that declares query methods. Add SQL templates in comments to specify how your query should run.

```go
// examples/query.go
package examples

type Query[T any] interface {
  // SELECT * FROM @@table WHERE id=@id
  GetByID(id int) (T, error)

  // Additional queries...
}
```

Keep your model types in the same package or directory.
</Step>

<Step title="Step 2: Run GORM CLI to Generate Code">
Execute the CLI using the interface definition as input.

```bash
gorm gen -i ./examples -o ./generated
```

This generates type-safe method implementations and field helpers automatically.
</Step>

<Step title="Step 3: Use Generated APIs in Your Code">
Import the generated package and use the query methods.

```go
user, err := generated.Query[User](db).GetByID(ctx, 123)
```

The methods provide strongly typed interaction with your database.
</Step>
</Steps>

---

## Practical Tips and Best Practices

- **Keep Interfaces Focused:** Define specific method signatures to represent distinct queries.
- **Use Template DSL for Dynamic Conditions:** Leverage `{{where}}` and `{{if}}` to generate concise, conditionally correct SQL.
- **Co-locate Queries and Models:** Place interfaces and models together to simplify generation.
- **Take Advantage of Context:** Pass `context.Context` for cancellation and deadlines.
- **Write Clear SQL Comments:** The SQL templates double as both query definitions and documentation.

### Common Pitfalls
- Forgetting to include error returns or correct method signatures may cause generation errors.
- Overly complex inline SQL templates can become hard to maintainâ€”extract logic where possible.

---

## Troubleshooting

<AccordionGroup title="Common Issues Generating Query APIs">
<Accordion title="Method Signature Errors">
Ensure your interface methods include correct return types: either `(T, error)` or `(error)` depending on query.
Methods must have at least one return value if they operate on SQL.
</Accordion>
<Accordion title="SQL Template Parsing Failures">
Check your SQL template comments for syntax errors or misplaced directives like `{{if}}` and `{{end}}`.
Use simple queries to narrow down the problem.
</Accordion>
<Accordion title="Output Directory Problems">
Confirm the `-o` flag points to a writable directory. If not specified, the default is `./g`.
</Accordion>
</AccordionGroup>

---

## How This Page Fits Into the Documentation

This page focuses exclusively on generating type-safe query APIs using Go interfaces with SQL templates and the GORM CLI generator. For foundational understanding of GORM CLI you can visit [What is GORM CLI?](/overview/product-intro/what-is-gorm-cli). For practical examples of using the generated code, refer to [Working with Generated APIs in Your Project](/guides/core-workflows/using-generated-apis).

Explore related configuration and advanced usage in [Advanced Code Generation Configuration](/guides/core-workflows/configuring-generation) and [Building Custom Queries with SQL Templates](/guides/advanced-patterns/template-queries).

---

## Summary
This page has introduced how to generate concrete, type-safe query methods in Go by defining SQL-annotated interfaces and using GORM CLI. You learned about the key concepts of interface-driven code generation, the powerful SQL template DSL, practical steps to generate query APIs, and how these APIs provide substantial benefits in safety and developer productivity.

Use this feature to transform your backend Go data access layer into a reliable, expressive, and maintainable codebase with compile-time guarantees.

---

[Back to Feature Quick Tour](../../features-quicktour/query-api-generation)
