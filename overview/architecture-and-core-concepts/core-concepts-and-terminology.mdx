---
title: "Core Concepts & Terminology"
description: "Define and explain essential domain-specific concepts: type-safe query APIs, model-driven field helpers, association helpers, template SQL, field assignment, field mapping, and generation config. Provides the conceptual toolkit needed for all GORM CLI users."
---

# Core Concepts & Terminology

Unlock the full potential of GORM CLI by mastering the essential concepts that power its type-safe query APIs and model-driven field helpers. This page provides a clear understanding of the foundational terms and ideas you’ll use daily when generating and working with your GORM code.

---

## What You Will Learn Here

- What type-safe query APIs are and why they matter
- How model-driven field helpers simplify data operations
- The role of association helpers in managing related data
- How template SQL enables flexible, maintainable queries
- Understanding field assignment and field mapping
- Overview of generation configuration for customization

---

## Type-Safe Query APIs

GORM CLI generates _type-safe query APIs_ from your Go interfaces paired with embedded SQL templates. 

**What this means for you:**

- **Compile-time safety:** Mistakes like mistyped column names or mismatched SQL parameters are caught early, before runtime.
- **Intuitive API:** Instead of writing raw SQL or fragile string queries, you call concrete, typed methods.

For example, defining an interface method with a SQL comment like:

```go
// SELECT * FROM @@table WHERE id=@id
GetByID(id int) (T, error)
```

Automatically generates a method where the parameter `id` maps safely and predictably into your SQL.

---

## Model-Driven Field Helpers

Based on your Go model structs, GORM CLI creates _field helpers_. These helpers are strongly typed objects representing each field and association in your struct.

**Benefits include:**

- Easily build filters, updates, and order clauses with methods like `.Eq`, `.Like`, `.Set`, and `.Incr`.
- Simplify managing nullable types and converting Go types to database-compatible expressions.

### Example usage:

```go
// Filtering users where Age > 18
users, err := gorm.G[User](db).
    Where(generated.User.Age.Gt(18)).
    Find(ctx)

// Creating a user with an update on related pets
gorm.G[User](db).
  Set(
    generated.User.Name.Set("Alice"),
    generated.User.Pets.Create(generated.Pet.Name.Set("Fido")),
  ).
  Create(ctx)
```

---

## Association Helpers

Associations manage relationships between database tables — such as "has one," "belongs to," "has many," and "many to many." GORM CLI generates _association helpers_ that encapsulate common operations on these relations with compile-time safety.

Supported association operations include:

- **Create / CreateInBatch:** Insert new related records and link them automatically.
- **Update:** Modify associated rows optionally filtered by conditions.
- **Unlink:** Remove associations without deleting the related rows (e.g., clearing foreign keys).
- **Delete:** Remove associated records (for many-to-many, removes link rows).

### Real-World Scenario:

You want to create a new user with multiple pets linked at once. Instead of raw SQL, use:

```go
gorm.G[User](db).
  Set(
    generated.User.Name.Set("polyglot"),
    generated.User.Languages.CreateInBatch([]models.Language{{Code: "EN"}, {Code: "FR"}}),
  ).
  Create(ctx)
```

GORM CLI handles linking and type compatibility seamlessly.

---

## Template SQL

Template SQL is a powerful domain-specific language embedded in interface method comments. It enables you to:

- Use placeholders like `@@table` and `@@column` to represent the model’s table name or columns dynamically.
- Bind Go function parameters to SQL parameters with `@param` syntax safely.
- Write conditional blocks (`{{if}}`), iterations (`{{for}}`), and dynamic `WHERE` and `SET` clauses (`{{where}}`, `{{set}}`).

This approach gives you the flexibility of raw SQL with the safety and maintainability of generated code.

### Example snippet:

```sql
SELECT * FROM @@table
{{where}}
  {{if user.Name != ""}} name=@user.Name {{end}}
  {{if user.Age > 0}} AND age=@user.Age {{end}}
{{end}}
```

This template generates `WHERE` clauses only when provided conditions are met.

---

## Field Assignment and Field Mapping

Field assignment refers to how you define what values go into your update or create operations using field helpers.

- `.Set(value)` assigns a direct value.
- `.SetExpr(expression)` allows for expressions or computed values.

Field mapping is the process of configuring how Go types or struct tag conventions map to field helper types, enabling custom treatment of fields.

Example: Mapping a string field tagged `gen:"json"` to use a JSON helper that generates database-specific JSON query expressions.

```go
var _ = genconfig.Config{
  FieldNameMap: map[string]any{
    "json": JSON{},
  },
}
```

This configuration enriches generated code to understand complex data types.

---

## Generation Configuration

GORM CLI supports flexible configuration through the `genconfig.Config` struct declared at the package level. Key configurable aspects include:

- **Output directory:** Where generated code files are placed.
- **Include/Exclude patterns:** Select which interfaces or structs to generate.
- **Field type and name mapping:** Customize how fields translate to helpers.
- **File-level vs package-level control:** Limit generation scope.

This lets you tailor generation to your project’s conventions and complexity without manual edits.

### Practical tip:

Place a config file in your package with desired settings to automatically influence generation on `gorm gen` runs.

---

## How This Page Fits In

This overview provides your essential toolkit for working effectively with GORM CLI. Building on this conceptual foundation, you should proceed to hands-on guides such as:

- [Using Type-Safe Query APIs](/guides/getting-started-workflows/using-type-safe-queries)
- [Field Helpers for Filters and Updates](/guides/getting-started-workflows/field-helper-basics)
- [Working with Associations](/guides/advanced-usage-patterns/working-with-associations)

These will deepen your mastery through practical examples and workflows.

---

## Visual Summary

```mermaid
graph TD
  A[Go Interfaces with SQL Templates] -->|Code Generation| B[Type-Safe Query APIs]
  C[Go Model Structs] -->|Code Generation| D[Model-Driven Field Helpers]
  D --> E[Association Helpers]
  B & E --> F[Type-Safe Data Access Layer for GORM]
  G[Generation Config] -.-> B
  G -.-> D
  G -.-> E
  subgraph Template SQL DSL
    I[Placeholders @@table, @@column]
    J[Parameter Bindings @param]
    K[Conditional Clauses {{if}}, {{where}}, {{set}}]
    L[Iteration {{for}}]
  end
  B --> |Uses| Template SQL DSL
```

---

## Troubleshooting and Tips

<AccordionGroup title="Common Questions & Pitfalls">
<Accordion title="What if my SQL templates are invalid or missing placeholders?">
Ensure you always use `@@table` for table name substitution and prefix parameters with `@` to enable safe binding. Missing these will cause generation errors or runtime failures.
</Accordion>
<Accordion title="How can I extend or customize field helpers for special types?">
Use `FieldNameMap` and `FieldTypeMap` in `genconfig.Config` to map custom types or tags to your own field helpers or custom logic.
</Accordion>
<Accordion title="Why do I sometimes get nil pointer errors on associations?">
Make sure associated slices or pointers in your structs are properly initialized and used according to GORM association semantics. Use association helpers to manage links safely.
</Accordion>
</AccordionGroup>

---

By mastering these core concepts and terminology, you gain the clarity and confidence to harness GORM CLI’s power for safer, faster, and more maintainable database interactions in Go projects.

