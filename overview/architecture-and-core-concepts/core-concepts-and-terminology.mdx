---
title: "Core Concepts & Terminology"
description: "Define and demystify the product's key concepts: type-safe query APIs, field helpers, associations, template-based queries, code generation config, and GORM integration. Glossary entries explain terms like 'field helpers', 'association operations', 'model-driven', and 'template DSL', connecting them directly to their role in developer workflow."
---

# Core Concepts & Terminology

## Understanding GORM CLI's Key Components

This page uncovers the foundational building blocks that power GORM CLI. By demystifying core concepts such as type-safe query APIs, field helpers, associations, template-based queries, code generation configuration, and integration with GORM, youâ€™ll gain clarity on how these pieces work together to enhance your development workflow.

Through concise definitions and contextual explanations, you will learn not just what these terms mean, but why they matter to you as a developer aiming for safer, more efficient database interactions.

---

## 1. Type-Safe Query APIs

### What Are They?
Type-safe query APIs are generated Go interfaces with method signatures derived from your SQL templates. These APIs allow you to write database queries that are verified at compile time, reducing runtime errors related to mismatched query parameters or incorrect result types.

### Why You Should Care
By using these type-safe APIs:
- You gain immediate feedback during development when SQL parameters or return types don't align.
- Code becomes easier to read and maintain due to clearly defined method contracts.
- You avoid subtle bugs caused by raw SQL strings or unchecked parameters.

### In Practice
Define your queries as interfaces with SQL in comments, then generate concrete, type-safe implementations automatically:

```go
// Query interface example
type Query[T any] interface {
  // SELECT * FROM @@table WHERE id=@id
  GetByID(id int) (T, error)
}
```

After generation, use these APIs to fetch typed results:

```go
user, err := generated.Query[User](db).GetByID(ctx, 123)
```

---

## 2. Model-Driven Field Helpers

### What Are Field Helpers?
Field helpers are strongly typed variables generated from your model structs. They encapsulate database column semantics for common operations like filtering, ordering, updates, and associations in a fluent, discoverable API.

### The Value They Bring
These helpers:
- Eliminate the guesswork of column names and SQL syntax.
- Provide intuitive method calls, e.g. `generated.User.Name.Like("%foo%")`.
- Support complex predicates and update expressions with type safety.

### Example
For a `User` model, you might have:

```go
generated.User.Age.Between(18, 65)        // age BETWEEN 18 AND 65
generated.User.Name.Set("alice")         // SET name = 'alice'
```

This makes creating queries and updates both concise and error-resistant.

---

## 3. Associations and Their Operations

### What Are Associations?
Associations represent relationships between your models, such as `has one`, `has many`, `belongs to`, and `many2many`. GORM CLI generates helpers to manage these associations with compile-time safety.

### Supported Operations
You can perform the following with association helpers:
- **Create**: Insert and link related records
- **CreateInBatch**: Batch insert and link multiple related records
- **Update**: Modify associated rows conditionally
- **Unlink**: Dissociate relationships without deleting data
- **Delete**: Remove associated records or join rows

### Practical Use
```go
gorm.G[User](db).
  Set(
    generated.User.Name.Set("alice"),
    generated.User.Pets.Create(generated.Pet.Name.Set("fido")),
  ).
  Create(ctx)
```

This creates a new user and associates a pet in one fluent call.

### Relationship Semantics
- **BelongsTo**: Unlink clears the parent foreign key; delete removes associated rows.
- **HasOne/HasMany**: Unlink clears child foreign keys; delete removes child rows.
- **Many2Many**: Unlink/Delete affect only join table rows.

---

## 4. Template-Based Queries (SQL Template DSL)

### What Is Template DSL?
Instead of hardcoding SQL, you write SQL with embedded Go templating instructions inside your interface methods. This generates flexible, conditional SQL adapted at runtime.

### Why Use It?
- Allows dynamic construction of WHERE clauses, SET assignments, and iteration over collections.
- Supports context-based SQL changes using simple `{{if}}`, `{{for}}`, and directives like `{{where}}`.
- Binds Go method parameters directly to SQL safely, preventing injection.

### Example
```go
// UPDATE @@table
// {{set}}
//   {{if user.Name != ""}} name=@user.Name, {{end}}
//   {{if user.Age > 0}} age=@user.Age, {{end}}
//   {{if user.Age >= 18}} is_adult=1 {{else}} is_adult=0 {{end}}
// {{end}}
// WHERE id=@id
UpdateUser(user User, id int) error
```

After generation, this compiles into a method you can call with a `User` struct to perform dynamic updates safely.

### Key Directives
| Directive  | Purpose                               | Example                                |
|------------|-------------------------------------|----------------------------------------|
| `@@table`  | Resolves to the model's table name  | `SELECT * FROM @@table WHERE id=@id`   |
| `@@column` | Dynamic column binding               | `WHERE @@column=@value`                |
| `@param`   | Binds Go parameters to SQL params   | `WHERE name=@user.Name`                |
| `{{where}}`| Conditional WHERE clause definitions | `{{where}} age>18 {{end}}`             |
| `{{set}}`  | Conditional UPDATE SET clause        | `{{set}} name=@name {{end}}`           |
| `{{if}}`   | Conditional SQL fragments            | `{{if age>0}} AND age=@age {{end}}`    |
| `{{for}}`  | Iterate over collection params       | `{{for _, tag := range tags}} ... {{end}}` |

---

## 5. Generation Configuration (`genconfig.Config`)

### Purpose
`genconfig.Config` facilitates customizing the behavior of code generation on a per-package or per-file basis.

### What You Can Customize
- **Output path**: Control where generated files are placed.
- **Type mapping**: Map Go types or struct tags (e.g., `gen:"json"`) to custom field helper wrappers.
- **Include/Exclude filters**: Whitelist or blacklist specific interfaces or structs by patterns or type literals.
- **File-level or package-level application**: Apply configuration globally or to individual files.

### Example Configuration
```go
var _ = genconfig.Config{
  OutPath: "examples/output",
  FieldNameMap: map[string]any{
    "json": JSON{},
  },
  IncludeInterfaces: []any{"Query*"},
}
```
This config generates only interfaces with names starting with "Query" and maps fields tagged `gen:"json"` to a JSON field helper.

---

## 6. GORM Integration

### Seamless Compatibility
Generated code integrates tightly with the official GORM library:
- Uses `*gorm.DB` and `context.Context` to execute queries.
- Works directly with your existing GORM models.
- Enables fluent chaining and expression building via `gorm.G[T](db)` interfaces.

### How It Fits Into Your Workflow
- Define your models as usual with GORM.
- Write query interfaces with SQL templates.
- Configure any custom mapping if needed.
- Run the generator to produce type-safe APIs and field helpers.
- Use the generated code in your services or repositories, gaining the benefits of compile-time checking and discoverable code.

---

## Glossary

| Term                | Definition & Role                                                |
|---------------------|----------------------------------------------------------------|
| **Field Helpers**    | Generated typed variables representing model fields for filters, updates, and association operations. They simplify writing fluent, type-safe queries.
| **Association Operations** | CRUD operations on related models with compile-time validation, such as Create, Update, Unlink, and Delete.
| **Model-Driven**     | An approach where code generation derives from your existing Go model structs to create helper APIs tailored to your schema.
| **Template DSL**     | A domain-specific language embedded in interface method comments for dynamic SQL query construction with Go-like templating syntax.
| **Code Generation Config** | Package- or file-level settings controlling aspects like output paths, type mappings, and interface/struct filters.
| **Type-Safe Query API** | Generated interface-driven database APIs based on parameterized SQL templates with compile-time validation.

---

## Practical Tips & Best Practices

- **Start simple:** Define straightforward query interfaces first before introducing complex conditional templates.
- **Use model-driven field helpers** to build queries rather than raw strings; it boosts readability and safety.
- **Leverage configuration** to map special types or customize code generation to your project's needs.
- **Manage associations carefully:** understand the semantics of unlinking vs. deleting to avoid unintended data loss.
- **Write clear templates:** Comment your SQL queries well, and test generated methods with the GORM DB context.

---

## Troubleshooting

### Common Issues
- **Missing generated code:** Check that your interfaces and structs meet include/exclude filter criteria in `genconfig.Config`.
- **Incorrect SQL generation:** Review template syntax carefully; ensure directives like `{{where}}` and `{{set}}` are balanced correctly.
- **Type mismatches:** Confirm method signatures match expected parameters and results, and SQL placeholders align with interface parameters.

### How to Verify
- Run the generator with verbose output.
- Inspect generated files for expected method signatures and field helpers.
- Write small test cases invoking generated methods, checking database response correctness.

---

Explore related pages for deeper understanding:
- [System Architecture](/overview/architecture-and-core-concepts/system-architecture)
- [Quick Feature Overview](/overview/architecture-and-core-concepts/feature-overview)
- Getting Started guides to see how concepts come alive in your workflow.


---