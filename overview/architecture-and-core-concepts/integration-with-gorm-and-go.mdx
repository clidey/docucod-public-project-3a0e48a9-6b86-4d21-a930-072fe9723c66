---
title: "Integration with GORM and Go Projects"
description: "Describe how the generated code fits seamlessly into existing Go projects using GORM. Highlight compatibility, requirements (Go 1.18+), and the minimal adoption barrier: just define models/interfaces and run generation for immediate API enhancements."
---

# Integration with GORM and Go Projects

Seamlessly integrate the powerful code generated by GORM CLI into your existing Go projects using GORM. This page guides you through the simple requirements, compatibility considerations, and adoption workflow, helping you unlock type-safe, fluent APIs for your database operations with minimal disruption.

---

## Why Integration Matters

Adopting GORM CLI-generated code enhances your Go projects by providing type-safe query APIs and model-driven field helpers that complement GORM's ORM capabilities. This integration enables safer, more maintainable, and discoverable database code, empowering you to write idiomatic Go with compiler-backed guarantees and reducing runtime errors.

Integration is designed to be non-intrusive and work with the tools and models you already have. You don't need to rewrite existing models or interfaces. Just add SQL annotations and generate code to expand your API surface effortlessly.

---

## Who Should Care

This page is for Go developers and teams already using [GORM](https://gorm.io/) who want to maximize productivity and correctness when working with databases. If you aim to enforce compile-time safety, implement expressive queries safely, or generate consistent helper methods for filters, updates, and associations, this integration guide is your starting point.

---

## Core Requirements

- **Go Version:** Requires **Go 1.18 or newer** for generics support, which powers the type-safe API generation.
- **GORM Version:** Compatible with GORM as your underlying ORM layer, leveraging its `*gorm.DB` objects and features.
- **Code Generation:** You define interfaces with SQL templates and annotate your models (if needed), then run the CLI tool to generate code that seamlessly plugs into your project.

There are no invasive changes—your existing GORM `*gorm.DB` handles actual database operations, while generated code offers a rich, type-safe wrapper.

---

## Integration Workflow: From Models and Interfaces to Typed APIs

1. **Define Your Models**

   Use your existing GORM model structs. You can optionally annotate fields with custom tags to control code generation for field helpers, such as JSON fields.

   ```go
   type User struct {
       gorm.Model
       Name    string
       Age     int
       Profile string `gen:"json"` // Custom JSON helper for special handling
   }
   ```

2. **Write Query Interfaces with SQL Templates**

   Define Go interfaces where you annotate methods with SQL templates in comments, expressing your query intent clearly.

   ```go
   type Query[T any] interface {
       // SELECT * FROM @@table WHERE id=@id
       GetByID(id int) (T, error)

       // SELECT * FROM @@table WHERE @@column=@value
       FilterWithColumn(column string, value string) (T, error)
   }
   ```

3. **Configure Generation (Optional)**

   Declare a `genconfig.Config` variable in your package to customize output paths, type mappings, and inclusions/exclusions.

   ```go
   var _ = genconfig.Config{
       OutPath: "examples/output",
       FieldTypeMap: map[any]any{
           sql.NullTime{}: field.Time{},
       },
       FieldNameMap: map[string]any{
           "json": JSON{},
       },
   }
   ```

4. **Run the Code Generator**

   Use the CLI tool to generate your APIs:

   ```bash
   gorm gen -i ./path/to/interfaces -o ./generated
   ```

5. **Use the Generated APIs in Your Go Project**

   Import the generated code and leverage the fluent, type-safe APIs with your existing `*gorm.DB` objects.

   ```go
   user, err := generated.Query[User](db).GetByID(ctx, 123)

   users, err := gorm.G[User](db).Where(generated.User.Age.Gt(18)).Find(ctx)
   ```

---

## Key Benefits of Integration

- **Zero Runtime Overhead:** Generated code builds on GORM’s native `*gorm.DB` functionality without extra runtime abstraction layers.

- **Type Safety Across Queries:** Avoid common mistakes like typos in column names or SQL syntax errors by relying on compile-time safety.

- **Enhanced Developer Experience:** Fluent code completion and discoverability accelerate development and reduce onboarding time.

- **Model and Query Sync:** Keep your interfaces and models close to your business logic; generate helpers that consistently reflect your DB schema and queries.

- **Seamless Association Support:** Model-driven generated code includes helpers for linked associations (has one, has many, many-to-many) enabling safe manipulations.

---

## Real-World Example

Imagine you need to update users aged over 18 to mark them as adults and increment their score. With the generated code, you do:

```go
err := gorm.G[User](db).
    Where(generated.User.Age.Gt(18)).
    Set(
        generated.User.IsAdult.Set(true),
        generated.User.Score.Incr(10),
    ).
    Update(ctx)
```

This code is straightforward, type-safe, and integrates naturally with your existing `*gorm.DB`.

---

## Practical Tips and Best Practices

- Make sure your models conform to GORM’s conventions for associations if you want association helpers generated.
- Use the optional `genconfig.Config` to customize generation behavior to fit your project structure.
- Define well-structured query interfaces with clear SQL templates for maximum benefit.
- Regularly regenerate code after changing interfaces or models to keep APIs in sync.

---

## Troubleshooting Common Issues

<AccordionGroup title="Integration Troubleshooting">
<Accordion title="Go Version or Module Issues">
Ensure you are running Go 1.18 or later. Modules should be tidy and dependencies up to date.
</Accordion>
<Accordion title="Generated Code Not Found or Cannot Import">
Check your `OutPath` setting in `genconfig.Config`, ensure the generated package is imported correctly, and your IDE's module cache is refreshed.
</Accordion>
<Accordion title="Queries Not Compiling After Model Changes">
After a model or interface update, rerun the generator to update the types and APIs, ensuring consistency.
</Accordion>
<Accordion title="Unexpected SQL Behavior">
Review the SQL templates and ensure placeholders match the method parameters and model fields properly.
</Accordion>
</AccordionGroup>

---

## Next Steps

- Visit the [Getting Started Essentials](../getting-started/essentials/prerequisites) page to ensure your environment setup.
- Learn how to write and use [Template-Based SQL Queries](../guides/advanced-usage-patterns/template-sql-queries) for richer query generation.
- Dive into [Working with Associations](../guides/advanced-usage-patterns/working-with-associations) to fully leverage the generated helpers for related data.
- Explore [Basic Generation Config](../getting-started/optional-configuration/basic-configuration) to customize output to your project.

By following this integration approach, you’ll quickly elevate your GORM-based Go projects with powerful, safe, and developer-friendly APIs.
