---
title: "Integration & Extensibility"
description: "Highlight how GORM CLI fits seamlessly alongside GORM in Go projects. Outline extensibility via custom field helpers and generation config, and describe how the tool adapts to different project structures and database drivers. Touch on integration patterns and relevant dependencies."
---

# Integration & Extensibility

GORM CLI elevates your Go projects by fitting seamlessly alongside the GORM ORM, offering powerful extensibility, flexible configuration, and smooth adaptation across diverse project structures and database drivers. This page details how GORM CLI integrates into your existing workflow, how to extend it with custom field helpers and generation configurations, and best practices for managing multiple environments and dependencies.

---

## Why GORM CLI Fits Naturally in Your GORM Projects

Imagine having a tool that enhances your GORM models with fully type-safe query APIs and model-driven helpers, without disrupting your existing project layout or development flow. GORM CLI does exactly this â€” it enhances your productivity and code safety while respecting your established project and database constraints.

By generating fluent, compile-time checked interfaces and field helpers, GORM CLI reduces runtime errors, improves developer discoverability through autocompletion, and integrates effortlessly across database drivers.

### What This Means for You

- **Seamless Integration:** GORM CLI is implemented as a command-line tool (`gorm gen`), embedded within the same Go ecosystem as GORM itself, making it straightforward to add code generation to your development and build processes.
- **Flexible Project Compatibility:** Whether your project follows a monorepo style, multiple module structures, or has complex directory layouts, GORM CLI adjusts code generation outputs correctly using per-package or per-file configuration.
- **Database Driver Agnostic:** It respects the nuances of different database dialects by generating drivers-aware SQL templated queries and field helpers, keeping your code portable.


## Extending GORM CLI with Custom Field Helpers and Generation Config

Extensibility is a cornerstone of GORM CLI. From adding bespoke field helper types to tuning the generation process, you control how your model layer evolves.

### Custom Field Helpers

GORM CLI lets you wrap Go types with custom field helpers, which generate SQL with database-specific adaptations. This is especially powerful for specialized data types like JSON, timestamps, or other serialized data.

#### Example: Adding a JSON Field Helper

1. **Declare a custom helper type implementing field behavior:**

```go
// JSON is a custom field helper for JSON columns
// It generates database-specific SQL expressions seamlessly
// Example included in GORM CLI's README for reference
```

2. **Map fields using struct tags or configuration:**

```go
package examples

var _ = genconfig.Config{
    FieldNameMap: map[string]any{
        "json": JSON{}, // applies to fields tagged with `gen:"json"`
    },
}

// Model example
package models

type User struct {
    Profile string `gen:"json"` // will use the JSON field helper
}
```

Using this approach ensures your generated APIs generate the correct SQL expression for various databases automatically.

### Generation Configuration

Control code generation behavior across your project by declaring a package-level `genconfig.Config` variable. This powerful configuration enables:

- **Output customization:** Redirect generated files to specific directories (`OutPath`).
- **Selective generation:** Include or exclude particular interfaces or structs via patterns.
- **Field mapping:** Map Go types and field `gen` tags to appropriate field helper types.
- **File-level targeting:** Enable generation on individual files instead of whole packages.

#### Configuration Example

```go
package examples

var _ = genconfig.Config{
    OutPath: "examples/output",
    FieldTypeMap: map[any]any{
        sql.NullTime{}: field.Time{},
    },
    FieldNameMap: map[string]any{
        "date": field.Time{},
        "json": JSON{},
    },
    IncludeInterfaces: []any{"Query*"},
}
```

Place such a variable in your source files, and the generator will pick it up automatically to tailor output.

---

## Adapting GORM CLI for Different Project Structures and Database Drivers

GORM CLI anticipates varied project layouts and database dialects, facilitating smooth integration.

### Supporting Multiple Project Structures

- **Multi-module and multi-package projects:** The generator respects package boundaries, generating output files that mirror your input file structure and applying configurations per package or even per file.
- **Whitelisting and blacklisting:** Using `Include*` and `Exclude*` settings, you can target generation precisely where it's needed, avoiding overhead or conflicts.

### Database Driver Adaptation

- The generated SQL templates understand your current GORM dialect and produce dialect-appropriate SQL expressions.
- Custom field helpers can generate dialect-specific expressions, as seen in the JSON example.
- This ensures your application remains portable and maintainable across MySQL, PostgreSQL, SQLite, and others.

---

## Integration Patterns and Relevant Dependencies

### CLI Workflow Integration

GORM CLI is built around the `gen` command, invoked as:

```bash
gorm gen -i <input_path> -o <output_path>
```

- **Input:** The path to Go files containing interfaces with embedded SQL templates and your model structs.
- **Output:** Generated Go files with type-safe query APIs and field helpers.

This plug-and-play approach fits easily into CI pipelines, pre-commit hooks, or manual workflows.

### Internal Architecture at a Glance

```mermaid
flowchart TD
  InputFiles["Go Interface & Model Files"] --> Parser("AST Parser & Config Loader")
  Parser --> Config["Aggregate genconfig.Config"]
  Config --> Generator["Code Generator"]
  Generator --> Output["Generated Go Files"]
  Output --> Integration["GORM Project Usage"]

  subgraph CLI Command
    GORMCLI["gorm gen"] --> Parser
    GORMCLI --> Generator
  end

  note right of Parser
    Parses interfaces
    and structs,
    applies config
  end
  note right of Generator
    Renders templates
    with SQL DSL and
    field helpers
  end

```

### Key Dependencies

- `gorm.io/gorm`: Core ORM package providing DB handling.
- `github.com/spf13/cobra`: CLI framework that powers `gorm gen` commands.
- `gorm.io/cli/gorm/genconfig`: Handles user-defined generation configurations.
- `gorm.io/cli/gorm/field`: Contains wrappers for field helpers managing SQL generation.

These dependencies ensure the CLI remains tightly integrated with GORM internals while being extensible and user-friendly.

---

## Practical Tips & Best Practices

- **Start simple:** Begin generation with default settings before introducing custom field helpers.
- **Use per-package configs:** Organize your generation config files close to corresponding model packages.
- **Leverage whitelists:** Narrow generation scope by including only relevant interfaces and structs to speed up generation.
- **Test generated code:** Always review generated code in your dev workflow to catch edge cases early.
- **Integrate generator runs:** Automate code generation as part of your build or pre-commit pipeline to keep APIs up to date.

---

## Troubleshooting Common Issues

<AccordionGroup title="Common Problems & Fixes">
<Accordion title="Generation Skips Interfaces or Structs">
Make sure your `genconfig.Config` includes appropriate include patterns and excludes unwanted items explicitly. Missing or incorrect patterns cause empty output.
</Accordion>
<Accordion title="Custom Field Helpers Not Applied">
Verify the `FieldNameMap` or `FieldTypeMap` configurations are correctly declared and imported. Also confirm your struct tags match the configured keys.
</Accordion>
<Accordion title="Output Directory Not Found or Empty">
Check `OutPath` in your config and command-line arguments. Ensure write permissions exist for the target directory.
</Accordion>
<Accordion title="SQL Template Parsing Errors">
Review the SQL template DSL syntax carefully. Use provided examples as patterns. Errors often come from mismatched placeholders or incorrect directives.
</Accordion>
</AccordionGroup>

---

## Next Steps

- Visit the [Quick Feature Overview](./feature-overview) to deepen understanding of core capabilities.
- Explore [Customizing Generation with genconfig.Config](../guides/core-workflows/customizing-generation) for advanced setup.
- Check [Generating Your First API and Field Helpers](../../guides/getting-started/first-code-generation) for hands-on tutorials.
- Consult [Integrating Generated Code into Your GORM Project](../guides/advanced-use-cases/integrating-with-gorm-projects) for best integration practices.

---

By understanding and leveraging GORM CLI's extensibility and seamless integration with GORM, you unlock a powerful workflow for safer, faster, and more maintainable database code in Go.


---

<Source url="https://github.com/go-gorm/cli" branch="main" paths={[{"path": "README.md", "range": "1-200"},{"path": "internal/gen/gen.go", "range": "1-70"},{"path": "internal/gen/generator.go", "range": "1-250"},{"path": "genconfig/config.go", "range": "1-70"},{"path": "examples/query.go", "range": "1-130"}]}/>