---
title: "Quick Feature Overview"
description: "Summarize at a glance the product’s core features and their benefits. Cover query API generation, field helper creation, association handling, template-based queries, configuration, and out-of-the-box integration with GORM. Use bullet points or a compact table to show the spectrum of capabilities."
---

# Quick Feature Overview

Discover GORM CLI's core capabilities through this concise overview designed to highlight the essential features that empower Go developers to build robust, type-safe, and maintainable database layers with GORM.

---

## Unlocking Fluent, Type-Safe Database Interactions

GORM CLI generates two synergistic code layers for your GORM projects that radically reshape how you craft database queries and manage models:

- **Type-Safe Query APIs** built from your Go interface definitions paired with SQL templates.
- **Model-Driven Field Helpers** automatically created from your model structs, enhancing filters, updates, and association operations.

These components work together to grant you compile-time safety and a fluent, discoverable API that makes your database operations safe, expressive, and efficient.

---

## Core Features at a Glance

| Feature                       | Description & User Benefit                                                                            |
|------------------------------|-----------------------------------------------------------------------------------------------------|
| **Query API Generation**      | Write Go interfaces with embedded SQL templates to auto-generate type-safe, compile-checked query methods. This eliminates runtime SQL errors and accelerates query prototyping.

| **Field Helper Creation**     | Generate strongly-typed field helpers from your model structs for filtering, ordering, and updates. This ensures concise, readable, and error-proof conditions and assignments.

| **Association Handling**      | Seamlessly create, update, unlink, or delete related entities with fully type-checked API methods, matching GORM’s relation semantics.

| **Template-Based Queries**    | Use powerful templating directives (e.g., `{{where}}`, `{{set}}`, conditional blocks) in SQL comments to craft expressive, conditional, and reusable queries.

| **Flexible Generation Configuration** | Customize output paths, include/exclude filters, file-level overrides, and field-type mappings using `genconfig.Config` for precise control of your generated code.

| **Out-of-the-Box GORM Integration** | Generated code integrates directly with the `gorm.io/gorm` package, allowing you to leverage GORM’s features alongside your type-safe structures effortlessly.

---

## Feature Highlights with Practical Examples

### 1. Type-Safe Query APIs from Interfaces

Define your queries in simple interfaces using embedded SQL templates:

```go
// Query interface embedding SQL in comments
type Query[T any] interface {
  // SELECT * FROM @@table WHERE id=@id
  GetByID(id int) (T, error)

  // SELECT * FROM @@table WHERE @@column=@value
  FilterWithColumn(column string, value string) (T, error)

  // UPDATE @@table
  // {{set}}
  //   {{if user.Name != ""}} name=@user.Name, {{end}}
  // {{end}}
  // WHERE id=@id
  UpdateInfo(user User, id int) error
}
```

The generator produces concrete, type-safe implementations that bind parameters and validate correctness at compile time, eliminating common SQL injection and runtime error risks.

### 2. Model-Driven Field Helpers

From your existing Go struct models like:

```go
type User struct {
  ID   uint
  Name string
  Age  int
}
```

GORM CLI generates field helpers for filtering and updating, e.g.,

```go
// Filtering examples
generated.User.ID.Eq(1)          // id = 1
generated.User.Name.Like("%jinzhu%") // name LIKE '%jinzhu%'
generated.User.Age.Between(18, 65) // age BETWEEN 18 AND 65

// Updating examples with zero values and expressions
gorm.G[User](db).
  Where(generated.User.Name.Eq("alice")).
  Set(
    generated.User.Age.Incr(1),
    generated.User.Name.Set("jinzhu"),
  ).
  Update(ctx)
```

This strongly typed approach greatly reduces bugs and increases expressiveness.

### 3. Comprehensive Association Management

Supports all major associations — `belongs to`, `has one`, `has many`, `many2many` — with compile-time checked methods for:

- Creating and linking associated entities
- Batch creation
- Updating with filters
- Unlinking (clearing foreign keys or join tables)
- Deleting associated rows

Example:

```go
// Create a user with a pet
gorm.G[User](db).
  Set(
    generated.User.Name.Set("alice"),
    generated.User.Pets.Create(generated.Pet.Name.Set("fido")),
  ).
  Create(ctx)

// Update pet named 'fido'
gorm.G[User](db).
  Where(generated.User.ID.Eq(1)).
  Set(generated.User.Pets.Where(generated.Pet.Name.Eq("fido")).
    Update(generated.Pet.Name.Set("rex")),
  ).
  Update(ctx)
```

This alignment with GORM enables smooth relational data workflows with added type safety.

### 4. Template-Driven SQL Query DSL

The generator supports a SQL template DSL within Go interface comments, with directives like:

| Directive  | Purpose                             | Example                          |
|------------|-----------------------------------|---------------------------------|
| `@@table`  | Resolves to model's table name    | `SELECT * FROM @@table WHERE id=@id` |
| `@@column` | Dynamic column binding             | `@@column=@value`                |
| `@param`   | Maps Go parameters to SQL params  | `WHERE name=@user.Name`          |
| `{{where}}`| Conditional WHERE clause           | `{{where}} age > 18 {{end}}`    |
| `{{set}}`  | Conditional SET clause for UPDATE | `{{set}} name=@name {{end}}`    |
| `{{if}}`   | Conditional SQL fragment           | `{{if age > 0}} AND age=@age {{end}}` |
| `{{for}}`  | Iterate over collections           | `{{for _, t := range tags}} ... {{end}}` |

This flexible templating empowers complex, reusable SQL with type-safe parameter binding.

---

## Why These Features Matter

- **Eliminate runtime SQL errors**: Your queries compile cleanly with guaranteed type compatibility.
- **Accelerate development**: Prototype, define, and generate complex database operations with minimal manual coding.
- **Improve maintainability**: Refactor models and queries safely with strong compile-time checks.
- **Leverage GORM**: Native integration means no compromises in using your favorite ORM’s features alongside generated code.

---

## Getting Started Preview

Kick off your journey by:

1. Defining your query interfaces alongside models.
2. Running the GORM CLI generator (`gorm gen -i ./path -o ./generated`).
3. Using the generated APIs for type-safe query and update operations in your Go projects.

Explore configuration options with `genconfig.Config` for customized generation. Dive deeper into related guides for detailed workflows on type-safe queries, association management, and more.

---

For a comprehensive understanding, visit related pages:
- [What is GORM CLI?](../introduction-and-core-value/what-is-gorm-cli)
- [Target Audience & Use Cases](../introduction-and-core-value/target-audience-and-use-cases)
- [System Architecture](../architecture-and-core-concepts/system-architecture)
- [Core Concepts & Terminology](../architecture-and-core-concepts/core-concepts-and-terminology)


---

Unlock type-safe, fluent, and robust database operations quickly with GORM CLI’s rich feature set—your gateway to safer and faster GORM development.
