---
title: "Feature Overview"
description: "Review the full set of GORM CLI's core features: interface-driven query generation, model-driven field helpers, association support, SQL template DSL usage, and code generation configuration."
---

# Feature Overview

Discover the core features that make GORM CLI an indispensable tool for generating type-safe, model-driven query APIs tailored for GORM-based Go applications. This page reviews the key capabilities you will leverage to write expressive SQL-in-Go interfaces, generate precise field helpers, manage associations seamlessly, utilize an intuitive SQL templating DSL, and configure your generation process.

---

## Interface-Driven Query Generation

At the heart of GORM CLI is the ability to auto-generate type-safe query APIs from simple Go interfaces decorated with SQL template comments. This feature enables you to write declarative method signatures with embedded SQL snippets or templates, which the CLI then converts into efficient, strongly-typed Go methods ready for use with GORM.

- **Write once, use safely everywhere**: Your interface methods become concrete implementations that map directly to SQL queries and commands.
- **Auto context injection**: Context parameters are injected if not explicitly declared, keeping signature ergonomic.
- **Flexible return types**: Support for single, multiple, and error return values, ensuring idiomatic Go patterns.

Example:

```go
// Query interface with raw SQL comments
type Query[T any] interface {
  // SELECT * FROM @@table WHERE id=@id
  GetByID(id int) (T, error)

  // Dynamic filter
  FilterByNameAndAge(name string, age int)
}
```

The generated code lets you use `Query[User](db).GetByID(ctx, 1)` safely, avoiding manual SQL strings and runtime errors.

---

## Model-Driven Field Helpers

GORM CLI generates strongly-typed field helpers directly from your model structs. These helpers offer fluent predicates and update expressions tailored to your data types—strings, numbers, booleans, time values, JSON, and more.

- **Type safety**: Use field-level helpers like `generated.User.Name.Eq("alice")` and `generated.User.Age.Between(18, 65)` with exact Go type checks.
- **Support for custom mappings**: Configure your own field types via `genconfig.Config` allowing domain-specific enhancements (e.g., for JSON or custom scalars).
- **Automatic handling of associations**: Model relations such as has-many, belongs-to, and many-to-many generate specialized helpers for nested operations.

Example predicates and uses:

```go
generated.User.Name.Like("%jinzhu%") // WHERE name LIKE '%jinzhu%'
generated.User.IsAdult.Set(true)      // UPDATE is_adult = true
```

---

## Comprehensive Association Support

Your models' relations become first-class citizens with fully supported association helpers. GORM CLI generates methods to manage related data with compile-time safety.

Supported operations include:

- **Create & CreateInBatch**: Easily create and link associated records in a single fluent call.
- **Update**: Perform scoped updates on related entities using filters.
- **Unlink**: Remove associations without deleting related records (null FK or detach join records).
- **Delete**: Delete related entities or join rows in many-to-many setups.

Example:

```go
gorm.G[User](db).
  Set(
    generated.User.Name.Set("alice"),
    generated.User.Pets.Create(generated.Pet.Name.Set("fido")),
  ).
  Create(ctx)

// Unlink a pet from a user without deleting
orm.G[User](db).
  Set(generated.User.Pets.Unlink()).
  Update(ctx)
```

Association semantics respect GORM conventions, ensuring your domain logic behaves correctly.

---

## SQL Template DSL Usage

Write expressive, templated SQL directly in your interface comments, tapping into GORM CLI’s built-in templating directives to handle dynamic queries easily.

- **Directives and placeholders**:
  - `@@table` and `@@column` for model and column name substitution
  - `@param` for binding Go method params securely
  - `{{where}}` and `{{set}}` blocks for conditional WHERE and SET clauses
  - `{{if}}`, `{{else}}`, and `{{for}}` for complex control flow and iteration

This DSL lets you represent dynamic query conditions, optional filters, and iterative clauses efficiently, all while retaining type-safety and composability.

Example snippet:

```sql
-- Select rows conditionally
SELECT * FROM @@table
{{where}}
  {{if user.Name != ""}} name=@user.Name {{end}}
  {{if user.Age > 0}} AND age=@user.Age {{end}}
{{end}}
```

The CLI parses and generates Go code that constructs this SQL safely with parameters injected in order.

---

## Code Generation Configuration

Customize your generation process effortlessly using a package-level `genconfig.Config` declaration. Configure:

- **Output directory** via `OutPath` for better project layout control
- **Field type and name mappings** to override or extend default helper types
- **File-level vs package-level generation** with `FileLevel` for scoping
- **Interface and struct inclusion/exclusion filters** using shell-like patterns

Example configuration snippet:

```go
var _ = genconfig.Config{
  OutPath: "examples/output",
  FieldTypeMap: map[any]any{
    sql.NullTime{}: field.Time{},
  },
  IncludeInterfaces: []any{"Query*"},
}
```

The generator detects this config automatically and applies it, enabling precise control without command-line clutter.

---

## Summary Mermaid Diagram: Feature Workflow

```mermaid
flowchart TD
  A[User writes Go interfaces 
with SQL template comments] --> B[Generator parses source 
and extracts interfaces]
  B --> C[Parse model structs 
and generate field helpers]
  C --> D[Apply user configs 
(e.g., field mappings, output path)]
  D --> E[Generate Go code:
 - Interface implementations
 - Model field helpers
 - Association helpers]
  E --> F[User invokes generated APIs
in application code]
  F --> G[Type-safe queries 
and updates through GORM]

  subgraph Generation Process
    B --> C --> D --> E
  end

  subgraph Developer Workflow
    A --> F --> G
  end

  classDef user fill:#e0f7fa,stroke:#006064,stroke-width:2px;
  class A,F,G user;
```

This diagram illustrates GORM CLI’s flow from source input to generated code and its use in developer workflows.

---

## Practical Examples

```go
// Generated Query interface usage
user, err := generated.Query[User](db).GetByID(ctx, 123)
if err != nil {
  // Handle error
}

// Generated field helpers with GORM Update
err = gorm.G[User](db).
  Where(generated.User.Name.Eq("alice"))
  .Set(generated.User.Age.Incr(1))
  .Update(ctx)

// Creating associated records
err = gorm.G[User](db).
  Set(
    generated.User.Name.Set("bob"),
    generated.User.Pets.Create(generated.Pet.Name.Set("spot")),
  ).
  Create(ctx)
```

---

## Best Practices & Tips

- **Keep your interfaces focused** on query intent with clear method names and SQL templates.
- Use **field and name maps** in your config to customize helpers for your domain-specific types.
- Harness the **SQL templating DSL** for complex, conditional queries instead of hardcoding SQL.
- Use **include/exclude filters** in configs to generate only what you need and keep outputs clean.
- Regularly review generated code and test queries to ensure mappings match database schema.

---

## Troubleshooting Common Issues

- **Missing context parameters?** GORM CLI auto-injects them if omitted but watch for methods that explicitly declare incompatible signatures.
- **Unexpected output location?** Check your `OutPath` in `genconfig.Config` or CLI `-o` flag.
- **Interface or struct missing from generation?** Review your include/exclude patterns.
- **Generation errors during parsing?** Ensure your interfaces and SQL comments meet syntax rules and return conventions.

---

## Next Steps

- Explore [Quickstart: From Models to Type-Safe APIs](/overview/features-and-workflows/quickstart-user-journey) to get hands-on.
- Dive into [Configuration & Extensibility](/overview/features-and-workflows/configuring-generation) for advanced setup.
- Understand [Core Concepts & Terminology](/overview/architecture-and-core-concepts/core-concepts-terminology) for foundational knowledge.

By mastering these feature sets, you will unlock the full potential of GORM CLI to enhance your GORM applications with type safety, productivity, and powerful query generation.
