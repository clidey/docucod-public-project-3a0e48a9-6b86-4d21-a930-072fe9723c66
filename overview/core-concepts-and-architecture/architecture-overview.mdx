---
title: "System Architecture"
description: "Presents a high-level architectural diagram (Mermaid) and narrative, detailing how the CLI orchestrates code generation: from user input via CLI, through configuration, to generating query APIs and field helpers. Highlights the major components and their interactions."
---

# System Architecture

Understanding how GORM CLI orchestrates code generation unlocks the power behind its seamless, type-safe integration with GORM. This page presents a clear, high-level architectural overview, illustrating how user input flows through the CLI tool, configuration layers, and the core generation engine to produce robust query APIs and field helpers.

---

## Overview

GORM CLI transforms Go interface definitions enriched with SQL templates and Go model structs into fully functional, strongly typed query APIs and model-driven field helper code. This process is orchestrated via a command-line interface that carefully integrates configuration, parsing, and templating steps to ensure precise and efficient output.

The diagram below lays out the major components involved and their interactions, giving you insight into what happens under the hood as you run the CLI to generate your query code.

---

## Architectural Components

- **User Input (CLI)**: Developers provide source input paths and optional output directories through the `gorm` CLI tool, focusing primarily on the `gen` command.

- **Configuration Loader**: The CLI scans source files for `genconfig.Config` declarations, capturing generation rules such as include/exclude filters, output paths, and custom field mappings.

- **Parser & AST Processor**: Each Go source file is parsed into an abstract syntax tree (AST). The generator walks the AST to extract metadata about interfaces, methods with SQL templates, and structs, while respecting discovered configuration filters.

- **Internal Data Model**: The extracted interface and struct representations are stored in an internal structure (`Generator.Files`) which aggregates all files and their applicable configs, ensuring propagation and merging of configurations across the project.

- **Code Generator (Template Engine)**: Using pre-defined Go text templates, the generator renders Go source files for:
  - Interface-driven query APIs based on method signatures and SQL templates.
  - Model-driven field helpers that wrap struct fields into fluent, type-safe predicates and setters.

- **Formatter & Output Writer**: Generated code is formatted automatically with `golang.org/x/tools/imports` and written to the specified output directory, preserving package structure and applying configuration customizations.

- **Error Handling & Reporting**: Throughout the process, errors in parsing, template rendering, or file I/O are caught and reported back to the user for corrective action.

---

## How It Works â€” Execution Flow

```mermaid
flowchart TD

  CLI[gorm CLI with 'gen' Command] --> InputProvided[Specify Input Path]
  CLI --> OutputDir[Specify Output Directory]
  InputProvided --> ConfigLoader[Load & Parse genconfig.Config]
  ConfigLoader --> Parser[Parse Go Source Files (AST)]
  Parser --> DataModel[Build Internal Metadata Model]
  DataModel --> CodeGen[Generate Go Code via Templates]
  CodeGen --> Formatter[Format Generated Source]
  Formatter --> OutputWriter[Write Files to Disk]

  OutputWriter -->|Success| Done([Generation Completed])
  OutputWriter -.->|Failure| ErrorHandler[Report Write Errors]
  Formatter -.->|Failure| ErrorHandler
  CodeGen -.->|Failure| ErrorHandler
  Parser -.->|Failure| ErrorHandler

  subgraph Configuration
    ConfigLoader
  end

  subgraph Processing
    Parser --> DataModel
    DataModel --> CodeGen
  end

  subgraph Output
    Formatter --> OutputWriter
  end

  classDef error fill:#fdd,stroke:#a00,stroke-width:2px;
  class ErrorHandler error;
```

---

## Component Responsibilities Explained

### 1. Command-Line Interface

- Provides a simple CLI entry point via the `main.go` file.
- Accepts required input flags:
  - `-i/--input`: Path to Go interfaces with SQL methods.
  - `-o/--output`: Target directory for generated files.
- Manages error propagation and program exit on failure.

### 2. Configuration Loader

- Detects package-level `genconfig.Config` from source files.
- Applies include/exclude filters for interfaces and structs.
- Handles output path overrides and field mapping customizations.
- Ensures configuration is merged across multiple config declarations.

### 3. Parser & AST Processor

- Parses each Go source file into AST nodes.
- Extracts interface definitions and annotated SQL methods.
- Reads struct definitions and maps fields to supporting field helper types.
- Filters interfaces and structs according to configuration.

### 4. Internal Data Model

- Aggregates all files and their metadata into a single `Generator` instance.
- Tracks imports, methods, parameters, configurations per file.
- Maintains linkages between methods and their interfaces.

### 5. Code Generator (Template Engine)

- Uses embedded Go templates to produce code for each interface and struct.
- Generates:
  - Query interface method implementations injecting context and type safety.
  - Fluent field helpers for predicates, updates, and associations.
- Honors special SQL template DSL directives.

### 6. Formatter & Output Writer

- Runs generated code through `goimports`-style formatter to produce idiomatic Go.
- Outputs files maintaining directory and package structure.
- Creates directories as needed.

### 7. Error Handling & User Feedback

- Reports parsing or generation errors with file context.
- Handles fatal errors by stopping execution and returning informative messages.

---

## Why This Matters

The architectural design enables GORM CLI to provide developers with a straightforward yet powerful code generation experience:

- **Maintainable Code Generation**: Builds clean, readable, and idiomatic Go code that reduces boilerplate.
- **Configurable Workflows**: Allows users to tailor generation behavior per package or file.
- **Safe & Fluent APIs**: Ensures generated APIs are type-safe, discoverable, and consistent.
- **Seamless Integration**: Fits into the developer workflow without friction, leveraging the Go toolchain.

With this clear mental model of the system, you can better diagnose generation issues, customize your configurations, and leverage advanced capabilities like complex template queries or association helpers.

---

## Next Steps

- Explore the [Core Concepts & Terminology](overview/core-concepts-and-architecture/core-concepts) to understand key abstractions.
- Learn how to [Generate Type-Safe Query APIs and Field Helpers](guides/getting-started/generating-type-safe-apis) in practical workflows.
- Review the [Feature Overview](overview/feature-highlights-and-getting-started/feature-overview) for all capabilities.

---