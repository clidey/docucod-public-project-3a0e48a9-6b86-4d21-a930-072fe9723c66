---
title: "Quickstart Workflow"
description: "Walks users step-by-step through the simplest workflow: installing GORM CLI, writing a sample model and interface, generating code, and making a type-safe query. Uses concise examples to illustrate how to get productive immediately."
---

# Quickstart Workflow

Get started with GORM CLI in minutes by following a simple, step-by-step journey: install the CLI tool, define your Go model and query interface, generate type-safe query code, and run your first query against a GORM-powered database.

This concise guide equips you with the essential workflow to become productive immediately, without diving deep into advanced configurations or concepts.

---

## 1. Install GORM CLI

Start by installing the GORM CLI tool, which generates type-safe query APIs and model-driven helpers tailored for your Go structs and SQL queries.

```bash
go install gorm.io/cli/gorm@latest
```

Make sure you’re using Go 1.18+ to leverage generics required by GORM CLI.

---

## 2. Write Your Model and Query Interface

Create a Go model struct representing your database table and write an interface describing your SQL query methods using embedded SQL templates in comments.

Example model `User`:

```go
package models

import "gorm.io/gorm"

type User struct {
    gorm.Model
    Name    string
    Age     int
    Role    string
    IsAdult bool
}
```

Define your query interface with SQL template annotations:

```go
package examples

import (
    "time"
    "gorm.io/cli/gorm/examples/models"
)

type Query[T any] interface {
    // SELECT * FROM @@table WHERE id=@id
    GetByID(id int) (T, error)

    // SELECT * FROM @@table WHERE @@column=@value
    FilterWithColumn(column string, value string) (T, error)

    // UPDATE @@table
    // {{set}}
    //   {{if user.Name != ""}} name=@user.Name, {{end}}
    //   {{if user.Age > 0}} age=@user.Age, {{end}}
    //   {{if user.Age >= 18}} is_adult=1 {{else}} is_adult=0 {{end}}
    // {{end}}
    // WHERE id=@id
    UpdateInfo(user models.User, id int) error

    // SELECT * FROM @@table
    // {{where}}
    //   {{if !start.IsZero()}} created_at > @start {{end}}
    //   {{if !end.IsZero()}} AND created_at < @end {{end}}
    // {{end}}
    FilterWithTime(start, end time.Time) ([]T, error)
}
```

> These comments define parameter bindings and conditional SQL using GORM CLI’s template DSL (`@@table`, `@param`, `{{if}}`, `{{set}}`) for safe, flexible queries.

---

## 3. Generate Query Code

Run the GORM CLI code generator to produce the implementation of your interfaces and the corresponding model-driven field helpers.

```bash
gorm gen -i ./examples -o ./generated
```

- `-i ./examples`: input directory containing your model and query interfaces
- `-o ./generated`: output directory for generated code

This generates typed query APIs implementing your SQL annotations, allowing compile-time safety and IDE autocompletion.

---

## 4. Use the Generated Code

In your Go code, import the generated package and use the query APIs with a GORM `*gorm.DB` instance.

Example usage:

```go
package main

import (
    "context"
    "fmt"
    "gorm.io/driver/sqlite"
    "gorm.io/gorm"
    "your_project/generated"
    "your_project/models"
)

func main() {
    db, err := gorm.Open(sqlite.Open("test.db"), &gorm.Config{})
    if err != nil {
        panic(err)
    }

    ctx := context.Background()

    // Instantiate the typed query
    query := generated.Query[models.User](db)

    // Run a type-safe GetByID query
    user, err := query.GetByID(ctx, 1)
    if err != nil {
        panic(err)
    }

    fmt.Printf("User: %+v\n", user)
}
```

This uses the generated `GetByID` method with correct parameter bindings and returns your strongly typed `User` struct.

---

## Practical Tips & Best Practices

- **Define clear interfaces:** Use SQL templates in comments to express your queries declaratively. Avoid embedding raw SQL elsewhere.
- **Use the template DSL:** Leverage `{{where}}`, `{{set}}`, and conditionals to write flexible queries adapting to runtime parameters.
- **Generate frequently:** Regenerate code after model or interface changes to keep API updated.
- **Use contexts:** All generated methods accept context automatically, supporting cancellation and deadlines.
- **Organize your code:** Keep models and interface definitions in clear packages for maintainability.

---

## Troubleshooting Common Issues

<AccordionGroup title="Common Quickstart Issues">
<Accordion title="1. CLI 'go install' Not Working">
Ensure Go 1.18+ is installed and your GOPATH/bin is in your PATH environment.
Check by running `go version` and `which gorm`.
</Accordion>
<Accordion title="2. Generated Code Not Found">
Double-check the `-o` output directory matches your import paths.
Make sure you run generation after interface/model changes.
</Accordion>
<Accordion title="3. Compilation Errors After Generation">
Check your SQL templates for valid syntax and correct parameter names.
Avoid using unsupported syntax or missing Go types.
</Accordion>
</AccordionGroup>

---

## Summary

From installing to generating and using type-safe queries, this workflow removes boilerplate and runtime errors from your GORM data layer development. Begin with clear models and SQL-annotated interfaces, generate the glue code, and gain a fluent, safe query API instantly.

For further mastery, explore more detailed guides on [core concepts and architecture](../core-concepts-and-architecture/core-concepts), [feature highlights](../feature-highlights-and-getting-started/feature-overview), and [integration workflows](../core-concepts-and-architecture/integration-and-workflow).

---

### See Also
- [Product Overview](../introduction-and-value/product-overview)
- [Feature Overview](../feature-highlights-and-getting-started/feature-overview)
- [Integration and Workflow](../core-concepts-and-architecture/integration-and-workflow)
- [Template DSL Reference](README.md#template-based-queries) (from main README)

---