---
title: "Core Concepts & Terminology"
description: "Breakdown of fundamental terms: type-safe query API, model-driven field helpers, associations, SQL templates, and config-driven generation. Learn how these concepts translate into developer productivity and confidence."
---

# Core Concepts & Terminology

Welcome to the fundamental concepts that power GORM CLI, the essential building blocks you need to understand to maximize your productivity and confidence when working with type-safe query APIs and model-driven field helpers.

---

## Unlocking the Key Concepts

GORM CLI transforms your raw Go interfaces and model structs into robust, type-safe database access layers. To navigate this streamlined world, you first need clarity on the core terminology that defines how your code translates into database operations:

- **Type-Safe Query API**
- **Model-Driven Field Helpers**
- **Associations**
- **SQL Templates**
- **Config-Driven Generation**


---

## Type-Safe Query API

At the heart of GORM CLI is the generation of _type-safe query APIs_. These are Go interfaces you write with convenient SQL templating annotations, which GORM CLI uses to generate concrete implementations. This approach ensures:

- **Compile-time safety:** Catch errors early by leveraging Go's static typing and generics
- **Expressive code:** Write queries declaratively as interface methods with embedded SQL templates
- **Intuitive usage:** Use generated types and method signatures that exactly match your database model

### How it works
Users define interfaces whose methods have SQL templates in Go doc comments. For example:

```go
// SELECT * FROM @@table WHERE id=@id
GetByID(id int) (T, error)
```

The generator turns this into a fully implemented method like `GetByID` that queries the corresponding table with type-checked parameters and results.

### What you gain
- No more manual SQL string crafting inside your Go code
- Autocomplete and discoverability in your IDE
- Safer refactoring since method signatures and SQL parameters stay in sync

---

## Model-Driven Field Helpers

Alongside query interfaces, GORM CLI generates _model-driven field helpers_ from your Go structs. These helpers abstract common predicate logic, update setters, and association operations:

- Field types (string, int, bool, time.Time, nullable types) get rich predicate helpers like `.Eq()`, `.Like()`, `.Between()`, `.IsNull()`, etc.
- Setters for updates (`.Set()`, `.Incr()`, `.SetExpr()`) enable expressive and clear update definitions
- Association helpers for relations (has one, has many, belongs to, many2many, polymorphic) enable safe creation, update, unlink, and delete operations on related data

### Concrete example
Given this model field:

```go
generated.User.Name.Eq("alice") // Represents SQL: name = 'alice'
```

And for associations:

```go
generated.User.Pets.Create(generated.Pet.Name.Set("fido"))
```

Creating and linking a pet with a user becomes a fluent, type-checked expression with no chance of mistyped column names.

---

## Associations

Understanding associations is crucial to managing related data. GORM CLI recognizes common relational patterns in your models and generates helpers accordingly:

- **Belongs To** — Connects to one parent entity
- **Has One** — One dependent entity
- **Has Many** — Multiple dependent entities
- **Many to Many** — Bidirectional many-to-many relations via join tables
- **Polymorphic** — Relations through general owner types

### Supported operations include:

- Create and batch create linked records
- Update associated records with safe conditions
- Unlink (removing foreign key references or join table links) without deleting data
- Delete associated records, especially for join tables in many-to-many relations

These operations are scripted as part of update or create workflows on the parent record using generated helpers.

---

## SQL Templates

Templates are the mechanism you use to define dynamic SQL inside your interface method comments. They serve as a DSL to express conditional queries, iteration, and parameter binding.

### Core directives:

| Directive   | Purpose                          | Example                                 |
|-------------|---------------------------------|-----------------------------------------|
| `@@table`   | Resolves to the model's table name | `SELECT * FROM @@table WHERE id=@id`    |
| `@@column`  | Bind a dynamic column            | `WHERE @@column=@value`                 |
| `@param`    | Bind Go parameters               | `name=@user.Name`                       |
| `{{where}}` | Conditional WHERE clause         | `{{where}} age > 18 {{end}}`             |
| `{{set}}`   | Conditional SET clause           | `{{set}} name=@name {{end}}`             |
| `{{if}}`    | Conditional fragments            | `{{if age > 0}} AND age=@age {{end}}`    |
| `{{for}}`   | Iterate collections             | `{{for _, tag := range tags}} ... {{end}}` |

### Practical scenario
Use `{{where}}` to conditionally include filters only when relevant values are provided, avoiding verbose or error-prone manual query building.

---

## Config-Driven Generation

GORM CLI lets you customize code generation behavior per package using a _config struct_ named `genconfig.Config`. This empowers you to tailor the generation process exactly to your project's structure and preferences:

- Set output directories (`OutPath`) for generated code
- Map Go types or field tags to custom field helpers via `FieldTypeMap` and `FieldNameMap`
- Control which interfaces or structs to include or exclude, using pattern-based or literal matching
- Decide if mappings apply per file or package-wide

### Example snippet

```go
var _ = genconfig.Config{
  OutPath: "examples/output",
  FieldTypeMap: map[any]any{sql.NullTime{}: field.Time{}},
  FieldNameMap: map[string]any{"json": JSON{}},
  IncludeInterfaces: []any{"Query*"},
  ExcludeStructs: []any{"*DTO"},
}
```

This config ensures generation only for interfaces starting with "Query" and maps `sql.NullTime` fields to use a special `Time` helper.

---

## How These Concepts Empower You

### Improved Developer Productivity
- Write declarative interface methods, free from manual SQL string assembly
- Fluent, discoverable field helpers reduce guesswork on column names and types

### Confidence Through Compile-Time Safety
- Catch query mismatches early via Go compiler errors
- Managed model associations reduce bugs with foreign keys and joins

### Maintainability & Collaboration
- Teams share well-defined APIs reflecting database schema intent
- Configurations customize behavior to fit evolving project needs

---

## Tips and Best Practices

- Start by modeling your database with Go structs, annotating associations clearly
- Define query interfaces closest to your model packages for convenient generation
- Use config files to keep generation outputs clean and consistent with project layout
- Leverage SQL templates fully—use `{{where}}` and `{{set}}` to write elegant, parameterized queries
- Use generated field helpers when building filters, updates, and association actions for maximum type safety

---

## Common Pitfalls

- Forgetting to include `ctx context.Context` in interface methods (GORM CLI auto-injects if missing)
- Omitting return error or data types in methods annotated with raw SQL
- Mixing incompatible config include/exclude rules causing interfaces or structs to not generate
- Overcomplicating SQL templates—test incrementally for template correctness

---

## What’s Next?

After mastering these core concepts, explore these linked pages to deepen your expertise and start writing your own queries and model helpers:

- [What is GORM CLI?](../intro-and-value/what-is-orm-cli) — Product overview
- [Generating Type-Safe Query APIs](../../guides/core-workflows/generate-type-safe-queries) — Hands-on with query interfaces
- [Generating Model-driven Field Helpers](../../guides/core-workflows/generate-field-helpers) — Working with model structs
- [Customizing Code Generation with Configurations](../../guides/advanced-usage-patterns/customizing-generation) — Fine-tuning your generation

Harness these concepts to build robust, maintainable, and efficient Go applications that interact with databases confidently and flawlessly.

---