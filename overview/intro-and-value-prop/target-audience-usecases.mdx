---
title: "Who Should Use GORM CLI?"
description: "Identify the ideal users and common use cases: Go developers seeking type-safe, ergonomic SQL query generation; teams demanding maintainable and scalable database interaction layers; power users of GORM who want to reduce manual code and improve safety; and projects leveraging complex associations or requiring robust field helper logic."
---

# Who Should Use GORM CLI?

GORM CLI is designed with precision to meet the needs of Go developers and teams who want to elevate their database interaction with **type-safe**, **maintainable**, and **ergonomic** code generation. This page helps you identify if GORM CLI aligns with your development goals by outlining its ideal user profiles and the common use cases where it delivers the most value.

---

## Ideal Users

### 1. Go Developers Seeking Type-Safe SQL Query Generation
If you write Go applications using GORM and want to avoid common pitfalls associated with raw SQL or string-based queries, GORM CLI empowers you to:

- Generate interface-driven query APIs that guarantee **compile-time safety**.
- Use fluent, discoverable methods based on typed Go interfaces.
- Avoid manual boilerplate code for CRUD and complex queries.

This means fewer bugs at runtime, better IDE auto-completion, and faster development cycles.

### 2. Teams Demanding Maintainable and Scalable Database Layers
For teams working on medium to large projects where maintainability and scaling are critical, GORM CLI offers:

- Structured generation of query and field helper code, ensuring consistency across the codebase.
- Robust support for evolving schemas through configuration and code regeneration.
- Clear separation of concerns: your raw SQL templates live alongside your Go interfaces, keeping business logic clean.
- Fine-grained control over what parts of your models and interfaces to include or exclude.

These benefits streamline onboarding, reduce technical debt, and help teams collaborate effectively.

### 3. Power Users of GORM Wanting Reduced Manual Code and Stronger Safety
If you already use GORM extensively but find yourself writing repetitive or error-prone queries, especially for updates and associations, GORM CLI facilitates:

- Model-driven **field helpers** that simplify filters, updates, orderings, and association handling with strong typing.
- Association operations such as `Create`, `Update`, `Unlink`, `Delete`, and batch creation with compile-time guarantees.
- Template-based query APIs that replace manual SQL composition with safer, reusable patterns.

This reduces manual code maintenance and improves overall safety without sacrificing flexibility.

### 4. Projects Leveraging Complex Associations or Robust Field Helper Logic
Your project benefits enormously if you have:

- Complex relations such as `has one`, `has many`, `belongs to`, and `many2many` associations.
- Need for precise association semantics (unlinking, deleting, batch creating related records).
- Use cases requiring advanced filtering and updating logic based on field helper predicates.

By automating these aspects, GORM CLI ensures your associations are consistently managed and your queries optimized.

---

## Common Use Cases

### Type-Safe Query and Update APIs
You write native Go interfaces that mirror SQL queries with embedded templates. GORM CLI generates implementations that:

- Bind parameters safely, avoiding SQL injection risks.
- Provide intelligent query builders with typed parameters and results.

Example:

```go
u, err := generated.Query[User](db).GetByID(ctx, 123)
```

### Model-Driven Field Helpers for Fluent Filters and Updates
You work with generated structs that contain detailed fields and association helpers, which you can combine fluently to build database operations:

```go
gorM.G[User](db).
  Where(generated.User.Age.Gt(18)).
  Set(generated.User.Name.Set("Alice"), generated.User.IsAdult.Set(true)).
  Update(ctx)
```

### Creating, Updating, and Managing Associations Safely
GORM CLI handles the complexity of relational operations, for example:

- Creating a user and their pets in a single operation.
- Updating a nested association with conditions.
- Unlinking or deleting associated records with fine control.

Example:

```go
gorm.G[User](db).
  Set(
    generated.User.Name.Set("Alice"),
    generated.User.Pets.Create(generated.Pet.Name.Set("Fido")),
  ).
  Create(ctx)
```

### Customizing Generation with Configurations
You control which interfaces and structs get generated, how field types are mapped, and override output directories via `genconfig.Config`. This flexibility lets you adapt code generation to your project’s unique structure and standards.

---

## Why This Matters to You

Without GORM CLI, developers face challenges with:

- Manually writing error-prone SQL or GORM queries with little compile-time validation.
- Managing complex associations with scattered code, leading to bugs and inconsistent logic.
- Maintaining large codebases where query logic is duplicated or unclear.

With GORM CLI, your experience improves with:

- Reduced runtime errors thanks to compile-time checking.
- Accelerated development with generated, reusable query and update APIs.
- More readable, maintainable, and scalable codebases.

You gain a more predictable, robust workflow, enabling your team to focus on delivering business value, not wrestling with database code minutiae.

---

## Getting Started

To explore GORM CLI with your projects, we recommend:

1. Writing your query interfaces using simple SQL templates alongside your model definitions.
2. Running the CLI generator to produce type-safe query code and field helpers.
3. Integrating the generated APIs in your application logic for safer and cleaner data access.

For detailed guides, see:

- [Basic Configuration](./overview/features-and-integration/config-customization)
- [Your First Code Generation](./getting-started/first-steps/your-first-generation)
- [Using Generated APIs](./getting-started/first-steps/validating-usage)

---

By identifying yourself with the ideal users and use cases laid out here, you ensure you harness the full value of GORM CLI’s powerful code generation capabilities.


---

### Related Documentation

- [What Is GORM CLI? (Product Purpose & Value)](/overview/intro-and-value-prop/product-purpose-value)
- [Key Benefits and Why It Matters](/overview/intro-and-value-prop/core-benefits)
- [Basic Configuration & Customization](/overview/features-and-integration/config-customization)
- [Working with Associations Guides](/guides/real-world-patterns/working-with-associations)


---

### Quick Navigation

| Section                      | Link                                                                    |
|------------------------------|-------------------------------------------------------------------------|
| What Is GORM CLI?             | /overview/intro-and-value-prop/product-purpose-value                    |
| Key Benefits and Use Cases    | /overview/intro-and-value-prop/core-benefits                            |
| Configuration Essentials      | /overview/features-and-integration/config-customization                |
| Using Associations            | /guides/real-world-patterns/working-with-associations                  |


---

For more hands-on, start with the `Getting Started` tab in this documentation set.
