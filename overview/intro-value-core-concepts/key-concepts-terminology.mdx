---
title: "Key Concepts and Terminology"
description: "Define key terms and concepts introduced by GORM CLI, such as query interface, field helper, association helper, SQL template DSL, and model associations. This provides users with a shared vocabulary for the rest of the documentation."
---

# Key Concepts and Terminology

Understanding the core terms and concepts introduced by GORM CLI is essential for effectively leveraging its powerful code generation capabilities. This page defines the foundational vocabulary that you will encounter throughout the documentation and when using the tool.

---

## Query Interface

The query interface is a Go interface where each method is annotated with raw SQL or SQL templates in comments. GORM CLI generates type-safe, fluent query APIs based on these interfaces.

- **Purpose:** Define custom, reusable, and type-safe query methods that map directly to SQL operations.
- **How it works:** You write Go interface methods, annotate them with SQL templates using a DSL, and GORM CLI produces concrete implementations that safely bind parameters and provide compile-time validation.

### Example
```go
// Query defines data retrieval methods for model T
// SQL templates are placed inside method comments
type Query[T any] interface {
  // SELECT * FROM @@table WHERE id=@id
  GetByID(id int) (T, error)

  // SELECT * FROM @@table WHERE @@column=@value
  FilterWithColumn(column string, value string) (T, error)
}
```

---

## Field Helper

Field helpers are generated model-driven code constructs that correspond to fields in your Go structs. They provide strongly typed predicates, setters, and expression builders for use in queries and updates.

- **Purpose:** Facilitate type-safe, fluent construction of query conditions, updates, and orderings on model fields.
- **Supported basic types:** integers, floats, strings, booleans, time.Time, slices of bytes, and types implementing the Scanner/Valuer or GORM Serializer interfaces.
- **Example Use:** `generated.User.Name.Eq("Alice")` creates a `WHERE name = 'Alice'` condition that can be composed into GORM queries.

### Example
```go
// Use generated field helper to build queries
users, err := gorm.G[User](db).
  Where(generated.User.Age.Between(18, 30)).
  Find(ctx)
```

---

## Association Helper

Association helpers extend field helpers to manage relationships between models, including `has one`, `has many`, `belongs to`, and `many2many` associations.

- **Purpose:** Provide convenient, type-safe operations to create, update, unlink, or delete associated records.
- **Operations include:**
  - `Create` and `CreateInBatch` to insert related records and link them.
  - `Update` to modify associated records conditionally.
  - `Unlink` to sever association links without deleting records.
  - `Delete` to remove associated rows, particularly for many-to-many join records.

### Example
```go
// Create a user with an associated pet
gorm.G[User](db).
  Set(
    generated.User.Name.Set("alice"),
    generated.User.Pets.Create(generated.Pet.Name.Set("fido")),
  ).
  Create(ctx)
```

---

## SQL Template DSL

GORM CLI introduces a simple but powerful SQL templating DSL to write dynamic SQL embedded in Go interface method comments.

- **Directives & Placeholders:**
  - `@@table`: Resolves dynamically to the model’s table name.
  - `@@column`: Allows dynamic column binding with parameters.
  - `@param`: Binds Go method parameters directly to SQL parameters.
  - `{{where}}` and `{{set}}`: Conditional blocks for dynamic `WHERE` and `SET` clauses.
  - `{{if}}` / `{{else}}`: Conditional SQL fragments based on parameter values.
  - `{{for}}`: Iterate over collections for IN clauses or repeated filters.

### Example
```sql
-- Dynamic WHERE with conditions
SELECT * FROM @@table
{{where}}
  {{if name != ""}} name=@name {{end}}
  {{if age > 0}} AND age=@age {{end}}
{{end}}
```

This DSL enables you to express flexible, dynamic queries while maintaining clear parameter binding and full type safety in Go.

---

## Model Associations

Model associations in GORM CLI reflect the relationships defined in your Go structs using GORM tags and conventions, which the generator translates into helpful association helpers.

- **Types Supported:**
  - **Has One:** One-to-one relation where a parent owns a single child.
  - **Has Many:** One-to-many relation where a parent owns multiple children.
  - **Belongs To:** Inverse of `has one` or `has many`; child refers back to parent via foreign key.
  - **Many2Many:** Many-to-many relations managed through join tables.
  - **Polymorphic:** Flexible associations where related models can belong to multiple parent types.

- **How Helpers Manage Them:** Association helpers keep operations safe and idiomatic, ensuring foreign keys and join tables are properly handled.

### Example Struct Associations
```go
type User struct {
  gorm.Model
  Account   Account       // has one
  Pets      []*Pet        // has many
  CompanyID *int
  Company   Company       // belongs to
  Languages []Language    `gorm:"many2many:UserSpeak"` // many2many
}
```

---

## Summary

Together, these concepts build a comprehensive vocabulary to effectively use GORM CLI's generation power:

- **Query interfaces** define your custom data access patterns.
- **Field helpers** make querying and updating fields type-safe and expressive.
- **Association helpers** streamline complex relational operations.
- **SQL template DSL** grants dynamic, flexible query construction within Go interfaces.
- **Model associations** reflect your domain relationships and guide generation.

Mastering these terms empowers you to craft robust, maintainable, and scalable data access layers using GORM CLI.

---

## Practical Tips

- Always name methods clearly in your query interfaces to match your domain language.
- Use field helpers to avoid manual SQL construction — this prevents injection and maintains type safety.
- Leverage association helpers for multi-table operations to maintain relational integrity.
- Write expressive SQL templates using the DSL for complex, conditional queries.
- Ensure your Go structs use GORM tags correctly to represent associations, enabling accurate helper generation.

---

## Troubleshooting Common Terminology Confusions

<AccordionGroup title="Common Questions and Clarifications">
<Accordion title="What is the difference between a field helper and association helper?">
Field helpers deal with simple column fields like strings or integers, providing predicates and setters. Association helpers manage related model records (has one/many, belongs to, many2many) and include operations like create or unlink associations.
</Accordion>
<Accordion title="Do I need to write SQL for association helpers?">
No. Association helpers abstract multi-table operations through generated methods — you manipulate associations programmatically rather than writing raw SQL.
</Accordion>
<Accordion title="How does the SQL Template DSL handle parameters safely?">
Parameters are bound automatically via named placeholders like `@param`. The generated code uses prepared statements to prevent SQL injection while allowing dynamic SQL construction.
</Accordion>
</AccordionGroup>

---

## Next Steps

- Proceed to [What is GORM CLI?](./what-is-gorm-cli) to understand the overall tool purpose and user benefits.
- Explore [Core Features and Value Proposition](./core-features-and-value) for a deep dive into capabilities empowered by these concepts.
- Begin your implementation journey with [Quickstart Workflow](../architecture-usage-integration/quickstart-workflow) once comfortable with terminology.

---

## Additional Resources

- [GORM CLI README](https://github.com/go-gorm/cli/blob/main/README.md) for comprehensive examples.
- SQL Template DSL examples in query interface definitions.
- Generated code samples showing field and association helpers in action.

---

Master these key concepts, and you'll unlock the full power of GORM CLI to build safer, clearer, and more maintainable Go data layers.