---
title: "Value Proposition & Key Benefits"
description: "Experience safer, discoverable, and more maintainable ORM workflows. GORM CLI eliminates boilerplate, ensures compile-time safety for queries and associations, and accelerates development. Its SQL templating and field helper generation deliver strong typing and autocompletion, empowering teams to write reliable database code efficiently."
---

# Value Proposition & Key Benefits

## Experience Safer, Discoverable, and Maintainable ORM Workflows

GORM CLI revolutionizes how you interact with GORM by generating type-safe, fluent, and highly discoverable APIs. By eliminating boilerplate code and ensuring compile-time safety for queries and associations, it empowers you and your team to write reliable database code efficiently and with confidence.

Whether you’re building complex data models or crafting custom queries, GORM CLI simplifies development and dramatically reduces runtime errors.

---

## Why GORM CLI Matters to You

GORM CLI directly addresses common pain points in ORM usage:

- **Boilerplate Reduction:** Automatically generate query interfaces and field helpers from your model structs and annotated Go interfaces.
- **Compile-Time Safety:** Catch query and association errors at build time, preventing costly runtime failures.
- **Intuitive Discoverability:** Autocomplete-friendly generated code guides you effortlessly through fields, predicates, and associations.
- **Accelerated Development:** Focus on defining intent, while GORM CLI handles the tedious code generation.
- **Flexible SQL Templating:** Define custom query logic with parameter binding and conditional SQL, all compiled into safe methods.


## Core Value Highlights

- **Type-Safe Query APIs from Interfaces:** Write simple Go interfaces with SQL templates as comments; get fully generated, generic, and strongly typed query methods.
- **Model-Driven Field Helpers:** From your GORM models, generate helpers for basic fields and associations to compose filters, updates, and joins with ease.
- **Association Operations with Safety:** Perform Create, Update, Unlink, Delete, and batch operations on relations with compile-time guarantees.
- **Configurable and Extensible:** Tailor generation behaviors via package-level `genconfig.Config` with inclusion/exclusion filters and custom field mappings.


## What GORM CLI Enables You To Do

### Safe and Fluent Queries

Generate query interfaces like this:

```go
// Define in your interface with SQL templates
// SELECT * FROM @@table WHERE id=@id
GetByID(id int) (T, error)

// Dynamic queries
FilterWithColumn(column string, value string) (T, error)

// Conditional SQL
QueryWith(user models.User) (T, error)
```

The generator creates implementations that allow calls like:

```go
user, err := generated.Query[User](db).GetByID(ctx, 123)
users, err := generated.Query[User](db).FilterWithColumn(ctx, "name", "jinzhu")
```

Type-safe parameters and automatic context injection remove guesswork and streamline development.

### Powerful Field Helpers

Generated from your models, these helpers let you write expressive and precise queries:

```go
// Basic field predicates
generated.User.ID.Eq(1)                // WHERE id = 1
generated.User.Name.Like("%jinzhu%") // LIKE pattern

// Numeric predicates
generated.User.Age.Between(18, 65)     // BETWEEN 18 AND 65

// Null checks
generated.User.Score.IsNull()           // IS NULL
```

Use them to compose filters, updates, and ordering with confidence and full autocompletion:

```go
gorm.G[User](db).
  Where(generated.User.Name.Eq("alice"), generated.User.Age.Gt(18)).
  Find(ctx)
```

### Seamless Handling of Associations

Manage related data with granular operations and type safety.

Operations include:
- `Create`: create and link new related records
- `CreateInBatch`: batch creation/linking
- `Update`: update associated records
- `Unlink`: remove links without deleting data
- `Delete`: delete associated records or join rows

Example:

```go
// Create a new user with a pet
gorm.G[User](db).
  Set(
    generated.User.Name.Set("alice"),
    generated.User.Pets.Create(generated.Pet.Name.Set("fido")),
  ).
  Create(ctx)

// Update pet name
gorm.G[User](db).
  Where(generated.User.ID.Eq(1)).
  Set(generated.User.Pets.Where(generated.Pet.Name.Eq("fido")).
    Update(generated.Pet.Name.Set("rex"))
  ).
  Update(ctx)
```

These association methods enable fine control over relational data with full type assistance.


## Benefits and Everyday Use Cases

- **Eliminate Runtime Errors:** Compile-time validation of SQL templates and query parameters reduces bugs.
- **Boost Developer Productivity:** Autocomplete-enabled APIs and helper methods speed coding and reduce searching.
- **Enhance Code Maintainability:** Generated code replaces manual mapping and repetitive CRUD logic.
- **Support Complex Queries & Data Shapes:** Flexibly express SQL with template directives and iterate over collections.
- **Manage Associations Reliably:** Create, link, unlink, and delete related data with clear, safe semantics.

Before using GORM CLI, developers might spend hours writing and testing SQL strings manually, risking typos and runtime errors. Now, write interface definitions and models once, generate code, and rely on the compiler to catch mistakes — saving time and stress.


## Getting Started Preview

To experience these benefits, your typical workflow will involve:

1. **Define Query Interfaces with Annotated SQL Templates:** Write your interfaces with embedded SQL comments that include placeholders and control structures.
2. **Declare Your GORM Models:** Use standard Go structs with GORM tags.
3. **Run the Generator:** Use `gorm gen -i ./path/to/your/interfaces -o ./generated` to produce type-safe APIs and helpers.
4. **Use Generated APIs:** Access generated query interfaces and field helpers in your code, enjoying autocomplete and type checks.

For detailed first steps, see: [Initialize Your Project](/getting-started/first-steps/initialize-your-project), [Generate Type-Safe Code](/getting-started/first-steps/generate-code), and [Validate Your Setup](/getting-started/first-steps/validate-your-setup).


---

## Tips for Success

- Keep SQL templates concise and leverage directives like `@@table` and `{{where}}` for dynamic query construction.
- Use `genconfig.Config` to customize generation behaviors and map field types as needed.
- Structure your interfaces to model logical queries, enabling expressive and reusable methods.
- Apply association operations thoughtfully to manage related data lifecycle safely.


## Common Pitfalls

- Not including `context.Context` in method signatures: GORM CLI auto-injects it; omit explicit context for simpler method definitions.
- Ignoring the generated field helpers: these dramatically simplify predicates and updates.
- Overcomplicating SQL templates unnecessarily: start simple with static queries and gradually use templating features.


---

Leveraging GORM CLI means accelerating your database interactions while reducing bugs and boilerplate. It brings a new level of confidence and clarity to your GORM-based data layer.

Explore the rest of the documentation to see detailed usage patterns, configuration options, and integration techniques.

---

<Callout type="info">
Learn more about what GORM CLI is and how it works in the next related page: [What is GORM CLI?](/overview/introduction-core-value/what-is-gorm-cli).
</Callout>