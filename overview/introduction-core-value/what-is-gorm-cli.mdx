---
title: "What is GORM CLI?"
description: "Discover GORM CLI—a code generation tool that produces type-safe, fluent APIs for GORM projects in Go. Learn how it bridges your query interfaces and model definitions to create a safer, more maintainable, and developer-friendly data access layer."
---

# What is GORM CLI?

## Unlock Type-Safe and Fluent Data Access in Go with GORM CLI

GORM CLI is a powerful code generation tool designed specifically for Go developers working with GORM. It transforms your raw SQL query interfaces and model definitions into type-safe, fluent Go APIs that streamline database interactions, improve maintainability, and minimize runtime errors.

### Why GORM CLI Matters to You

- **Type-Safe Query APIs:** Write your queries as Go interfaces with embedded SQL templates, and get generated methods with full compile-time safety.
- **Model-Driven Helpers:** Benefit from generated field helpers for filters, updates, and association management, making complex queries and updates intuitive.
- **Fluent and Discoverable Code:** Navigate database operations through clear, idiomatic Go code that is easy to understand and maintain.
- **Seamless GORM Integration:** Works directly with the popular `gorm.io/gorm` package, leveraging its features while simplifying your access layer.

### Who Should Use GORM CLI?

If you're a Go developer building data-rich applications using GORM, and you want to avoid repetitive boilerplate code, reduce bugs caused by unsafe queries, and enable cleaner data manipulation, GORM CLI is tailored for you.

---

## What Is GORM CLI?

At its core, GORM CLI is an automatic code generator that bridges your raw SQL query definitions and GORM models into a polished, fluent API layer for your application.

**What problem does it solve?**
- Writing manual database access code is error-prone and repetitive.
- SQL embedded in strings lacks type safety and discoverability.
- Managing associations and updates efficiently can be complex.

GORM CLI solves these pain points by generating:

- **Query APIs:** Methods generated from your Go interfaces annotated with SQL templates, providing type-safe access to database reads and updates.
- **Field Helpers:** Strongly typed abstractions for model fields, enabling fluent filtering, updating, and association handling.

### How Does GORM CLI Work?

You define:

- Go interfaces that describe query methods, embedding SQL using a simple template DSL.
- Your GORM model structs with fields and associations.

GORM CLI parses these inputs, then produces:

- Concrete implementations of your query interfaces with type-safe, optimized code.
- Helper variables and functions for each model field and association.

This combination empowers you to write cleaner business logic, relying on generated code to enforce correct and efficient data operations.

---

## Key Features & Capabilities

### Interface-Driven Query API Generation

Define your queries via interfaces like this:

```go
// Query interface with SQL templates
type Query[T any] interface {
  // SELECT * FROM @@table WHERE id=@id
  GetByID(id int) (T, error)

  // WHERE clause using custom column
  FilterWithColumn(column string, value string) (T, error)

  // UPDATE with conditional SET
  UpdateInfo(user User, id int) error
}
```

GORM CLI generates fully typed implementations, injecting context and binding Go parameters safely to SQL.

---

### Model-Driven Field Helpers

From your GORM models such as:

```go
type User struct {
  ID      uint
  Name    string
  Age     int
  Profile string `gen:"json"`
}
```

You get fluent field helpers that make predicates and updates straightforward:

```go
generated.User.ID.Eq(1)                   // id = 1
generated.User.Name.Like("%jinzhu%")     // name LIKE '%jinzhu%'
generated.User.Age.Between(18, 65)         // age BETWEEN 18 AND 65
gorm.G[User](db).
  Where(generated.User.Age.Gt(18)).
  Set(generated.User.Name.Set("alice")).
  Update(ctx)
```

This avoids manually writing error-prone SQL snippets.

---

### Association Management with Safety and Ease

Manage complex associations confidently with generated helpers:

- Create new linked records
- Update associated data conditionally
- Unlink relations without deleting
- Delete associated entities safely

Example:

```go
// Create a user and link languages (many2many)
gorm.G[User](db).
  Set(
    generated.User.Name.Set("polyglot"),
    generated.User.Languages.CreateInBatch([]models.Language{{Code: "EN"}, {Code: "FR"}}),
  ).
  Create(ctx)

// Unlink pets from user
gorm.G[User](db).
  Where(generated.User.ID.Eq(1)).
  Set(generated.User.Pets.Unlink()).
  Update(ctx)
```

Each association operation respects GORM semantics like foreign keys and join tables.

---

### Powerful SQL Template DSL

GORM CLI uses a simple but expressive template language embedded in Go interface comments:

| Directive  | Purpose                        | Example                             |
|------------|-------------------------------|-----------------------------------|
| `@@table`  | Model's table name             | `SELECT * FROM @@table WHERE id=@id` |
| `@@column` | Dynamic column binding         | `WHERE @@column=@value`            |
| `@param`   | Binding Go params to SQL       | `WHERE name=@user.Name`            |
| `{{where}}`| Conditional WHERE clause       | `{{where}} age > 18 {{end}}`       |
| `{{set}}`  | Conditional SET clause (UPDATE)| `{{set}} name=@name {{end}}`       |
| `{{if}}`   | Conditional SQL snippets       | `{{if age > 0}} AND age=@age {{end}}`|
| `{{for}}`  | Iterate over slices or arrays  | `{{for _, t := range tags}} ... {{end}}`|

Example:

```sql
SELECT * FROM @@table
{{where}}
  {{if user.ID > 0}}
    WHERE id=@user.ID
  {{else if user.Name != ""}}
    WHERE name=@user.Name
  {{end}}
{{end}}
```

This DSL ensures dynamic, safe, and templated queries without manual string concatenation.

---

## Why Should I Care? (Benefits & Use Cases)

### Unlock High-Quality Outcomes

- **Eliminate Runtime Query Errors:** Compile-time checks catch mistakes early.
- **Reduce Boilerplate:** Focus on business logic instead of writing repetitive SQL accesses.
- **Maintain Consistency:** Centralized generation enforces uniform query patterns.
- **Empower Fluent Updates:** Handle complex updates and relations with simple setters.
- **Accelerate Development:** Quickly add query methods by defining interfaces and regenerate.

### Ideal Use Cases

- Building **CRUD-heavy services** requiring robust, type-safe data layers.
- Maintaining **complex domain models** with rich associations.
- Developing **multi-developer teams** that benefit from discoverable APIs.
- Creating **customized database querying patterns** with dynamic SQL templates.

### Before and After Comparison

| Without GORM CLI                                | With GORM CLI                                      |
|------------------------------------------------|-------------------------------------------------|
| Writing raw SQL strings, prone to typos and errors | Compile-time typed API preventing mistakes       |
| Manually constructing queries and bindings      | Fluent, helper-driven query building               |
| Difficult association management                  | Intuitive, safe association operations             |
| Tedious updates involving manual WHERE/SET      | Conditional updates via templates and helpers      |

### Return on Investment

Projects using GORM CLI report substantial time savings in writing and maintaining data access layers, fewer bugs, and easier onboarding of new developers due to clear, typed interfaces.

---

## Getting Started Preview

### Quick Start Steps

1. **Define your query interface** with SQL templates in Go interfaces.
2. **Declare your GORM model structs** with fields and associations.
3. **Run the GORM CLI `gen` command** specifying the input source and output directory:

```bash
gorm gen -i ./examples -o ./generated
```

4. **Use the generated APIs** directly in your application code for querying and updating your database.

### Prerequisites

- Go 1.18 or later (due to generics use).
- Basic knowledge of GORM and Go interfaces.
- Your project should have GORM models defined.

### Next Steps

- Proceed to the [Quickstart Workflow](overview/feature-highlights-getting-started/quickstart-workflow) to learn how to integrate GORM CLI into your development process.
- Explore [Installation & Prerequisites](getting-started/setup-introduction/prerequisites-system-requirements) to set up your environment.
- Check out [Why Use GORM CLI](overview/introduction-core-value/value-proposition-and-key-features) to deepen your understanding of its capabilities.

---

## Additional Tips & Best Practices

- Organize your interfaces and models carefully within the same package or directory for smooth generation.
- Use the built-in template DSL directives to handle dynamic conditions and collections gracefully.
- Leverage configuration options (`genconfig.Config`) to customize generation behavior such as output paths, included interfaces, or custom field mappings.
- When working with JSON or other custom data types, define appropriate field helpers and map them in your configuration.

---

Embrace GORM CLI today and revolutionize how you interact with your database in Go—bringing safety, clarity, and developer productivity to the forefront of your data layer.

---

_For full examples and detailed guides, visit the [GORM CLI GitHub repository](https://github.com/go-gorm/cli)_
