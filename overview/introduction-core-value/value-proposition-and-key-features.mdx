---
title: "Why Use GORM CLI: Value Proposition & Key Features"
description: "Understand the core reasons to adopt GORM CLI: compile-time safety for queries and updates, seamless GORM integration, customizable generation, and powerful helpers for fields and associations. Get a quick rundown of its most impactful features."
---

# Why Use GORM CLI: Value Proposition & Key Features

GORM CLI redefines the developer experience for Go applications leveraging GORM by providing an intelligent, compile-time safe code generation toolkit. It removes the friction of manually writing SQL queries and field helpers, automates the generation of robust, type-safe APIs, and unlocks seamless integration with GORM models and associations.

---

## Unlock Compile-Time Safety for Queries and Updates

Working directly with raw SQL and reflection often leads to runtime errors, subtle bugs, and cumbersome refactoring. GORM CLI eliminates these pain points by generating interface-driven query APIs that bind SQL templates tightly to Go types. This strategy:

- Detects query issues early at compile time
- Enforces accurate parameter bindings and result types
- Offers discoverable, fluent APIs tailored to your models

Imagine writing your queries as Go interface methods, and instantly accessing perfectly typed, error-resistant implementations—without sacrificing flexibility.

## Seamless GORM Integration

GORM CLI doesn't replace GORM; it extends it gracefully. Generated code leverages the familiar `gorm.io/gorm` API surface, supports context injection automatically, and produces idiomatic GORM wrappers. This allows you to:

- Use generated query APIs alongside manual GORM queries elegantly
- Apply filters, updates, and associations with strongly typed helpers
- Mix custom raw SQL queries with model-driven field operations

In practical terms, this means your existing GORM workflows become safer and more productive without disruption.

## Powerful, Configurable Field and Association Helpers

Beyond queries, GORM CLI generates rich, model-driven field helpers crafted from your struct definitions. These helpers enable concise, expressive operations:

- Compose predicates like `.Eq()`, `.Like()`, `.Between()` on fields
- Perform batch creates, updates, unlinks, and deletes on associations
- Customize behavior by mapping Go types or `gen` tags to helper types

For example, instead of writing error-prone manual filters, you write: 

```go
generated.User.Name.Eq("alice")
generated.User.Age.Between(18, 65)
gorm.G[User](db).
  Set(
    generated.User.Name.Set("alice"),
    generated.User.Pets.Create(generated.Pet.Name.Set("fido")),
  ).
  Create(ctx)
```

This results in clean, intention-revealing code that compiles to precise GORM operations.

## Customizable Generation via `genconfig.Config`

Recognizing diverse project needs, GORM CLI offers flexible configuration options:

- Override output paths for generated files
- Map complex Go types (e.g., `sql.NullTime`) to field helpers
- Include or exclude specific interfaces or structs using glob-style selectors
- Support file-level or package-wide configurations

This lets teams tailor generation without sacrificing automation or safety.

## Core Features at a Glance

- **Interface-Driven Query Code Generation:** Define raw SQL templates in Go interface comments and get fully implemented, type-safe methods.
- **Model-Driven Field Helper Generation:** Automatically create strongly typed helpers based on struct fields and associations.
- **Support for Associations:** Create, update, unlink, or delete related entities through generated fluent APIs.
- **SQL Template DSL:** Use powerful, context-aware DSL directives (`@@table`, `@param`, `{{where}}`, `{{set}}`, etc.) for expressive query definitions.
- **Automatic Context Injection:** Context parameters are added seamlessly to generated methods for modern Go practices.

## Why You Should Care

Implementing database queries and updates manually is error prone, especially with complex relationships, optional filters, and evolving schema. GORM CLI empowers you to:

- **Accelerate Development:** Eliminate boilerplate for query and field helper writing.
- **Ensure Code Quality:** Catch mistakes at compile time, reducing runtime surprises.
- **Enhance Maintainability:** Express database interactions declaratively in interfaces and structs.
- **Boost Performant Queries:** Fine-tune SQL via templating while keeping code safe.

### Real-World Use Cases

- Teams building large Go apps with complex data models and need concise, type-safe queries.
- Projects requiring generation of custom query APIs that integrate cleanly with GORM.
- Developers managing many associations and needing consistent, safe CRUD helpers.
- Organizations seeking to enforce database access patterns through interface contracts.

---

## Getting Started Preview

Ready to see GORM CLI in action? The typical workflow looks like this:

1. **Define Query Interfaces with SQL Templates:** Write Go interfaces commenting SQL snippets and SQL template DSL.
2. **Run the Generator:** Use the `gorm gen` CLI command pointing at your interfaces and models.
3. **Use Generated Code:** Call strongly typed query methods and leverage field helpers in your codebase.

### Prerequisites

- Go 1.18+ (for generics support)
- Your Go models and query interfaces organized in packages/directories

### Next Steps

Explore our [Quickstart Workflow](/overview/feature-highlights-getting-started/quickstart-workflow) to jump into hands-on usage or visit [Defining Query Interfaces & SQL Templates](/guides/core-workflows/query-apis-and-templates) for a deeper dive into writing your queries.

---

For more examples, configuration options, and detailed usage, visit related documentation sections listed in the next summary.


---

<Info>
Harness GORM CLI today to transform your database layer into a type-safe, productive asset — cut down bugs, speed up feature delivery, and enjoy the power of generated, fluent APIs tightly integrated with your Go application.
</Info>

---

<AccordionGroup title="Feature Highlights & Usage Examples">
<Accordion title="Interface-Driven Query API Generation">
Define your SQL templates in comments above Go interface methods, and generate fully typed query APIs that provide compile-time safety and integration with `gorm.io/gorm`.

```go
// Query interface example
// SELECT * FROM @@table WHERE id=@id
GetByID(id int) (T, error)
```
</Accordion>
<Accordion title="Model-Driven Field Helper Generation">
Create strong typed helpers for model fields enabling expressive predicates and update operations.

```go
generated.User.Age.Between(18, 65)
gorm.G[User](db).Set(generated.User.Name.Set("alice")).Create(ctx)
```
</Accordion>
<Accordion title="Association Operations Made Safe and Fluent">
Work with associations confidently with generated helpers supporting Create, Update, Unlink, Delete, and batch operations.

```go
gorm.G[User](db).Set(
  generated.User.Pets.Create(generated.Pet.Name.Set("fido")),
).Create(ctx)
```
</Accordion>
</AccordionGroup>