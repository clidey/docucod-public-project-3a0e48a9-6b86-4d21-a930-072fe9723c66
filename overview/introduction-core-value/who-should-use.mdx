---
title: "Who Should Use GORM CLI?"
description: "Ideal for Go developers and teams working with databases through GORM, especially those seeking type safety, tooling-assisted productivity, and complex query flexibility. Perfect for engineering organizations focused on reliability, readability, and strong validation in their data access layers."
---

# Who Should Use GORM CLI?

GORM CLI is the essential code generation tool expertly crafted for Go developers and teams who demand reliability, type safety, and productivity when working with their databases via GORM. This page focuses specifically on identifying the ideal users who will benefit most from integrating GORM CLI into their development workflow.

---

## Unlocking Productivity and Safety for Go Developers

If you work with Go and GORM, you already understand the power of expressive ORMs—but balancing flexibility with type safety and maintainability can be challenging. GORM CLI was created to solve precisely that.

The CLI is tailor-made for developers who want to **eliminate runtime SQL errors** by shifting query correctness checks to compile time. It’s also for engineering teams that prioritize **strong validation**, **readable and maintainable data access layers**, and **tooling-assisted development** that scales with codebase complexity.

---

## Ideal Users of GORM CLI

### 1. Individual Go Developers Seeking Type Safety

- If you write custom SQL queries embedded in your Go code and want to catch errors before runtime.
- If you value IDE auto-completion and richer tooling support when crafting queries and data manipulation logic.
- If you want a fluent, discoverable API to navigate through models and relationships without guessing database details.

### 2. Development Teams in Engineering Organizations

- Teams maintaining large codebases where consistent, **interface-driven query APIs** prevent subtle bugs.
- Groups with multiple developers who need **standardized and validated query patterns** to ensure readability and reliability across the team.
- Organizations focused on **robust data access layers** where complex relations—has-one, has-many, many-to-many—must be operated with strong validation and correctness.

### 3. Projects Needing Flexible and Complex Query Support

- Projects that demand crafting custom SQL logic while maintaining type-safe bindings.
- Developers who want to leverage **template-based SQL in interface methods** for advanced filtering, updates, and batching operations.
- Teams that require rich association operations such as create, update, unlink, and delete with compile-time guarantees.

---

## Why Choose GORM CLI?

- **Type-Safe Query APIs**: Define your desired queries as Go interfaces annotated with SQL templates. GORM CLI generates concrete implementations that guarantee correct parameter bindings and result types.
- **Model-Driven Field Helpers**: Easily access strongly typed fields and associations for filters, updates, and ordering, minimizing mistakes and boosting code clarity.
- **Scalable Association Operations**: Handle complex associations such as many-to-many relationships or polymorphic associations with explicit, safe helper methods.
- **Configurable Generation**: Tailor generation behavior by selecting which interfaces and structs to include/exclude, mapping custom field types, and applying granular output control.

---

## Real-World Scenarios Where GORM CLI Shines

### Scenario: Building a Reliable User Management System

Say you’re developing a system where users have multiple pets and belong to companies. Using GORM CLI, you generate strongly typed APIs for fetching users by ID, filtering by attributes like name and age, and managing associations like creating new pets linked to users—all without writing raw SQL inline or risking parameter mismatch.

```go
// Generated query usage example
user, err := generated.Query[User](db).GetByID(ctx, 123)
pets := user.Pets // type-safe list of Pet

// Association operation example
err = gorm.G[User](db).
    Set(
      User.Name.Set("alice"),
      User.Pets.Create(
        Pet.Name.Set("fido"),
      ),
    ).Create(ctx)
```

### Scenario: Enforcing Strong Validation Across the Team

Teams benefit from the standardization GORM CLI enforces—developers write SQL templates once in interfaces; the generator ensures all queries used meet those expectations type-safely, reducing runtime surprises and improving maintainability.

---

## Best Practices for Who Should Use GORM CLI

- **Start with Go 1.18+ projects** that leverage generics, since GORM CLI requires them to generate type-safe code.
- Use GORM CLI alongside your existing GORM setup to add safety and productivity incrementally.
- Drive adoption in teams with shared conventions for interface names and model struct organization to maximize generation effectiveness.

<Tip>
The most effective users of GORM CLI integrate it into their continuous development cycle, generating code regularly to keep query implementations and field helpers in sync with evolving database models.
</Tip>

<Note>
GORM CLI is not intended for projects outside the Go ecosystem or those not using GORM as the ORM. It complements GORM, focusing on compile-time safety and developer experience rather than runtime enhancements.
</Note>

---

## Getting Started from Here

Ready to harness type safety and tooling productivity?

- If you’re a Go developer new to GORM CLI, see the [What is GORM CLI?]( /overview/introduction-core-value/what-is-gorm-cli) page for an introduction.
- For engineering teams, the [Value Proposition & Key Benefits]( /overview/introduction-core-value/value-proposition-benefits) page explains why strong typing and code generation matter.
- When you’re ready to dive in, explore the [Quickstart: Generating Type-Safe APIs]( /guides/getting-started-workflows/quickstart-complete-workflow) to begin generating code.

Harness GORM CLI to supercharge your database coding confidence and maintainability—because your data layer deserves the strongest foundation.
