---
title: "What is GORM CLI?"
description: "An orientation to GORM CLI, highlighting its capabilities to automatically generate type-safe query APIs and powerful field helpers using your Go interfaces and models, all to reduce manual boilerplate and boost developer productivity."
---

# What is GORM CLI?

## Unlock Seamless, Type-Safe Database Interactions in Go

GORM CLI is a developer-centric command-line tool designed to dramatically reduce repetitive boilerplate when working with GORM in Go. By automatically generating type-safe query APIs from your Go interfaces and powerful model-driven field helpers from your struct models, GORM CLI elevates your productivity and confidence when interacting with databases.

## Why GORM CLI Matters

Traditional database querying in Go often involves crafting raw SQL strings or writing repetitive methods to handle database operations — prone to runtime errors, tedious to maintain, and difficult to refactor safely. GORM CLI eliminates these pain points by generating **compile-time safe**, discoverable, and fluent query APIs.

## What Does GORM CLI Do?

- **Generates Type-Safe Query APIs:** By processing simple Go interfaces annotated with SQL templates, it crafts concrete query methods with automatic parameter binding and result handling.

- **Produces Model-Driven Field Helpers:** It analyzes your model structs to create field helpers for filters, updates, ordering, and associations, all strongly typed to your data.

- **Supports Complex Association Operations:** Enables safe, expressive operations like creating, updating, unlinking, and deleting related data with full type checks.

- **Integrates Seamlessly With GORM:** The generated code builds directly on top of GORM's familiar APIs and structures, fitting naturally into your existing projects.

## How GORM CLI Works

At its core, GORM CLI scans your Go codebase for interface definitions containing specialized SQL template comments and your struct model definitions. It then generates two complementary sets of code:

1. **Query API Implementations:** Concrete code that fulfills the interface methods, implementing parameter-bound SQL queries and operations.
2. **Field Helper Structures:** Typed helpers derived from your models that provide intuitive builders for WHERE clauses, SET clauses, association handling, and beyond.

This means you write minimal interface definitions and models — GORM CLI handles the rest, creating a strong, safe, and efficient database interaction layer.

---

## A Real-World Example

Imagine you have the following Go interface defining queries for your User model:

```go
// Query[T any] defines database operations on User
type Query[T any] interface {
  // SELECT * FROM @@table WHERE id=@id
  GetByID(id int) (T, error)

  // Updates the user info
  UpdateInfo(user User, id int) error

  // Filters users by name and age
  FilterByNameAndAge(name string, age int)
}

// User represents a user in your system
// with typical fields like ID, Name, Age
```

By running GORM CLI on this interface and your User model, it automatically generates parametrized, type-safe methods that you can call like:

```go
u, err := generated.Query[User](db).GetByID(ctx, 123)
err = generated.Query[User](db).UpdateInfo(ctx, User{Name: "jinzhu", Age: 20}, 1)
users, err := generated.Query[User](db).FilterByNameAndAge("alice", 25).Find(ctx)
```

Behind the scenes, these methods execute exactly the SQL you specified but with automatic safety, parameter binding, and robust results handling.

---

## Key Value Propositions

- **Type Safety at Compile Time:** Eliminate countless runtime surprises by catching errors early.
- **Boost Developer Productivity:** No need to hand-write repetitive query methods or construct raw SQL strings.
- **Rich Association Helpers:** Safely create, update, unlink, or delete related records in your domain.
- **Customizable Generation:** Fine-tune output with configuration options for included interfaces, struct fields, field type mappings, and output paths.
- **Leverages Familiar GORM Patterns:** Built on GORM's core paradigms so you stay in your zone.

---

## Who Should Use GORM CLI?

- **Go Developers Using GORM:** Anyone who wants safer, productive database access without the overhead of handwritten SQL or reflection-based queries.
- **Teams Seeking Robust Codebases:** Projects that benefit from strongly-typed APIs that simplify maintenance and reduce bugs.
- **Applications with Complex Data Models:** Systems needing to manage rich associations between entities with compile-time guarantees.

---

## Getting Started Preview

To harness GORM CLI:

1. Define your SQL query interfaces in Go using simple method comments.
2. Ensure your Go struct models reflect your database schema.
3. Run `gorm gen -i ./path/to/interfaces -o ./generated` to produce the generated code.
4. Import and use the generated APIs in your application logic with confidence.

This process removes months of manual effort and helps you focus on building great business logic.

---

For step-by-step guides on installation, configuration, and usage, visit the [Getting Started](https://your-docs/getting-started) section.

---

## Summary

GORM CLI transforms your database access layer into a robust, type-safe, and efficient mechanism driven entirely by your Go code interfaces and models. It empowers you to write less boilerplate, catch errors early, and build maintainable data access layers effortlessly.

Explore the rest of the documentation to master how to integrate GORM CLI effectively into your Go GORM projects.

---

## Additional Resources

- [Installation & Setup](https://your-docs/getting-started/setup-installation/installation)
- [Using the Generated APIs](https://your-docs/getting-started/first-generation/using-generated-code)
- [Configuring Generation Options](https://your-docs/guides/customization-advanced/generation-config)
- [Templates and SQL DSL](https://your-docs/guides/practical-usage-patterns/template-dsl-patterns)


---

This introduction lays a solid foundation to appreciate the power and simplicity GORM CLI brings to Go developers working with databases.