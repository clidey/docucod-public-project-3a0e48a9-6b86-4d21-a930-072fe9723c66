---
title: "Feature Highlights"
description: "A high-level tour of GORM CLI’s core features—type-safe query APIs, model-driven field helpers, association operations, dynamic configuration, and frictionless GORM integration—each designed to solve practical developer pain points."
---

# Feature Highlights

Explore the core features of GORM CLI that deliver practical value for Go developers building robust, maintainable database code with GORM. Each feature is designed to empower you with type safety, fluent APIs, and seamless integration to accelerate development and minimize runtime errors.

---

## Type-Safe Query APIs from Interfaces

GORM CLI automatically generates type-safe query APIs based on the Go interfaces you define with embedded SQL templates. This gives you:

- **Compile-time checking** to catch SQL and parameter mismatches early.
- **Fluent, discoverable methods** tailored to your data models.
- **Automatic context injection**, simplifying method signatures while supporting cancellation and deadlines.

### How It Works
You define interfaces with SQL templates in method comments; GORM CLI generates concrete implementations you use directly. For example:

```go
// Your interface defines a query method
// SELECT * FROM @@table WHERE id=@id AND name = "@name"
GetByID(id int) (T, error)
```

The generated method:

```go
user, err := generated.Query[User](db).GetByID(ctx, 123)
```

This abstracts away boilerplate and SQL string building while ensuring type safety.

---

## Model-Driven Field Helpers

From your Go struct models, GORM CLI generates:

- **Strongly typed field helpers** for queries (filters, updates, ordering).
- **Association helpers** for managing related data with compile-time awareness.

These helpers provide API methods like `.Eq()`, `.Like()`, `.Between()`, and `.Set()` enabling expressive, safe queries.

**Example:**

```go
// Query users aged between 18 and 65
users, err := gorm.G[User](db).
  Where(generated.User.Age.Between(18, 65)).
  Find(ctx)
```

The generated helpers reflect the actual column names and types, protecting you from typos and runtime errors.

---

## Rich Association Operations

Managing SQL associations (has one, has many, belongs to, many2many) is complex. GORM CLI simplifies this by generating association helpers supporting operations:

- **Create / CreateInBatch** — insert and link associated records.
- **Update** — selectively update associated records.
- **Unlink** — dissociate an association without deleting records.
- **Delete** — remove associated records or join rows.

### Semantics by Association Type
- **Belongs to:** `Unlink()` clears parent FK, `Delete()` removes associated row.
- **Has one/has many:** `Unlink()` clears child FK, `Delete()` removes child rows.
- **Many2many:** `Unlink/Delete` remove join table rows only.

### Example use case

```go
// Create a new user and associate pets
err := gorm.G[User](db).
  Set(
    generated.User.Name.Set("alice"),
    generated.User.Pets.Create(generated.Pet.Name.Set("fido")),
  ).
  Create(ctx)
```

This composes a parent create with child relations seamlessly.

---

## Dynamic and Configurable Code Generation

GORM CLI supports flexible configuration through `genconfig.Config` enabling you to tailor generation:

- **Output paths** for generated files.
- **Include/Exclude filters** by interface or struct patterns.
- **Custom type mappings** for specialized field helpers (e.g., JSON fields).

Configurations can be localized per package or file and support complex patterns to fit your project structure.

---

## Frictionless GORM Integration

Everything generated by GORM CLI works naturally with `gorm.io/gorm`:

- Generated code accepts standard GORM `*gorm.DB` instances.
- APIs chain with existing GORM query builders and scopes.
- Uses GORM conventions and extensions internally.

This ensures that adopting GORM CLI enhances, rather than disrupts, your familiar workflow.

---

## Real-World Developer Workflow

1. **Define models and query interfaces** in your project with SQL templates.
2. **Run `gorm gen`** to generate type-safe APIs and field helpers.
3. **Use generated APIs** in your application for queries, updates, and association management with confidence.

This workflow reduces manual SQL string building and common runtime errors, boosting developer productivity.

---

## Practical Tips & Best Practices

- Always annotate query interface methods with clear SQL templates to maximize generated method accuracy.
- Leverage model-driven helpers for both simple fields and rich associations for cleaner code.
- Use `genconfig.Config` to map custom types or limit generation scope to avoid unnecessary code.
- Integrate generated APIs gradually into existing codebases to reduce disruption.

---

## Troubleshooting Common Issues

- **Missing generated files:** Verify your interfaces contain properly formatted SQL comments.
- **Compilation errors:** Check your Go version supports generics (1.18+).
- **Association ops misbehaving:** Confirm association types in your models match expected GORM conventions.

Refer to the [Getting Started Guide](../getting_started/first_code_generation/minimal_configuration.md) for detailed setup instructions.

---

## Summary

GORM CLI’s feature set transforms GORM workflows by providing:

- Compile-time safe, fluent query APIs from annotated interfaces.
- Model-driven field and association helpers for expressive database operations.
- Flexible configuration for generation customization.
- Seamless integration preserving the familiar GORM experience.

Unlock these features to drastically improve code safety, maintainability, and developer efficiency in your Go projects.

---

For complete user journeys, see the [What is GORM CLI?](./what-is-gorm-cli.md) and [Target Audience & Use Cases](./target-audience-use-cases.md) sections in this documentation.
