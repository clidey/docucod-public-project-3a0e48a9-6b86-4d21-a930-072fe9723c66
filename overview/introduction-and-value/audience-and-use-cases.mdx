---
title: "Who Should Use GORM CLI?"
description: "Understand the target users—Go developers using GORM who want safer, faster, and more maintainable database code—and explore common scenarios such as building robust APIs, ensuring compile-time query safety, and streamlining model updates."
---

# Who Should Use GORM CLI?

## Unlock Safer, Faster, and More Maintainable Database Code

GORM CLI is purpose-built for Go developers leveraging GORM to interact with databases more effectively. If you want to eliminate error-prone manual query construction, ensure compile-time safety, and streamline updates to your data models, this is the tool for you.

This page guides you through understanding exactly who benefits the most from GORM CLI, illustrating real-world use cases, and how it fits naturally into common Go development workflows.

---

## Target Audience: Go Developers Using GORM

- **Backend Engineers building robust APIs:** Quickly generate clean, type-safe query interfaces and model helpers to reduce boilerplate and increase reliability.
- **Teams enforcing compile-time safety:** Prevent runtime SQL errors by catching query issues at build time through typed APIs.
- **Developers maintaining evolving data models:** Automate updates to query APIs and field helpers as your structs and interfaces change, ensuring consistent integration.

If your work involves writing raw SQL queries or manually crafting GORM queries, GORM CLI will transform how you interact with your database layer.

---

## Common Scenarios Where GORM CLI Excels

### 1. Building Robust, Maintainable APIs
Define Go interfaces with SQL templates directly in your comments and generate type-safe query APIs. This keeps your data access layer concise and highly readable while preventing common SQL bugs.

Example:

```go
// Define an interface with SQL templates
// SELECT * FROM @@table WHERE id=@id
GetByID(id int) (T, error)
```

Generate the API and consume it with confidence:

```go
user, err := generated.Query[User](db).GetByID(ctx, 123)
```

### 2. Ensuring Compile-Time Query Safety
GORM CLI converts your interfaces and struct models into strongly typed query methods and field helpers, catching invalid queries or field usage early during compilation rather than at runtime.

Failures like misspelled column names or mismatched types become impossible to overlook.

### 3. Streamlining Model Updates and Refactoring
When your Go structs evolve (adding fields, changing types, or associations), GORM CLI regenerates corresponding helper fields and query methods automatically.

This synchronization dramatically reduces manual updates and helps keep your codebase reliable and up to date.

---

## Why You Should Choose GORM CLI

- **Type Safety:** Avoid SQL injection risks and runtime errors by leveraging static type checking.
- **Productivity Gains:** Write less boilerplate and focus on business logic rather than query construction.
- **Fluent APIs:** Generated query and field helpers provide intuitive, discoverable methods.
- **Seamless Integration:** Works directly with GORM, enhancing your existing projects without disrupting workflows.

---

## How Does This Work in Practice?

1. **Define interfaces** reflecting your desired SQL operations with embedded SQL templates.
2. **Annotate your Go structs** (models) as usual.
3. **Run `gorm gen`** specifying your input and output paths to generate code.
4. **Use the generated APIs and field helpers** safely and fluently in your application logic.

---

## Practical Tips & Best Practices

- Use consistent naming conventions in your interfaces (e.g., prefix query interfaces with `Query*`) to leverage generator include/exclude filters.
- Where applicable, declare a `genconfig.Config` in your package to customize output paths, field mappings, or to whitelist/blacklist interfaces and structs.
- Take advantage of model-driven association helpers for managing related entities (create, update, unlink, delete) with type safety.
- Utilize SQL template directives like `@@table`, `@param`, and conditional blocks (`{{if}}`) to build flexible, secure queries.

---

## Common Pitfalls to Avoid

- Missing context parameter: GORM CLI auto-injects `context.Context` into generated methods if absent, but be mindful when defining interfaces.
- Overlooking config filters: Without proper `IncludeInterfaces` or `ExcludeInterfaces` settings, unwanted code might be generated — configure filters carefully.
- Ignoring field mappings: If your model uses custom types like `sql.NullTime`, map them in `FieldTypeMap` to generate correct helpers.

---

## Next Steps

- Explore the [Installation Guide](https://gorm.io/cli/overview/introduction-and-value/what-is-gorm-cli) to get set up.
- Check out [Minimal Configuration & Project Setup](https://gorm.io/cli/getting-started/first-generation/basic-configuration) for smooth project integration.
- Dive into [Using the Generated APIs](https://gorm.io/cli/getting-started/first-generation/using-generated-code) to master daily usage.

---

## Related Documentation

- [What is GORM CLI?](https://gorm.io/cli/overview/introduction-and-value/what-is-gorm-cli) (Core concepts and value proposition)
- [Generation Config Guide](https://gorm.io/cli/guides/customization-advanced/generation-config) (Customize code generation behavior)
- [Model-driven Field Helpers](https://gorm.io/cli/guides/getting-started/field-helpers-basics) (Master field and association helpers)


---

Gain unmatched confidence in your database code by embracing GORM CLI — the definitive tool for Go developers seeking safer, quicker, and cleaner database interaction using familiar GORM patterns.