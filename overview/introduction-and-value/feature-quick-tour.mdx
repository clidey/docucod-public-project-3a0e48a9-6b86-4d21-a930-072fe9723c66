---
title: "Key Features at a Glance"
description: "An at-a-glance tour of the most important features: type-safe query generation from Go interfaces, model-driven field helper creation (for filters, updates, and associations), comprehensive association handling, and out-of-the-box integration with GORM."
---

# Key Features at a Glance

Discover the core capabilities of GORM CLI that redefine how Go developers interact with databases. This page offers a succinct tour of the flagship features offering type-safe query generation, powerful model-driven field helpers, seamless association management, and out-of-the-box integration with GORM, designed to elevate your development workflow.

---

## Type-Safe Query APIs from Go Interfaces

GORM CLI transforms your Go interfaces with SQL template annotations into fully type-safe, fluent query APIs. Instead of writing repetitive boilerplate SQL or hand-coded queries, define your queries declaratively through annotated method comments.

### What You Achieve
- **Compile-time Safety**: Catch query signature mismatches and type errors during compilation, preventing runtime surprises.
- **Fluent API**: Use generated strongly-typed interfaces with idiomatic Go method calls.
- **SQL Template DSL**: Leverage flexible placed holders (`@@table`, `@param`, `{{where}}`) to express dynamic, conditional SQL elegantly.

### Example
```go
// Define your query interface with SQL in comments
 type Query[T any] interface {
   // SELECT * FROM @@table WHERE id=@id
   GetByID(id int) (T, error)

   // UPDATE @@table
   // {{set}}
   //   {{if user.Name != ""}} name=@user.Name, {{end}}
   // {{end}}
   // WHERE id=@id
   UpdateUser(user User, id int) error
 }
```

Generated with GORM CLI, you get:

```go
user, err := generated.Query[User](db).GetByID(ctx, 123)
err := generated.Query[User](db).UpdateUser(ctx, updatedUser, 123)
```

This reduces manual errors and accelerates maintenance.

---

## Model-Driven Field Helpers for Filters, Updates, and Associations

From your Go structs representing database models, GORM CLI automatically generates typed field helpers that make building queries and updates precise and discoverable.

### Benefits
- **Strongly Typed Fields**: Access fields as typed helpers (e.g., `generated.User.Name.Eq("alice")`) that provide predicates and setters.
- **Comprehensive Coverage**: Handles basic data types (strings, ints, bools, dates) and supports custom field mappings.
- **Expressive Updates**: Apply zero-value and expression-based updates safely and clearly.

### Example Usage
```go
// Predicates
generated.User.Name.Eq("alice")               // name = 'alice'
generated.User.Age.Between(18, 65)              // age BETWEEN 18 AND 65

// Update setters
gorm.G[User](db).
  Where(generated.User.ID.Eq(1)).
  Set(
    generated.User.Name.Set("bob"),
    generated.User.Age.Incr(1),
  ).
  Update(ctx)
```

This reduces error-prone SQL string concatenation and improves code readability.

---

## Comprehensive Association Handling

GORM CLI generates dedicated helpers for managing complex associations, supporting all common relationship types:

- **Belongs To**
- **Has One**
- **Has Many**
- **Many to Many (m2m)** including polymorphic associations

### Supported Operations
- **Create**: Insert related records and link them automatically.
- **Update**: Apply targeted changes on associated data.
- **Unlink**: Remove association links safely without deleting data.
- **Delete**: Delete associated records or join rows where applicable.
- **CreateInBatch**: Batch insert and link multiple related records.

### Examples
```go
// Create a user with one pet
gorm.G[User](db).
  Set(
    generated.User.Name.Set("alice"),
    generated.User.Pets.Create(generated.Pet.Name.Set("fido")),
  ).
  Create(ctx)

// Update a user's pet name
gorm.G[User](db).
  Where(generated.User.ID.Eq(1)).
  Set(generated.User.Pets.Where(generated.Pet.Name.Eq("fido")).Update(
    generated.Pet.Name.Set("rex"),
  )).
  Update(ctx)

// Unlink pets
gorm.G[User](db).
  Where(generated.User.ID.Eq(1)).
  Set(generated.User.Pets.Unlink()).
  Update(ctx)
```

Each operation respects the semantics by association type for safe and precise data integrity.

---

## Seamless GORM Integration

GORM CLI-generated code is designed to plug directly into your existing GORM workflows without friction.

### Highlights
- Generated APIs accept `*gorm.DB` instances directly, allowing chaining and composition.
- Supports context injection automatically when missing, ensuring modern Go concurrency practices.
- Works hand-in-hand with GORM’s clause expressions and query builders.

### Workflow Example
```go
// Create and link a new user and languages
gorm.G[User](db).
  Set(
    generated.User.Name.Set("polyglot"),
    generated.User.Languages.CreateInBatch([]models.Language{{Code: "EN"}, {Code: "FR"}}),
  ).
  Create(ctx)

// Use generated query interface with context and fluent call
user, err := generated.Query[User](db).GetByID(ctx, 123)
```

This tight integration ensures you can adopt GORM CLI without disrupting your existing database access patterns.

---

## Visual Summary: Feature Generation Flow
```mermaid
flowchart TD
  IFace["Input: Query Interface with SQL annotations"] -->|Parse interfaces and methods| ASTParser["AST Processor"]
  Models["Input: Model Structs"] -->|Parse struct fields and tags| ASTParser

  ASTParser --> CodeGen["Code Generator"]

  subgraph Generated Code
    QueryAPI["Type-safe Query APIs"]
    FieldHelpers["Model-driven Field Helpers"]
    AssociationHelpers["Comprehensive Association Handlers"]
  end

  CodeGen --> Generated Code

  Generated Code --> Development["Developer Usage: Fluent, Safe DB Access"]

  classDef input fill:#e3f7fc,stroke:#1e81b0,stroke-width:1px,font-weight:bold
  classDef generated fill:#d1fccf,stroke:#2f7a20,stroke-width:1px,font-weight:bold

  class IFace,Models input
  class QueryAPI,FieldHelpers,AssociationHelpers generated
```

---

## Best Practices & Tips

- **Leverage SQL Templates Fully**: Use the DSL directives (`@@table`, `@param`, `{{where}}`, `{{set}}`, `{{for}}`) to write expressive, dynamic SQL directly in interface comments.
- **Use Config for Custom Mappings**: Define package-level `genconfig.Config` to customize output paths, include/exclude patterns, and field mapping (e.g., JSON).
- **Adopt Associations Early**: Model your relationships precisely to benefit from automated association helpers.
- **Include Context Explicitly or Rely on Auto-Injection**: For clarity, include `ctx context.Context` in your method signatures, though the generator handles its injection when omitted.

## Common Pitfalls

- **Unmatched Return Signatures**: Ensure methods returning data have correct signature: one value plus `error`, or just `error` for void methods.
- **Improper Use of Config Includes/Excludes**: Misconfiguring whitelist or blacklist patterns can exclude necessary code generation unexpectedly.
- **Ignoring Generated Field Helpers**: Avoid raw SQL strings in favor of generated typed helpers for predicate building.

---

## Next Steps
- Check out the [Getting Started guides](overview/introduction-and-value/overview/) for walkthroughs on setup and first-generation.
- Dive deeper into [Template DSL patterns](guides/practical-usage-patterns/template-dsl-patterns) to master complex query generation.
- Customize generation using [Configuration](guides/customization-advanced/generation-config) and [JSON Field Mapping](guides/customization-advanced/json-field-mapping).

---

Harnessing these key features empowers your Go projects with robust, type-safe, and maintainable database access — all while embracing idiomatic GORM integration.