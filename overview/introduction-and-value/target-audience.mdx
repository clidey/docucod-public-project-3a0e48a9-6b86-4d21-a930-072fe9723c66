---
title: "Who Should Use GORM CLI?"
description: "Defines the primary audience, such as backend Go developers working with relational databases and GORM, teams seeking safe and productive database interactions, and projects requiring maintainable and discoverable query logic."
---

# Who Should Use GORM CLI?

GORM CLI is purpose-built for Go developers and teams that prioritize safe, productive, and maintainable interactions with relational databases—especially those leveraging GORM as their ORM solution. This page guides you through identifying if GORM CLI fits your context and project needs, helping you understand why it matters to you and your development workflow.

---

## Target Audience

- **Backend Go Developers:** If you write Go applications that interact with relational databases using GORM, especially those who value type-safe, compile-time checked data access.

- **Teams Building Database-Driven Software:** Groups aiming to improve collaboration, standardize query logic, and reduce runtime errors by generating consistent, discoverable query APIs.

- **Projects Demanding High Maintainability:** Codebases where query complexity grows over time and where manually maintained SQL or dynamic query construction often leads to bugs or fragmented logic.

- **Developers Needing Strong Discoverability:** Users who want query and update logic that is auto-generated, easy to explore via IDEs, and tightly coupled with their data models.

---

## Why GORM CLI is Your Solution

At its core, GORM CLI transforms your Go interfaces and model structs into two key assets:

- **Type-Safe Query APIs** generated from your interface definitions annotated with SQL templates, enabling fluent, safe database queries with full Go compiler checks.

- **Model-Driven Field Helpers** generated from your struct definitions, creating strongly typed helpers for filters, updates, and association management.

This dual approach empowers you to avoid common pitfalls related to hand-written queries, reduce boilerplate, and enforce correctness early in your development cycle.

---

## Realistic User Scenarios

### 1. Backend developers managing relational data
You design Go interfaces representing your queries with SQL templates as comments and use your GORM model structs as the foundation for generating helper fields. This workflow guarantees that your queries will be:

- Checked at compile time for parameter correctness
- Easy to read and maintain via generated, idiomatic Go methods
- Consistent across your team, reducing bugs caused by custom dynamic SQL strings

### 2. Teams scaling query logic complexity
When your project grows to include nested filters, complex joins, or polymorphic associations, GORM CLI’s generation system helps keep your queries modular and discoverable. It supports configurations to whitelist or blacklist specific interfaces and structs, ensuring only relevant code is generated.

### 3. Projects requiring extendable and configurable code generation
You can customize code generation with `genconfig.Config`, override output directories, map custom field helpers (e.g., JSON, time types), and apply pattern-based inclusion/exclusion logic. This makes GORM CLI adaptable to advanced and unique project requirements.

---

## Key Benefits for Users

- **Compile-Time Safety:** Prevent runtime SQL errors by leveraging Go’s type system in generated query APIs.
- **Fluent, Discoverable API:** Write queries using intuitive Go methods auto-generated from interfaces and models.
- **Maintainable Query Logic:** Centralized interface declarations and model-based helpers foster cleaner code structure.
- **Configurable Output:** Tailor generated code via configuration files to match your project conventions and directory layout.

---

## How This Page Fits in the Documentation

This page builds on the foundational understanding introduced in [What is GORM CLI?](../introduction-and-value/product-overview) by zooming in on who benefits most from the tool. It complements the [Key Benefits & Use Cases](../introduction-and-value/value-proposition) page and is an essential read before diving into [Feature Overview](../../feature-highlights-and-getting-started/feature-overview) or beginning code generation with the [Quickstart Workflow](../../feature-highlights-and-getting-started/quickstart).

---

## Practical Tips & Next Steps

- **Assess Your Needs:** If your development involves frequent database interactions with GORM and you seek type safety and maintainability, GORM CLI is an ideal fit.

- **Explore Configuration:** Customization is straightforward; start with the default settings and gradually experiment with `genconfig.Config` as your project evolves.

- **Try the Quickstart:** To see GORM CLI in action, visit the [Quickstart Workflow](../../feature-highlights-and-getting-started/quickstart).

- **Review Examples:** Sample code and usage scenarios are demonstrated in the [examples](../../../examples) folder within the repository.

- **Plan for Team Adoption:** Share this documentation to align your team around safer, generated APIs, reducing debugging and accelerating development cycles.

---

## Related Resources

- [What is GORM CLI?](../introduction-and-value/product-overview) — Understand core value and approach
- [Key Benefits & Use Cases](../introduction-and-value/value-proposition) — Detailed advantage scenarios
- [Feature Overview](../../feature-highlights-and-getting-started/feature-overview) — Explore capabilities to solve problems
- [Quickstart Workflow](../../feature-highlights-and-getting-started/quickstart) — Hands-on getting started guide
- [Configuration & Customization](../../getting-started/first-steps/configuration-setup) — Tune generator to your needs

---

## Summary
This page clarifies who gains the most from GORM CLI, focusing on Go backend developers and teams working with GORM, aiming for safer, more maintainable database interactions through generated, type-safe APIs and field helpers. It guides you on identifying your fit with the tool and directs you to practical next steps in the documentation.

---

*Use GORM CLI when you want confidence in your data queries, fluent code generation from familiar Go constructs, and a scalable way to manage relational database operations safely and productively.*
