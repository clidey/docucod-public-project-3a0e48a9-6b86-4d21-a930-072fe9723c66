---
title: "System Architecture"
description: "Understand GORM CLI's high-level system architecture through a mermaid diagram. See the interplay between user-defined models/interfaces, the CLI entry point, the code generation engine, and the final generated code used in your application. This bird’s-eye view makes it easy to grasp how everything connects."
---

# System Architecture

## High-Level Overview

GORM CLI is designed with a modular architecture that elegantly bridges your Go project models and interfaces with generated, type-safe query code. This page offers a high-level view of the major components involved in GORM CLI's workflow, detailing how each part interacts to deliver seamless code generation and integration.

Understanding this architecture helps you grasp the flow from writing your raw SQL interface definitions to using the final generated APIs in your application.

---

## Core Components and Interactions

### 1. User-Defined Source

- **Models**: Your GORM model structs representing database tables.
- **Interfaces with SQL Templates**: Go interfaces annotated with SQL queries and templating comments defining type-safe query methods.

These are the input foundations that GORM CLI processes to generate code.

### 2. CLI Entry Point

- **Command Line Interface (`gorm gen`)**: The developer-facing command that triggers code generation.
- Accepts flags like `-i` (input path) and `-o` (output directory).
- Loads and parses user source files.

### 3. Code Generation Engine

- **AST Parsing & Analysis**
  - Parses Go source files to extract interfaces, structs, method comments, and associated SQL templates.
- **Configuration Processing**
  - Reads package-level configurations via `genconfig.Config` declarations.
  - Determines inclusion/exclusion rules and custom mappings.
- **SQL Template Parsing**
  - Processes embedded SQL and template directives (e.g., `{{where}}`, `@@table`) to build dynamic query snippets.
- **Template Rendering**
  - Transforms the parsed data and templates into fully formed Go code with fluent APIs.
- **File Output**
  - Writes generated code files respecting directory structure and configured output paths.

### 4. Generated Code

- **Type-Safe Query APIs**
  - Interface implementations that wrap GORM `*gorm.DB`, providing compile-time safety.
- **Field Helpers**
  - Struct and slice field helpers with expressive predicates and update helpers.
- **Association Operations**
  - Helper methods for create, update, unlink, delete on related data.

This code is ready to import and use directly in your application, seamlessly integrating with GORM operations.

---

## Diagram: System Architecture Flow

```mermaid
flowchart TD

  subgraph User Source
    Models["User-Defined Models (Structs)"]
    Interfaces["User Interfaces with SQL Templates"]
  end

  CLI["CLI Entry Point\n (gorm gen -i INPUT -o OUTPUT)"]

  subgraph Code Generation Engine
    AST["AST Parsing & Syntax Analysis"]
    ConfigProc["Config Processing (genconfig.Config)"]
    SQLParser["SQL Template Parsing"]
    Renderer["Template Rendering & Code Generation"]
    FileOut["Writing Generated Code Files"]
  end

  GeneratedCode["Generated Type-Safe APIs & Field Helpers"]

  subgraph Application
    UseInApp["Import & Use Generated Code in App"]
  end

  Models --> AST
  Interfaces --> AST

  CLI --> AST
  CLI --> ConfigProc

  AST --> SQLParser
  ConfigProc --> Renderer
  SQLParser --> Renderer

  Renderer --> FileOut
  FileOut --> GeneratedCode
  GeneratedCode --> UseInApp

  %% Styling for clarity
  classDef userSource fill:#e8f0fe,stroke:#3b82f6,stroke-width:2px;
  class UserSource userSource;
  class CLI fill:#d1fae5,stroke:#10b981,stroke-width:2px;
  classCodeGen fill:#fef3c7,stroke:#f59e0b,stroke-width:2px;
  class Application fill:#f3f4f6,stroke:#6b7280,stroke-width:2px;

  class Models,Interfaces userSource;
  class CLI CLI;
  class AST,ConfigProc,SQLParser,Renderer,FileOut CodeGen;
  class GeneratedCode,UseInApp Application;
```

---

## User Flow Narrative

Imagine you are a developer enhancing your Go project with robust, type-safe database query code:

1. **Define Your Data and Queries**
   - You write GORM model structs that represent your database schema.
   - You craft Go interfaces with method signatures annotated with SQL templates — flexible yet type-safe query definitions.

2. **Run the GORM CLI Generator**  
   At the command line, you execute:
   ```bash
gorm gen -i ./path/to/interfaces -o ./path/to/generated
```

3. **Behind the Scenes**
   - The generator parses your source into abstract syntax trees (AST), extracting every interface, struct, and SQL template.
   - It applies any configuration overrides you declared (for inclusion, custom mappings, output remodeling).
   - It interprets the SQL templates, handling dynamic placeholders (`@@table`, `{{set}}`, etc.) and generating Go code that safely binds parameters.

4. **Generated Code Gives You Fluent APIs**
   The output is ready-to-use code:
   - Type-safe query interfaces with method implementations you defined.
   - Helper structs that make building predicates and updates intuitive.
   - Association helpers that manage related data with correct semantics.

5. **Use Directly in Your Application**
   Import the generated packages, and your database access code benefits from compile-time safety, discoverability, and maintenance ease.

---

## Practical Tips & Best Practices

- **Keep Interfaces Lean**: Define focused query interfaces with clear SQL templates for maintainability.

- **Leverage Configuration**: Use package-level `genconfig.Config` declarations to customize output paths, field mappings, and filter generation targets.

- **Use Template Directives**: Harness `{{where}}`, `{{set}}`, and conditional logic in your SQL comments to support dynamic query generation.

- **Validate Your Generated Code**: After generation, build and test the generated code to catch template or type mismatches early.

- **Regularly Update CLI Tool**: Keep GORM CLI up-to-date to benefit from improvements in parsing and generation.

---

## Troubleshooting Common Issues

<AccordionGroup title="Troubleshooting Common System Architecture Issues">
<Accordion title="Generated Code Not Reflecting New Interface Changes">
Make sure the input path (`-i`) points to the right directory or file containing your latest interfaces. Clear any output directories if overwriting is unclear.
</Accordion>
<Accordion title="Configuration Not Applying as Expected">
Verify that your `genconfig.Config` definition is in the package being generated and that inclusion/exclusion patterns match the interface and struct names exactly.
</Accordion>
<Accordion title="SQL Template Parsing Errors">
Check the syntax and directives in your SQL template comments are correct and supported by GORM CLI template DSL (see `{{where}}`, `{{if}}`, etc.).
</Accordion>
<Accordion title="Imports Missing in Generated Code">
Ensure your source files include necessary import statements and package paths are correctly resolved by the generator.
</Accordion>
</AccordionGroup>

---

## Next Steps

To deepen your mastery of GORM CLI's internals and expand your usage:

- Explore the [Overview of GORM CLI](../introduction-and-key-concepts/what-is-gorm-cli) for foundational knowledge.
- See [Core Concepts & Terminology](../introduction-and-key-concepts/core-concepts-and-terminology) for definitions that make reading code and docs easier.
- Read [Writing and Using Template-Based Queries](../../guides/advanced-patterns/template-dsl-guide) to craft complex reusable SQL templates.


---

**Repository and Source**

For the source code of the core generation engine and CLI entry point, review:

- [internal/gen/generator.go](https://github.com/go-gorm/cli/blob/main/internal/gen/generator.go)
- [internal/gen/sqlparser.go](https://github.com/go-gorm/cli/blob/main/internal/gen/sqlparser.go)
- [main.go (CLI Entrypoint)](https://github.com/go-gorm/cli/blob/main/main.go)

This architectural insight empowers you to customize or debug GORM CLI at a deeper level if needed.

---