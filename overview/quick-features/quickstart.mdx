---
title: "Quickstart Workflow"
description: "Step-by-step outline of the typical GORM CLI usage: authoring query interfaces and models, running the CLI to generate code, and embedding the results into your application. Optimized for new adopters who want immediate feedback."
---

# Quickstart Workflow

Welcome to the Quickstart Workflow for GORM CLI â€” your step-by-step guide to efficiently integrate type-safe, generated query APIs and field helpers into your GORM-based Go applications. This guide is designed for new adopters eager to see immediate benefits from GORM CLI and gain fast feedback on their initial code generation.

---

## Why Follow This Workflow?

GORM CLI delivers safety and productivity by generating Go code from your existing interfaces and models. This workflow is tailored to:

- Help you author query interfaces and define models in your code
- Run GORM CLI to generate type-safe, fluent APIs
- Embed and use the generated code seamlessly in your application

By following these steps, you'll eliminate boilerplate, reduce runtime errors, and enjoy compile-time validation of your database queries.

---

## Overview of the Steps

1. **Define Your Query Interfaces and Models**
2. **Run the GORM CLI Generator**
3. **Use the Generated APIs in Your Application**
4. **Validate Generated Code and Debug**

Let's dive into each step.

---

## 1. Define Your Query Interfaces and Models

At the heart of GORM CLI's power are your Go interfaces and model structs.

### Author Query Interfaces

Create Go interfaces with methods annotated by SQL templates in comments. Example:

```go
// examples/user_query.go
package examples

type Query[T any] interface {
  // SELECT * FROM @@table WHERE id=@id
  GetByID(id int) (T, error)

  // SELECT * FROM @@table WHERE name=@name AND age=@age
  FilterByNameAndAge(name string, age int) ([]T, error)
}
```

These interfaces define the queries GORM CLI will generate implementations for, with automatic binding of parameters.

### Define Your Models

Create Go structs representing your database tables with conventional GORM tags or embedded models:

```go
// examples/models/user.go
package models

type User struct {
  ID   uint
  Name string
  Age  int
}
```

You can also include associations and custom field types, which GORM CLI will generate helpers for.

#### Best Practices

- Keep query interfaces and models in the same package for ease of generation.
- Use meaningful method names and SQL comments as templates.
- Define all fields you want to generate helpers for, including associations.

---

## 2. Run the GORM CLI Generator

With your interfaces and models ready, run the GORM CLI to generate type-safe APIs.

### Basic Generation Command

```bash
gorm gen -i ./examples -o ./generated
```

- `-i` specifies the input directory containing your interfaces and models.
- `-o` defines the output directory for generated code.

### What Happens?

- The generator scans your input for interfaces with SQL templates.
- It creates concrete implementations exposing fluent, type-safe query methods.
- It generates field helpers from your model structs for filters, updates, ordering, and association management.

### Configuration Options

You can customize generation through a `genconfig.Config` object placed in your package:

```go
package examples

import "gorm.io/cli/gorm/genconfig"

var _ = genconfig.Config{
  OutPath: "examples/output",
  IncludeInterfaces: []any{"Query*"},
  IncludeStructs: []any{"User"},
}
```

This enables selective generation and custom type mappings.

---

## 3. Use the Generated APIs in Your Application

After generation, embed and interact with the generated code from your Go application.

### Example Usage

```go
import (
  "context"
  
  "your_project/generated"
  "gorm.io/gorm"
)

func exampleUsage(db *gorm.DB) error {
  ctx := context.Background()

  // Query a user by ID
  user, err := generated.Query[generated.User](db).GetByID(ctx, 123)
  if err != nil {
    return err
  }

  // Filter users by name and age
  users, err := generated.Query[generated.User](db).FilterByNameAndAge("alice", 30).Find(ctx)
  if err != nil {
    return err
  }

  // Example output
  fmt.Println(user, users)
  return nil
}
```

Here, `generated.Query[User](db)` accesses the generated, type-safe API with automatic parameter binding and query construction.

### Using Field Helpers

You can build predicates and updates fluently:

```go
import "generated"

db.Where(
  generated.User.Name.Eq("alice"),
  generated.User.Age.Gt(18),
).Find(ctx)
```

This approach eliminates raw SQL strings and prevents common query errors.

---

## 4. Validate Generated Code and Debug

After integrating generated code, verify your new interfaces and field helpers work as expected.

### Testing

- Write unit tests using the generated APIs.
- Use in-memory databases (e.g., SQLite in `:memory:` mode) to isolate tests.

Example from tests:

```go
users, err := generated.Query[generated.User](db).FilterByNameAndAge(ctx, "alice", 25).Find()
if err != nil {
  t.Fatal(err)
}
```

### Common Pitfalls

- Ensure your interfaces have correctly formatted SQL templates in comments.
- Confirm your models are defined with standard Go struct conventions.
- If you modify models or interfaces, re-run the generator to update code.

### Troubleshooting

Use the following tips when errors arise:

<AccordionGroup title="Troubleshooting Common Issues">
<Accordion title="Generated API Not Found">
Ensure you specified the correct input path with `-i` and that your interfaces have SQL templates.
</Accordion>
<Accordion title="Compile Errors in Generated Code">
Check your Go struct definitions for unsupported types or missing imports. Re-generate after fixing.
</Accordion>
<Accordion title="Runtime Errors with Queries">
Verify parameter types in interface methods match those used in templates exactly.
</Accordion>
</AccordionGroup>

---

## Summary

| Step                        | Purpose                                         |
| --------------------------- | -----------------------------------------------|
| 1. Define Interfaces & Models | Prepare types and queries for generation       |
| 2. Run CLI Generator         | Produce type-safe APIs and helpers              |
| 3. Use Generated APIs        | Embed and invoke fluent, compile-time-safe code|
| 4. Validate & Debug          | Confirm correctness and troubleshoot            |

Following this workflow ensures you quickly realize the benefits of GORM CLI with minimal friction.

---

## Additional Resources

- [Define Models & Query Interfaces](/getting-started/first-generation/define-models-interfaces)
- [Run the Code Generator](/getting-started/first-generation/run-code-generator)
- [Validate Generated APIs](/getting-started/first-generation/validate-generated-apis)
- [Troubleshooting Common Issues](/getting-started/first-generation/troubleshooting-common-issues)
- [Why Use GORM CLI?](/overview/product-intro/why-gorm-cli)
- [Feature Overview](/overview/quick-features/feature-summary)

---

Embrace this workflow to unlock safer, faster, and more maintainable database interactions in Go with GORM CLI.