---
title: "Product Purpose and Value"
description: "Summarizes GORM CLI's goal of providing interface-driven, type-safe query APIs and model-driven helpers for GORM. Explains the value proposition: generate safer, more discoverable APIs for database operations, supporting both reads and writes with fluent Go code, and reducing runtime query errors."
---

# Product Purpose and Value

## Unlock Safer, More Discoverable Database Operations with GORM CLI

GORM CLI empowers Go developers using GORM to write database queries and operations with unmatched safety and clarity. By generating interface-driven, type-safe query APIs and comprehensive model-driven helpers, it transforms your database code into fluent, compile-time verified Go code that reduces runtime errors and boosts development productivity.

### Key Benefits
- **Type-Safe Query APIs:** Generate Go interfaces with embedded SQL templates that ensure compile-time validation of your database query parameters.
- **Model-Driven Helpers:** Automatically produce strongly typed helpers for filters, updates, ordering, and association management based on your Go models.
- **Comprehensive CRUD Support:** Seamlessly perform create, read, update, delete, and batch operations with fluent, discoverable code.
- **Fluent, Discoverable API:** Intuitive, Go-idiomatic method chains improve readability and encourage best practices.
- **Reduced Runtime Errors:** Eliminate many classes of query bugs early through compile-time safety.

### Who Should Use This?
GORM CLI is designed for Go developers and teams leveraging GORM who want to improve the reliability and maintainability of their database access code. Whether you are building complex applications or maintaining large codebases, GORM CLI delivers safer and faster database interaction.

---

## What is GORM CLI?

At its core, GORM CLI is a code generation tool that bridges your Go code with your database through GORM. It produces two essential outputs:

1. **Interface-Driven Query APIs:** From Go interfaces decorated with SQL templates, GORM CLI generates concrete, type-safe methods that compile directly into efficient GORM queries.
2. **Model-Driven Field Helpers:** From your existing Go model structs, it generates field-specific helpers that simplify writing filters, updates, and association operations.

### Why Use GORM CLI?
Without GORM CLI, writing queries against your database in Go can lead to repetitive and error-prone code. You may misspell column names, provide wrong types, or build dynamic SQL poorly. GORM CLI prevents these issues by automating:

- The generation of strongly typed query methods tailored to your data structures
- Fluent and discoverable query building with compile-time guarantees
- Safe management of associations, including complex relations like many-to-many

### How It Works (At a High Level)
You provide:
- Go interface definitions with SQL templates in comments
- Go model structs that represent your database schema

GORM CLI processes these inputs and generates:
- Go interface implementations with type-safe methods
- Field helpers for all model fields and associations

This dual-generation approach gives you a seamless, safe, and fluent API to interact with your database through GORM.

---

## Core Capabilities and Features

### 1. Type-Safe Query APIs from Interfaces
Define interfaces with methods annotated by SQL templates. GORM CLI uses these to generate fully typed implementations that provide:
- Parameter binding with automatic type checks
- Conditional and dynamic SQL with built-in template directives like `{{where}}` and `{{set}}`
- Support for both single-result and multi-result queries

Example:

```go
// Define query interface with SQL in comments
// SELECT * FROM @@table WHERE id=@id
GetByID(id int) (T, error)
```

Generated usage:

```go
user, err := generated.Query[User](db).GetByID(ctx, 123)
```

### 2. Model-Driven Field Helpers
Based on your Go model structs, GORM CLI generates typed helpers for each field, enabling:

- Writing precise filters and predicates:

  ```go
  generated.User.Name.Like("%jinzhu%") // name LIKE '%jinzhu%'
  generated.User.Age.Between(18, 65)     // age BETWEEN 18 AND 65
  ```

- Updates supporting zero values and complex expressions
- Order by, null checks, and other common query operations

### 3. Comprehensive Association Management
Automatically generated helpers for associations including:

- Belongs To
- Has One
- Has Many
- Many to Many (with support for polymorphic relationships)

Operations supported with compile-time guarantees:

- Create and link new related records
- Update associated records with rich filtering
- Unlink associations (clear foreign keys or remove join rows)
- Delete associated rows safely
- Batch create/link for has-many and many-to-many associations

Example:

```go
gorm.G[User](db).
  Set(
    generated.User.Name.Set("alice"),
    generated.User.Pets.Create(generated.Pet.Name.Set("fido")),
  ).
  Create(ctx)
```

### 4. Template DSL for Dynamic, Conditional Queries
GORM CLI offers a powerful SQL templating DSL in method comments, enabling flexible query generation:

- `@@table` and `@@column` placeholders for dynamic resolution
- `@param` bindings for safe SQL parameter injection
- Conditional logic (`{{if}}`, `{{else}}`, `{{end}}`) for WHERE and SET clauses
- Looping constructs (`{{for}}`) to build composite conditions

Example:

```sql
SELECT * FROM @@table
{{where}}
  {{if user.Name != ""}} name=@user.Name {{end}}
  {{if user.Age > 0}} AND age=@user.Age {{end}}
{{end}}
```

Enables writing flexible queries that adapt to input values without manual SQL construction.

### 5. Seamless GORM Integration
Generated code works transparently with your existing `*gorm.DB` instances. It extends GORM's fluent API with all the type safety and discoverability from your generated helpers and query interfaces.

---

## Why GORM CLI Matters: Key Benefits and Use Cases

### Deliverable Outcomes
- **Eliminate Runtime Query Errors:** Type checking ahead of time catches misused field names, parameter types, and SQL errors.
- **Accelerate Development:** Write less boilerplate and instantly navigate all available query methods and fields.
- **Enhance Code Readability:** Generated APIs offer a natural, fluent syntax familiar to Go developers.
- **Maintain Large Codebases:** Automatic generation reduces manual coding errors and makes refactoring safer.

### Scenarios Where GORM CLI Excels
- Building complex database queries requiring conditional logic
- Working extensively with associations and relational data
- Projects with evolving models requiring synchronized query helpers
- Teams focusing on robust API design and compile-time correctness

### Before and After
Before GORM CLI, you might write dynamic SQL strings or manually hand-code repetitive queries prone to typos and logic errors. After adopting GORM CLI, your queries become explicit, type-safe Go method calls, with rich, model-aware helper functions generated automatically.

---

## Getting a Quick Start Preview

Getting started involves three straightforward steps:

1. **Define Query Interfaces and Models:** Write Go interfaces with SQL template comments and declare your GORM model structs.

2. **Generate Code:** Run `gorm gen -i ./your/input/folder -o ./generated` to produce your query implementations and helper types.

3. **Use the Generated APIs:** Invoke fluent, type-safe methods against your `*gorm.DB` to perform queries, updates, and association operations with confidence.

For detailed instructions and examples, see the [Getting Started](../getting-started/welcome-and-installation/introduction-and-benefits) guide.

---

## Practical Tips and Best Practices

- Maintain your query interfaces alongside your models to ensure synchronization.
- Use the SQL template DSL to encode complex dynamic query logic declaratively.
- Embrace generated field helpers to write precise WHERE and SET clauses.
- Leverage association helpers to manage related entities safely and idiomatically.
- Configure generation rules using `genconfig.Config` in your packages to filter interfaces or adjust output as needed.

<Note>
When specifying dynamic SQL in interface comments, always use `@@table` and `@param` placeholders to keep queries safe and flexible.
</Note>

<Warning>
Avoid manual edits in generated files. Instead, modify interfaces and models and regenerate code to keep source-of-truth and implementation synchronized.
</Warning>

---

By adopting GORM CLI, you transform your database access layer into a type-safe, maintainable, and developer-friendly experience â€” reducing bugs, saving time, and increasing confidence in your application's data operations.

---

For more on usage, consult the rest of the documentation, including the [Query Interfaces & SQL Templates](../concepts/association-and-query-models/query-interfaces-and-sql-templates) and [Field Helpers: Type-Safe Predicates & Setters](../concepts/core-architecture/field-helper-generation) pages.

---

### References
- [GORM CLI GitHub Repository](https://github.com/go-gorm/cli)
- [Getting Started Guide](../getting-started/welcome-and-installation/introduction-and-benefits)
- [Using Generated APIs](../getting-started/first-steps/using-generated-apis)
- [Template DSL for Dynamic Queries](../guides/advanced-usage-patterns/template-dsl)

---