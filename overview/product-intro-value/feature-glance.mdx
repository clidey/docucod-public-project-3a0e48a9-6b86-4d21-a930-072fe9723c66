---
title: "Features at a Glance"
description: "An at-a-glance roundup of GORM CLI's main features: query API generation from interfaces with SQL templates, model-driven field helpers, association operation helpers, configuration options, and seamless GORM integration. A quick reference for product capabilities."
---

# Features at a Glance

Discover the core capabilities that make GORM CLI a powerful companion for your GORM projects. This at-a-glance overview highlights how GORM CLI transforms raw Go interfaces and model structs into type-safe, efficient, and fluent APIs without sacrificing developer productivity or code safety.

---

## Interface-Driven, Type-Safe Query APIs from SQL-Annotated Interfaces

GORM CLI lets you define Go interfaces with embedded SQL templates in comments â€” then automatically generates concrete, type-safe APIs for your database queries.

- **Write declarative SQL once** on interface methods using intuitive SQL templates and placeholders.
- **Generate fully typed methods** that tightly integrate with your Go models, providing compile-time safety.
- **Automatically manage context injection** so every method supports idiomatic Go best practices.

**Example:**
```go
// Query interface with embedded SQL
 type Query[T any] interface {
  // SELECT * FROM @@table WHERE id=@id
  GetByID(id int) (T, error)

  // WHERE clause with dynamic column reference
  FilterWithColumn(column string, value string) (T, error)
}
```

Run the generator to produce these methods with concrete SQL implementations and strong type checks.

---

## Model-Driven Field Helpers for Filters, Updates, and Ordering

From your Go model structs, GORM CLI generates rich field helper objects designed for:

- **Building strong-typed predicates** for filtering queries (e.g., `Eq`, `Like`, `Between`).
- **Constructing update setters** including zero-values, increments, and SQL expressions.
- **Expressing ordering and sorting criteria elegantly.**

These helpers make constructing queries fluent, discoverable, and error-resistant.

**Example usage with predicates:**
```go
// Find user by name and increment age
 u, err := gorm.G[User](db).
   Where(generated.User.Name.Eq("alice"))
   .Set(generated.User.Age.Incr(1))
   .Update(ctx)
```

---

## Association Operation Helpers for Robust Relationship Management

GORM CLI generates helpers to confidently manage all types of associations your models use, including:

- `belongs to`
- `has one`
- `has many`
- `many2many`

Operations covered:

- Create and link associated records automatically on parent creation or update
- Batch create associated slices
- Update associated rows conditionally
- Unlink associations cleanly without removing data
- Delete associated rows with optional filtering

**Practical workflow example:**
```go
// Create user with associated pets
err := gorm.G[User](db).
  Set(
    generated.User.Name.Set("alice"),
    generated.User.Pets.Create(generated.Pet.Name.Set("fido")),
  ).
  Create(ctx)
```

You can also perform conditional unlink or delete operations on associations by chaining the appropriate filters.

---

## Flexible Configuration Options to Customize Generation

GORM CLI supports powerful configuration that lets you tailor generation behavior to your project needs:

- Specify output paths per package or file
- Map Go types to custom field helper types, including JSON and Time handling
- Include or exclude specific interfaces and struct types with shell-style patterns
- Configure file-level scopes for granular control

**Example configuration snippet:**
```go
var _ = genconfig.Config{
  OutPath: "examples/output",
  FieldTypeMap: map[any]any{
    sql.NullTime{}: field.Time{},
  },
  IncludeInterfaces: []any{"Query*"},
}
```

Configurations are automatically picked up during generation, streamlining your workflow.

---

## Seamless Integration with GORM and Your Go Codebases

Produced code fits naturally into your existing GORM-powered applications:

- Uses idiomatic GORM `*gorm.DB` builders passed into generated APIs
- Supports context-aware calls for concurrency and cancellation
- Leverages GORM internals for compiling expressions, SQL clause building, and execution
- Exposes familiar method chains for filtering, updating, creating, and associations

**Example combined usage:**
```go
// Type-safe query with generated API and predicates
u, err := generated.Query[User](db).GetByID(ctx, 123)
users, err := gorm.G[User](db).
  Where(generated.User.Age.Gt(18)).
  Find(ctx)
```

---

## Summary Table of Core Features

| Feature                                    | Description                                                              | User Benefit                      |
|--------------------------------------------|-------------------------------------------------------------------------|---------------------------------| 
| Interface-Driven Query APIs                 | Generate based on Go interfaces annotated with SQL                     | Compile-time safety & ease       |
| Model-Driven Field Helpers                  | Strongly typed fields for predicates and setters                      | Fluent, discoverable, error-proof |
| Association Management Helpers              | Create, update, unlink, delete associations                           | Manage relations confidently     |
| Configurable Generation                     | Override paths, mappings, filters                                      | Adapt to project conventions      |
| Full GORM Integration                       | Use with `*gorm.DB` seamlessly                                          | Natural, idiomatic Go workflows   |

---

## Practical Tips and Best Practices

- **Start by defining clean query interfaces** with embedded SQL comments to maximize benefit.
- **Use the generated field helpers** rather than hand-writing predicates to reduce bugs.
- **Configure generation when you need custom behaviors or output locations.**
- **Leverage association helpers** to reduce repetitive relational SQL and maintain integrity.
- **Run code generation automatically during your build or CI process** to keep helpers up to date.

---

Explore deeper workflows, configuration, and advanced usage in the surrounding documentation to unlock full value.

---

## Visual Overview

```mermaid
flowchart TD
  InterfaceDefs["SQL-Annotated Go Interfaces"] -->|Code Generation| QueryAPI["Type-Safe Query APIs"]
  ModelStructs["Go Model Structs"] -->|Code Generation| FieldHelpers["Strongly-Typed Field Helpers"]
  FieldHelpers --> AssociationHelpers["Association Operation Helpers"]
  QueryAPI --> Usage["Fluent, Compile-Safe Usage"]
  AssociationHelpers --> Usage
  Usage --> Integration["Seamless GORM Integration"]

  subgraph Config
    Config["Generation Configuration"]
    Config -->|Customizes| QueryAPI
    Config -->|Customizes| FieldHelpers
    Config -->|Customizes| AssociationHelpers
  end
```

---

## Next Steps

- Visit **Getting Started > Generating Your First Code** to see how to define your interfaces and start generating.
- Review **Core Workflows > Writing Type-Safe Queries** and **Using Field Helpers for Filters & Updates** for hands-on guides.
- Consult **Advanced Usage & Patterns > Customizing Generation via Config** to tailor behavior.

---

## See Also
- [Product Purpose and Value](overview/product-intro-value/product-purpose)
- [Target Audience & Typical Use Cases](overview/product-intro-value/target-audience-usecases)
- [Getting Started > Installation Guide](getting-started/welcome-and-installation/installation)
- [Core Concepts & Architecture > Integration with GORM and Go Projects](overview/architecture-concepts/integration-overview)


<Source url="https://github.com/go-gorm/cli" branch="main" paths={[{"path": "README.md", "range": "1-200"},{"path": "examples/query.go", "range": "1-80"},{"path": "internal/gen/gen.go", "range": "1-90"}]} />