---
title: "Target Audience & Typical Use Cases"
description: "Describes the types of users who benefit most from GORM CLI, including Go developers using GORM that demand compile-time safety, and teams scaling database codebases. Highlights use cases such as rapidly generating query APIs from interfaces, customizing field helpers for advanced CRUD operations, and integrating smoothly with existing projects."
---

# Target Audience & Typical Use Cases

## Who Benefits Most from GORM CLI?

GORM CLI is meticulously crafted for Go developers and teams who demand impeccable compile-time safety and productivity when working with GORM-based projects. This tool seamlessly generates type-safe query APIs and model-driven helpers, empowering users to write robust and maintainable database operations with confidence.

### Primary Users

- **Go Developers Using GORM**: Individual developers who want to enhance their data access layer with fluent, type-safe APIs that align with idiomatic Go and GORM.
- **Development Teams Scaling Database Codebases**: Teams maintaining large or complex databases benefit from consistent, auto-generated query interfaces and helpers that reduce boilerplate, errors, and cognitive load.
- **Projects Needing Compile-Time Query Safety**: Those who prioritize catching query-related flaws at compile time rather than at runtime, especially in safety-critical or enterprise applications.
- **Teams Wanting Seamless Integration**: Developers who want code generation deeply integrated with GORM's patterns for models, associations, and CRUD operations.

## Typical Use Cases

GORM CLI addresses a wide range of real-world development scenarios where developers seek to accelerate database interaction workflows with increased confidence and efficiency.

### 1. Rapidly Generating Type-Safe Query APIs

Define your raw SQL or SQL-template methods as Go interfaces, and GORM CLI generates concrete implementations with type-safe method signatures. This accelerates development by eliminating manual query crafting while ensuring:

- Automatic context injection for all queries
- Compile-time checking of parameters and return types
- Fluent chaining and execution using GORM semantics

#### Example

```go
// Define interface with SQL annotations in comments
// SELECT * FROM @@table WHERE id=@id
GetByID(id int) (T, error)

// Generate using CLI
gorm gen -i ./examples -o ./generated

// Use generated API
user, err := generated.Query[User](db).GetByID(ctx, 123)
```

### 2. Creating Advanced Field Helpers for CRUD Operations

Model structs yield rich, strongly-typed field helpers for predicates (filters), setters (updates), and ordering. These helpers reduce errors and increase discoverability.

- Fields like `int`, `string`, `time.Time`, and custom mapped types automatically generate predicates such as `.Eq()`, `.Like()`, `.Between()`.
- Support for updates with zero values, incremental updates, and complex expressions.

#### Example

```go
gorm.G[User](db).
  Where(generated.User.Name.Eq("alice"))
  .Set(
    generated.User.Age.Incr(1),
    generated.User.Status.Set("active"),
  ).
  Update(ctx)
```

### 3. Managing Associations with Full Compile-Time Safety

Handle `has one`, `has many`, `belongs to`, and `many2many` associations directly from generated helpers.

- Create, update, unlink, or delete related records with clear intent.
- Batch operations supported for performance and convenience.
- Conditional unlink and delete with filters.

#### Real Scenarios

- Creating a new user with related pets
- Linking or unlinking languages in a `many2many` relationship
- Updating child or related entities based on specific conditions

```go
gorm.G[User](db).
  Set(
    generated.User.Name.Set("bob"),
    generated.User.Pets.Create(generated.Pet.Name.Set("rex")),
  ).
  Create(ctx)
```

### 4. Integrating into Existing GORM Projects

GORM CLI fits naturally into your current GORM codebase without changing your application design.

- Generate APIs alongside your models and interfaces
- Customize code generation via a flexible config system
- Supports complex architectures including polymorphic associations and custom field mappings

### 5. Enabling Teams to Maintain Large Codebases More Effectively

Automatically generated and verified query interfaces promote:

- Consistent query patterns across services
- Reduced bug surface with compile-time validation
- Easier onboarding through fluent, discoverable APIs

## Before and After GORM CLI Adoption

| Without GORM CLI                                                | With GORM CLI                                                     |
|---------------------------------------------------------------|-----------------------------------------------------------------|
| Manual query string construction prone to typos and SQL errors | Type-safe generated APIs catch mistakes at compile-time         |
| Scattered helper functions with inconsistent styles           | Unified, discoverable field and association helpers             |
| Difficult to maintain and refactor query code                 | Rapid regeneration of APIs reflecting latest model/interface changes |
| Lengthy debugging of runtime errors in data layer             | Early feedback through generated method signatures              |

## Summary of Benefits

- **Speed**: Accelerate development by auto-generating query code
- **Safety**: Gain compile-time validation for SQL queries and operations
- **Productivity**: Fluent, chainable APIs reduce boilerplate
- **Maintainability**: Align generated code with evolving models and interfaces
- **Robustness**: Manage associations safely and idiomatically

---

## Getting Started Preview

Begin by writing your query interfaces with annotated SQL comments and defining your models. Then run the code generation CLI to produce ready-to-use, type-safe query APIs and helpers. For detailed instructions, see the [Getting Started Guide](../getting-started/welcome-and-installation/introduction-and-benefits).

<Tip>
Ensure your Go environment is 1.18+ to utilize generics required by GORM CLI.
</Tip>

---

Explore these related documentation pages for a seamless learning experience:

- [Product Purpose and Value](../overview/product-intro-value/product-purpose) – Understand why GORM CLI was created and its core advantages.
- [Features at a Glance](../overview/product-intro-value/feature-glance) – Quick overview of key capabilities.
- [Basic Configuration Setup](../../getting-started/first-steps/basic-configuration) – Learn to configure the generator to your needs.

