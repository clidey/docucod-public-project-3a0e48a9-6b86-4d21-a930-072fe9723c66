---
title: "Product Introduction & Value"
description: "Gain a quick, high-level understanding of what GORM CLI is, its unique strengths, and how it augments the Go and GORM developer experience. Learn how it provides type-safe query APIs and powerful, fluent field helpers through code generation."
---

# Product Introduction & Value

## Unlock Type-Safe and Fluent Querying for Your Go & GORM Projects

GORM CLI revolutionizes your Go development with GORM by generating code that provides **compile-time safety** and **intuitive query APIs**. It bridges the gap between raw SQL interfaces and Go’s type system, enabling you to write safer, clearer, and more maintainable data access layers.

### Why GORM CLI Matters to You

- **Eliminate runtime SQL errors** with type-safe generated query APIs.
- **Fluent, discoverable field helpers** reduce boilerplate and speed up common CRUD operations.
- **Support for advanced association handling** — manage related data with clarity and confidence.
- **Leverage Go interfaces annotated with SQL templates** for precise and reusable query definitions.
- **Seamless integration with existing GORM projects** without compromising flexibility.

### Who Should Use This?

- Go developers building applications with GORM who want to enforce type safety across database queries.
- Teams seeking maintainable, clear, and reusable data access code.
- Developers aiming to reduce SQL injection risk by using code-generated query interfaces.

---

## What Is GORM CLI?

GORM CLI is a code generation tool designed specifically for Go projects using GORM. It processes your Go interfaces annotated with raw SQL templates and your model structs to produce:

1. **Type-safe query APIs** derived from your interface methods, which automatically generate the method implementations to execute SQL.
2. **Model-driven field helpers**, which offer a fluent API for crafting filters, updates, ordering, and association operations.

This combination ensures your queries are verified at compile time and makes your GORM usage more expressive and less error prone.

### Core Problem It Solves

Writing raw SQL queries in Go can be error-prone, lacking type safety and requiring repetitive boilerplate code. GORM CLI eliminates these issues by generating safe, well-typed query APIs _directly from your code_.

### What Makes GORM CLI Unique?

- Uses Go interfaces enriched with SQL annotations to generate the exact query code you need.
- Combines query interfaces with field helpers for both filtering and association management.
- Supports complex SQL templating with conditions, iterations, and dynamic columns.
- Provides configurable code generation via package-level configuration.

---

## Key Features & Capabilities

### 1. Interface-Driven Type-Safe Query APIs
Write Go interfaces with SQL templates in method comments, then generate concrete implementations that:
- Automatically bind Go parameters safely to SQL.
- Return strongly typed results or perform updates with error checking.

### 2. Model-Driven Fluent Field Helpers
From your Go models, generate strongly typed fields representing columns and associations, supporting:
- Predicates for filtering (e.g., `Eq`, `Like`, `Between`).
- Setters and update expressions.
- Association operations such as creating, updating, unlinking, deleting related records.

### 3. Support for Complex Associations
Easily manage relationships such as `has one`, `has many`, `belongs to`, and `many2many` including polymorphic relations with compile-time safety.

### 4. Flexible Configuration
Control generation via `genconfig.Config`:
- Specify output paths.
- Include or exclude interfaces and structs.
- Customize how fields map to helpers.

### 5. Template-Based SQL DSL
Use directives like `@@table`, `@param`, `{{where}}`, and `{{set}}` to compose dynamic, conditional SQL safely embedded in Go interfaces.

---

## Why Should I Care?

### Achieve Compile-Time Safety
With generated query APIs, mistakes like parameter mismatch or incorrect result handling are caught at compile time, preventing runtime surprises.

### Improve Developer Productivity
Forget writing repetitive SQL query scaffolding. Write concise interfaces and get full implementations instantly.

### Maintain Cleaner Codebases
Generated fluent APIs encourage more readable and consistent data access layers, simplifying onboarding and maintenance.

### Real-World Use Cases
- Building CRUD APIs with complex filtering and associations.
- Implementing custom SQL queries with safety and clarity.
- Managing relational data updates and batch creations.

### Comparative Advantage
**Before GORM CLI:** Raw SQL strings scattered across code, prone to runtime errors and SQL injection risk.

**After GORM CLI:** Well-typed, interface-driven APIs seamlessly integrated with your Go code.

---

## Getting Started Preview

### Quick Start Workflow
1. **Define your Go interfaces with annotated SQL templates** describing your queries.
2. **Define your model structs** reflecting database schema.
3. **Run the `gorm gen` command** to generate query and field helper code.
4. **Use the generated APIs** in your code for strong type safety and fluent querying.

### Prerequisites
- Go 1.18 or later, to support generics.
- GORM installed and used as your ORM.

### Next Steps
- Explore the [Writing Your First Models and Query Interfaces](/getting-started/first-steps-usage/writing-models-interfaces) page.
- Follow the [Generating Code with GORM CLI](/getting-started/first-steps-usage/generating-code) guide.
- Learn how to [Use the Generated APIs in Your Project](/getting-started/first-steps-usage/using-generated-apis).

---

## Example Overview

### Defining Query Interfaces
```go
// Define an interface with SQL method comments
// SELECT * FROM @@table WHERE id=@id
GetByID(id int) (T, error)

// Filter by dynamic column
// SELECT * FROM @@table WHERE @@column=@value
FilterWithColumn(column string, value string) (T, error)
```

### Defining Model
```go
type User struct {
  ID    uint
  Name  string
  Age   int
}
```

### Generating Code
```shell
gorm gen -i ./examples -o ./generated
```

### Using Generated API
```go
// Fetch user by ID type-safely
user, err := generated.Query[User](db).GetByID(ctx, 123)

// Filter users by age
users, err := generated.Query[User](db).FilterByNameAndAge("jinzhu", 25).Find(ctx)
```

---