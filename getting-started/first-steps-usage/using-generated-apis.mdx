---
title: "Using the Generated APIs in Your Project"
description: "See typical queries and mutations using your new, typeâ€‘safe, and fluent APIs. Practical code walkthroughs demonstrate compiling, running, and integrating the generated code with GORM and your database."
---

# Using the Generated APIs in Your Project

Experience the power and safety of your newly generated APIs from GORM CLI in practical, real-world Go projects. This guide walks you through typical queries and mutations using the generated type-safe, fluent APIs, helping you compile, run, and smoothly integrate with GORM and your database.

---

## 1. What You Will Achieve

By following this guide, you will:

- **Understand how to call generated query interfaces and use fluent field helpers** to write expressive, safe data queries.
- **Perform common CRUD operations**, including filtering, creating, updating, and deleting records with straightforward syntax.
- **Leverage association helpers to handle related data** safely and conveniently.
- **Compile and run examples** demonstrating the generated code in action.

---

## 2. Overview of Generated API Usage

The core strength of GORM CLI lies in generating two complementary APIs:

- **Query API from interfaces:** Your annotated Go interfaces with embedded SQL templates generate concrete, type-safe query methods.
- **Model-driven field helpers:** Your Go model structs generate fluent, compile-time safe field helper types for predicates, setters, and association operations.

This combination provides a fluent, discoverable programming experience for safe database interaction.

---

## 3. Setup: Import and Initialize

Ensure your Go project imports the generated package after running the code generator. For example:

```go
import (
  "context"
  "gorm.io/gorm"
  "your_module/generated" // adjust import path accordingly
)

func main() {
  ctx := context.Background()
  db := /* initialize *gorm.DB connection */

  // Use the generated Query interface for your model
  query := generated.Query[User](db)
}
```

<Tip>
If you generated code under a package like `generated`, use that package path in your imports and references. Your database connection `db` must be a properly initialized `*gorm.DB` instance connected to your database.
</Tip>

---

## 4. Running Typical Queries

### 4.1 Fetch a Single Record by ID

Use the generated query method `GetByID`:

```go
user, err := generated.Query[User](db).GetByID(ctx, 123)
if err != nil {
  // handle error
}
fmt.Printf("Found user: %+v\n", user)
```

This runs the SQL `SELECT * FROM users WHERE id=123`, returning a typed `User` struct with compile-time safety.

### 4.2 Filtering Records with Dynamic Criteria

You can chain predicates using the generated field helpers:

```go
users, err := gorm.G[User](db).
  Where(generated.User.Age.Gt(18)).
  Where(generated.User.Name.Like("%jinzhu%"))
  .Find(ctx)

if err != nil {
  // handle error
}
```

This safely builds a query to fetch users older than 18 whose names contain "jinzhu".

### 4.3 Using Interface-Driven Queries

Your generated query interface methods with SQL templates allow flexible queries:

```go
user, err := generated.Query[User](db).FilterWithColumn(ctx, "email", "alice@example.com")
if err != nil {
    // handle error
}
```

This runs `SELECT * FROM users WHERE email='alice@example.com'` dynamically.

### 4.4 Handling Complex SQL Templates

Advanced queries with conditional logic can be called directly:

```go
users, err := generated.Query[User](db).Filter(ctx, []User{
    {Name: "jinzhu", Age: 20, Role: "admin"},
    {Name: "alice", Age: 30, Role: "user"},
})

if err != nil {
   // handle error
}
```

This uses your templated SQL to handle multiple filters safely.

---

## 5. Writing Mutations: Create, Update, and Associations

### 5.1 Create a New Record

Use fluent setters generated for your model fields:

```go
err := gorm.G[User](db).
  Set(
    generated.User.Name.Set("alice"),
    generated.User.Age.Set(25),
    generated.User.IsAdult.Set(true),
  ).
  Create(ctx)

if err != nil {
  // handle error
}
```

This inserts a new user row with your provided values.

### 5.2 Update Records Using Fluent APIs

Update values conditionally:

```go
err := gorm.G[User](db).
  Where(generated.User.ID.Eq(123)).
  Set(
    generated.User.Name.Set("jinzhu"),
    generated.User.Age.Incr(1),
  ).
  Update(ctx)

if err != nil {
  // handle error
}
```

This updates the name and increments the age for the user with ID 123.

### 5.3 Working with Associations

Association helpers allow you to create, update, unlink, or delete related records safely:

```go
// Create a user with one pet
err := gorm.G[User](db).
  Set(
    generated.User.Name.Set("alice"),
    generated.User.Pets.Create(generated.Pet.Name.Set("fido")),
  ).
  Create(ctx)

// Link multiple languages (many2many)
err := gorm.G[User](db).
  Where(generated.User.ID.Eq(1)).
  Set(generated.User.Languages.CreateInBatch([]Language{{Code: "EN"}, {Code: "FR"}})).
  Update(ctx)

// Unlink user's pet
err := gorm.G[User](db).
  Where(generated.User.ID.Eq(1)).
  Set(generated.User.Pets.Unlink()).
  Update(ctx)
```

Each association type (belongs to, has many, many2many) has clear semantics for unlinking or deleting.

<Tip>
Unlinking removes the association without deleting data (e.g., nullifies foreign key). Deleting removes the associated rows as appropriate.
</Tip>

---

## 6. Understanding API Design & Generated Code

- **Query methods** generated from interfaces accept parameters and return typed results with error handling.
- **Field helpers** wrap column names with strongly typed predicates (e.g., `Eq`, `Lt`, `Like`) and setters.
- **Association helpers** are available as fields on generated model helpers, enabling safe relational operations.

This design ensures compile-time consistency, reduces boilerplate, and increases productivity while maintaining full GORM compatibility.

---

## 7. Practical Tips & Best Practices

- **Always handle returned errors** from query and mutation calls.
- Use **context.Context** to control query lifetimes and deadlines.
- When using **batch or conditional operations**, write tests to verify that generated SQL matches your expectations.
- Use **conventional interface naming** (e.g., `Query[T]`) and generate code consistently in a dedicated package to keep imports clean.
- Leverage the **template DSL** in your query interfaces for expressive SQL logic with minimal duplication.

---

## 8. Troubleshooting Common Issues

<AccordionGroup title="Common Issues and Solutions">
<Accordion title="Generated Code Cannot Be Imported">
Check your package import paths and ensure the generated code was output to the expected module directory. Run `go mod tidy` and rebuild your project.
</Accordion>
<Accordion title="Methods Not Found on Generated Query">
Confirm that your interfaces with SQL templates were correctly parsed and that generation succeeded without errors. Inspect your input interface file and re-run generation.
</Accordion>
<Accordion title="Queries Return No Data or Errors">
Verify your database connection and data presence. Check SQL logs by enabling GORM debug mode to inspect generated SQL.
</Accordion>
<Accordion title="Association Operations Fail or Don't Affect Data">
Confirm foreign key constraints in your database schema. Ensure proper association tags on your GORM models and that association helpers match your schema.
</Accordion>
</AccordionGroup>

---

## 9. Example: Full Workflow Snippet

```go
func example(ctx context.Context, db *gorm.DB) error {
  // Fetch user by ID
  user, err := generated.Query[User](db).GetByID(ctx, 1)
  if err != nil {
    return err
  }

  // Create a new user with a pet
  err = gorm.G[User](db).
    Set(
      generated.User.Name.Set("newuser"),
      generated.User.Pets.Create(generated.Pet.Name.Set("buddy")),
    ).
    Create(ctx)
  if err != nil {
    return err
  }

  // Update user's age
  err = gorm.G[User](db).
    Where(generated.User.ID.Eq(user.ID)).
    Set(generated.User.Age.Set(30)).
    Update(ctx)
  if err != nil {
    return err
  }

  return nil
}
```

This example illustrates fetching, creating with associations, and updating records using generated APIs.

---

## 10. Next Steps

- Explore [Writing Your First Models and Query Interfaces](https://your-docs/getting-started/first-steps-usage/writing-models-interfaces) to deepen understanding of query interface design.
- Use [Generating Code with GORM CLI](https://your-docs/getting-started/first-steps-usage/generating-code) to refine code generation settings.
- Refer to [Integration with GORM & Other Systems](https://your-docs/overview/integrations/gorm-integration) to learn seamless project integration workflows.
- Dive into [Working with Associations Patterns and Examples](https://your-docs/guides/advanced-patterns/association-operations) for complex relational operations.

---

Your journey with GORM CLI continues as you build safer, maintainable, and efficient database code with the confidence of type safety and fluent APIs.


---

<Check>
Need support? Join the community or check out the [GitHub repository](https://github.com/go-gorm/cli) for issues, discussions, and updates.
</Check>
