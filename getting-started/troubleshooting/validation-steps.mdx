---
title: "Validating Generated Code"
description: "Shows how to check that generated code appears in expected locations and integrates with your project without errors. Instructs on reviewing output for first real use."
---

# Validating Generated Code

This guide helps you verify that the code generated by GORM CLI is correctly produced, located in the expected directories, and integrates smoothly with your project without errors. By following these steps, you'll confirm that your first real use of the generated queries and field helpers is successful, preventing common issues early.

---

## 1. Understanding Where Generated Code Appears

When you run GORM CLI to generate code, it outputs files as configured. By default, generated files are placed under the `./g` directory, but this can be customized using the `-o` (output) flag or generation config.

### How to Confirm Output Location

- If you specified `-o ./generated` when running the generator, expect generated files inside `generated/` relative to your current directory.
- If you did not specify an output directory, the default `./g` folder is used in your project root.

Example CLI usage:

```bash
gorm gen -i ./examples -o ./generated
```

This places all generated source files under the `generated` folder, preserving package structure.

---

## 2. Verifying the Generation Output

To check that generation succeeded and the output files are complete:

1. **Locate the generated files:** Navigate to your output folder.

2. **Review generated source code:** Open generated Go files and ensure your interfaces and structs are represented.

3. **Look for key artifacts:**
   - _Interface implementations_: These implement your raw SQL interfaces as type-safe query methods.
   - _Field helper declarations_: Variables representing your model’s fields for fluent filtering, updates, and associations.

A sample generated variable block looks like:

```go
var User = struct {
    ID   field.Number[uint]
    Name field.String
    Age  field.Number[int]
}{
    ID:   field.Number[uint]{}.WithColumn("id"),
    Name: field.String{}.WithColumn("name"),
    Age:  field.Number[int]{}.WithColumn("age"),
}
```

---

## 3. Validating Integration in Your Project

Once the code is generated, you'll want to confirm it compiles and works as intended within your Go project.

### Step-by-Step Validation

<Steps>
<Step title="Import the generated package in your Go code">
Import the generated code package in your application or tests.

Example:

```go
import "your_module/generated"
```

</Step>

<Step title="Use generated query API methods">
Call methods on the generated interfaces, passing the correct parameters.

Example:

```go
user, err := generated.Query[User](db).GetByID(ctx, 123)
if err != nil {
    log.Fatal(err)
}
fmt.Println(user)
```
</Step>

<Step title="Use generated field helpers to build queries">
Use field helpers to construct conditions and updates type-safely.

Example:

```go
users, err := gorm.G[User](db).
  Where(generated.User.Age.Gt(18)).
  Find(ctx)

if err != nil {
  log.Fatal(err)
}
```
</Step>

<Step title="Build and run your project">
Run `go build` or tests that use generated code. Ensure no build errors occur.
</Step>
</Steps>

<Tip>
If you encounter build errors referencing generated code, double-check your import paths and that the output directory is included in your Go module.
</Tip>

---

## 4. Checking the Generated Code Matches Your Interfaces

Since GORM CLI generates code based on your annotated interfaces with SQL templates, you should ensure the generated implementations align correctly.

- Verify method signatures match your interface definitions with the proper parameter and return types.
- Confirm that SQL template comments in your interfaces translate into the expected SQL snippets in the generated code.

You can inspect the generated method bodies to understand the SQL building behavior. For advanced verification, consider running your tests that call these queries.

---

## 5. Troubleshooting Common Validation Issues

<AccordionGroup title="Common Validation Issues">
<Accordion title="Generated files missing or empty">
- **Cause:** Incorrect output directory or no interfaces matched generation filters.
- **Solution:** Verify `-i` and `-o` flags in your CLI command, and your `genconfig.Config` does not exclude your interfaces/structs.
- Run with verbose logging if supported to see processed files.
</Accordion>

<Accordion title="Compilation errors referencing generated code">
- **Cause:** Incorrect import paths or missing generated code in your module.
- **Solution:** Confirm Go module path matches the generated package import.
- Run `go mod tidy` after generation.
- Check your project’s build contexts include generated files.
</Accordion>

<Accordion title="Runtime errors from queries">
- **Cause:** Generated query methods called with invalid parameters or database connection issues.
- **Solution:** Verify parameter types, that your database connection is valid and matches your schema.
- Validate SQL templates for correctness.
</Accordion>

<Accordion title="Unexpected SQL output or behavior">
- **Cause:** Complex SQL template syntax may generate unintended SQL.
- **Solution:** Review SQL template comments in your interface.
- Use minimal templates and then incrementally enhance to isolate issues.
</Accordion>
</AccordionGroup>

---

## 6. Example Validation Walkthrough

Imagine you have a simple interface:

```go
// Query interface snippet
// SELECT * FROM @@table WHERE id=@id
GetByID(id int) (User, error)
```

After generation:

- Find the generated file `query_gen.go` in your output directory.
- Open and locate `GetByID` implementation, which should build a SQL string with bound parameters.
- Write a Go test or main program to call `generated.Query[User](db).GetByID(ctx, 123)`.
- On successful run with no errors, your generation and integration are validated.

---

## 7. Next Steps After Validation

- Proceed to write application logic or tests using the generated code confidently.
- Explore [Defining Models & Query Interfaces](https://your-docs.example.com/getting-started/initial-usage/defining-models-interfaces) to enhance your interface designs.
- Use [Generating Code with GORM CLI](https://your-docs.example.com/getting-started/initial-usage/generating-code) to learn more about generation options.
- Review [Troubleshooting Common Errors](https://your-docs.example.com/getting-started/troubleshooting/common-errors) for problem-solving.

---

## References

- [GORM CLI Quickstart Workflow](https://your-docs.example.com/overview/architecture-usage-integration/quickstart-workflow)
- [Generating Code with GORM CLI](https://your-docs.example.com/getting-started/initial-usage/generating-code)
- [Defining Models & Query Interfaces](https://your-docs.example.com/getting-started/initial-usage/defining-models-interfaces)
- [Troubleshooting Common Errors](https://your-docs.example.com/getting-started/troubleshooting/common-errors)

---

This validation guide assures you can trust the generated code's location, completeness, and smooth integration, empowering you to build robust data access layers with confidence.