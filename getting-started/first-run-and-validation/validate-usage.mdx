---
title: "Quick Validation & Usage Test"
description: "Verify your setup by importing generated code, writing a simple query or mutation, and ensuring everything compiles and runs as expected. Provides sample validation code and pointers for common errors."
---

# Quick Validation & Usage Test

Verify your GORM CLI setup by importing the generated code, running simple queries or mutations, and confirming everything compiles and executes as expected. This guide walks you through testing your initial generation with pragmatic code examples, interpretation of results, and troubleshooting tips to catch common pitfalls early.

---

## 1. Importing Generated Code

After running the code generator, your output directory contains Go packages with generated query APIs and field helpers. To validate, begin by importing the generated package and your model definitions into your Go test or main file.

For example:

```go
import (
  "context"
  "fmt"

  "gorm.io/gorm"
  "your_project/generated"  // replace with your output package path
  "your_project/models"     // replace with your model package path
)
```

This step ensures your project references the generated strongly typed APIs and your model structs.

<Check>
Be sure your module's `go.mod` file includes correct replace directives if your generated code is outside the main module path.
</Check>

---

## 2. Running Your First Query

Leverage the generated query interface to run a simple query operation, such as fetching a user by ID.

### Example Use Case: Fetch User by ID

```go
ctx := context.Background()
db := setupYourGormDB() // create and configure your GORM DB connection

// Initialize generated query interface
query := generated.Query[models.User](db)

// Example ID to fetch
userID := 1

// Run query with generated method
user, err := query.GetByID(ctx, userID)
if err != nil {
  fmt.Println("Error retrieving user:", err)
  return
}

fmt.Printf("Found user: %+v\n", user)
```

### Expected Outcome

- The query fetches the user with ID `1` from your database.
- The user object is populated with fields according to your model.
- No runtime errors or compilation failures occur.

<Note>
If your database is empty or user ID `1` does not exist, handle the "record not found" error gracefully.
</Note>

---

## 3. Testing Updates with Generated Code

You can also test generated update methods that use SQL templates.

### Example Use Case: Update User Info

```go
updateUser := models.User{Name: "newname", Age: 30}
userID := 1

err := query.UpdateInfo(ctx, updateUser, userID)
if err != nil {
  fmt.Println("Update failed:", err)
  return
}

fmt.Println("User updated successfully")
```

### Outcome

- The user with ID `1` has their name and age updated.
- The underlying SQL uses the template with conditional SET clauses.
- Confirm changes by querying the user again or checking your database directly.

---

## 4. Running Queries Using Field Helpers

The generated package also provides field helpers for building fluent GORM conditions.

### Example Use Case: Filter users older than 18

```go
// Use generated filters
users, err := gorm.G[models.User](db).
  Where(generated.User.Age.Gt(18)).
  Find(ctx)

if err != nil {
  fmt.Println("Query error:", err)
  return
}

fmt.Printf("Found %d users older than 18\n", len(users))
```

### Outcome

- This returns a list of users older than 18.
- The query is type-safe, using the generated Age field helper.

---

## 5. Validating Template-Based Queries

If you generated query interfaces with SQL templates, ensure your queries behave correctly by running various methods.

### Example:

```go
// Filter with multiple users
filters := []models.User{{Name: "alice", Age: 20}, {Name: "bob", Age: 25}}
results, err := query.Filter(ctx, filters)
if err != nil {
  fmt.Println("Filter failed:", err)
  return
}
fmt.Printf("Filtered users count: %d\n", len(results))
```

This tests complex where clause generation with slices and templated logic.

---

## 6. Common Issues & Troubleshooting

<AccordionGroup title="Common Errors and How to Fix Them">
<Accordion title="Compilation Errors Related to Missing Imports or Types">
- **Cause:** Your generated code references packages or types not imported or available.
- **Fix:** Ensure that your module paths and imports are correct. Use `go mod tidy` and verify output directory mapping.
</Accordion>

<Accordion title="Runtime Errors: Record Not Found">
- **Cause:** Querying for non-existent data.
- **Fix:** Add error handling for `gorm.ErrRecordNotFound`. Seed your database with test data before querying.
</Accordion>

<Accordion title="Query Returns Unexpected or Empty Results">
- **Cause:** SQL template conditions not matching data.
- **Fix:** Double-check SQL templates and parameters. Use logging on GORM DB to see generated SQL.
- Enable SQL logging:
```go
db, _ := gorm.Open(...)
db = db.Debug()
```
</Accordion>
</AccordionGroup>

---

## 7. Next Steps

- Explore more generated query methods beyond the basics.
- Test association operations like `Create`, `Update`, and `Unlink` with generated helpers.
- Customize your SQL templates and regenerate code.
- Refer to guides on configuring `genconfig.Config` for tailored outputs.
- Review example test files often included in generated code packages.

---

## Additional References

- [Defining Models and Query Interfaces](/getting-started/first-run-and-validation/create-models-and-interfaces)
- [Running the Code Generator](/getting-started/first-run-and-validation/run-code-generation)
- [Troubleshooting Common Issues](/getting-started/troubleshooting-and-help/troubleshooting-common-issues)
- GORM official documentation: https://gorm.io/docs/

---