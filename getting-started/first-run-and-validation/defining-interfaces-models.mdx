---
title: "Defining Query Interfaces & Models"
description: "Start by authoring simple query interfaces (with SQL templates) and model structs. Discover best practices for structuring your package for code generation, and see concrete Go examples that set the stage for powerful, type-safe APIs."
---

# Defining Query Interfaces & Models

Welcome to the first critical step in harnessing GORM CLI’s powerful type-safe code generation: authoring your **query interfaces** embedded with SQL templates alongside your **model structs**. This page shows you how to craft simple, idiomatic Go code that lays a solid foundation for generating fluent, compile-time safe query APIs and field helpers tailored to your GORM project.

---

## 1. Understanding User Intent: Why Define Query Interfaces and Models?

You want to achieve **safe and ergonomic database access** by abstracting SQL logic into clear Go interfaces while letting GORM CLI generate the underlying implementation code automatically. Your models represent your database schema, and your query interfaces express how you want to query and manipulate that data with custom, reusable SQL templates.

This approach eliminates manual query boilerplate, increases maintainability, and empowers intuitive IDE assistance.

## 2. Structuring Your Package for Code Generation

To maximize clarity and code generation effectiveness:

- **Place your query interfaces and model structs in the same Go package or directory.**
- Ensure each interface documents SQL logic using method comments (SQL templates).
- Define model structs to mirror your database tables with standard Go struct fields.
- Organize supporting Go files logically, grouping related queries and models.

_Tip_: Keeping queries and models close simplifies configuration discovery and reduces errors during generation.

## 3. Writing Query Interfaces with Embedded SQL Templates

### Basic Interface Example

```go
// Query interface with generic type placeholder for model types.
type Query[T any] interface {
  // SELECT * FROM @@table WHERE id=@id
  GetByID(id int) (T, error)

  // where("name=@name AND age=@age")
  FilterByNameAndAge(name string, age int)
}
```

- Use method comments immediately above each method to write SQL or SQL templates.
- Use placeholder directives:
  - `@@table` to refer to the model’s table name automatically.
  - `@param` to bind Go parameters safely.
  - Inline directives like `{{where}}`, `{{set}}` for conditional logic.

### Advanced SQL Template Example

```go
// SearchUsers allows conditional filtering using struct fields
// SELECT * FROM @@table
// {{where}}
//   {{if @user.Name}} name=@user.Name {{end}}
//   {{if @user.Age > 0}} AND age=@user.Age {{end}}
// {{end}}
SearchUsers(user User) ([]T, error)

// UpdateUser updates fields conditionally
// UPDATE @@table
// {{set}}
//   {{if user.Name != ""}} name=@user.Name, {{end}}
//   {{if user.Age > 0}} age=@user.Age {{end}}
// {{end}}
// WHERE id=@id
UpdateUser(user User, id int) error
```

This demonstrates:
- Embedding complex conditional SQL logic.
- Using Go struct fields to bind query parameters dynamically.

_Tip_: If a method is missing `context.Context` as a parameter, the CLI generator adds it automatically.

## 4. Defining Your Model Structs

Your model structs represent database tables and should follow Go best practices:

- Export all fields that map to database columns.
- Use GORM tags as needed to specify database column names or other metadata.
- Optionally provide `gen:"name"` struct tags for mapping to custom field helper types.

### Sample Model Struct

```go
package models

import (
  "time"
  "gorm.io/gorm"
)

type User struct {
  gorm.Model
  Name  string
  Age   int
  Email string
  // Use gen tag to customize field helper generation
  Profile string `gen:"json"`
  CreatedAt time.Time
}
```

This definition:
- Embeds `gorm.Model` for ID, timestamps, and soft delete.
- Adds fields representing typical columns.

### Best Practice

> Define your structs clearly and concisely. Avoid complex embedded or anonymous structs that might confuse the generator unless you intend to flatten fields.


## 5. Mapping Models and Fields to Field Helpers

GORM CLI generates field helper objects from your model structs enabling type-safe predicates and setters.

- Basic Go types (`string`, `int`, `bool`, `time.Time`) map automatically.
- Support is provided for nullable types like `sql.Null*` and custom mapped types, configurable via `genconfig.Config`.
- Use the `gen:"customName"` struct tag to specify a custom field helper mapping like `json` (see full example in config docs).

Example for JSON field mapping:

```go
// Custom JSON field helper will be used
Profile string `gen:"json"`
```


## 6. Putting It All Together: Example Workflow

Below is a minimal working example of your package setup for the generator:

```go
// file: examples/query.go

package examples

// Query interface for User model
// SELECT * FROM @@table WHERE id=@id
//
type Query[T any] interface {
  GetByID(id int) (T, error)
  FilterByNameAndAge(name string, age int)
}

// file: examples/models/user.go

package examples

import "gorm.io/gorm"

type User struct {
  gorm.Model
  Name string
  Age  int
}
```

Then run generation:

```bash
gorm gen -i ./examples -o ./generated
```


## 7. Practical Tips & Common Pitfalls

- **Keep your query interfaces simple initially.** Start with few methods and expand as needed.
- **Use `@@table` and `@@column` carefully.** They correspond to model table and field names.
- **Avoid complex embedded structs unless flattening fields;** the generator recursively includes embedded fields.
- **Add context.Context explicitly or omit it;** the generator inserts it automatically as needed.
- **Make sure your method returns are correct:** single error or (data, error) tuple.
- **Check method comments carefully for valid SQL syntax:** errors in templates will cause generation failures.

## 8. Troubleshooting Generation Issues

If your generation fails or produces unexpected code:

- Verify your query method comments are properly formatted SQL templates.
- Check your models for exported fields and proper tags.
- Run the CLI with verbose logging to surface parsing errors.
- Confirm no duplicate interface or struct names conflicting in your package.

For more help, see the [Troubleshooting Common Setup Issues]( /getting-started/troubleshooting-and-validation/common-issues ) guide.

---

## 9. What’s Next?

After defining your query interfaces and models:

1. Proceed to [Running the Generator]( /getting-started/first-run-and-validation/generating-code ) to produce your type-safe query implementations.
2. Explore [Using the Generated APIs]( /getting-started/first-run-and-validation/using-generated-apis) for integrating the generated code in your application.
3. Learn about advanced configurations at [Configuring the CLI]( /getting-started/setup-essentials/configuring-cli ) to tailor generation behavior.

---

<Info>
This page focuses exclusively on authoring the core source code inputs: your **query interfaces with embedded SQL templates** and your **Go model structs**. For installation and runtime steps, please refer to other parts of the Getting Started documentation.
</Info>

---

## Appendix: SQL Template DSL Overview

| Directive | Description | Example |
|-----------|-------------|---------|
| `@@table` | Model table name placeholder | `SELECT * FROM @@table` |
| `@@column` | Dynamic column binding | `WHERE @@column=@value` |
| `@param`   | Parameter binding from Go method params | `WHERE name=@name` |
| `{{where}}`| Conditional WHERE clause block | `{{where}} age > 18 {{end}}`
| `{{set}}`  | Update SET clause conditional block | `{{set}} name=@name {{end}}`
| `{{if}}`   | Conditional SQL fragment | `{{if age > 0}} AND age=@age {{end}}`
| `{{for}}`  | Iteration over collections | `{{for _, tag := range tags}} ... {{end}}`

Crafting your queries with these allows dynamic, readable, and maintainable interfaces.

---

## Code Example Reminder

```go
// Query interface example
// SELECT * FROM @@table WHERE id=@id
GetByID(id int) (T, error)

// Model example
// type User struct with exported fields

type User struct {
  gorm.Model
  Name string
  Age int
}
```

With this, you're ready to generate powerful, type-safe, and efficient data access layers using GORM CLI.
