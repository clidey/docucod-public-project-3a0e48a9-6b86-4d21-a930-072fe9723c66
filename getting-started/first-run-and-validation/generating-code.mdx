---
title: "Running the Generator"
description: "Execute your first code generation run with `gorm gen`. Understand CLI options, common directory setups, and how generated code appears. Visual walkthroughs anchor expectations, so you immediately see results in your `generated` (or custom) output directory."
---

# Running the Generator

Welcome to the pivotal step where you execute your first code generation run with the `gorm gen` command. This guide takes you through using the CLI with precise options, understanding common directory layouts, and inspecting the generated output to validate success immediately.

---

## 1. Prepared? Confirm Your Setup

Before generating code, verify these essentials:

- Your query interfaces and model structs are properly defined with SQL templates in Go source files (e.g., `examples/query.go`).
- The GORM CLI tool is installed (`go install gorm.io/cli/gorm@latest` with Go 1.18+).
- Your working directory reflects the source layout where interfaces reside.

<Tip>
Having a clean project directory with a dedicated place for generated files (like a `generated/` folder) simplifies output management and code review.
</Tip>

---

## 2. Run `gorm gen` with Required CLI Flags

The core command is:

```bash
gorm gen -i <input-path> -o <output-path>
```

Where:
- `-i`, `--input`: Path to the Go source file or directory containing your query interfaces with embedded SQL comments.
- `-o`, `--output`: Directory where generated Go files will be placed.

### Example Usage

Assuming your interfaces are in `./examples` and you want output to `./generated`:

```bash
gorm gen -i ./examples -o ./generated
```

This runs the generator over all suitable files inside the `examples` directory.

<Check>
Remember to use the exact path where your interfaces exist and ensure your terminal is in the right project root.
</Check>

---

## 3. Understand How the Generator Finds and Filters Code

- The generator recursively processes Go source files under the input path.
- It looks for interfaces annotated with SQL templates and Go structs for your models.
- A package-level configuration file (named or declared as `genconfig.Config`) can further filter which interfaces and structs are included or excluded.

<Tip>
If you have declared an `OutPath` or interface inclusion/exclusion rules in your `genconfig.Config`, the CLI honors those without needing extra CLI flags.
</Tip>

---

## 4. Inspecting Generated Code

After completion, check your output directory (`generated` in the example) for generated Go source files.

- Generated files mirror the input directory structure.
- Each interface produces a strongly typed Go file with method implementations based on your SQL templates.
- Model structs are enhanced with field helper types for predicates and updates.

### What to Look For

- Files with names reflecting your input files (e.g., `query.go` ➔ `query.go` in `generated/`).
- Well-formed Go code with generated comments such as:

  ```go
  // Code generated by 'gorm.io/cli/gorm'. DO NOT EDIT.
  ```

- Methods with SQL generation logic matching your interface method comments.

### Example Terminal Output

```text
Generating file ./generated/examples/query.go from ./examples/query.go...
```

If you see a success message like above and the output files appear, your generation was successful.

---

## 5. Common Directory Layouts for Generation

Here's how projects typically organize source and generated code:

```
/project-root
  /examples
    query.go           # Source interfaces with SQL templates
    models/
      user.go          # Go structs for DB models
  /generated
    examples/
      query.go         # Generated code output
```

- Input paths point to `examples` (packages holding queries and models).
- Output paths point to `generated`.

You can customize these paths freely but keeping generated code separate ensures your IDE and version control are clean.

---

## 6. Verify Results Programmatically

Try importing and using the generated code in your project to confirm it integrates properly:

```go
import "your/project/generated/examples"

func main() {
  // Assume db is your *gorm.DB instance
  q := examples.Query[models.User](db)
  user, err := q.GetByID(ctx, 123)
  if err != nil {
    log.Fatalf("Failed to get user: %v", err)
  }
  fmt.Println(user.Name)
}
```

Successful compilation and runtime calls validate your generated code.

---

## 7. Troubleshooting Common Issues

<AccordionGroup title="Troubleshooting Generation Problems">
<Accordion title="No Output Files Generated">
- Verify the `-i` input path points to your interface source file/folder.
- Check that interfaces have SQL template comments (e.g., `// SELECT * FROM ...`).
- Confirm no interface filters (Inclusions/Exclusions) omit your interfaces via configuration.
</Accordion>
<Accordion title="Syntax Errors in Generated Code">
- Confirm you wrote valid Go code in your interfaces and models.
- Look for unclosed or malformed SQL template comments.
- Run `go fmt` or `golangci-lint` on your sources to catch model or interface errors beforehand.
</Accordion>
<Accordion title="Permission or Write Errors on Output">
- Ensure you have write access to the output directory.
- If files exist, verify they're not immutable or locked.
- Try running the CLI with elevated privileges or change output dirs.
</Accordion>
</AccordionGroup>

<Tip>
Run the generator with verbose/logging enabled if you modify the source – this may be via manual logging in your setup or by watching the CLI output closely.
</Tip>

---

## 8. Next Steps

- Proceed to using the generated query APIs in your application code ([Using the Generated APIs](/getting-started/first-run-and-validation/using-generated-apis)).
- Customize generation by adjusting your model and interface annotations ([Configuring the CLI](/getting-started/setup-essentials/configuring-cli)).
- Explore advanced querying features via templated SQL in your interfaces ([Using Template SQL & DSL in Custom Queries](/guides/advanced-patterns/template-sql-dsl)).

---

## Summary
Running the `gorm gen` command is a straightforward yet powerful step that turns your annotated query interfaces and models into type-safe, fluent Go APIs integrated with GORM. Following this guide ensures you correctly specify input/output paths, understand the output structure, and validate your generated code for immediate use. Troubleshooting tips prepare you to overcome common pitfalls, accelerating your journey to productive database access code.

---

## Recommended Reading

- [Defining Query Interfaces & Models](../defining-interfaces-models) — Craft interfaces your generator understands
- [Using the Generated APIs](../using-generated-apis) — Learn how to consume generated code
- [Configuring the CLI](../../setup-essentials/configuring-cli) — Customize generation with config files
- [Troubleshooting Common Setup Issues](../../troubleshooting-and-validation/common-issues) — Solve generation and usage errors

---