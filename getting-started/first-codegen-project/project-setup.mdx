---
title: "Project Setup & Model Definition"
description: "Define your models and query interfaces as the foundation for generating type-safe APIs. This page guides you on structuring your source files and what sample code to write before generation."
---

# Project Setup & Model Definition

Establishing a solid foundation by defining your Go models and query interfaces is the essential first step in generating type-safe, fluent GORM query APIs. This guide walks you through structuring your source files and crafting the necessary interface and model code before you proceed to code generation.

---

## 1. Project Structure and Source File Organization

To achieve efficient and logical generation, organize your code so that your Go model structs and query interfaces reside within the same package or directory. This allows the GORM CLI generator to process them together seamlessly.

Example project layout:

```plaintext
project-root/
├── models/
│   └── user.go          # User struct definition
├── queries/
│   └── query.go         # Query interface definitions
├── main.go              # Application entry
```

> The generator accepts a directory or file path as input, making it flexible to process multiple source files together.

---

## 2. Define Your Models

Models are standard Go structs representing your database tables. These should be designed with exported fields and GORM tags as needed.

### Basic Model Example

```go
package models

import "gorm.io/gorm"

type User struct {
  gorm.Model
  Name    string
  Age     int
  Role    string
  IsAdult bool
}
```

### Key Points

- Ensure fields are exported (start with uppercase) for visibility.
- Use GORM tags if you want to customize column names or behaviors.
- Associations such as has-one, has-many, belongs-to are supported and will generate powerful association helpers.

---

## 3. Define Query Interfaces with SQL Templates

Core to GORM CLI is generating type-safe query APIs from your interfaces. Define one or more Go interfaces with method signatures and embed SQL query templates as comments above each method.

### Example Query Interface

```go
package queries

type Query[T any] interface {
  // SELECT * FROM @@table WHERE id=@id
  GetByID(id int) (T, error)

  // where("name=@name AND age=@age")
  FilterByNameAndAge(name string, age int)

  // UPDATE @@table
  // {{set}}
  //   {{if user.Name != ""}} name=@user.Name, {{end}}
  //   {{if user.Age > 0}} age=@user.Age, {{end}}
  //   {{if user.Age >= 18}} is_adult=1 {{else}} is_adult=0 {{end}}
  // {{end}}
  // WHERE id=@id
  UpdateUser(user User, id int) error
}
```

### Template DSL Highlights

- `@@table`: Replaced with the table name corresponding to the model `T`.
- `@param`: Bindings to method parameters, including structs with field access (e.g., `@user.Name`).
- `{{where}}` / `{{set}}`: Conditional clauses for flexible SQL generation.
- `{{if}}` / `{{for}}`: Conditionals and loops for dynamic query building.

### Tips

- Method names become fluent API methods.
- Methods returning results must follow GORM CLI rules: the last return type must always be `error`.
- Generation injects `context.Context` if not present in the parameter list to support cancellation and tracing.

---

## 4. Writing Your First Interface and Model

A practical minimal setup:

```go
package examples

import "gorm.io/gorm"

type User struct {
  gorm.Model
  Name string
  Age  int
}

// Query interface
// SELECT * FROM @@table WHERE id=@id
// This method fetches a user by ID.
type Query[T any] interface {
  GetByID(id int) (T, error)

  // where("age > @age")
  FilterByAge(age int)
}
```

This file can be named `examples/user.go` or separated as models and queries files under the same package.

---

## 5. Validation Before Generation

Ensure your Go source files compile cleanly and export the interfaces and models as expected. The CLI generator relies on valid Go code to parse and process these types.

Use your editor or run:

```bash
go build ./...
```

To verify no errors exist.

---

## 6. Common Pitfalls

<Tip>
- Interface methods must return `error` as the last value; this enables error propagation from generated code.
- Methods that execute queries returning a single item generally return `(T, error)`.
- Methods building query chains without immediate execution can omit return values or return interfaces.
- Always place SQL template comments immediately above the method declaration.
- Use `@@table` to refer to the current model’s table reliably.
</Tip>

<Warning>
Avoid mixing unrelated models and interfaces in the same directory without proper configuration, as the generator processes them all together.
</Warning>

---

## 7. Summary

By defining your models and query interfaces with embedded SQL templates, you lay the foundation for GORM CLI to generate type-safe APIs and powerful field helpers. Organize your code well, follow the template syntax, and ensure error signatures are correct.

Next, you are ready to run the generator CLI command to produce your generated code.


---

## Additional Resources

- [Installation Instructions](/getting-started/prerequisites-installation/cli-installation)
- [Generating Code](/getting-started/first-codegen-project/generate-code)
- [Using the Generated APIs](/getting-started/first-codegen-project/quickstart-usage)
- [Template DSL Reference](#)  

---

## Example Workflow Recap

<Steps>
<Step title="Define Models and Query Interfaces">
Create Go structs and interfaces with SQL comments as shown above.
</Step>
<Step title="Organize Your Source Files">
Place related models and interfaces in the same package/directory.
</Step>
<Step title="Verify Code Compiles">
Run `go build ./...` to ensure no syntax errors.
</Step>
<Step title="Run Code Generation">
Use the CLI command:
```bash
gorm gen -i ./path/to/your/source -o ./generated
```
</Step>
</Steps>

---

## Troubleshooting

<AccordionGroup title="Configuration and Common Issues">
<Accordion title="No Methods Detected in Interface">
Check that your interfaces' methods are exported and have SQL annotations immediately above them.
</Accordion>
<Accordion title="Generator Skips Files or Types">
Ensure your files are within the specified input path, and check for any exclusion configurations applied via `genconfig.Config`.
</Accordion>
<Accordion title="Missing `context.Context` in Generated Methods">
Generator injects `context.Context` if omitted; however, explicit declaration can help clarity. Always check method signatures.
</Accordion>
</AccordionGroup>

---

## Example: Minimal `query.go`
```go
package examples

type Query[T any] interface {
  // SELECT * FROM @@table WHERE id=@id
  GetByID(id int) (T, error)
}
```

---

By completing these steps, your project is properly prepared to generate robust and type-safe database query APIs with GORM CLI.


