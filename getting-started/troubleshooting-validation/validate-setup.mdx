---
title: "Validate Your Setup"
description: "Learn how to quickly test generated APIs within your project. Provides sample function calls and expected behaviors, ensuring that your environment and code scaffolding work as intended."
---

# Validate Your Setup

Welcome to the crucial step where you validate that your GORM CLI setup, generated code, and environment are working together flawlessly. This guide walks you through practical checks by running generated APIs in your project to confirm your code scaffolding produces the expected behaviors — empowering you to confidently proceed with your development.

---

## 1. Purpose of Validation

Before launching into full-scale development with GORM CLI’s generated code, it’s essential to verify:

- Your Go environment and dependencies are correctly configured.
- The CLI has generated type-safe query interfaces and model field helpers properly.
- Generated code integrates cleanly with your project.
- Sample operations run without errors.

This ensures that you catch any common setup issues early and gain a concrete understanding of how to interact with generated APIs.

---

## 2. Setup a Test Environment

To validate effectively, prepare a dedicated test environment or directory in your project:

- Use a separate Go test file or package (e.g., `examples/output/test_helpers_test.go`) to isolate validation code.
- Use an in-memory or disposable test database such as SQLite for safe and fast verification.
- Prepare basic models and your generated package imports.

> If you followed the recommended code generation paths (like `-o ./generated`), your generated code will be in a predictable location for imports.

---

## 3. Write Sample Test Code to Validate Generated APIs

The key to validation is running simple CRUD operations using the generated APIs for your models. The following example demonstrates the workflow using a `User` model and query interface:

```go
package examples

import (
  "context"
  "testing"

  "gorm.io/cli/gorm/examples/models"
  "gorm.io/cli/gorm/examples/output" // Adjust to your generated output package path
  "gorm.io/driver/sqlite"
  "gorm.io/gorm"
)

// setupTestDB creates a fresh in-memory database, migrates schemas, and returns the DB instance
func setupTestDB(t *testing.T) *gorm.DB {
  dsn := "file::memory:?cache=shared"
  db, err := gorm.Open(sqlite.Open(dsn), &gorm.Config{})
  if err != nil {
    t.Fatalf("failed to open database: %v", err)
  }

  // AutoMigrate your models
  if err := db.AutoMigrate(&models.User{}, &models.Account{}, &models.Pet{}); err != nil {
    t.Fatalf("failed to migrate schema: %v", err)
  }

  return db
}

func TestValidateGeneratedUserAPI(t *testing.T) {
  db := setupTestDB(t)
  ctx := context.Background()

  // Use the generated query interface for User
  userQuery := output.Query[models.User](db)

  // Create a user
  user := models.User{Name: "Alice", Age: 30}
  if err := db.Create(&user).Error; err != nil {
    t.Fatalf("failed to create user: %v", err)
  }

  // Retrieve user by ID using generated GetByID method
  fetched, err := userQuery.GetByID(ctx, int(user.ID))
  if err != nil {
    t.Fatalf("GetByID failed: %v", err)
  }

  if fetched.Name != "Alice" {
    t.Errorf("expected user Name 'Alice', got %s", fetched.Name)
  }

  // Use FilterWithColumn method to query user
  filteredUser, err := userQuery.FilterWithColumn(ctx, "name", "Alice")
  if err != nil {
    t.Fatalf("FilterWithColumn failed: %v", err)
  }

  if filteredUser.Age != 30 {
    t.Errorf("expected Age 30, got %d", filteredUser.Age)
  }

  // Update user info
  err = userQuery.UpdateInfo(ctx, models.User{Name: "AliceUpdated", Age: 31}, int(user.ID))
  if err != nil {
    t.Fatalf("UpdateInfo failed: %v", err)
  }

  // Verify update
  updatedUser, err := userQuery.GetByID(ctx, int(user.ID))
  if err != nil {
    t.Fatalf("GetByID after update failed: %v", err)
  }

  if updatedUser.Name != "AliceUpdated" || updatedUser.Age != 31 {
    t.Errorf("update validation failed: got %+v", updatedUser)
  }
}
```

---

## 4. What to Expect

- The test sets up a clean in-memory database with migrations.
- Generated query interfaces are used directly to perform standard database operations.
- No runtime errors should occur during method invocations.
- Retrieved data should match the inserted/updated values.
- This confirms that your generated code, SQL annotations, and underlying database schema align.

---

## 5. Common Validation Pitfalls and How to Avoid Them

- **Generated code import errors**: Ensure your `-o` output path is correct and your `go.mod` includes the generated package import.
- **Model mismatch**: Verify your models match the schema expected by GORM and are included in migrations.
- **SQL annotation errors**: If generated methods don’t exist or cause compilation errors, recheck your query interface annotations.
- **Database connectivity**: For tests, prefer SQLite in-memory to isolate from external DB issues.

<Tip>
Always run `go test` in your test package to verify end-to-end correctness of the generated code.
</Tip>

---

## 6. Next Steps After Validation

Once your validation passes:

- Proceed to write application-specific query interfaces and model updates.
- Explore advanced generated APIs like association helpers for relational data operations.
- Consult the guides:
  - [Create Models and Query Interfaces](../project-initialization/first-query-interface)
  - [Generate Code with the CLI](../project-initialization/run-generator)
  - [Using the Generated APIs in Real Projects](../../guides/core-workflows/using-generated-apis)

You are now ready to unlock the full benefits of type-safe, model-driven querying with GORM CLI!

---

## 7. Troubleshooting Validation Issues

If you encounter errors during validation:

- Confirm Go version is 1.18 or higher.
- Verify CLI installation: run `gorm gen --help` to display commands.
- Check that your input directory or file path is correct for the generator.
- Ensure your interface methods have proper SQL template comments.
- Rebuild the generated code by running the CLI and recompiling your project.

Refer to [Common Issues & Troubleshooting](/getting-started/troubleshooting-validation/common-issues) for detailed solutions.

---

## Summary
Validating your setup through test routines gives you direct feedback that your GORM CLI environment is correctly installed and generating usable code. By exercising generated query interfaces and successively running typical CRUD operations, you ensure your project is ready to benefit from safer and more expressive database code.


---

# Related Documentation

- [Install the GORM CLI](/getting-started/setup/installation)  
- [Create Models and Query Interfaces](/getting-started/project-initialization/first-query-interface)  
- [Generate Code with the CLI](/getting-started/project-initialization/run-generator)  
- [Using the Generated APIs in Real Projects](/guides/core-workflows/using-generated-apis)  
- [Common Issues & Troubleshooting](/getting-started/troubleshooting-validation/common-issues)