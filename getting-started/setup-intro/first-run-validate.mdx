---
title: "First Run & Quick Validation"
description: "Demonstrates how to verify your installation with a simple CLI invocation, validating basic usage and tool visibility. Ensures your environment is correctly set before moving to code generation."
---

# First Run & Quick Validation

This guide will walk you through verifying your GORM CLI installation with a simple command to validate your environment and tool visibility. Ensuring that the CLI is correctly installed and operational is essential before proceeding to code generation and advanced workflows.

---

## 1. Verify Installation

After installing the GORM CLI tool, the very first step is to confirm that the CLI is accessible and functioning in your terminal environment.

### Step 1: Confirm `gorm` Command Availability

Open your terminal or command prompt and run:

```bash
gorm --help
```

**Expected Outcome:**
- The CLI outputs usage information explaining the available commands.
- No command not found or similar errors.

### Troubleshooting

- If the command is not recognized:
  - Ensure your `$GOPATH/bin` or Go `bin` directory is included in your system `PATH`.
  - Confirm you installed the CLI with the command:

    ```bash
go install gorm.io/cli/gorm@latest
    ```

- Restart your terminal after installation to refresh environment variables.

---

## 2. Execute a Simple Generator Command

The `gen` command is the core generator that processes your Go interfaces annotated with SQL templates.

### Step 2: Prepare a Minimal Interface File

Create a file named `example_query.go` with a minimal valid interface to test generation.

Example:

```go
package examples

// Query interface for testing
// SELECT 1
//
// SimpleQuery runs a simple SQL statement
//
type Query interface {
  // SELECT 1
  SimpleQuery() (int, error)
}
```

Place this file inside a directory (e.g., `./examples`).

### Step 3: Run the Code Generator

Invoke the generator by running:

```bash
gorm gen -i ./examples -o ./generated
```

**Options:**
- `-i ./examples`: Input directory where your Go interface file is.
- `-o ./generated`: Output directory where generated code will be saved.

### Expected Outcome:
- CLI outputs messages indicating file generation, e.g., "Generating file ./generated/query_gen.go from ./examples/example_query.go..."
- The `./generated` directory contains the generated Go files.

### Troubleshooting

- If you receive errors about the input path, verify the directory and file permissions.
- Ensure your interface follows GORM CLIâ€™s expected format with SQL annotations in comments.

---

## 3. Validate the Generated Code

After generation, verify the correctness and usability of the generated output.

### Step 4: Inspect the Generated Files

Check the output directory:

- Confirm generated files exist matching your input interfaces.
- Open any generated file to see type-safe methods corresponding to your interfaces.

### Step 5: Run a Basic Test Using the Generated Code

If your project includes test files or you create a minimal one, run:

```bash
go test ./generated
```

This validates that generated code compiles and that test cases run.

### Troubleshooting

- If tests fail, review your interface annotations for compliance with expected SQL template DSL.
- Check your Go environment variables and dependencies.

---

## 4. Environment Checks & Common Issues

### Common Pitfalls

- **Missing Go 1.18 or higher:** Ensure your Go version supports generics, which GORM CLI depends on.
- **Incorrect module path:** The `-i` input path should point to the directory or file with your interfaces.
- **Empty generation output:** The CLI skips generation if no matching interfaces or structs are found or filtered out by config.

### Tips

- Use a minimal interface file initially to confirm tool operability before expanding.
- Make sure your Go project modules are tidy and dependencies resolved (run `go mod tidy`).
- You can enable verbose/debug output by setting the environment variable `DEBUG=true` to get detailed logs during generation.

---

## 5. Next Steps

After successfully validating your first run:

- Proceed to write robust query interfaces with SQL templates as per [Defining Models & Query Interfaces](/getting-started/initial-usage/defining-models-interfaces).
- Explore code generation options and configuration in [Generating Code with GORM CLI](/getting-started/initial-usage/generating-code).
- Review practical usage in the [Quickstart Workflow](/overview/architecture-usage-integration/quickstart-workflow).

---

<Check>
Confirm that your CLI is properly installed and functional before moving forward with writing query interfaces and generating code. This verification step prevents wasted effort and ensures a smooth development experience.
</Check>

---

## Appendix: Sample Quick Validation Bash Script

For users comfortable with shell scripting, this script checks CLI availability and does a simple generation:

```bash
#!/bin/bash
set -e

if ! command -v gorm &> /dev/null
then
  echo "Error: gorm CLI not found in PATH."
  exit 1
fi

echo "gorm CLI found, version:"
gorm --help | head -5

# Create temporary directory for example
mkdir -p ./tmp_examples
cat > ./tmp_examples/query.go <<EOF
package tmp_examples

type Query interface {
  // SELECT 1
  SimpleQuery() (int, error)
}
EOF

gorm gen -i ./tmp_examples -o ./tmp_generated

if [ -f ./tmp_generated/query_gen.go ]; then
  echo "Generation succeeded: ./tmp_generated/query_gen.go created"
else
  echo "Generation failed: output file not found"
  exit 1
fi

rm -rf ./tmp_examples ./tmp_generated

exit 0
```

Run with:

```bash
bash quick_validation.sh
```

---

## References

- [Installing GORM CLI](/getting-started/setup-intro/installing-cli)
- [Defining Models & Query Interfaces](/getting-started/initial-usage/defining-models-interfaces)
- [Quickstart Workflow](/overview/architecture-usage-integration/quickstart-workflow)
- [Generating Code with GORM CLI](/getting-started/initial-usage/generating-code)

---

By following this guide, you ensure your GORM CLI setup is validated and ready, setting a firm foundation for building type-safe, efficient data access layers in your Go projects.
