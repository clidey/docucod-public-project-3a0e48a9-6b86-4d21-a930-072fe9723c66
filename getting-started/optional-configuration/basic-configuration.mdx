---
title: "Basic Generation Config"
description: "Introduces optional configuration via `genconfig.Config` for customizing output directories, field mappings, and included types. Ideal for users whose project layouts or field types differ from the standard."
---

# Basic Generation Config

GORM CLI offers powerful optional configuration via the `genconfig.Config` struct that allows you to customize how your code is generated on a per-package basis. This customization is ideal for users whose project layouts diverge from standard conventions or who want precise control over output directories, field mappings, and selection of types to include or exclude.

This guide walks you through practical usage of `genconfig.Config`, helping you tailor generated code to your project's needs.

---

## Why Use Generation Configuration?

By default, GORM CLI generates query APIs and model-driven field helpers into directories and files following convention. However, projects often contain specialized layouts, custom field types, or need to limit generation scope. `genconfig.Config`:

- Overrides default output paths for generated files.
- Maps Go types or `gen` tag names to custom field helper wrappers.
- Controls which interfaces and struct models get included or skipped during code generation.
- Handles file-level versus package-level generation control.

This flexibility unlocks a smooth integration into existing or complex project structures.

---

## 1. Declaring a `genconfig.Config`

Place a `var _ = genconfig.Config{ ... }` declaration at the package-level within a source file in the package where generation will occur. The generator auto-detects these declarations when scanning your code.

### Example Basic Configuration

```go
package examples

import (
    "database/sql"
    "gorm.io/cli/gorm/field"
    "gorm.io/cli/gorm/genconfig"
)

var _ = genconfig.Config{
    // Custom output directory for this package's generated files
    OutPath: "examples/output",

    // Map Go types to GORM CLI field helpers
    FieldTypeMap: map[any]any{
        sql.NullTime{}: field.Time{},
    },

    // Map `gen` tag names to field helpers
    FieldNameMap: map[string]any{
        "date": field.Time{},   // e.g. fields tagged `gen:"date"` get Time helper
        "json": JSON{},        // use custom JSON helper for fields tagged `json`
    },

    // Include only specific interfaces or structs (optional)
    IncludeInterfaces: []any{"Query*"},
    IncludeStructs:    []any{"User", "Account"},

    // Exclude deprecated or unwanted interfaces/structs
    ExcludeInterfaces: []any{"*Deprecated*"},
    ExcludeStructs:    []any{"*DTO"},

    // Set to true to limit config scope to the declaring source file only
    FileLevel: false,
}
```

---

## 2. Configuration Options Explained

| Field              | Purpose                                                                                     | Example Values                          |
|--------------------|---------------------------------------------------------------------------------------------|---------------------------------------|
| **OutPath**        | Overrides default output directory for generated code in this package                       | "examples/output"                     |
| **FieldTypeMap**   | Maps Go type instances to field helper instances, enabling custom type wrapping             | `sql.NullTime{}: field.Time{}`         |
| **FieldNameMap**   | Maps field `gen` tag names to specific field helper types                                  | `"json": JSON{}`                      |
| **FileLevel**      | When `true`, applies config only to the declaring source file, not the entire package       | `true` or `false`                      |
| **IncludeInterfaces** | Whitelist of interfaces for code generation; supports shell patterns and typed nil values  | `[]any{"Query*"}`, `[]any{models.Query(nil)}` |
| **ExcludeInterfaces** | Blacklist of interfaces to skip generation, applied after IncludeInterfaces                 | `[]any{"*Deprecated*"}`              |
| **IncludeStructs** | Whitelist of structs for code generation; supports patterns and type literals               | `[]any{"User", models.User{}}`       |
| **ExcludeStructs** | Blacklist of structs to skip, applied after IncludeStructs filtering                        | `[]any{"*DTO"}`                      |

---

## 3. Practical Configuration Examples

### Example A: Simple Output Directory and Field Mapping

```go
var _ = genconfig.Config{
    OutPath: "generated/models",
    FieldTypeMap: map[any]any{
        sql.NullTime{}: field.Time{},
    },
    FieldNameMap: map[string]any{
        "json": JSON{},
    },
}
```

This example moves generated output to a `generated/models` folder and makes fields tagged `json` use a custom JSON helper.

---

### Example B: Selectively Generate Only Query Interfaces Starting With "Query"

```go
var _ = genconfig.Config{
    IncludeInterfaces: []any{"Query*"},
}
```

Only interfaces with names starting with "Query" are generated. This scoping avoids generating unwanted interfaces.

---

### Example C: Exclude Deprecated Interfaces

```go
var _ = genconfig.Config{
    ExcludeInterfaces: []any{"*Deprecated*"},
}
```

Skips generating any interface with "Deprecated" in its name.

---

### Example D: File-Level Scoped Config

```go
var _ = genconfig.Config{
    OutPath:   "custom/output",
    FileLevel: true,
}
```

Limits this configuration only to the current source file during generation, leaving other files in the package unaffected.

---

## 4. Workflow for Using `genconfig.Config`

<Steps>
<Step title="Step 1: Define Your Config">
Place a `genconfig.Config` variable in a source file within the package where you want custom generation behavior.
</Step>
<Step title="Step 2: Customize Output and Mappings">
Set `OutPath`, `FieldTypeMap`, and `FieldNameMap` as needed for your project requirements.
</Step>
<Step title="Step 3: Control Generation Scope">
Use `IncludeInterfaces`, `ExcludeInterfaces`, `IncludeStructs`, and `ExcludeStructs` to restrict what gets generated.
</Step>
<Step title="Step 4: Run Code Generation">
Invoke the CLI as usual with `gorm gen -i ./your/package`.
The generator picks up the configuration automatically.
</Step>
<Step title="Step 5: Verify Output">
Check the configured output directory for generated code files.
Ensure that generated code respects your field mappings and type filters.
</Step>
</Steps>

---

## 5. Tips and Best Practices

- **FieldNameMap Has Priority:** When both `FieldNameMap` and `FieldTypeMap` apply, the generator uses `FieldNameMap`.
- **Use Typed Instances:** Prefer using typed instances like `sql.NullTime{}` and `field.Time{}` in maps rather than strings for better import and type resolution.
- **Shell Patterns Supported:** For include/exclude lists, leverage shell-style wildcard patterns (`"Query*"`, `"*Deprecated*"`) for flexible selection.
- **FileLevel for Granularity:** Use `FileLevel: true` to apply config narrowly to a single file if mixing different configs in one package.
- **Keep Config Close:** Locate your config file near the models/interfaces it applies to for easy maintenance.

---

## 6. Common Pitfalls & Troubleshooting

<AccordionGroup title="Common Generation Config Issues">
<Accordion title="Config Not Being Picked Up">
- Ensure the `genconfig.Config` variable is declared at package level (not inside a function).
- Confirm the file containing your config is included in the package build and scanned by the generator.
- Run the CLI with appropriate package import path or directory.
</Accordion>
<Accordion title="Field Mappings Not Working as Expected">
- Verify you use concrete type instances (e.g., `sql.NullTime{}`) as map keys, not types or strings.
- Remember `FieldNameMap` entries override `FieldTypeMap`.
- Check your field tags in model source match exactly the key names.
</Accordion>
<Accordion title="Include/Exclude Lists Not Filtering Correctly">
- Check pattern syntax for typos (should be shell glob-style).
- Confirm that `Include*` lists take precedence over `Exclude*`.
- Use type-conversion forms (e.g., `models.Query(nil)`) or string names consistently.
</Accordion>
</AccordionGroup>

---

## 7. Additional References

- [GORM CLI README](https://github.com/go-gorm/cli/blob/main/README.md) — For full feature usage and examples
- [Template-Based Queries](../guides/advanced-usage-patterns/template-sql-queries) — To extend query capabilities
- [Custom Field Helper Mapping](./custom-field-mappings) — For advanced customization
- [Troubleshooting & Common Issues](../essentials/troubleshooting) — For to solve generation errors

---

## Summary
This guide introduced the `genconfig.Config` struct, providing you with flexible control over code generation in GORM CLI. You learned how to customize output paths, map fields to custom helpers, and control which interfaces and structs are generated, aligning with your project’s unique layout and requirements. Following these steps lets you tailor GORM CLI generation to fit your architecture seamlessly, speeding development and ensuring clean integration.

---

## Example Snippet Revisited

```go
package examples

import (
    "database/sql"
    "gorm.io/cli/gorm/field"
    "gorm.io/cli/gorm/genconfig"
)

var _ = genconfig.Config{
    OutPath: "examples/output",
    FieldTypeMap: map[any]any{
        sql.NullTime{}: field.Time{},
    },
    FieldNameMap: map[string]any{
        "date": field.Time{},
        "json": JSON{},
    },
    IncludeInterfaces: []any{"Query*"},
    ExcludeInterfaces: []any{"*Deprecated*"},
    IncludeStructs:    []any{"User", "Account"},
    ExcludeStructs:    []any{"*DTO"},
    FileLevel: false,
}
```

This configuration customizes output directory, types, and generation scope for this package.

---

For further customization options and advanced usage, see the [Custom Field Helper Mapping](./custom-field-mappings) guide.


---