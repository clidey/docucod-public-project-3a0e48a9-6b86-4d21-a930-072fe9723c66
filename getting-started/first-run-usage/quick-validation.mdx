---
title: "Validating Generated Code"
description: "Instructs users how to import and use the generated code within their projects, with simple usage examples. Offers tips for quickly checking that codegen results are as expected and compiles cleanly."
---

# Validating Generated Code with GORM CLI

This guide walks you through importing, reviewing, and testing the code generated by GORM CLI within your Go projects. You'll learn how to quickly check that your generated type-safe query APIs and model-driven field helpers compile cleanly and behave as expected, minimizing integration friction.

---

### 1. Importing Generated Code into Your Project

After you have run the GORM CLI to generate your query APIs and field helpers (e.g., via `gorm gen -i ./path/to/interfaces -o ./generated`), the next step is to use this generated code effectively within your Go modules.

1. **Add the generated code package to your module dependencies**

```go
import (
  "context"
  "gorm.io/gorm"
  "path/to/generated" // replace with your generated code module path
)
```

2. **Initialize the generated query interface or field helpers using your GORM database instance:**

```go
func useGenerated(db *gorm.DB) error {
  ctx := context.Background()

  // Example: Create a typed query interface for User model
  userQuery := generated.Query[User](db)

  // Example: Use the generated field helper for filtering by Age
  ageFilter := generated.User.Age.Gt(18)

  // Use generated API to query
  users, err := userQuery.FilterByAge(ctx, 18) // method name based on your interfaces
  if err != nil {
    return err
  }
  // Process users...

  // Alternatively, use field helpers with GORM for custom queries
  err = db.Where(ageFilter).Find(&users).Error
  if err != nil {
    return err
  }

  return nil
}
```


### 2. Quick Validation Checks

To verify your generated code is ready for use, perform these straightforward checks:

- **Compile-Time Verification**

  Run `go build` or `go test` in your module importing the generated code to ensure there are no syntax errors or missing dependencies.

  ```bash
  go build ./...
  go test ./...
  ```

- **Syntax Validation**

  Use a code editor or Go tooling (like `go vet`) which supports static analysis to identify any irregularities or unexpected issues.

- **Functional Smoke Test**

  Write a small test function that calls several generated query methods or uses field helpers with your actual database to confirm the functionality behaves as expected.

  ```go
  func TestGeneratedCode(t *testing.T) {
    db := setupTestDB()
    ctx := context.Background()

    userQuery := generated.Query[User](db)
    user, err := userQuery.GetByID(ctx, 1)
    if err != nil {
      t.Fatalf("failed to get user: %v", err)
    }
    if user.ID != 1 {
      t.Fatalf("expected user ID 1, got %v", user.ID)
    }

    users, err := userQuery.FilterByNameAndAge(ctx, "alice", 30)
    if err != nil {
      t.Fatalf("failed to filter users: %v", err)
    }
    t.Logf("Found %d users", len(users))
  }
  ```

### 3. Interpreting Generated Code Output

The generated Go files implement the interfaces and models you defined with embedded SQL annotations. Typical contents include:

- **Typed interfaces and struct implementations** providing type-safe, fluent APIs for query execution.
- **Model-driven field helpers** exposing strongly typed predicates and setters per struct field.

Use your IDE to navigate these generated files if desired, or read them as reference to understand the synthesized query logic and helper methods.

### 4. Best Practices for Validation

- **Source Control Integration**: Always check generated files into source control so the exact state is reproducible and consistent across developers.

- **Incremental Changes**: When updating interfaces or models, regenerate code and rerun validation before pushing changes.

- **Run Generator from Clean State**: Remove previous output (e.g., with `rm -rf ./generated`) and regenerate fresh to avoid stale artifacts.

- **Keep Generation Command and Configs Versioned**: Record `gorm gen` command flags and any package-level `genconfig.Config` to ensure consistent output.

### 5. Common Pitfalls & Troubleshooting

<AccordionGroup title="Troubleshooting Validation Issues">
<Accordion title="Generated Code Fails to Compile">
- Verify Go version eligibility (Go 1.18+ supporting generics).
- Confirm no conflicting imports or missing dependencies.
- Check your interfaces and models for syntax errors; malformed SQL templates can lead to incomplete generation.
- Regenerate after any interface or struct changes.
</Accordion>
<Accordion title="Method Not Found in Generated Interface">
- Ensure your interface method signatures match the conventions (return values must include an error).
- Review your SQL template comment placement and correctness.
- Check inclusion/exclusion filters in `genconfig.Config`.
</Accordion>
<Accordion title="Generated Files Are Not Updated">
- Clean output directory before running generator.
- Confirm the correct `-i` (input) and `-o` (output) paths are used.
- Verify no file-level config overrides cause selective generation.
</Accordion>
<Accordion title="Unexpected Generated Code Behavior at Runtime">
- Test on a real or staging database.
- Check that your SQL template placeholders and parameter bindings align with your method params.
- Use logging or debugging to inspect SQL and parameters.
- Verify field helper usage matches expected types.
</Accordion>
</AccordionGroup>

### 6. Example Validation Workflow

```bash
# Run generation
gorm gen -i ./examples -o ./generated

# Switch to your module and get dependencies
cd myapp
go mod tidy

# Build and test to verify compile-time correctness
go build ./...
go test ./...

# Run a quick functional test
go test -run TestGeneratedCode
```

### 7. Next Steps

- Explore [Defining Models & Query Interfaces](/getting-started/first-run-usage/defining-models-interfaces) to refine your inputs.
- Learn more about [Generating Code](/getting-started/first-run-usage/generating-code) and advanced flags.
- Dive into [Troubleshooting Setup & Generation Issues](/getting-started/first-run-usage/troubleshooting) for deeper problem resolution.
- Use [Best Practices for Interface Design and Query Safety](/guides/practices-integration/practices-patterns) to strengthen your generation approach.

---

<Check>
You have validated that your generated code compiles cleanly and runs expected query operations successfully inside your Go application.
</Check>

---

For detailed generation mechanics, visit the internal code overview and testing logic in the repository [source](https://github.com/go-gorm/cli). Common methods for validating syntax and behavior are built into the CLIâ€™s process, ensuring output is reliable.


---

This concludes your guide on validating generated code with GORM CLI. Confident use of the generated code empowers safer, faster database interactions in your Go projects.

---

# See Also
- [Generating Code](https://gorm.io/docs/cli.html#getting-started/first-run-usage/generating-code)
- [Defining Models & Query Interfaces](https://gorm.io/docs/cli.html#getting-started/first-run-usage/defining-models-interfaces)
- [Troubleshooting Setup & Generation Issues](https://gorm.io/docs/cli.html#getting-started/first-run-usage/troubleshooting)
- [Using Model-Driven Field Helpers](https://gorm.io/docs/cli.html#guides/core-getting-started/field-helper-basics)


---

# Additional Resources
- [GORM CLI GitHub repository](https://github.com/go-gorm/cli)
- [GORM Official Documentation](https://gorm.io/)


---