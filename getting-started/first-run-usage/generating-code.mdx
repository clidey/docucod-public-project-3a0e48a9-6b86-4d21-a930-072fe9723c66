---
title: "Generating Code"
description: "Shows how to execute the CLI to generate both type-safe query APIs and field helpers. Explains the command-line flags, expected output locations, and provides example CLI invocations."
---

# Generating Code with GORM CLI

This guide explains how to execute the GORM CLI code generator to produce both type-safe query APIs and model-driven field helpers. It covers essential command-line options, expected locations of generated code, and practical CLI examples to get your first generation running smoothly.

---

## 1. Overview

GORM CLI automates the generation of two key code artifacts:

- **Query APIs:** Type-safe, fluent interfaces generated from your Go interfaces that embed SQL templates.
- **Field Helpers:** Model-based, strongly typed helpers for filters, updates, ordering, and associations generated from your Go structs.

This page focuses on running the CLI tool to generate these artifacts and how to customize the generation process through command-line flags.

---

## 2. Prerequisites for Code Generation

Before generating code, make sure you have the following prepared:

- **Go interfaces with SQL annotations** for your queries defined in `.go` files.
- **Go structs representing your models** in the same package or directory.
- (Optional) A `genconfig.Config` object in your package to customize generation behavior.

You should already be familiar with defining your models and query interfaces as described on [Defining Models & Query Interfaces](/getting-started/first-run-usage/defining-models-interfaces).

---

## 3. Running the CLI to Generate Code

### CLI Command Structure

The primary command to generate code is:

```bash
gorm gen -i <input-path> [-o <output-path>]
```

- `-i, --input` **(required)**: Path to the directory or Go file containing your query interfaces and models with SQL templates.
- `-o, --output` (optional): Directory where generated code will be written. Defaults to `./g`.

### Step-by-Step Example

1. **Navigate to your project directory** containing your code, for example:

   ```bash
   cd ~/projects/my-gorm-service
   ```

2. **Execute the generator:**

   ```bash
   gorm gen -i ./examples -o ./generated
   ```

   This command processes the files in `./examples`, generates query APIs and field helpers, and writes them into `./generated`.

3. **Observe output:**

   During execution, you will see console messages like:

   ```plaintext
   Generating file ./generated/query.go from ./examples/query.go...
   ```

   Confirm there are no errors.

### Default Output Path

If you omit the `-o` flag, the generator writes to the default directory `./g`. You can then adjust your import paths accordingly when using generated code.

---

## 4. Understanding Generated Files and Locations

- **Output directory structure mirrors input:**

  The generator preserves the relative directory structure from your input path inside the output path.

- **Generated files are valid Go source files** with auto-generated query APIs and field helpers.

- **Package names match the input:**

  Each output file belongs to the same Go package as the input source files.

- **Example:**

  Input: `examples/query.go` outputs to `generated/query.go` (if `-o ./generated`).


---

## 5. Example CLI Invocations

Here are practical commands to generate code in common scenarios:

### Generate code for a single file

```bash
gorm gen -i ./examples/query.go
```

### Generate code for a package directory and specify output

```bash
gorm gen -i ./examples -o ./generated
```

### Use with a configuration package-level override

If you have a `genconfig.Config` declared with a custom `OutPath` inside your package, the generator will use it automatically to determine the output for files within that package.

---

## 6. Command-Line Flags Reference

| Flag       | Description                                        | Required | Default      |
|------------|--------------------------------------------------|----------|--------------|
| `-i, --input`    | Input path to Go interface files or directories   | Yes      | None         |
| `-o, --output`   | Output directory for generated code               | No       | `./g`         |

---

## 7. Tips & Best Practices

- **Maintain separation:** Keep your query interfaces and models organized in dedicated packages or directories to simplify generation.
- **Leverage configuration structs:** Use `genconfig.Config` to control output paths, include/exclude filters, and type mappings, reducing CLI complexity.
- **Incremental generation:** Run the generator whenever your interfaces or models change to keep generated code in sync.
- **Check generated code:** Always validate that the output compiles and reflects your intended queries and fields.

---

## 8. Common Issues & Troubleshooting

<AccordionGroup title="Common Generation Problems and Solutions">
<Accordion title="Input path is missing or incorrect">
Ensure the `-i` flag points to the correct file or directory containing your interfaces. The generator will fail if the path is invalid or empty.

Example fix:
```bash
gorm gen -i ./examples
```
</Accordion>
<Accordion title="Generated code does not appear in the expected directory">
Verify if you have configured a `genconfig.Config` with a custom `OutPath` in your package that overrides CLI `-o`. The generator honors this config for files within that package.

Check config and adjust `OutPath` or CLI flag accordingly.
</Accordion>
<Accordion title="Errors parsing interfaces or SQL templates">
Review your query interface methods and ensure SQL templates are valid and present in method comments as described in [Defining Models & Query Interfaces](/getting-started/first-run-usage/defining-models-interfaces).

Ensure your methods return the correct number and type of values (last must be `error`, etc.).
</Accordion>
<Accordion title="Go syntax errors in generated code">
Generated code should be well formatted and syntactically correct.

If you encounter errors:

- Check Go versions (Go 1.18+ recommended)
- Verify interface and model definitions
- Run `go fmt` on your codebase
</Accordion>
</AccordionGroup>

<Note>
Run `gorm gen --help` to see available flags and options for the generator.
</Note>

---

## 9. Next Steps

After generating code:

- Review and import the generated packages in your application code.
- Use generated query APIs and field helpers for type-safe database interactions.
- Explore advanced customization via [Configuring Generation](/overview/feature-tour/customization-config) to tune generation output.
- Continue to [Validating Generated Code](/getting-started/first-run-usage/quick-validation) to ensure generation correctness.

---

## 10. References

- [Defining Models & Query Interfaces](/getting-started/first-run-usage/defining-models-interfaces)
- [Configuring Generation](/overview/feature-tour/customization-config)
- [Validating Generated Code](/getting-started/first-run-usage/quick-validation)
- [Troubleshooting Setup & Generation Issues](/getting-started/first-run-usage/troubleshooting)

---

## 11. Summary Diagram: Code Generation Workflow

```mermaid
flowchart TD
  User["User: Go Developer"] --> Write["Write Go interfaces with SQL templates & Go structs"]
  Write --> GenCmd["Run 'gorm gen -i <input> -o <output>'"]
  GenCmd --> Process["GORM CLI processes input files"]
  Process --> Generate["Generates query APIs & field helpers"]
  Generate --> OutputDir["Written to output directory"]
  OutputDir --> Use["Import & use in app code"]
  Use --> Benefit["Enjoy type-safety & fluent DB queries"]

  subgraph ""
    Write
    GenCmd
    Process
    Generate
    OutputDir
    Use
  end

  classDef userNode fill:#cce5ff,stroke:#333,stroke-width:1px
  class User userNode
```

---

This completes the instructions for generating your first GORM CLI code artifacts.


---