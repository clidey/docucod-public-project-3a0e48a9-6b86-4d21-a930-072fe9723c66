---
title: "Quick Validation and Testing"
description: "Outlines simple validation steps to ensure GORM CLI is working as expected. Encourages verification using provided examples and test helpers, and suggests ways to check for common mistakes in setup or code generation."
---

# Quick Validation and Testing

Ensuring that GORM CLI is operating correctly after installation and initial setup is crucial for smooth development. This guide walks you through **simple, practical validation steps** to confirm that your environment and generated code are producing the expected results. These checks help you recognize common setup mistakes early and provide confidence in your GORM CLI usage.

---

## 1. Verify Generated Code Compilation

After running the code generator, the first indicator of success is that the generated Go code compiles without errors.

### Steps:

1. Run code generation:

   ```bash
   gorm gen -i ./examples/query.go -o ./generated
   ```

2. Build your Go project including the generated files:

   ```bash
   go build ./generated
   ```

3. Confirm there are no compile errors.

<Tip>
Compilation errors often hint at incorrect SQL template syntax or missing models/interfaces. Review your interface definitions and model structs if errors arise.
</Tip>

---

## 2. Run Unit Tests on Generated Code

The repository includes example test cases that exercise the generated APIs. Running these tests confirms functional validation beyond compiling.

### Steps:

1. Navigate to the generated code directory:

   ```bash
   cd ./generated
   ```

2. Execute tests:

   ```bash
   go test ./...
   ```

3. Look for test pass messages without failures.

<Check>
Passing tests demonstrate that SQL templates were rendered correctly and the generated methods behave as expected.
</Check>

### Common Pitfalls:

- Test failures caused by database connectivity mean you need to configure your DB or connection settings correctly.
- Mismatched model definitions cause method failures; double-check your Go structs.

---

## 3. Use Provided Example Interfaces for Functional Checks

You can run simple manual checks using the `examples/query.go` interface and accompanying query methods.

### Example:

1. Write a Go function to use the generated `Query` interface:

   ```go
   package main

   import (
       "context"
       "fmt"
       "gorm.io/cli/gorm/generated"  // Adjust import path
       "gorm.io/driver/sqlite"
       "gorm.io/gorm"
   )

   func main() {
       ctx := context.Background()
       db, err := gorm.Open(sqlite.Open("test.db"), &gorm.Config{})
       if err != nil {
           panic(err)
       }

       queryAPI := generated.Query[User](db)

       user, err := queryAPI.GetByID(ctx, 1)
       if err != nil {
           panic(err)
       }

       fmt.Printf("User: %+v\n", user)
   }

   type User struct {
       ID   int
       Name string
       Age  int
   }
   ```

2. Run the program and confirm it fetches data correctly without runtime errors.

### What to Validate:

- The method returns expected data or a no-results error without panics.
- SQL executed matches your template and includes correct parameters.

---

## 4. Check Template Rendering Using Test Helpers

The internal tests (`internal/gen/sqlparser_test.go`) validate SQL template parsing and rendering. While these are internal, you can leverage the pattern:

- Confirm that your query methods’ SQL templates produce the expected SQL strings.
- Look for suspicious whitespace, parameter mismatches, or unsupported directives.

---

## 5. Common Troubleshooting Tips

<AccordionGroup title="Troubleshooting Common Issues">
<Accordion title="Code Does Not Compile after Generation">
- Verify that your interfaces define return types correctly (error must be the last return).
- Confirm your models have exported fields matching the database columns.
- Check for syntax errors in SQL comments, especially in abbreviations like `@@table` and `@param`.
</Accordion>
<Accordion title="Generated Methods Return Unexpected Errors">
- Validate your DB connection settings and migration state.
- Confirm that context is properly passed in function calls.
- Look into your SQL templates for parameter misspelling or missing fields.
</Accordion>
<Accordion title="Tests Fail to Run or Find Expected Files">
- Check the output directory path passed to the generator.
- Ensure that the generated code files are included in your test module’s path.
- Review `genconfig.Config` for selective interface/struct filtering that may exclude needed code.
</Accordion>
</AccordionGroup>

---

## 6. Best Practices for Validation

- **Start Small:** Begin validation with simple query interfaces and models.
- **Use Context:** Always pass `context.Context` when invoking API methods to aid debugging.
- **Leverage Examples:** Use example code from the repository and adapt progressively.
- **Integrate Early:** Add generated code to your build and CI pipelines immediately to catch issues.

---

## 7. Next Steps

After confirming your setup works correctly:

- Proceed to [Using Generated APIs](../using-generated-apis) to learn how to integrate queries and helpers smoothly.
- Explore [Basic Configuration](../basic-configuration) to tailor output paths and field mappings.
- Try your [First Code Generation](../first-code-generation) with your own models and interfaces.


---

## References

- [Installing GORM CLI](/getting-started/onboarding-core/installing-gorm-cli)
- [Basic Configuration](/getting-started/onboarding-core/basic-configuration)
- [Your First Code Generation](/getting-started/onboarding-core/first-code-generation)
- [Using Generated APIs](/getting-started/onboarding-core/using-generated-apis)
- [Troubleshooting Common Setup Issues](/getting-started/onboarding-core/troubleshooting-setup)


---

By following this validation pathway, you ensure that GORM CLI is correctly set up, generating syntactically and functionally valid code fit for further development and integration.
