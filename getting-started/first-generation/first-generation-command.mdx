---
title: "Running Your First Code Generation"
description: "A hands-on walkthrough: running the 'gorm gen' command, what inputs and outputs to provide, and how to control output paths. Includes reference explanation of the generator's output."
---

# Running Your First Code Generation

This guide walks you through using the `gorm gen` command to generate your first type-safe query APIs and model-driven field helpers with GORM CLI. You will learn how to provide necessary inputs, control output paths, and understand the structure of the generated code.

---

## 1. Understanding the `gorm gen` Command

`gorm gen` is the core command of GORM CLI responsible for analyzing your Go source code (interfaces and models) and producing generated Go files. These files include concrete implementations of your query interfaces and field helpers that integrate seamlessly with GORM.

### Key Input Parameters

- **`-i` or `--input`**: The path to your Go interface file or directory. This must contain interfaces annotated with SQL templates as comments.
- **`-o` or `--output`**: The directory where generated code will be saved. Defaults to `./g` if not specified.


### Basic Command Structure

```bash
gorm gen -i <input-path> -o <output-path>
```

Example:

```bash
gorm gen -i ./examples -o ./generated
```

This command processes all Go files under `./examples`, generates code, and writes the results into the `./generated` folder.

---

## 2. Preparing Inputs

Before running the generator, ensure your project is structured as follows:

- **Query Interface(s)**: Place one or more Go interfaces with SQL template comments in your specified input path.

  Example interface method:

  ```go
  // SELECT * FROM @@table WHERE id=@id
  GetByID(id int) (T, error)
  ```

- **Model Structs**: Your data models must be present in the same package/directory or reachable by the generator.

- **Optional Configuration**: You can create a package-level `genconfig.Config` variable for advanced behaviors like output path overrides, filtering interfaces, or custom field type mappings. If absent, defaults apply.

---

## 3. Step-by-Step: Running Your First Generation

<Steps>
  <Step title='Step 1: Write your interfaces and models'>
    Create Go files defining your query interfaces with SQL templates and your models as structs. For example, place these in `./examples`.
  </Step>

  <Step title='Step 2: Run the generator'>
    Open a terminal in your project root and execute:

    ```bash
    gorm gen -i ./examples -o ./generated
    ```

    The CLI will:
    - Parse your input files
    - Extract interfaces and methods
    - Generate type-safe implementations and field helpers
    - Save generated source code in the `./generated` folder
  </Step>

  <Step title='Step 3: Verify generation output'>
    Check the output directory (`./generated`) for generated `.go` files. The CLI will print generation log messages like:

    ```
    Generating file ./generated/query.go from ./examples/query.go...
    ```

    Confirm the generated files contain your interfaces’ implementations and field helpers.
  </Step>
</Steps>

---

## 4. Controlling Output Paths and Filters

### Output Path Control

- By default, if no `-o` flag is given, the generator writes code to `./g`.
- You can override this with the `-o` flag on the CLI.
- Alternatively, define `OutPath` in a package-level `genconfig.Config` to control output paths per package/subdirectory.

### Interface and Struct Filtering

If you want to limit generation to specific interfaces or structs:

- Use your package-level `genconfig.Config` with `IncludeInterfaces` or `ExcludeInterfaces` slices.
- Similarly, control struct generation using `IncludeStructs` or `ExcludeStructs`.

Example config snippet:

```go
var _ = genconfig.Config{
  OutPath: "myoutput",
  IncludeInterfaces: []any{"Query*"},
}
```

This focuses generation on interfaces starting with "Query" and changes the output folder.

---

## 5. Understanding the Generator’s Output

### What’s Generated?

1. **Interface Implementations:** Concrete types implementing your query interfaces with fluent methods translating your SQL templates.

2. **Field Helpers:** Variables and helpers for struct fields for building expressive queries and updates safely.

### Example of Generated Code Elements

```go
// Query interface implementation
func Query[T any](db *gorm.DB, opts ...clause.Expression) _QueryInterface[T] {
    return _QueryImpl[T]{
        Interface: gorm.G[T](db, opts...),
    }
}

// Field helpers for User struct
var User = struct {
    ID    field.Number[int]
    Name  field.String
    Age   field.Number[int]
}{
    ID:   field.Number[int]{}.WithColumn("id"),
    Name: field.String{}.WithColumn("name"),
    Age:  field.Number[int]{}.WithColumn("age"),
}
```

This allows calling

```go
u, err := generated.Query[User](db).GetByID(ctx, 123)
users, err := gorm.G[User](db).Where(generated.User.Age.Gt(18)).Find(ctx)
```

---

## 6. Tips and Best Practices

- Always specify the input path (`-i`) to point to the root of your interfaces and models.
- Use `-o` to organize generated code separate from your handwritten source files.
- Start with basic interfaces and SQL templating; refine configurations as your needs grow.
- Define `genconfig.Config` early if you want to customize output and filtering.
- Use descriptive interface method comments leveraging GORM CLI’s templating DSL for clean, maintainable SQL.

---

## 7. Common Issues and Troubleshooting

<AccordionGroup title="Common Problems When Running 'gorm gen'">
  <Accordion title='Error: required flag(s) input not set'>
    This indicates you forgot to specify the `-i` argument. Always provide the input path.

    Example fix:

    ```bash
    gorm gen -i ./examples
    ```
  </Accordion>

  <Accordion title="No generated files appear after running the command">
    - Confirm input path points to files with annotated interfaces.
    - Verify your interfaces include SQL template comments.
    - Check if filtering configuration excluded all interfaces or structs.
    - Review output path and folder permissions.
  </Accordion>

  <Accordion title="Permission denied writing output files">
    - Check your output directory permissions.
    - Run the command with appropriate user privileges.
    - Ensure no files are locked or opened elsewhere.
  </Accordion>

  <Accordion title="Parsing errors or panic related to interface methods">
    - Validate method signatures: methods must return `(T, error)` or `error` as appropriate.
    - Ensure SQL templates are well-formed and placeholders match method parameters.
    - Avoid unsupported return types or missing errors.
  </Accordion>
</AccordionGroup>

---

## 8. Next Steps

After successfully generating your first code:

- Explore the [Using the Generated APIs](../using-generated-code) guide to integrate generated code in your application.
- Learn about the [Template DSL](../../guides/practical-usage-patterns/template-dsl-patterns) to write advanced SQL templates.
- Customize generation with [Configuration](../../guides/customization-advanced/generation-config).
- Troubleshoot further using the [Troubleshooting & Common Issues](../troubleshooting) guide.


---

## References

- [GORM CLI Overview and Installation](../../overview/introduction-and-value/what-is-gorm-cli)
- [Minimal Configuration & Project Setup](../basic-configuration)
- [Template Syntax for SQL Annotations](../../guides/practical-usage-patterns/template-dsl-patterns)
- [genconfig.Config Usage for Control](../../guides/customization-advanced/generation-config)


---

<Check>
  You have successfully run your first `gorm gen` command, generating type-safe query APIs and model helpers.
  Check your output folder for generated files and proceed to integrate them in your Go project.
</Check>

---

Happy coding with GORM CLI!