---
title: "Setting Up Your First Project"
description: "Walkthrough of structuring your code: creating models, defining query interfaces with SQL templates, and preparing a directory for generation. Designed to make the code generator work seamlessly out-of-the-box."
---

# Setting Up Your First Project

This guide walks you through structuring your Go project to work seamlessly with GORM CLI. You'll learn how to organize your models, define query interfaces with SQL templates, and prepare your directory so the code generator produces correct, ready-to-use output by default.

---

## 1. Project Structure Overview

GORM CLI expects your code to follow a clear, logical layout where your data models and query interfaces reside alongside each other. This organization enables the code generator to find and process all relevant elements efficiently.

Here is a typical minimal project structure:

```plaintext
my-project/
 ├── models/
 │    └── user.go          # Your GORM model structs
 ├── queries/
 │    └── user_queries.go  # Interfaces with SQL template comments
 └── generated/            # Output directory (optional, configured during generation)
```

**Key points:**
- Models and query interfaces can be in the same or separate packages, but must be importable together.
- The generator scans the directory pointed by your input flag (`-i`) for interfaces and structs.
- The output directory (`-o`) will contain all generated code.


## 2. Creating Your Models

Start by defining your Go structs that represent database tables. Use standard GORM conventions and tags to describe fields and relationships.

### Example: `models/user.go`

```go
package models

import (
  "gorm.io/gorm"
)

type User struct {
  gorm.Model
  Name   string
  Age    int
  Email  string
}
```

> The generator will analyze this struct to create strongly-typed field helpers that enhance your ability to write filters, updates, and association operations.


## 3. Defining Query Interfaces with SQL Templates

Next, create interfaces that specify your database queries. Embed raw SQL with parameter bindings and template directives to define precisely the operations you want.

Place these interfaces in the same package or a close sibling package to models.

### Example: `queries/user_queries.go`

```go
package queries

import (
  "time"
  "my-project/models"
)

type UserQuery interface {
  // SELECT * FROM @@table WHERE id=@id
  GetByID(id int) (models.User, error)

  // SELECT * FROM @@table WHERE name=@name AND age=@age
  FilterByNameAndAge(name string, age int) ([]models.User, error)

  // UPDATE @@table
  // {{set}}
  //   {{if user.Name != ""}} name=@user.Name, {{end}}
  //   {{if user.Age > 0}} age=@user.Age, {{end}}
  // {{end}}
  // WHERE id=@id
  UpdateUser(user models.User, id int) error

  // SELECT * FROM @@table
  // {{where}}
  //   {{if !start.IsZero()}} created_at > @start {{end}}
  //   {{if !end.IsZero()}} AND created_at < @end {{end}}
  // {{end}}
  FilterWithTime(start, end time.Time) ([]models.User, error)
}
```

> Note the use of `@@table`, parameter bindings like `@id`, and template blocks like `{{where}}`.


## 4. Preparing for Generation

To trigger code generation, you need to organize your source files so the CLI command can process them smoothly.

### Steps to verify:

- Confirm your Go module is initialized (`go.mod` file).
- Place your models and query interfaces under a directory; for example, `./queries`.
- If desired, define package-level configuration (`genconfig.Config`) in one of your Go files for customizations.

### Minimal Config Example

```go
package queries

import "gorm.io/cli/gorm/genconfig"

var _ = genconfig.Config{
  OutPath: "./generated",
}
```

> This tells the generator where to place the output files.


## 5. Generating the Code

Run the CLI code generator pointing to your query interface directory. For example:

```bash
gorm gen -i ./queries -o ./generated
```

- `-i` specifies the input directory holding your interfaces and models.
- `-o` specifies the output directory for generated Go code.

The generator will create:

- Type-safe query API implementations for each interface method.
- Field helpers for each model struct.


## 6. Verifying Your Setup

Check the generated directory for:

- Go files named after your packages/interfaces.
- Methods corresponding to your interface definitions, with generated SQL binding.
- Field helpers for model attributes, ready for fluent querying.

You can then import and use these in your project immediately.


## 7. Best Practices and Tips

- **Keep Interfaces Focused:** One interface per main data entity improves clarity.
- **Use Meaningful Method Names:** Names like `GetByID` or `FilterWithTime` help maintainable code.
- **Validate Templates:** Test SQL templates for correctness, as errors show at generation.
- **Organize Configurations:** Use `genconfig.Config` to customize your generation output, field mappings, and inclusions/exclusions.
- **Isolate Generated Code:** Keep generated code in separate directories to avoid manual edits.


## 8. Troubleshooting Common Issues

<AccordionGroup title="Common Setup & Generation Issues">
<Accordion title="Generator reports no interfaces found">
- Ensure your input path (`-i`) correctly points to the directory with query interfaces.
- Check interface names and that code files compile.
- Confirm interfaces have at least one method with SQL template comments.
</Accordion>
<Accordion title="Output directory doesn't show generated files">
- Verify write permissions to the output path.
- Confirm `OutPath` in `genconfig.Config` matches the `-o` CLI flag.
- Make sure generation command ran without errors.
</Accordion>
<Accordion title="Generated code does not compile">
- Check for syntax errors or missing imports in your models or interfaces.
- Validate template syntax is correct, especially conditional blocks.
- Run `go mod tidy` to resolve dependencies.
</Accordion>
</AccordionGroup>


## 9. Next Steps

- Explore [Generating Code and Using Output](/getting-started/essentials/first-generation) to learn how to integrate generated APIs.
- Read about [Basic Generation Config](/getting-started/optional-configuration/basic-configuration) to customize output behavior.
- Consult [Troubleshooting & Common Issues](/getting-started/essentials/troubleshooting) for deeper problem-solving guidance.


---

By following this setup, you create a strong foundation for using GORM CLI's powerful code generation features, enabling type-safe, readable, and maintainable database code from day one.
