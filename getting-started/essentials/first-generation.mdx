---
title: "Generating Code and Using Output"
description: "Learn how to invoke the CLI (`gorm gen`) for the first time. Validate output, explore generated APIs, and run sample queries. This page helps you confirm the tool is working and see immediate results."
---

# Generating Code and Using Output

Learn how to invoke the GORM CLI code generator (`gorm gen`) for the first time, validate the output, explore the generated APIs, and run sample queries. This guide ensures you confirm the tool is functioning correctly and that you can immediately use the generated code in your project.

---

## 1. Prerequisites & Preparation Before Generation

Before running the CLI, ensure you have:

- **Go 1.18+ installed** (supports generics required by GORM CLI).
- A Go project with:
  - Your model structs defined (e.g., `User` struct).
  - Your SQL-annotated query interfaces written with method comments using SQL templates.
- The project directory correctly structured so the CLI can locate interfaces and models.

> These elements are critical because GORM CLI uses your Go interfaces with embedded SQL templates alongside your models to generate type-safe query APIs and field helpers.


## 2. Running the Code Generation Command

GORM CLI exposes the `gen` command to generate code based on your interfaces and models.

### Invocation Pattern

Run from your terminal inside your project directory or specify paths explicitly.

```bash
gorm gen -i <path-to-your-interfaces> -o <output-directory>
```

- `-i` or `--input`: Path to the Go file or directory containing your SQL-annotated query interfaces and model structs.
- `-o` or `--output`: Directory where generated files will be placed. Defaults to `./g`.

### Example

Assuming you have:

- Interfaces and models in `./examples`
- You want output in `./generated`

Run:

```bash
gorm gen -i ./examples -o ./generated
```

### Expected Output

The CLI prints messages such as:

```
Generating file ./generated/query.go from ./examples/query.go...
```

Verification that files were processed and written successfully will appear.

---

## 3. Validating the Generated Code

After generation, confirm you can successfully build and use the code.

### Step 1: Inspect the Generated Files

- Navigate to your output directory (e.g., `./generated`).
- You should see generated `.go` files with type-safe query APIs and field helper structs.

### Step 2: Review Generated APIs

- Generated interfaces follow this pattern:

```go
func Query[T any](db *gorm.DB, opts ...clause.Expression) _QueryInterface[T] {...}

var User = struct { ... }{ ... }
```

- The `Query` function corresponds to your interface (e.g., `Query[T any]`) with methods you defined.
- The `User` struct contains field helpers that facilitate predicates, updates, and association operations.

### Step 3: Run Go Build

Run `go build ./...` or your projectâ€™s build command to ensure no compilation errors come from generated code.

### Step 4: Write a Simple Program Using Generated Code

Example usage:

```go
package main

import (
  "context"
  "fmt"

  "gorm.io/driver/sqlite"
  "gorm.io/gorm"
  "your_project/generated"  // adjust path
  "your_project/examples/models"
)

func main() {
  ctx := context.Background()
  db, err := gorm.Open(sqlite.Open("test.db"), &gorm.Config{})
  if err != nil {
    panic(err)
  }

  // Use generated Query API
  user, err := generated.Query[models.User](db).GetByID(ctx, 1)
  if err != nil {
    fmt.Printf("Error fetching user: %v\n", err)
    return
  }

  fmt.Printf("User: %+v\n", user)
}
```

Run the program to ensure the functions work and your database connection is valid.

---

## 4. Exploring Generated Features

The generated code supports two complementary features:

### 4.1. Type-safe Query APIs

- Interfaces with SQL templates generate concrete implementations.
- Methods like `GetByID`, `FilterByNameAndAge`, and others become available.
- Parameters bind safely to your SQL templates, ensuring compile-time safety.

Example:

```go
user, err := generated.Query[User](db).GetByID(ctx, 123)
```

This runs a `SELECT * FROM users WHERE id=123` query safely.

### 4.2. Model-driven Field Helpers

- Generated structs (e.g., `User`) expose typed field predicates.
- Used to build queries in a fluent style.

Example predicates and chaining:

```go
users, err := gorm.G[User](db).
  Where(generated.User.Age.Gt(18)).
  Find(ctx)
```

This fetches all users older than 18.

---

## 5. Running Sample Queries and Operations

Try the following examples to confirm the generated APIs' abilities:

### Example 1: Simple Query by ID

```go
user, err := generated.Query[models.User](db).GetByID(ctx, 1)
if err != nil {
  // handle error
}
fmt.Println(user)
```

### Example 2: Filter by Name and Age

```go
users, err := generated.Query[models.User](db).FilterByNameAndAge("jinzhu", 25).Find(ctx)
```

### Example 3: Update User Info

```go
err := generated.Query[models.User](db).UpdateInfo(ctx, models.User{Name: "jinzhu", Age: 20}, 1)
```

### Example 4: Use Field Helpers for Queries

```go
users, err := gorm.G[models.User](db).
  Where(generated.User.Name.Like("%jinzhu%"), generated.User.Age.Between(18, 65)).
  Find(ctx)
```

---

## 6. Best Practices & Tips

- **Keep your interfaces and models together or clearly structured** so the CLI can find and parse them efficiently.
- **Write clear, concise SQL templates in interface method comments** for predictable generation.
- Use the field helpers for expressive and type-safe query building to reduce SQL injection risks.
- Customize generation by adding a `genconfig.Config` in your package if you want to:
  - Change output paths
  - Filter generated interfaces or structs
  - Override field type mappings

---

## 7. Troubleshooting Common Issues

### Issue: CLI fails to generate code or outputs no files

- Confirm the `-i` input path is correct and contains Go files with interfaces.
- Verify your interface methods have SQL template comments.
- Check for Go syntax or parsing errors in your input files.

### Issue: Generated code does not compile

- Ensure you have Go 1.18+ as the tool relies on generics.
- Confirm that your models and generated code imports are consistent.
- Check for conflicts caused by configuration filters excluding your interfaces or structs.

### Issue: Runtime errors when using generated code

- Check context usage and database connection.
- Validate that your SQL templates are syntactically correct and parameters are properly bound.

---

## 8. Next Steps

- Integrate generated code into your project workflows.
- Explore advanced templates with DSL for dynamic SQL.
- Learn how to work with associations using generated association helpers.
- Customize generation to match your project by using `genconfig.Config` (see the configuration guide).

---

## References & Links

- [System Requirements & Prerequisites](../getting-started/essentials/prerequisites)
- [Installing GORM CLI](../getting-started/essentials/installation)
- [Setting Up Your First Project](../getting-started/essentials/initial-setup)
- [Troubleshooting & Common Issues](../getting-started/essentials/troubleshooting)
- [Using Type-Safe Query APIs](../guides/getting-started-workflows/using-type-safe-queries)
- [Working With Associations](../guides/advanced-usage-patterns/working-with-associations)


---

This page completes your initial use of `gorm gen` and primes you for explorative usage of the powerful type-safe query APIs and model-driven field helpers generated by GORM CLI.