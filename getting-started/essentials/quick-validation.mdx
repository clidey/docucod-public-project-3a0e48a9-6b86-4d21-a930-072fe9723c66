---
title: "Quick Validation Steps"
description: "Efficient ways to verify your GORM CLI installation and generated code are functioning correctly. Offers diagnostic commands and minimal code samples to test connectivity with your database and the generation process."
---

# Quick Validation Steps

Efficient validation of your GORM CLI installation and generated code is crucial for a smooth developer experience. This guide offers practical methods to confirm your setup works correctly by running diagnostic commands and simple code tests to verify database connectivity and generation correctness.

---

## 1. Verifying GORM CLI Installation

Before diving into generated code, ensure the GORM CLI tool is correctly installed and accessible.

### 1.1 Check GORM CLI Version

Run the following command to verify the installed version and confirm CLI operability:
```bash
gorm --version
```

Expected output:
```text
GORM CLI version x.y.z
```

If you encounter a "command not found" error, confirm the installation steps from [Installing GORM CLI](/getting-started/essentials/installation).

### 1.2 Help and Command Availability

Invoke help to see available commands and options:
```bash
gorm --help
```

You should see commands like `gen` listed, confirming the CLI is ready.

---

## 2. Validating Generated Code Basics

Once generation is complete, validating the generated code ensures the correctness of your interfaces, query APIs, and model helpers.

### 2.1 Quick Code Compilation

Attempt to build your project incorporating the generated package:
```bash
go build ./...
```

A successful build indicates the generated code compiles and integrates without errors.

### 2.2 Running Built-In Unit Tests

The GORM CLI project includes example tests illustrating typical usage of generated APIs. Running these tests in the output directory or your project confirms functionality:

```bash
cd ./generated
go test ./...
```

The tests cover common query and update operations, confirming the generation matches expected interfaces:
- Query extraction
- Filter and update methods
- Association handling

Refer to the [Test Example](#test-example) below for sample tests mimicking this validation.

---

## 3. Sample Code Test for Generated APIs

Use minimal code to programmatically test your generated query APIs for expected behavior.

### 3.1 Example Test for Query Interface

Create a Go test file `query_test.go` in your generated or examples folder with the following:

```go
package examples

import (
	"context"
	"testing"

	"gorm.io/cli/gorm/examples/models"
	"gorm.io/gorm"
)

func TestUserQueries(t *testing.T) {
	db := setupTestDB(t) // Implement DB setup with your connection

	query := Query[models.User](db)
	user, err := query.GetByID(context.Background(), 1)
	if err != nil {
		t.Fatalf("Error fetching user by ID: %v", err)
	}

	if user.ID != 1 {
		t.Errorf("Expected user ID 1, got %v", user.ID)
	}
}
```

This test executes the generated `GetByID` method to fetch a user, verifying correct operation.

### 3.2 Adapting for Your Database

- Replace `setupTestDB(t)` with your database connection setup, ensuring it returns a connected *gorm.DB instance.
- Seed any required test data before running assertions.

---

## 4. Confirming Database Connectivity

Generated code operates on top of GORM and your database, so ensure your database connection is configured and working.

### 4.1 Simple Connectivity Check

Run a standalone Go snippet or command to ping your database:

```go
package main

import (
	"fmt"
	"gorm.io/driver/mysql"  // Adjust driver as per your DB
	"gorm.io/gorm"
)

func main() {
	dsn := "user:password@tcp(localhost:3306)/dbname?parseTime=true"
	db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{})
	if err != nil {
		panic(err)
	}

	dbSQL, err := db.DB()
	if err != nil {
		panic(err)
	}

	if err = dbSQL.Ping(); err != nil {
		panic("Failed to connect to the database: " + err.Error())
	}

	fmt.Println("Database connection successful")
}
```

Run this snippet to verify the basic connectivity your generated queries will rely on.

### 4.2 Troubleshooting Connectivity

If ping fails:
- Confirm database is running
- Verify connection string details (credentials, host, port, database name)
- Check network/firewall settings

See [Troubleshooting & Common Issues](/getting-started/essentials/troubleshooting) for deeper guidance.

---

## 5. Quick Commands to Verify Generation Workflow

To verify your end-to-end workflow briefly from interface definitions to generated APIs:

### 5.1 Generate Code

```bash
gorm gen -i ./examples -o ./generated
```

Where `./examples` contains your query interfaces and models with SQL templates.

### 5.2 Inspect Generated Files

Check generated files in `./generated`:
- Query interface implementations
- Model-driven field helper structs

They should not contain compilation errors and reflect your input definitions.

### 5.3 Run Your Example Tests

Run tests as described in section 2.2 above to execute queries against a test database.

---

## 6. Common Validation Pitfalls

- **Missing Context Parameters**: Ensure all generated method calls receive `context.Context`.
- **Incorrect Database Setup**: Generated code requires a properly initialized `*gorm.DB` pointing to your target.
- **Interface or Model Mismatch**: Regenerate code if you change interfaces or model structs.
- **Generation Path Confusion**: Use consistent `-i` and `-o` paths to avoid mismatches.

<Tip>
Regularly regenerate your code after any interface or model changes to keep APIs in sync.
</Tip>

---

## 7. Additional Resources

- [Installation Guide](/getting-started/essentials/installation)
- [Initial Project Setup](/getting-started/essentials/initial-setup)
- [Code Generation & First Use](/getting-started/essentials/first-generation)
- [Troubleshooting & Common Issues](/getting-started/essentials/troubleshooting)

---

## Example Test Code (Detailed)

For reference, here’s a more comprehensive example adapted from GORM CLI’s test suite illustrating several query validations:

```go
package examples

import (
	"context"
	"testing"
	"time"

	"gorm.io/cli/gorm/examples/models"
	"gorm.io/gorm"
)

func TestUserQueries(t *testing.T) {
	db := setupTestDB(t) // Define connection and seeding

	// Seed with test user
	users := seedUsers(t, db, models.User{Name: "@name", Age: 28, Role: "special"})

	query := Query[models.User](db)

	// Test: GetByID
	for _, u := range users {
		if u.Name == "@name" {
			user, err := query.GetByID(context.Background(), int(u.ID))
			if err != nil {
				t.Errorf("unexpected GetByID error: %v", err)
			}
			if user.Name != "@name" {
				t.Errorf("expected '@name' got %+v", user)
			}
		}
	}

	// Test: FilterWithColumn
	user, err := query.FilterWithColumn(context.Background(), "role", "special")
	if err != nil {
		t.Errorf("FilterWithColumn error: %v", err)
	}
	if user.Role != "special" {
		t.Errorf("expected 'special' role, got %+v", user)
	}

	// Additional tests for query with dynamic filters, update, and time ranges can follow here
}
```

Replace `setupTestDB` and `seedUsers` with your database connection and data seeding logic.

---

By following these steps, you ensure that your GORM CLI setup, generated code, and database connectivity are fully operational, enabling a smooth development workflow with confidence in your generated type-safe queries.
