---
title: "Use the Generated APIs"
description: "Shows how to write code that uses the newly generated type-safe query and field helpers, with simple real-world usage examples. Ensures that users can connect code generation results to actual productivity gains."
---

# Use the Generated APIs

This guide shows you how to effectively write Go code that leverages the type-safe query and field helpers generated by GORM CLI. Through practical, real-world examples, you will understand how to connect your generated code to live GORM operations and dramatically improve safety, discoverability, and productivity in your database interactions.

---

## Understanding the Generated APIs

After running the GORM CLI generator, you gain two powerful constructs:

- **Type-safe Query Interfaces:** These are Go interfaces you defined with SQL template annotations. The generator emits concrete implementations offering fluent methods to run the associated queries.
- **Model-driven Field Helpers:** Struct-derived helpers provide type-safe predicates and setters for every database column and association, used to build filters, updates, and association operations.

Your goal is to use these generated types in your code to safely build and execute complex database operations without runtime errors or unsafe SQL.

---

## Step 1: Import and Prepare

Make sure your generated code directory is imported where you want to use the APIs. For example:

```go
import (
    "context"
    "gorm.io/gorm"
    "your_project/generated" // replace with your generated package path
    "your_project/models"    // your model package
)
```

Start with a database connection instance `db *gorm.DB` and a context `ctx context.Context` ready.

---

## Step 2: Use Generated Query Interfaces

For each generated query interface `Xxx` corresponding to your interface, you construct an instance by providing a `*gorm.DB` handle. This gives you strongly-typed methods directly callable.

### Example: Basic Query Usage

If you generated an interface named `Query` for your model `User`, use it like this:

```go
// Select a user by ID
user, err := generated.Query[models.User](db).GetByID(ctx, 123)
if err != nil {
    // handle error
}
fmt.Println(user.Name)
```

This calls a generated method `GetByID` which:
- Accepts a Go context and parameters as defined
- Translates the annotated SQL template
- Returns the typed model instance and error


### Example: Complex Query with Multiple Filters

```go
users, err := generated.Query[models.User](db).
    FilterByNameAndAge(ctx, "jinzhu", 25).
    Find(ctx) // chaining fluent GORM queries
if err != nil {
  // handle error
}
```

Here, `FilterByNameAndAge` is a generated method returning a fluent query builder, letting you chain custom GORM operations like `Find`.

---

## Step 3: Use Generated Model Field Helpers

For every struct model, the generator creates a variable with typed fields and helpers for predicates and setters. These simplify building queries, filters, updates, and association operations safely.

### Basic Field Helpers Example

```go
// Filtering users by age > 18
err := gorm.G[models.User](db).
    Where(generated.User.Age.Gt(18)).
    Find(ctx, &users).
    Error

// Updating a user's name
err = gorm.G[models.User](db).
    Where(generated.User.ID.Eq(1)).
    Set(generated.User.Name.Set("alice"), generated.User.Age.Incr(1)).
    Update(ctx)
```

The field helpers include predicate methods such as `Eq()`, `Gt()`, `Like()`, `Between()`, and setters like `Set()`, `Incr()`.

### Association Helpers

Associations are exposed as structs or slices with typed operations:

```go
// Create a pet and associate with a user
err = gorm.G[models.User](db).
    Set(
      generated.User.Name.Set("alice"),
      generated.User.Pets.Create(generated.Pet.Name.Set("fido")),
    ).
    Create(ctx)

// Update a user's pet name
err = gorm.G[models.User](db).
    Where(generated.User.ID.Eq(1)).
    Set(
        generated.User.Pets.Where(generated.Pet.Name.Eq("fido")).
          Update(generated.Pet.Name.Set("rex")),
    ).
    Update(ctx)
```

Supported association operations include:
- `Create`: Insert and associate new related records
- `Update`: Update matched associated records
- `Unlink`: Remove association (e.g., NULL FK or delete join rows)
- `Delete`: Remove associated database rows
- `CreateInBatch`: Batch creation and association

---

## Step 4: Run Your First Operation End-to-End

Suppose you have a generated interface `Query[User]` and model `User` with fields and associations.

<Steps>
<Step title="Create a user with related pets">
Use the association helpers to create a user with pets:

```go
err := gorm.G[models.User](db).
  Set(
    generated.User.Name.Set("bob"),
    generated.User.Pets.CreateInBatch([]models.Pet{{Name: "fido"}, {Name: "rex"}}),
  ).
  Create(ctx)
```

Verify `err` for success.
</Step>
<Step title="Query user by ID and filter pets">

```go
user, err := generated.Query[models.User](db).
  GetByID(ctx, 1)

pets, err := gorm.G[models.Pet](db).
  Where(generated.Pet.UserID.Eq(1), generated.Pet.Name.Like("f%")) // filters pets starting with 'f'
  .Find(ctx, &pets)
```
</Step>
<Step title="Update user and unlink pets">

```go
err = gorm.G[models.User](db).
  Where(generated.User.ID.Eq(1)).
  Set(generated.User.Pets.Unlink()).
  Update(ctx)
```

This unlinks all pets from user with ID 1.
</Step>
</Steps>

---

## Step 5: Tips, Best Practices, and Common Pitfalls

- **Context Always First or Added:** Generated query methods add `ctx context.Context` automatically if omitted. Always pass a valid context.
- **Use Field Helpers for Safety:** Avoid manual SQL strings for filters and updates; rely on generated helpers to prevent injection and errors.
- **Check for Generated Methods:** Your query interfaces define the available generated methods. Use `gorm gen` rebuild after changing interfaces.
- **Associations Must be Modeled:** To get association helpers, your models must define GORM associations properly (has one/many, belongs-to, many2many).
- **Chain Carefully:** Chaining returned interfaces preserves fluent API; call terminating methods such as `Find`, `Create` or `Update` with context explicitly.

---

## Troubleshooting

<AccordionGroup title="Common Issues When Using Generated APIs">
<Accordion title="Generated Method Not Found">
Confirm:
- You have run the code generator after adding the interface method.
- The method's SQL template is correct.
- Your imports are referencing the generated package path.
- Your Go module is properly reloaded.

Regenerate with:
```bash
gorm gen -i ./yourinterfacepackage -o ./generated
```
</Accordion>
<Accordion title="Field Helper Methods Do Not Exist">
Check:
- Your model struct includes standard Go field types or configured custom mappings.
- You have defined and imported the generated `User` (or model) field helper variable.
- Rebuild the generated package after model changes.

Custom field mappings require a `genconfig.Config` to be set correctly.
</Accordion>
<Accordion title="Association Operations Fail or Are Missing">
Ensure:
- Associations are declared properly with GORM tags on your models.
- The generator picks up relevant structs (use Include/Exclude lists if needed).
- Generated code for relations was created (check output logs).
</Accordion>
</AccordionGroup>

---

## Next Steps & Further Learning

- Explore your generated code to see the full list of methods and field helpers.
- Review the [Quickstart & Main Workflow](/overview/architecture-workflows-integration/quickstart-and-primary-workflow) and [Prepare Your Project](/getting-started/first-usage-configuration/project-structure) docs for detailed setup.
- Dive deeper into [Field Helpers: Filters and Updates](/guides/using-generated-apis/field-helpers-basics) and [Working with Associations](/guides/using-generated-apis/working-with-associations).
- Learn advanced customization with [Customizing Generation with genconfig.Config](/guides/advanced-usage-best-practices/customizing-generation).


---

## Summary

This page empowers you to transition from code generation to practical usage. You now understand how to:

- Instantiate generated query interfaces
- Call typed query methods with context and parameters
- Utilize model-driven typed field helpers for filters, updates, and association operations
- Compose complex queries and updates confidently, avoiding SQL injection or runtime errors

By adopting these APIs, you transform raw SQL templates and model metadata into a fluent, type-safe, and productive workflow that scales with your project.

---

## References & Links

- [GORM CLI GitHub Repository](https://github.com/go-gorm/cli)
- [Preparing Your Project](https://your-docs/getting-started/first-usage-configuration/project-structure)
- [Running the Generator](https://your-docs/getting-started/first-usage-configuration/run-generator)
- [Field Helpers Basics](https://your-docs/guides/using-generated-apis/field-helpers-basics)
- [Working with Associations](https://your-docs/guides/using-generated-apis/working-with-associations)
- [Template-Driven Queries](https://your-docs/guides/using-generated-apis/template-based-queries)

---

### Example Code Snippet

```go
package main

import (
    "context"
    "fmt"
    "your_project/generated"
    "your_project/models"
    "gorm.io/gorm"
)

func main() {
    var db *gorm.DB // initialized GORM DB
    ctx := context.Background()

    // Use generated Query interface
    user, err := generated.Query[models.User](db).GetByID(ctx, 101)
    if err != nil {
        fmt.Println("Error fetching user:", err)
        return
    }
    fmt.Println("User name:", user.Name)

    // Use field helpers to filter users older than 21
    var adults []models.User
    err = gorm.G[models.User](db).
        Where(generated.User.Age.Gt(21)).
        Find(ctx, &adults)
    if err != nil {
        fmt.Println("Error fetching adults:", err)
        return
    }
    fmt.Printf("Found %d adults\n", len(adults))

    // Create user with pets
    err = gorm.G[models.User](db).
        Set(
            generated.User.Name.Set("alice"),
            generated.User.Pets.Create(generated.Pet.Name.Set("fido")),
        ).
        Create(ctx)
    if err != nil {
        fmt.Println("Error creating user with pet:", err)
    }
}
```
