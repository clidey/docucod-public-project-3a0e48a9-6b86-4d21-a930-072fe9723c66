---
title: "Prepare Your Project"
description: "Explains how to lay out models and query interfaces in a Go project, referencing example directory structures. Helps users get their environment ready for their first code generation run."
---

# Prepare Your Project

This guide walks you through laying out your Go project so GORM CLI can correctly process your models and query interfaces. A well-organized directory structure and explicit package boundaries empower the code generator to produce precise, type-safe query APIs and model-driven helpers.

By following these steps, you'll prepare your environment for a seamless first code generation run.

---

## 1. Understand the Role of Models and Query Interfaces

At the core of your project with GORM CLI are:

- **Models:** Your Go structs representing database tables, often located in a directory such as `models/`.
- **Query Interfaces:** Go interfaces that declare methods with embedded SQL templates, defining query operations.

Both models and query interfaces generally reside in the same Go package or directory.

**Example:**

```go
// examples/models/user.go
package models

type User struct {
    ID   uint
    Name string
    Age  int
}
```

```go
// examples/query.go
package examples

type Query[T any] interface {
    // SELECT * FROM @@table WHERE id=@id
    GetByID(id int) (T, error)
}
```

This arrangement allows GORM CLI to associate queries with specific models, generating fluent, type-safe APIs.

<Tip>
Keep your models and query interfaces together if possible. This simplifies paths passed to the generator and reduces configuration overhead.
</Tip>

---

## 2. Organize Your Project Directory Structure

The GORM CLI processes Go files and preserves relative directory structures under the specified input and output paths.

A typical project layout looks like this:

```
my-project/
├── examples/
│   ├── models/
│   │   └── user.go           # Model structs
│   ├── query.go              # Query interfaces with SQL templates
│   └── filters/              # Optional – filtered configs or query variants
├── generated/               # Output directory for generated code
└── main.go                  # Application entry
```

**Key points:**

- The `input` directory given to the generator is the root for traversal. It should cover both models and interfaces.
- The `output` directory is where generated code goes, preserving relative paths.

**Example CLI command:**

```bash
gorm gen -i ./examples -o ./generated
```

Afterward, generated code will appear inside `generated/`, maintaining directory substructure like `models/`.

<Warning>
Avoid placing generated code inside your input directories to prevent infinite processing loops.
</Warning>

---

## 3. Understand Example Directory Structures

The `examples/` directory in the repository contains practical setups:

- `examples/query.go`: Defines interfaces with SQL templates.
- `examples/models/`: Holds model struct definitions.
- `examples/filters/`: Contains advanced usage with filtered generation configs.

Examining these will help visualize how to lay out your own project.

---

## 4. Configuring Packages and Import Paths

Your Go source files must declare packages consistently to allow the generator to resolve imports, associations, and relationships correctly.

- Use standard Go package names.
- If your project is multi-module or uses nested packages, ensure Go modules and import paths align.
- The generator automatically detects relative packages by inspecting your source layout.

If you need fine control over generation behavior, you can place a package-level `genconfig.Config` variable in your packages to customize output location, field mappings, and filters.

Example configuration (optional):

```go
package examples

import (
    "gorm.io/cli/gorm/genconfig"
)

var _ = genconfig.Config{
    OutPath: "examples/output",
    IncludeInterfaces: []any{"Query*"},
}
```

---

## 5. Preparing Your Interface Files

Place your query interfaces in files with clear, descriptive naming, such as `query.go` or `user_queries.go`.

Each interface method should have a comment block with embedded SQL templates to enable type-safe method generation.

Example:

```go
// Select user by ID
//
// SELECT * FROM @@table WHERE id=@id
GetByID(id int) (T, error)
```

You can define multiple interfaces across different packages/directories. The CLI will process all files under the input path by default.

---

## 6. Run a Quick Sanity Check with `test_all.sh`

To verify your environment and project layout correctness, you can run the provided test script, which exercises the examples and modules inside the repository.

```bash
./scripts/test_all.sh
```

This command runs Go tests across the codebase, ensuring all generated code and examples compile and behave properly.

---

## 7. Summary: Key Preparation Checklist

- [ ] Place your models and query interfaces together logically and consistently under an input directory.
- [ ] Maintain standard Go package declarations and correct module paths.
- [ ] Avoid generating output inside your source input directories.
- [ ] Consider custom package-level `genconfig.Config` for overrides.
- [ ] Use clear naming conventions for your interface files.
- [ ] Validate by running included tests or a first dry run.

---

## 8. Next Steps

With your project prepared and directory structure established:

1. Proceed to [Generate Code: Your First Run](../run-generator) to execute the generator.
2. Explore [Use the Generated APIs](../using-generated-code) to integrate generated code in your app.
3. Optionally, refine generation behavior via [Minimal Configuration](../minimal-configuration).

---

## 9. Troubleshooting Tips

- **Generator reports no interfaces found:** Confirm your input path covers the directory with your interface files.
- **Conflicts in package imports:** Verify your Go module setup and that your packages import correctly.
- **Output directory remains empty:** Check you passed the `-o` output flag and have interfaces with SQL comments.

<Tip>
If unsure, start with the `examples/` directory from the GORM CLI repo as a working reference.
</Tip>

---

## 10. Explore Further

- Examine the `examples/` directory for fully worked-out models, interfaces, and configurations.
- Review the [README.md](https://github.com/go-gorm/cli/blob/main/README.md) for detailed explanations and sample code.

---

### Diagram: Project Layout Conceptual Flow

```mermaid
flowchart TD
  A[Your Go Project Root]
  A --> B[examples/]
  B --> B1[models/]
  B --> B2[query.go - Query Interfaces with SQL Templates]
  A --> C[generated/ (Output)]
  B1 --> D[Model Structs]
  B2 --> E[Defined Query Interfaces]
  E --> F[GORM CLI Generator]
  D --> F
  F --> C
```

This shows how your source files feed into the generator, producing structured output.

---

## References

- [GORM CLI GitHub Repository](https://github.com/go-gorm/cli)
- [Examples Directory](https://github.com/go-gorm/cli/tree/main/examples)
- Related Documentation Pages:
  - [Generate Code: Your First Run](../run-generator)
  - [Use the Generated APIs](../using-generated-code)
  - [Minimal Configuration](../minimal-configuration)



