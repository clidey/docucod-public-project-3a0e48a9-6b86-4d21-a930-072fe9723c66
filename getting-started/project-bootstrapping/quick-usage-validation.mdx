---
title: "Validating Generated Code"
description: "Use and verify your newly generated APIs in a real Go application. This page walks you through integrating with GORM, checking generated field helpers, and running end-to-end validation queries."
---

# Validating Generated Code

This guide helps you use and verify the APIs generated by GORM CLI in your Go application. It walks you through integrating with GORM, inspecting generated field helpers, and running end-to-end validation queries to ensure your code generation workflow was successful.

---

## 1. Integrate Generated Code with Your GORM Project

After running the GORM CLI generator on your interfaces and models, your output folder will contain Go code with type-safe query APIs and model-driven field helpers.

### Steps:

1. **Import Generated Packages**
   - Include the generated package(s) into your Go application.
   - Typical directory structure places generated code under your project, for example:

   ```go
   import (
       "context"
       "gorm.io/gorm"
       "your_project/generated"  // adjust import path as needed
   )
   ```

2. **Setup GORM DB Instance**
   - Initialize your GORM database connection as usual.

   ```go
   db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{})
   if err != nil {
       panic(err)
   }
   ```

3. **Create Context**
   - Prepare a `context.Context` value for your DB queries.

   ```go
   ctx := context.Background()
   ```

<Tip>
Ensure your GORM instance uses the same database schema that your models and generated code expect.
</Tip>

---

## 2. Exploring Generated Field Helpers

Your generated code contains field and association helpers that provide fluent, type-safe ways to express queries and mutations.

### How to Check Generated Field Helpers:

- The generated model files declare variables with capitalized struct names matching your models.
- Each struct contains fields corresponding to model columns with typed helpers.

Example snippet from generated code for a `User` model:

```go
var User = struct {
    ID   field.Number[uint]
    Name field.String
    Age  field.Number[int]
    // ... other fields
} {
    ID:   field.Number[uint]{}.WithColumn("id"),
    Name: field.String{}.WithColumn("name"),
    Age:  field.Number[int]{}.WithColumn("age"),
}
```

Use these helpers to construct strong-typed SQL expressions:

```go
import "your_project/generated"

// Example: Filter users where age > 18
users, err := gorm.G[models.User](db).
    Where(generated.User.Age.Gt(18)).
    Find(ctx)
```

<Note>
The helpers support predicates (`Eq`, `Gt`, `Like`), updates (`Set`), and advanced expressions.
</Note>

---

## 3. Running End-to-End Validation Queries

This verifies that your generated query APIs function correctly with your database.

### Example Walkthrough

Test with a simple type-safe query generated from your interface:

```go
// Assume generated.Query[T] generated from your Query interface
user, err := generated.Query[models.User](db).GetByID(ctx, 123)
if err != nil {
    panic(err)
}
fmt.Printf("User fetched by ID: %+v\n", user)
```

### More sample queries:

- Filtering by name and age:

```go
users, err := generated.Query[models.User](db).FilterByNameAndAge(ctx, "alice", 30)
if err != nil {
    panic(err)
}
fmt.Printf("Users filtered by name and age: %+v\n", users)
```

- Updating a user with partial fields:

```go
err = generated.Query[models.User](db).UpdateUser(ctx, models.User{Name: "bob", Age: 25}, 123)
if err != nil {
    panic(err)
}
fmt.Println("User updated successfully")
```

<Warning>
Make sure your database contains expected data for the IDs or criteria you use in tests.
</Warning>

---

## 4. Troubleshooting Validation Issues

If your generated code or queries do not work as expected, consider:

- **Build Errors:**
  - Confirm your imports and module paths correctly include the generated packages.
  - Ensure your Go version is 1.18+ to support generics.

- **Runtime Errors:**
  - Check your database connection and credentials.
  - Verify your interface method comments have correct SQL template syntax.
  - Confirm schema compatibility: table names, columns, and data types.

- **No Generated Files or Empty Output:**
  - Verify that your input paths and file inclusion/exclusion filters in your `genconfig.Config` or CLI flags are correct.
  - Ensure your interface methods have comment-based SQL templates.

- **Unexpected SQL Behavior:**
  - Review SQL template DSL usage and placeholders.
  - Use debug or logging to inspect generated SQL string before execution.

<Tip>
Run the `gorm gen` command with verbose or debug flags (if supported) to gather detailed diagnostic output.
</Tip>

---

## 5. Next Steps and Further Learning

After validating your generated APIs:

- Integrate generated query APIs and field helpers fully into your application logic.
- Explore model associations using generated association helpers.
- Customize code generation via `genconfig.Config` to fine-tune output.
- Deepen your knowledge by consulting these key guides:

  - [Writing Query Interfaces & Models](/getting-started/project-bootstrapping/writing-query-interfaces)
  - [Running the Generator](/getting-started/project-bootstrapping/basic-generation-workflow)
  - [Model-Driven Field & Association Helpers](/overview/features-quicktour/model-field-helpers)
  - [Template-Driven Queries](/guides/advanced-patterns/template-queries)

<Check>
You are now ready to confidently use GORM CLI-generated code in your projects to achieve type-safe, expressive, and efficient database access!
</Check>