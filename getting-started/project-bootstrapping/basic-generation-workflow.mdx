---
title: "Running the Generator"
description: "Follow the core workflow to generate query APIs and field helpers from your interfaces and models. Includes command-line usage, key options, and output expectations."
---

# Running the Generator

Welcome to the core workflow page where you'll run the GORM CLI generator to produce type-safe query APIs and model-driven field helpers from your Go interfaces and structs. This guide walks you through the command-line usage, explains essential flags, describes what output to expect, and equips you with troubleshooting tips to ensure a smooth generation process.

---

## 1. Preparation: Ensure Your Project is Ready

Before running the generator, confirm the following:

- You have defined one or more Go interfaces with embedded SQL templates in comments. These interfaces represent your query APIs.
- Your GORM model structs are present in the same package or accessible from the input path.
- (Optional) If needed, you've declared a `genconfig.Config` in your package to customize generation.

Your interfaces must contain methods documented with SQL or templating comments that direct the generator how to create type-safe methods. Models form the basis for generating field and association helpers.

<Check>
Ensure your input directory or file contains:
- Interface definitions with SQL template comments
- Model structs
- (Optional) Configuration via `genconfig.Config`
</Check>

## 2. Running the Generator Command 

The generator is exposed via the `gorm gen` command in the CLI. Here's how to run it:

```bash
gorm gen -i <input_path> -o <output_path>
```

- `-i`, `--input`: Required. Path to your Go source files containing the query interfaces and models.
- `-o`, `--output`: Optional. Directory where generated code files will be written. Defaults to `./g`.

### Example

Assuming you have your interfaces and models under `./examples` and want output in `./generated`:

```bash
gorm gen -i ./examples -o ./generated
```

Upon success, generated Go files will appear preserving your input directory structure.

<Note>
You must specify the `--input` option; the generator will error out if this is missing.
</Note>

## 3. What Happens During Generation

### Processing Input

- The generator recursively processes all Go files under the specified input path.
- It parses Go Abstract Syntax Trees (ASTs) to identify interfaces, models, and configs.
- It collects SQL templates from method comments on interfaces.

### Configuration Application

- If present, your package-level `genconfig.Config` customizes output paths, field type mappings, and inclusion/exclusion filters.
- Configurations with `FileLevel: false` apply across the package; those with `FileLevel: true` apply only to the declaring file.

### Code Output

- The generator creates concrete implementations of your interfaces with type-safe, SQL-driven methods.
- Model structs generate typed field helpers, including association operations.
- Output directory structure mirrors your input path for easy project integration.

### Console Output

You will see lines similar to:

```
Generating file generated/query.go from /absolute/path/examples/query.go...
```

### Success Criteria

- Generated files are syntactically valid Go code, ready to be imported.
- Each interface and struct with included methods or fields produces corresponding generated code.

## 4. Understanding Key Generator Options

| Flag    | Description                                | Default      |
|---------|--------------------------------------------|--------------|
| `-i`    | Input path to Go source files              | None (required) |
| `-o`    | Output directory for generated files       | `./g`        |

<Warning>
Input path can be a single file or a directory. When a directory is specified, the generator keeps the relative path in output, so ensure your input directory structure suits your project layout.
</Warning>

## 5. Example Walkthrough

Imagine you've created the following interface and model:

```go
// examples/query.go
package examples

type Query[T any] interface {
  // SELECT * FROM @@table WHERE id=@id
  GetByID(id int) (T, error)
}

// examples/models/user.go
package examples

type User struct {
  ID   uint
  Name string
  Age  int
}
```

Run:

```bash
gorm gen -i ./examples -o ./generated
```

Output generated code will include:
- `GetByID` method with SQL to select from the user's table by `id`.
- Field helper struct for `User` with typed fields like `User.ID`, `User.Name`, and `User.Age`.

You can then import `generated` in your project and invoke:

```go
u, err := generated.Query[User](db).GetByID(ctx, 123)
```

## 6. Post-Generation: What to Do Next

- Import the generated packages into your application code.
- Use the generated interfaces to write type-safe queries.
- Leverage model-driven fields and associations for filters, updates, and creations.
- Continue expanding your SQL template interfaces and rerun the generator as your schema evolves.

## 7. Troubleshooting Common Issues

### Problem: Missing `--input` Argument

**Symptom:** Running `gorm gen` without `-i` results in an error.

**Solution:** Always specify the input path where your interfaces and models reside.

### Problem: No Files Generated

**Symptom:** The command runs, but no generated files appear.

**Possible Causes:**
- Input path is incorrect or empty.
- Your interfaces or structs do not meet inclusion filters.
- Your interfaces lack methods with SQL template comments.

**Solution:**
- Verify your `-i` path.
- Check for `genconfig.Config` filters excluding your types.
- Confirm methods have proper SQL template comments.

### Problem: Syntax Errors in Generated Code

**Symptom:** Compilation errors after generation.

**Solution:**
- Review SQL templates in method comments for correctness.
- Avoid unsupported constructs or malformed SQL DSL.
- Use `genconfig.Config` to customize field type mappings as needed.

## 8. Tips & Best Practices

- **Incrementally build your query interfaces:** Start with simple methods and add complexity.
- **Keep models and query interfaces organized:** Place them in logical packages to leverage the generator’s relative path mirroring.
- **Use generation configs thoughtfully:** Control scope via `IncludeInterfaces`, `ExcludeStructs`, and field mappings.
- **Leverage templated SQL awareness:** Use directives like `@@table`, `{{where}}`, and `@param` to write dynamic and safe SQL.

<Info>
Your generated code works seamlessly with GORM at runtime, enhancing type safety and expressiveness without runtime reflection or overhead.
</Info>

## 9. References & Next Steps

Explore these related pages to deepen your understanding and master the GORM CLI workflow:

- [Writing Query Interfaces & Models](https://your-doc-domain/getting-started/project-bootstrapping/writing-query-interfaces) – Learn how to define your interfaces for generation.
- [Validating Generated Code](https://your-doc-domain/getting-started/project-bootstrapping/quick-usage-validation) – Verify your generated code by writing tests.
- [Optional: Customizing Generation with Config](https://your-doc-domain/getting-started/project-bootstrapping/initial-configuration) – Tailor the generator for complex needs.

For installation and first run preparations, see:

- [Prerequisites & System Requirements](https://your-doc-domain/getting-started/setup-installation/prerequisites)
- [Installing GORM CLI](https://your-doc-domain/getting-started/setup-installation/installing-gorm-cli)
- [First Run & Validation](https://your-doc-domain/getting-started/setup-installation/first-run-validation)

---

With this guide, you are well-equipped to run the GORM CLI generator and bring type safety and fluent querying power to your Go projects.

Happy coding!
