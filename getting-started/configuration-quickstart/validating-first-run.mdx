---
title: "Validating a Successful Setup"
description: "How to confirm that generation succeeded: inspecting output files, integrating the generated code, and performing the first type-safe query. Ensures you are ready to build with confidence."
---

# Validating a Successful Setup

This guide helps you confirm that your GORM CLI code generation completed successfully. You'll learn how to inspect the generated files, integrate the output into your Go projects, and perform your first type-safe query to ensure everything is wired up correctly. By following these steps, you'll gain confidence to build reliable, type-safe database operations powered by GORM CLI.

---

## 1. Inspect Generated Output Files

After running the generator (`gorm gen`), the generated code should appear in the output directory you specified (default is `./g` if not overridden).

### What to look for:

- **Generated query interfaces and implementations:** Files containing the type-safe query APIs with method implementations you defined via your SQL-annotated Go interfaces.
- **Model-driven field helpers:** Strongly typed helper definitions for model fields, including basic fields and associations.

### Example file structure:

```
./generated/
  query.go            # Generated query interface implementations
  user.go             # Model-based field helpers for User struct
  pet.go              # Field helpers for Pet struct and associations
```

### Verify:
- The generated Go files compile with no errors.
- Content reflects your SQL interface methods (e.g., `GetByID`, `FilterByNameAndAge`).
- Field helpers provide methods for your model fields, such as `.Eq()`, `.Set()`.

<Tip>
If you overrided the output path via `-o ./myoutput`, check that directory instead.
</Tip>

---

## 2. Integrate Generated Code in Your Project

Follow these steps to incorporate the generated code in your Go project:

### Step 1: Import the Generated Package

```go
import (
  "context"
  "gorm.io/gorm"
  "path/to/generated"  // Replace with your actual generated package import path
)
```

### Step 2: Initialize the Database Connection

Make sure you have your `*gorm.DB` initialized using your preferred database driver.

```go
// Example using sqlite in-memory (for demonstration)
import (
  "gorm.io/driver/sqlite"
  "gorm.io/gorm"
)

db, err := gorm.Open(sqlite.Open(":memory:"), &gorm.Config{})
if err != nil {
  panic("failed to connect database")
}
```

### Step 3: Use the Generated Query API

Create a typed query instance from the generated package for your model type and perform operations.

```go
ctx := context.Background()

// Example: Fetch a User by ID
user, err := generated.Query[models.User](db).GetByID(ctx, 123)
if err != nil {
  // handle error
}
// Use 'user' object here
```

<Tip>
Replace `models.User` and `generated.Query` with your actual package paths and types.
</Tip>

---

## 3. Run Your First Type-Safe Query

Ensure the generated APIs work as expected by performing a simple query.

### Example Walkthrough: Get User by ID

```go
package main

import (
  "context"
  "fmt"
  "gorm.io/driver/sqlite"
  "gorm.io/gorm"
  "path/to/generated" // Update with correct import
  "path/to/models"    // Update with your model package
)

func main() {
  db, err := gorm.Open(sqlite.Open("test.db"), &gorm.Config{})
  if err != nil {
    panic(err)
  }

  ctx := context.Background()

  user, err := generated.Query[models.User](db).GetByID(ctx, 1)
  if err != nil {
    fmt.Println("Query failed:", err)
    return
  }

  fmt.Printf("User: %+v\n", user)
}
```

### Expected outcome:

- The user with `ID=1` is fetched without compile or runtime errors.
- The query method is type-safe and uses your SQL template logic.

<Tip>
If you see compilation errors referencing missing generated code, verify the output directory and package import paths.
</Tip>

---

## 4. Understanding the Generated Code

The output contains two main categories:

- **Query implementations**: Concrete methods matching your interface with SQL template-based queries.
- **Field helpers**: Structs with fluent methods like `.Eq()`, `.Set()`, `.Create()`, enabling clear and safe query construction.

By combining these, you get a fluent API that integrates seamlessly with GORM for expressive, type-safe database access.

---

## 5. Troubleshooting Common Issues

<AccordionGroup title="Troubleshooting Tips">
<Accordion title="Generated files are missing or empty">
- Ensure you ran `gorm gen` with the correct `-i` input and `-o` output flags.
- Check for any generator errors during the run.
- Verify the input Go files have correct interface definitions with SQL template comments.
</Accordion>
<Accordion title="Compilation errors due to package import mismatch">
- Confirm your import paths match the generated code location.
- Adjust your Go module `go.mod` if necessary to align with generated files.
</Accordion>
<Accordion title="Runtime query errors or no results returned">
- Verify the underlying database connection and schema.
- Ensure your SQL templates in interfaces correspond correctly to your database tables.
</Accordion>
</AccordionGroup>

---

## 6. Next Steps

- Proceed to [Building Model-Driven Field Helpers](https://gorm.io/cli/docs/guides/getting-started/model-driven-field-helpers) to fully leverage field helpers.
- Explore [Running the Generator](https://gorm.io/cli/docs/getting-started/configuration-quickstart/running-the-generator) for detailed CLI usage.
- Visit [Common Setup and Generation Issues](https://gorm.io/cli/docs/getting-started/troubleshooting-help/common-issues) if you encounter problems.


<Tip>
Validating your setup with a simple query first helps ensure smooth development and faster bug detection later.
</Tip>

---