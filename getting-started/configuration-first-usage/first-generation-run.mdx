---
title: "Your First Code Generation"
description: "A practical, step-by-step walkthrough: define your model and query interface, run the code generator with a sample command, and explore the resulting, type-safe APIs. Helps users validate they have a working pipeline from definition to usable Go code."
---

# Your First Code Generation

A practical, step-by-step walkthrough to help you define your model and query interface, run the GORM CLI code generator, and explore the resulting type-safe APIs. This guide ensures you have a working pipeline from writing definitions to using generated Go code effectively.

---

## 1. Define Your Model

Begin by declaring your Go model struct that matches your database schema. This struct will serve as the foundation for generating model-driven field helpers.

```go
package models

import "gorm.io/gorm"

// User represents a user entity in your database.
type User struct {
    gorm.Model
    Name string
    Age  int
}
```

> **Tip:** Place your model struct in a package or directory where you plan to generate code to keep your project organized.


## 2. Write a Query Interface With SQL Templates

Define an interface specifying your queries using method comments to embed SQL templates. This interface drives type-safe, code-generated query methods.

```go
package examples

import (
	"gorm.io/cli/gorm/examples/models"
)

// Query defines database query methods with SQL templates.
type Query[T any] interface {
	// SELECT * FROM @@table WHERE id=@id
	GetByID(id int) (T, error)

	// where("name=@name AND age=@age")
	FilterByNameAndAge(name string, age int)
}
```

- Use SQL annotations prefixed by `//` immediately above methods.
- Placeholders like `@@table` resolve to the model's table automatically.
- Query parameters map directly to SQL parameters (`@param`).

<Note>
Methods without explicit `ctx context.Context` will have it auto-injected during code generation.
</Note>


## 3. (Optional) Declare a Generation Configuration

You can create a `genconfig.Config` at package level to customize generation output, filtering, or field mapping.

```go
package examples

import (
	"database/sql"
	"gorm.io/cli/gorm/field"
	"gorm.io/cli/gorm/genconfig"
)

var _ = genconfig.Config{
	OutPath: "examples/output",            // Output directory for generated code
	FieldTypeMap: map[any]any{
		sql.NullTime{}: field.Time{},         // Map sql.NullTime to Time helper
	},
	FieldNameMap: map[string]any{
		"json": JSON{},                      // Map fields with `gen:"json"` tag to JSON helper
	},
	IncludeInterfaces: []any{"Query*"},   // Include interfaces that start with "Query"
}
```

> **Note:** Config is optional; GORM CLI will generate code with sensible defaults.


## 4. Run the Code Generator

Execute the CLI tool specifying the input directory/module containing your query interfaces and models. You can specify the output directory.

```bash
gorm gen -i ./examples -o ./generated
```

- `-i` or `--input` points to the Go source directory with your interface and model files.
- `-o` or `--output` defines where generated files will be created (defaults to `./g`).

<Check>
Ensure your Go environment is set up correctly and Go version is 1.18+ for generics support.
</Check>


## 5. Explore the Generated Code

After generation, inspect the output directory to see:

- Query API structs implementing your interfaces with concrete SQL method bodies.
- Model-driven field helpers for building filters, updates, and association operations.

Example usages of the generated APIs:

```go
// Instantiate the generated Query API
q := generated.Query[models.User](db)

// Fetch a user by ID
user, err := q.GetByID(ctx, 123)
if err != nil {
	// Handle error
}

// Use field helpers to filter users by name and age
users, err := q.FilterByNameAndAge("jinzhu", 25).Find(ctx)
```


## 6. Validate Your Setup

Successful code generation with no errors and compilation of your application confirm your environment and pipeline are correct.

- The `generated/` directory contains Go files with query implementations and field helpers.
- Compile your project; no missing types or methods related to generated code.
- Execute sample queries in your application and verify database interactions.


## Troubleshooting Common Issues

<AccordionGroup title="Troubleshooting Code Generation">
<Accordion title="Code generation command fails to run">
- Verify that you are using Go 1.18 or newer.
- Confirm the `gorm` CLI tool is installed and available in your `PATH`.
- Check the input directory path for correctness and that it contains Go files.
</Accordion>
<Accordion title="Generated files not appearing in output directory">
- Ensure the output directory specified with `-o` exists and is writable.
- Check for errors reported by the generator.
- Confirm your package contains a `genconfig.Config` if using filters; filters may exclude everything unintentionally.
</Accordion>
<Accordion title="Compilation errors referencing generated code">
- Confirm your code imports the generated package correctly.
- Ensure your Go module aware environment is set up.
- Run `go mod tidy` to synchronize dependencies.
</Accordion>
</AccordionGroup>


## Next Steps

- Proceed to using generated APIs in your application for real-world queries and updates.
- Explore customizing generation with more interfaces, model relations, and advanced field helpers.
- Study [`Template-Based Queries`](../guides/best-practices-patterns/template-based-queries) and [`Working With Associations`](../guides/best-practices-patterns/associations-and-relations) for expanding capabilities.

---

## References

- [Basic Configuration Guide](../getting-started/configuration-first-usage/basic-configuration)
- [Template DSL and Query Patterns](../guides/best-practices-patterns/template-based-queries)
- [Field Helpers and Associations](../guides/best-practices-patterns/working-with-basic-fields)
- [Installation and Prerequisites](../getting-started/setup-prerequisites-installation/installation)

---

This guide shows a straightforward, reproducible way to go from your first interface definition to usable, type-safe database query APIs with GORM CLI. Run your first generation to unlock safer, clearer, and more productive data access patterns.