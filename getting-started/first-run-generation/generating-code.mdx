---
title: "Generating Code"
description: "Explain how to invoke the generator using the CLI, highlighting the basic `gorm gen` workflow, directory structure, and what output files to expect. Connect real input files to generated artifacts, demystifying what happens on code generation."
---

# Generating Code with GORM CLI

This guide explains how to invoke the GORM CLI generator using the command-line interface (CLI), walks you through the essential `gorm gen` workflow, outlines the directory structure of inputs and outputs, and clarifies what files to expect after generation. You'll learn how your raw Go interface and model files map directly to the generated code, helping you understand and trust the code generation process.

---

## 1. Overview of the `gorm gen` Command

The core command to generate code is `gorm gen`. This command scans your Go source files containing interfaces with raw SQL annotations and your model structs, then produces type-safe, fluent query APIs and field helpers integrated with GORM.

### Key Command Flags

- `-i, --input` (required): Path to the Go file or directory where your interface and model definitions exist.
- `-o, --output` (optional): Directory where generated code files will be placed. Defaults to `./g` if not specified.

### Basic Usage

```bash
gorm gen -i <input_path> [-o <output_dir>]
```

Example:

```bash
gorm gen -i ./examples -o ./generated
```

This command:
- Reads all Go files in `./examples`.
- Processes interfaces with SQL templates and structs.
- Writes the generated Go files inside `./generated` while preserving package subdirectories.

---

## 2. Understanding the Workflow

The `gorm gen` workflow follows these sequential steps to convert your source code into generated code:

### Step 1: Input Scanning

The generator accepts either a single Go file or a directory.

- If a directory is specified, it recursively scans all `.go` files, skipping any previously generated code files.
- It parses Go AST, extracting interfaces, methods, and structs.

### Step 2: Configuration Detection

If a package-level `genconfig.Config` variable is declared, the generator automatically picks up configurations like:
- Customized output path
- Inclusion/exclusion filters for interfaces or structs
- Field type mapping

### Step 3: Parsing Query Interfaces

For each interface with SQL annotations in method comments, the generator:
- Extracts SQL query templates (`SELECT`, `WHERE`, `SET` etc.).
- Validates method signatures, ensuring returns have errors and match expectations.
- Prepares method bodies by rendering SQL templates into Go code that builds query strings and parameters.

### Step 4: Parsing Structs

For each struct:
- Gathers all exported fields, including fields from embedded structs (anonymous embedding).
- Resolves the corresponding database column names considering GORM tags.
- Determines the Go field types, influences field helper generation.

### Step 5: Code Generation

- Applies the configured output path.
- Maintains directory structure relative to input.
- Generates files using a Go template that defines interface implementations and model-driven field helpers.
- Applies Go imports formatting with `golang.org/x/tools/imports`.

### Step 6: Output Files

The typical output:
- Generated Go source files mirroring the input package structures.
- Each file contains interface implementations with typed methods and model field helper definitions.


---

## 3. Directory Structure: Inputs and Outputs

### Input Directory

Your working directory containing:
- Go interface files with SQL-annotated methods.
- Model structs used in queries.
- Optional `genconfig.Config` for advanced customization.

Example input structure:

```
examples/
├── models/
│   └── user.go       # model structs
└── query.go           # interfaces with SQL templates
```

### Output Directory

By default, output files go to `./g` folder unless overridden. The output directory mirrors input structure to preserve package hierarchy.

Example output structure matching above input:

```
generated/
├── models/
│   └── user_gen.go   # generated field helpers
└── query_gen.go      # generated query API implementations
```


---

## 4. What Happens During Code Generation?

Understanding exactly how your source files translate to generated code builds confidence and helps with debugging.

### Mapping Input Interfaces to Generated API

- Each SQL-annotated interface method is rendered as a Go function.
- The method body builds SQL strings dynamically based on your templates.
- Parameters from Go method signatures bind to query placeholders.
- The generated code returns concrete types or errors as defined.

### Mapping Input Structs to Field Helpers

- Each exported struct field (including embedded fields) produces
a field helper with strongly typed methods (e.g., `Eq()`, `Like()`, `Between()`).
- Helper methods enable fluent, safe querying and updates.

### Code Generation Example

For an example method with SQL template:

```go
// SELECT * FROM @@table WHERE id=@id
GetByID(id int) (T, error)
```

The generated Go method will:
- Construct SQL with the table name resolved via `clause.Table{Name: clause.CurrentTable}`.
- Bind the `id` parameter safely.
- Execute the query returning the matched struct.

---

## 5. Detailed CLI Command Usage

Here is the full command usage for invoking code generation:

```bash
gorm gen -i ./examples -o ./generated
```

- The `-i` flag expects a file or directory path.
- The `-o` flag specifies the output directory.

### Important Notes

- The input path **must** be provided.
- The output directory will be created if it does not exist.
- The generator skips any `.go` files already containing generated code markers.

<Tip>
Keep your interface and model files organized within their packages to produce clean, structured generated code that maps naturally to your source layout.
</Tip>

---

## 6. What Output Files to Expect?

Once executed, you will find generated `.go` files in your output directory reflecting your input package hierarchy.

### Typical Generated Files

- Query API implementation files named after your interface files, e.g., `query_gen.go`.
- Model helper files named after your model package/files, e.g., `user_gen.go`.

### File Contents

- Implementations of your SQL-annotated interface methods with type-safe query construction.
- Model structs expanded with generated field helpers for filtering, updating, associations.

### File Headers

Generated files carry the header:

```go
// Code generated by 'gorm.io/cli/gorm'. DO NOT EDIT.
```

This prevents accidental manual edits.

---

## 7. How Your Input Relates to Generated Artifacts

| Input Aspect                  | Generated Output                                         | Description                                  |
|------------------------------|---------------------------------------------------------|----------------------------------------------|
| Interfaces with SQL methods   | Implementations of typed query methods                  | Your raw SQL templates become safe Go code  |
| Structs with fields           | Field helpers for queries and updates                    | Generate helpers for expressive query building |
| Package-level `genconfig.Config` | Customized generation behavior (output path, filters) | Overrides default output location and scope      |

---

## 8. Practical Tips & Best Practices

- Always provide the `-i` input flag pointing to your interface/model source files.
- Keep interfaces and models co-located or in clear subdirectories to maintain structure.
- Use `genconfig.Config` in your packages to customize output paths and mappings.
- Avoid editing generated files; treat them as ephemeral build artifacts.
- Run `gorm gen` as part of your build or codegen pipeline for consistent updates.

<Tip>
If you add new methods or change models, rerun the generator to keep your code in sync.
</Tip>

---

## 9. Troubleshooting Common Issues

<AccordionGroup title="Common Code Generation Issues">
<Accordion title="Missing Input Path Error">
If you forget to specify the input path with `-i`, the generator will refuse to run.

**Solution:** Always use the `-i` flag with a valid path.
</Accordion>
<Accordion title="Generated Files Not Updated">
Sometimes generated files may appear outdated if your input contains errors or is skipped.

**Solution:** Check your interface method SQL annotations and declarations for errors. Make sure source files do not contain syntax errors.
</Accordion>
<Accordion title="Output Directory Wrong or Unexpected">
If generated files appear in unexpected places, confirm your `-o` flag usage and any `genconfig.Config.OutPath` overrides.

**Solution:** Remove conflicting configs or explicitly specify `-o` on CLI.
</Accordion>
<Accordion title="Parsing SQL Templates Fails">
Incorrect SQL template syntax in interface method comments can cause parse errors.

**Solution:** Review your SQL template comments ensuring directives like `{{where}}` and `{{set}}` are correctly closed with `{{end}}`.
</Accordion>
</AccordionGroup>

---

## Summary

Generating code with GORM CLI through the `gorm gen` command transforms your Go interfaces and models into robust, type-safe query APIs and field helpers. This process maintains your package structure, respects your config settings, and outputs ready-to-use Go source files with minimal manual intervention.

Make `gorm gen` a routine part of your development cycle to harness compile-time SQL safety and expressive database querying.

---

For more advanced configuration, usage examples, and integration details, consult the [Customizing Code Generation](./customizing-generation) and [Using Model-Driven Field Helpers](./field-helper-usage) documentation pages.


---

### Related Documentation

- [What is GORM CLI?](../../getting-started/introduction-setup/about-gorm-cli)
- [Writing Interfaces & Models](../../getting-started/first-run-generation/configuration-basics)
- [Using Generated APIs](../../getting-started/first-run-generation/first-usage)
- [Customizing Code Generation](../../getting-started/configuration-validation/customizing-generation)
- [Troubleshooting Common Issues](../../getting-started/configuration-validation/troubleshooting)


---

## Generated Code Example Preview

Here is a trimmed example snippet of what a generated method implementation looks like for a method with SQL annotation:

```go
func (e _QueryInterface[T]) GetByID(ctx context.Context, id int) (T, error) {
	var sb strings.Builder
	params := make([]any, 0, 2)
	sb.WriteString("SELECT * FROM ? WHERE id=?")
	params = append(params, clause.Table{Name: clause.CurrentTable}, id)
	return e.Raw(sb.String(), params...).Scan(ctx, &result)
}
```

This code builds the SQL query dynamically and binds your parameters safely, with type safety guaranteed by Golang generics.


---