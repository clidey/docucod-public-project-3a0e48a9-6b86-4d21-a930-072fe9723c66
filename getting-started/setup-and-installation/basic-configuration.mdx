---
title: "Basic Configuration"
description: "An introduction to the minimum configuration needed to use GORM CLI, with focus on code generation settings, output directories, and integration with your Go modules."
---

# Basic Configuration

Welcome to the essential setup guide for configuring the GORM CLI tool. This page focuses on the minimum configuration needed to get started with the GORM CLI code generator, emphasizing how to specify output directories, map custom code generation settings, and integrate with your Go module structure effectively.

---

## 1. Purpose of Configuration

Configuration in GORM CLI controls how and where generated code is output and lets you customize code generation behavior per package or even per file.

Without any configuration, the generator uses defaults and outputs generated code alongside your source. Adding a `genconfig.Config` declaration in your package files lets you tailor:

- Output directory for generated code
- Custom field mappings (e.g., how certain Go types or tagged fields map to generated helpers)
- Inclusion or exclusion of specific interfaces or structs by pattern
- File-level versus package-level granularity of configuration

This ensures your generated code fits your project layout and coding standards seamlessly.

---

## 2. Where and How to Declare Configuration

Create a package-level (directory-scoped) `genconfig.Config` variable in any `.go` source file within the package that you want to generate code for. The generator automatically detects it.

Example:

```go
package examples

import (
    "database/sql"
    "gorm.io/cli/gorm/field"
    "gorm.io/cli/gorm/genconfig"
)

var _ = genconfig.Config{
    OutPath: "examples/output",

    FieldTypeMap: map[any]any{
        sql.NullTime{}: field.Time{},
    },

    FieldNameMap: map[string]any{
        "date": field.Time{}, // Map all fields with `gen:"date"` tag to Time helper
        "json": JSON{},       // Map `gen:"json"` tag to custom JSON helper
    },

    FileLevel: false, // Apply configuration at package level

    IncludeInterfaces: []any{"Query*", models.Query(nil)},
    ExcludeInterfaces: []any{"*Deprecated*"},

    IncludeStructs: []any{"User", "Account*", models.User{}},
    ExcludeStructs: []any{"*DTO"},
}
```

### Key Fields Explained

| Field             | Purpose & Usage                                                                                                   |
|-------------------|-----------------------------------------------------------------------------------------------------------------|
| `OutPath`         | Overrides the default output directory for generated files in this package. Can be a relative path from module root or absolute.
|
| `FieldTypeMap`    | Maps Go types (e.g., `sql.NullTime{}`) to generator field helpers (e.g., `field.Time{}`). Enables custom code for special fields.
|
| `FieldNameMap`    | Maps field tag names (e.g., `gen:"json"`) to helper types, allowing you to influence generation based on struct tags.
|
| `FileLevel`       | When `true`, configuration applies only to the current file, not the whole package. Useful for fine-grained control.
|
| `IncludeInterfaces` / `ExcludeInterfaces` | Whitelists or blacklists query interface types by name patterns or type for inclusion/exclusion during generation.
|
| `IncludeStructs` / `ExcludeStructs`       | Whitelists or blacklists model structs by name pattern or type literal.

---

## 3. Integration with Your Go Modules and Project Layout

- The `OutPath` setting controls where source-generated files go. For clean project organization, set this to a dedicated directory (e.g., `generated/` or `examples/output`).

- Paths are relative to your project's Go module root.

- Generated code respects Go module boundaries and imports. This seamless integration means you can `go generate` or run the CLI tool in your module root, and it will correctly write output respecting import paths.

- When you use multiple packages, declare separate `genconfig.Config` in each package directory to customize generation per package.

- Use the `FileLevel` option to granularly configure individual source files if needed.

---

## 4. Minimal Working Example

Hereâ€™s a concise example to ensure your code generation outputs to a clean directory with a custom field mapping:

```go
package examples

import (
    "database/sql"
    "gorm.io/cli/gorm/field"
    "gorm.io/cli/gorm/genconfig"
)

var _ = genconfig.Config{
    OutPath: "examples/output",
    FieldTypeMap: map[any]any{
        sql.NullTime{}: field.Time{},
    },
    FieldNameMap: map[string]any{
        "json": JSON{},
    },
    FileLevel: false,
}
```

Place this file alongside your Go source and run the CLI generator:

```bash
gorm gen -i ./examples -o ./generated
```

Check `examples/output` for generated code.

---

## 5. Best Practices & Tips

- **Start Simple:** Begin with only `OutPath` set to keep generated code separate from manual code.

- **Declarative Mapping:** Use `FieldTypeMap` and `FieldNameMap` to handle special types or tag-driven generation requests upfront.

- **Use Wildcards:** Use shell-style glob patterns (e.g., `Query*`, `Account*`) to include/exclude interfaces or structs flexibly.

- **Isolate Per Package:** When working on many packages, maintain separate config declarations in each to avoid unexpected propagation.

- **Leverage `FileLevel` When Necessary:** If you want tight control, file-specific config helps avoid overriding others.

- **Keep Config Files Checked-In:** Treat your generation config files as part of your source to get consistent generation across your team.

- **Watch Output Locations:** Confirm `OutPath` resolves as expected relative to your module root to prevent tangled directories.

---

## 6. Troubleshooting Common Configuration Issues

<AccordionGroup title="Common Configuration Issues">
<Accordion title="Generated Files Not Appearing in Expected Directory">
- Check that `OutPath` is set correctly relative to your Go module root.
- If no `genconfig.Config` is declared, the default output is alongside source files.
- Run the CLI command from module root or specify full import paths.
</Accordion>
<Accordion title="Field Mapping Not Applied as Expected">
- Ensure you use Go type **instances** in `FieldTypeMap` keys (e.g., `sql.NullTime{}`, not `sql.NullTime`).
- When mapping by field name with `FieldNameMap`, verify the tags on your struct fields match exactly.
- Combined mapping prioritizes `FieldNameMap` over `FieldTypeMap`.
</Accordion>
<Accordion title="Interfaces or Structs Generating Unexpectedly">
- Validate your `Include*` and `Exclude*` settings.
- Patterns are shell-style wildcards; incorrect use can lead to inclusion/exclusion surprises.
- Remember `Include*` takes priority over `Exclude*`.
</Accordion>
</AccordionGroup>

---

## 7. Related Configuration Pages

- [Customization with genconfig](https://docs.gorm.io/guides/advanced-use-cases/customizing-generation) for deeper options
- [Defining Models and Query Interfaces](https://docs.gorm.io/getting-started/first-code-generation/defining-models-and-interfaces) to apply configuration with your types
- [Running the Code Generator](https://docs.gorm.io/getting-started/first-code-generation/running-gorm-cli-gen) to connect config with execution

---

## 8. Summary

Configuring GORM CLI via the `genconfig.Config` variable allows you to control code generation output paths, customize field mappings, and filter which types get generated. This flexible setup integrates cleanly with Go modules and project layouts to create a smooth developer experience for type-safe GORM code generation.

Start with minimal `OutPath` settings, expand with mapping and includes/excludes as your codebase grows, and check generated output to verify configuration success.


---

## Example Configuration File for Quick Reference

```go
package examples

import (
    "database/sql"
    "gorm.io/cli/gorm/field"
    "gorm.io/cli/gorm/genconfig"
)

var _ = genconfig.Config{
    OutPath:       "examples/output",
    FieldTypeMap:  map[any]any{sql.NullTime{}: field.Time{}},
    FieldNameMap:  map[string]any{"json": JSON{}},
    FileLevel:     false,
    IncludeInterfaces: []any{"Query*"},
    ExcludeInterfaces: []any{"*Deprecated*"},
    IncludeStructs:    []any{"User", "Account*"},
    ExcludeStructs:    []any{"*DTO"},
}
```

Follow this structure to fit your project needs and keep your code generation consistent and maintainable.
