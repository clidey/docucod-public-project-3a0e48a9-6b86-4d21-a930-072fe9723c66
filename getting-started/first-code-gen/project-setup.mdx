---
title: "Preparing Your Project"
description: "Learn how to structure your Go project for GORM CLI. Understand where to place models, query interfaces, and optional config files to maximize ease-of-use and generator effectiveness."
---

# Preparing Your Project for GORM CLI

Learn how to organize your Go project to maximize the effectiveness of the GORM CLI code generator. This guide helps you structure models, query interfaces, and optional configuration files thoughtfully, enabling seamless generation of type-safe database querying code and fluent model-driven field helpers.

---

## Why Project Structure Matters

Correctly preparing your project layout ensures that the GORM CLI tool can discover your Go interfaces and model structs effectively, apply any configuration overrides smoothly, and produce clean, maintainable generated code. A well-structured project saves time by minimizing generator issues and simplifies long-term maintenance.


## 1. Organize Your Models and Query Interfaces

### Place Models and Interfaces Together

- **Recommended:** Group your database model structs and SQL-annotated query interfaces in the same package or directory.
- This setup allows GORM CLI to pick up related files without extra configuration.
- Example:

```plaintext
/myproject
  /examples
    models.go        # Your Go structs representing database tables
    query.go         # Go interfaces with SQL template comments
```

### Example Query Interface

Define your query interfaces using Go generics and method comments with SQL templates. Use `@@table`, `@param`, and DSL directives for dynamic queries.

```go
// examples/query.go
package examples

type Query[T any] interface {
  // SELECT * FROM @@table WHERE id=@id
  GetByID(id int) (T, error)

  // where("name=@name AND age=@age")
  FilterByNameAndAge(name string, age int) ([]T, error)
}
```

### Example Model Struct

Define your models with basic Go structs using GORM tags as needed.

```go
// examples/models/user.go
package models

import "gorm.io/gorm"

type User struct {
  gorm.Model
  Name string
  Age  int
}
```


## 2. Optional: Add Package-Level Configuration

You can fine-tune code generation per package by declaring a `genconfig.Config` struct in a Go source file within that package.

- Use this to specify output paths, include/exclude patterns, or override field mappings.
- The generator automatically discovers such configs.

### Example Configuration File

```go
// examples/filters/pattern/config.go
package pattern

import "gorm.io/cli/gorm/genconfig"

// Limit generation to interfaces starting with 'Query'
var _ = genconfig.Config{
  IncludeInterfaces: []any{"Query*"},
}
```

### How this Helps

- Limits which interfaces or structs are processed within the package subtree
- Adjusts output directories for generated files
- Customizes field type helpers and name mappings


## 3. Naming Conventions and Placement Best Practices

- **File Naming:** Use expressive file names such as `models.go`, `query.go`, or `<feature>_config.go`.
- **Package Layout:** Keep your models and query interfaces under the same package namespace to simplify imports and increase generator clarity.
- **Config Files:** Place `genconfig.Config` declarations in files named `config.go` or related logical names within the package.


## 4. Practical Example Directory Structure

```
myproject/
 ├─ examples/             # Package for sample queries and models
 │   ├─ models.go         # Define User, Pet, etc. structs
 │   ├─ query.go          # Interfaces with SQL templates
 │   ├─ config.go         # Optional genconfig.Config for package customization
 │   └─ filters/          # Subpackage with filtering patterns
 │       └─ pattern/
 │           ├─ config.go # package config with IncludeInterfaces
 │           └─ other.go  # query interfaces or models
 └─ generated/           # Output directory specified in config or CLI
```


## 5. Key Tips for Maximizing Generator Effectiveness

- **Restate Package Paths Clearly:** Your models and interfaces should reflect the proper import paths without ambiguity.
- **Interface Naming:** Use consistent, predictable prefixes or suffixes for query interfaces (e.g., `Query`, `Repo`) so you can include/exclude by pattern.
- **Use Optional Config to Focus Generation:** Especially in larger projects, restrict generation to relevant interfaces to avoid excess generated code.
- **Avoid Circular Dependencies:** Models and query interfaces in the same package reduce import cycles and simplify generation.


## 6. How the Generator Uses Project Structure

- **Discovery:** Scans your input directory recursively, processing all `.go` files.
- **Config Application:** Loads and applies any package-level `genconfig.Config` settings.
- **Filtering:** Applies include/exclude rules based on interface and struct names or patterns.
- **Generation:** Writes generated code into configured output directories, keeping relative path structure intact.


## 7. Verifying Your Project Setup

Before running the code generator, verify:

- Models and interfaces compile without errors.
- Optional `genconfig.Config` declarations are syntactically correct.
- Your directory structure is consistent with planned output organization.

You can run a dry code generation and check for warnings.


## 8. Running the Generator (Brief Overview)

Once your project is ready:

```bash
gorm gen -i ./examples -o ./generated
```

This consumes all interfaces and models in `./examples` applying any configs found and places output into `./generated` or a configured output path.


## Troubleshooting Common Project Setup Issues

<AccordionGroup title="Common Project Setup Troubleshooting">
<Accordion title="Generator does not find interfaces or models">
- Ensure your query interfaces and models are in `.go` files under the specified input directory.
- Confirm that package-level `genconfig.Config` does not mistakenly exclude interfaces or structs.
- Check for spelling or case sensitivity in include/exclude patterns.
</Accordion>
<Accordion title="Generated code files are missing or empty">
- Verify your interfaces include properly formatted method-level comments with SQL templates.
- Validate that your models have exported fields.
- If using configuration, check that OutPath is correct and writable.
</Accordion>
<Accordion title="Import cycles or unresolved packages during generation">
- Keep related code (models and queries) in the same package to reduce import complexity.
- Avoid cross-package references that create cyclic imports.
</Accordion>
</AccordionGroup>


## Summary

Properly organizing your Go project for GORM CLI enhances generator accuracy and increases developer productivity. Group your models, query interfaces, and configuration logically under coherent packages. Leverage package-level configurations to fine-tune generation behavior as your project grows.

---

### Related Documentation

- [Creating Models & Query Interfaces](./writing-models-interfaces) — Learn how to write well-formed models and query interfaces.
- [Running the Generator](./running-generator) — Execute code generation with your prepared project.
- [Customizing Code Generation](../../guides/advanced-usage/customizing-generation) — Dive deeper into configuration options and patterns.

---

For more detailed examples, see the [examples](https://github.com/go-gorm/cli/tree/main/examples) directory in the GORM CLI repository.

---

_Last updated: 2024_
