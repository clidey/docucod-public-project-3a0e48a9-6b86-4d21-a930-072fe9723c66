---
title: "Your First Code Generation"
description: "Walk through generating code from your models and query interfaces using the GORM CLI. Includes example model/interface setup and the precise CLI command to use, with expectations for the generated output. Designed to build immediate confidence in the workflow."
---

# Your First Code Generation

Welcome to your initial hands-on experience with the GORM CLI code generation workflow. This guide will walk you through creating your first data model and query interface, running the GORM CLI generation command, and understanding the output to confidently start using the generated code in your project.

By following this practical walkthrough, you'll see how the CLI transforms your Go interfaces annotated with SQL templates and your Go model structs into fully typed, fluent, and safe APIs that integrate seamlessly with GORM's ORM.

---

## 1. Prepare Your Model and Query Interface

Before generating code, you first need to have:

- **Data Models:** Go structs that represent your database tables.
- **Query Interfaces:** Go interfaces containing method declarations with SQL templates in comments.

This setup gives GORM CLI exactly what it needs to generate tailored code for your data access layer.

### Example Model Setup

Create a simple model, such as a `User` struct, representing the user table:

```go
package models

import (
	"gorm.io/gorm"
)

type User struct {
	gorm.Model
	Name string
	Age  int
}
```

### Example Query Interface

Define an interface with SQL templates in method comments that describe the queries:

```go
package examples

// Query defines the user-related queries.
type Query[T any] interface {
	// SELECT * FROM @@table WHERE id=@id
	GetByID(id int) (T, error)

	// where("name=@name AND age=@age")
	FilterByNameAndAge(name string, age int)
}
```

### Location and Package

Place your model and query interface in the same package or directory to simplify scanning by the generator.

---

## 2. Run the GORM CLI Generator

With your Go files prepared, invoke the GORM CLI generator to produce the code.

### Installation Check

Ensure you have Go 1.18+ installed and the CLI tool available:

```bash
go install gorm.io/cli/gorm@latest
```

### Generate Code Command

Run the `gorm gen` command, specifying your input directory or file and the output directory:

```bash
gorm gen -i ./examples -o ./generated
```

- `-i` or `--input`: Points to the folder or file with your interfaces and models.
- `-o` or `--output`: Destination directory for the generated Go code.

### Expected Output

You will see logs indicating files being generated:

```
Generating file ./generated/query.go from ./examples/query.go...
Generating file ./generated/models.go from ./examples/models/user.go...
```

<Tip>
If you encounter errors, verify your input path validity and model/interface correctness. Ensure your interface methods have valid SQL annotations and return signatures.
</Tip>

---

## 3. Understand the Generated Code

The CLI produces two key sets of files:

### a. Type-Safe Query APIs

- For each interface method, concrete implementations with typed parameters and returns.
- Methods connect to GORM's `*gorm.DB` and run your annotated SQL with compile-time safety.

Example:

```go
// GetByID executes: SELECT * FROM users WHERE id=@id
u, err := generated.Query[User](db).GetByID(ctx, 123)
```

### b. Model-Driven Field Helpers

- Strongly typed structs to build filters, setters, and predicates on your model fields.

Example:

```go
// Filter users where name is 'jinzhu' and age equals 25
users, err := gorm.G[User](db).
  Where(generated.User.Name.Eq("jinzhu"), generated.User.Age.Eq(25)).
  Find(ctx)
```

---

## 4. Run Your First Operation

Try running your generation result in a simple Go program:

```go
package main

import (
	"context"
	"fmt"
	"gorm.io/driver/sqlite"
	"gorm.io/gorm"
	"yourmodule/generated"
	"yourmodule/models"
)

func main() {
	db, err := gorm.Open(sqlite.Open("test.db"), &gorm.Config{})
	if err != nil {
		panic(err)
	}

	ctx := context.Background()

	// Use the generated Query interface:
	user, err := generated.Query[models.User](db).GetByID(ctx, 1)
	if err != nil {
		fmt.Println("Error fetching user:", err)
		return
	}

	fmt.Println("User fetched:", user)
}
```

<Tip>
Replace `yourmodule` imports with your actual Go module name/path.
</Tip>

---

## 5. Verification & Success Criteria

You have successfully completed your first code generation if:

- The CLI generates source files in your specified output directory.
- Generated code compiles without errors.
- You can import generated packages and invoke methods like `Query[User].GetByID`.
- Query results from the database match the actual data.

---

## 6. Practical Tips & Best Practices

- **Keep models and interfaces close:** Placing related files together simplifies scanning and generation.
- **Annotate interfaces clearly:** SQL templates in comments must be valid and use placeholders like `@@table` and `@param`.
- **Use Context consistently:** The generator adds context if omitted; you can pass it explicitly.
- **Review generated code:** Familiarize yourself with the generated files to harness full power and extend usage.

<Tip>
Use Go tooling (`go fmt`, `go vet`, IDE navigation) on generated code; itâ€™s human-readable and well-structured.
</Tip>

---

## 7. Troubleshooting Common Issues

<AccordionGroup title="Troubleshooting First Code Generation">
<Accordion title="No files generated or empty output directory">
- **Check input path:** Confirm that the input directory or file contains valid Go files with interfaces/models.
- **Ensure method annotations:** Methods must have SQL templates in comments.
- Use the `gorm gen --help` command for flag usage guidance.
</Accordion>

<Accordion title="Compilation errors in generated code">
- Verify model structs have exported fields.
- Confirm interface methods have valid return types (must end with `error`).
- Check for typos or missing imports.
</Accordion>

<Accordion title="Runtime errors when calling generated methods">
- Confirm database connection and schema match model definitions.
- Ensure context is passed properly.
- Use logs or errors from GORM to diagnose SQL execution issues.
</Accordion>
</AccordionGroup>

---

## 8. Next Steps

Now that you have run your first code generation and executed a basic operation:

- Explore [Basic Configuration](https://docs.example.com/getting-started/first-run-configuration/basic-configuration) to customize generation.
- Learn about [Advanced Generation Settings](https://docs.example.com/getting-started/first-run-configuration/advanced-configuration) for deeper control.
- Review [Usage of Generated APIs](https://docs.example.com/guides/getting-started/using-generated-apis) to integrate with your application logic.


---

For a broader understanding of GORM CLI and its powerful features, see our [Product Introduction & Value](https://docs.example.com/overview/getting-started-core/overview-intro) and [Feature Highlights](https://docs.example.com/overview/getting-started-core/overview-feature-quicklook).


---