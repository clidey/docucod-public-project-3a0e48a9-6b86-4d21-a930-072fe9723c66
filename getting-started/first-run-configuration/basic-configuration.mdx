---
title: "Basic Configuration"
description: "Learn how GORM CLI automatically discovers and applies sensible generation defaults. Understand where generated files are placed, and how common defaults align with Go and GORM conventions. Includes entry points for modification."
---

# Basic Configuration

GORM CLI is designed to work out-of-the-box with sensible defaults that match typical Go and GORM project conventions. This page guides you through understanding how GORM CLI automatically discovers these defaults, where your generated files are placed, and how you can customize or extend this basic configuration to fit your project needs.

---

## 1. Automatic Discovery of Defaults

When you run the generator, GORM CLI scans your Go packages for model structs and query interfaces. Without any configuration, it applies the following conventions:

- **Output directory:** Generated code files are placed in a default directory named `./g` relative to your current working directory.
- **File and directory structure:** The generator mimics your input directory's structure inside the output folder, preserving package organization.
- **Detection of models and interfaces:** It automatically identifies all exported structs and interfaces in scanned Go files, generating field helpers and type-safe query APIs.
- **Field Types Mapping:** Basic Go types such as `int`, `string`, `bool`, `time.Time`, and others that are common in GORM models are detected and mapped to corresponding field helpers (e.g., `field.String`, `field.Number[int]`, `field.Time`). This mapping ensures generated helpers follow GORM idioms.
- **Associations:** GORM CLI automatically recognizes your model's associations like `has one`, `has many`, `belongs to`, and `many2many`, generating fully typed association helpers.

<Tip>
You don’t need to write any configuration to get started. The default behavior matches most use cases and can be tested simply by running the generator on your model and interface packages.
</Tip>

## 2. Where Generated Files Are Placed

By default, GORM CLI uses the output directory `./g`. Inside this directory, your project's internal Go package structure is preserved:

- If your input path is a directory, the generator recreates relative paths inside `./g` for generated files.
- This keeps your source and generated code logically separated but similarly organized.

For example, if your input files reside in `./examples/models/`, generated code will be under `./g/examples/models/`.

<Note>
You can override this default output directory with the `-o` flag when running the CLI (e.g., `gorm gen -i ./examples -o ./custom_generated`).
</Note>

## 3. How Defaults Align with Go and GORM Conventions

The generator knows common Go naming patterns and GORM struct tagging conventions:

- It converts Go struct field names to database column names with GORM's standard rules.
- It respects embedded structs in models to include their fields automatically.
- Types such as `sql.NullTime` or custom wrappers can be seamlessly mapped to field helpers via configuration (see the next section).
- SQL templates in interfaces use `@@table` and `@@column` placeholders that automatically resolve to your model's table names and column names, ensuring your generated API matches your schema.

## 4. Entry Points for Modification

Though the defaults cover most situations, you can override any part of the generation process using configuration variables declared directly in your package source files.

### 4.1 Package-level `genconfig.Config`

Place a `genconfig.Config` variable in one of your Go source files in the package you want to customize. This config can modify:

- **OutPath:** Overrides the default output path for generated files within that package.
- **FieldTypeMap:** Maps Go types to specific field helper types.
- **FieldNameMap:** Associates generator tags (e.g., `gen:"json"`) with custom helpers.
- **Include/Exclude filters:** Control which interfaces or structs get included or excluded by name patterns.
- **FileLevel:** When enabled, the config applies only to a single file, otherwise to the whole package or subtree.

Example:
```go
package examples

import (
	"database/sql"
	"gorm.io/cli/gorm/field"
	"gorm.io/cli/gorm/genconfig"
)

var _ = genconfig.Config{
	OutPath: "examples/output",
	FieldTypeMap: map[any]any{
		sql.NullTime{}: field.Time{},
	},
	FieldNameMap: map[string]any{
		"json": JSON{},
	},
	IncludeInterfaces: []any{"Query*"},
	ExcludeStructs: []any{"*DTO"},
}
```

### 4.2 Using Your Configuration

Once declared in the source, the generator automatically picks up your config and adjusts generation accordingly.

<Tip>
Organize configs close to your models or interface files for clear visibility and easy maintenance.
</Tip>

## 5. Best Practices for Basic Configuration

- **Start simple:** Use the defaults early in development to avoid unnecessary complexity.
- **Incrementally customize:** Add config only when you have specific requirements like custom output paths or specialized type mappings.
- **Use include/exclude lists:** Precisely filter which code elements to generate, keeping the output clean.
- **Leverage Go interfaces for filtering:** Use patterns like `Query*` to generate only relevant interfaces.

## 6. Troubleshooting Common Configuration Issues

<AccordionGroup title="Basic Configuration Troubleshooting">  
<Accordion title="Generated Files Not Found Where Expected">  
Check that you have set the output path correctly via the `-o` flag or `OutPath` in your config. Confirm your input path is accurate and that your source files exist.
</Accordion>  
<Accordion title="My Custom Field Mapping Is Not Applied">  
Ensure your package-level `genconfig.Config` variable is declared properly and imported. Confirm the `FieldTypeMap` uses correct Go type instances as keys.
</Accordion>  
<Accordion title="Some Interfaces or Structs Are Not Being Generated">  
Verify your include and exclude filters in config do not unintentionally filter out types. Remember include filters have priority over exclude.
</Accordion>  
</AccordionGroup>

## 7. Summary

By leveraging GORM CLI's intelligent defaults and optional package-level configurations, you can efficiently generate type-safe query APIs and field helpers that fit your project's needs. Begin with default settings, observe generated output in the `./g` directory, and extend with configs as your project scales or requires customization.

---

## Additional Learning

For deeper understanding and extended workflows, consider these related guides:

- [Prerequisites & System Requirements](../setup-installation/prerequisites) — Ensure your environment matches GORM CLI's needs
- [Your First Code Generation](../first-run-configuration/your-first-generate) — Hands-on guide to running your initial codegen
- [Advanced Generation Settings](../first-run-configuration/advanced-configuration) — Explore detailed customization
- [Troubleshooting Common Issues](../setup-installation/troubleshooting) — Debug setup and configuration problems

---

## References

- [GORM CLI README](https://github.com/go-gorm/cli/blob/main/README.md) for examples and core usage
- [genconfig.Config source](https://github.com/go-gorm/cli/blob/main/genconfig/config.go) for full configuration options

---

## Example Command

Run your first generation with defaults:

```bash
gorm gen -i ./examples/models
```

This generates type-safe APIs and field helpers into `./g/examples/models/`.

Override output path:

```bash
gorm gen -i ./examples/models -o ./generated
```

---