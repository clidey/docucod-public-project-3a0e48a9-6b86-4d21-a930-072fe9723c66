---
title: "Validating Generated APIs"
description: "How to check that code gen has run successfully: where to find generated output, evaluating generated query APIs and field helpers, and testing them in a quick local run to ensure everything is wired up."
---

# Validating Generated APIs

Ensure the code generation process created valid, usable, and type-safe APIs. This guide walks you through verifying that GORM CLI's generated query interfaces and field helpers are correctly generated, locating the output, and testing your generated APIs locally with a quick example run.

---

## 1. Where to Find the Generated Output

After running the CLI generator with your input interface files and specifying an output directory, your generated files will be located in the directory defined by your configuration or CLI flags.

- The output directory defaults to `./g` if you don't specify one.
- You can override this with the `-o` or `--output` CLI flag (e.g., `gorm gen -i ./examples -o ./generated`).
- Config files (`genconfig.Config`) in your source packages can also dictate a custom `OutPath` per package.

Look inside the output directory:

- You will find generated Go files, each containing:
  - Concrete implementations of your query interfaces
  - Type-safe methods built from your SQL templates
  - Model-driven field helper structs and predicate methods for querying and updates

Example:

```bash
ls ./generated
iface.go
models.go
models_relations.go
```

If you see files like these with code containing your interfaces and generated methods, the generation ran successfully.

<Tip>
Avoid modifying the generated files directly. Treat them as autogenerated artifacts that can be regenerated anytime from your interfaces and models.
</Tip>

---

## 2. Evaluating Generated Query APIs and Field Helpers

### What to Expect in the Generated Code

- **Query Interfaces:** Concrete, generic implementations of your SQL template methods.
- **Field Helpers:** Structs with helper fields for each database column in your models.
- Methods matching your interface signatures but filled with generated SQL query-building logic.

### How to Inspect Generated Code

- Open generated files and look for functions like `Query[T any](db *gorm.DB)` returning your interfaces.
- Method implementations should contain SQL strings translated from your interface comments.
- Structs named after your models provide typed fields for creating fluent, compile-safe queries.

You should observe that:
- SQL condition templates are translated into Go code.
- Method signatures include `context.Context` even if omitted in your interface (auto-injected).
- Fields carry types configured via your `genconfig.Config` or default mappings.

Example snippet from a generated method:

```go
func (e _QueryInterfaceImpl[T]) GetByID(ctx context.Context, id int) (T, error) {
    // generated SQL and param binding
    var result T
    err := e.Raw(sb.String(), params...).Scan(ctx, &result)
    return result, err
}
```

---

## 3. Testing the Generated APIs Locally with a Quick Run

Before integrating generated code into your project, run a basic local test to make sure your query methods work and are wired up correctly.

### Step-by-Step Local Run

<Steps>
<Step title="Prepare Generated Code">
Make sure your generated code is in your Go module and accessible to your test or main package. For example, if your output is in `generated`, import it as:

```go
import "yourmodule/generated"
```
</Step>
<Step title="Open Your Database Connection">
Initialize a GORM `*gorm.DB` connection to your database.

```go
db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{})
if err != nil {
    log.Fatalf("Failed to connect to DB: %v", err)
}
ctx := context.Background()
```
</Step>
<Step title="Create an Instance of the Query Interface">
Use the generated constructor to get your query interface:

```go
query := generated.Query[models.User](db)
```
</Step>
<Step title="Run a Sample Query">
Invoke one of your generated methods, like `GetByID`, with valid parameters.

```go
user, err := query.GetByID(ctx, 1)
if err != nil {
    log.Fatalf("Query failed: %v", err)
}
fmt.Println("User fetched:", user)
```
</Step>
</Steps>

If this runs without error and returns expected results, your generated code is working correctly.

<Tip>
Make sure your database has test data matching your queries to validate results effectively.
</Tip>

---

## 4. Troubleshooting Common Issues

### Generated Files Missing or Empty

- Verify the CLI command completed successfully without error.
- Confirm the correct input path with your interfaces.
- Check that your interfaces actually contain SQL template comments.

### Syntax Errors in Generated Code

- Ensure your Go interface files parse correctly.
- Avoid unsupported SQL template syntax.
- Review comments to confirm SQL templates are properly formatted.

### Methods Not Appearing as Expected

- Check inclusion/exclusion patterns in your `genconfig.Config`.
- Confirm interface and struct naming matches your config.

### Runtime Errors When Running Generated Methods

- Confirm your DB connection is active and reachable.
- Validate parameter values.
- Test SQL queries manually against your DB.

<Tip>
Use your IDE or `go test` tools to identify compile-time or runtime errors quickly.
</Tip>

---

## 5. Summary & Next Steps

### Success Indicators

- Generated files exist in the output directory.
- Files contain your expected interfaces and methods.
- Generated query methods compile and successfully run against a live database.

### Recommended Next Tasks

- Integrate generated code into your main Go application.
- Explore generated field helpers for building expressive, fluent queries.
- Automate regeneration as part of your build or CI process.
- Consult guides on advanced template syntax and associations for richer queries.

### Useful Documentation Links

- [Quickstart: Your First Workflow](../quickstart-overview)
- [Running Code Generation](../generation-cli-commands)
- [Basic Configuration & Structure](../basic-config-setup)
- [Using the Generated APIs in Your Project](../../guides/getting-started/using-generated-apis)
- [Common Errors & Solutions](../../getting-started/troubleshooting-faq/common-errors-solutions)

---

Ensure your first validation phase confirms the generatorâ€™s output aligns precisely with your design intent and prepares you confidently for integration.


---

## Appendix: Example Code to Validate Generated Query

```go
package main

import (
    "context"
    "fmt"
    "log"

    "gorm.io/driver/sqlite"
    "gorm.io/gorm"

    "yourmodule/generated"
    "yourmodule/models"
)

func main() {
    db, err := gorm.Open(sqlite.Open("test.db"), &gorm.Config{})
    if err != nil {
        log.Fatalf("failed to connect database: %v", err)
    }

    ctx := context.Background()

    query := generated.Query[models.User](db)

    user, err := query.GetByID(ctx, 1)
    if err != nil {
        log.Fatalf("query failed: %v", err)
    }

    fmt.Printf("Fetched user: %+v\n", user)
}
```

Replace `sqlite` and `test.db` with your actual database driver and source.

---

## Additional Resources

Visit the official [GORM CLI GitHub repository](https://github.com/go-gorm/cli) for more examples and usage patterns.

Useful commands:

```bash
gorm gen -i ./examples -o ./generated
```

Run tests to verify:

```bash
go test ./generated/...
```

Keep iterating until your generated code matches expectations and integrates smoothly into your development flow.


<Source url="https://github.com/go-gorm/cli" paths={[{"path": "internal/gen/generator_test.go", "range": "1-82"},{"path": "internal/gen/sqlparser_test.go", "range": "1-117"}]} />
