---
title: "Running Code Generation"
description: "Practical instructions for invoking the CLI to generate code. Covers the CLI command structure, specifying source and output directories, and common parameters. Includes troubleshooting tips for common mistakes in this step."
---

# Running Code Generation

This page guides you through invoking the **GORM CLI** to generate type-safe query APIs and model-driven field helpers from your Go source files. You will learn how to use the CLI commands effectively, specify input and output paths, apply common flags, and handle common issues faced during this critical step of your development workflow.

---

## 1. Overview of GORM CLI Code Generation

GORM CLI converts your Go interfaces annotated with SQL templates and your model structs into fully type-safe and ergonomic query APIs and field helpers. This process creates Go code that integrates directly with your GORM-backed project, increasing safety and development speed.

Your goal here is to execute the CLI command that parses your Go source files and outputs these generated files in your chosen directory, preserving package structure.

---

## 2. CLI Command Structure

The primary command to generate code is:

```bash
gorm gen -i <input_path> -o <output_path>
```

- **-i, --input** (required): Path to the Go interface file or directory containing your annotated interfaces and model structs.
- **-o, --output** (optional): Directory where the generated code files will be placed. Defaults to `./g` if not specified.

### Basic Example

```bash
gorm gen -i ./examples -o ./generated
```

This command:
- Scans all Go files recursively under `./examples`.
- Processes the interfaces with SQL annotations and models found.
- Outputs generated code preserving directory structure under `./generated`.

---

## 3. Step-by-Step Instructions

<Steps>
<Step title="Prepare your Go project with interfaces and models">
Ensure your project directory contains the Go interface files annotated with SQL templates and model structs, typically in the same package or a dedicated folder.

> Example:
> ```go
> // examples/query.go
> type Query[T any] interface {
>   // SELECT * FROM @@table WHERE id=@id
>   GetByID(id int) (T, error)
> }
>
> // examples/models/user.go
> type User struct {
>   ID   uint
>   Name string
> }
> ```
</Step>
<Step title="Open your terminal at the project root">
Navigate to your Go project root directory or wherever your input folder is relative to.
</Step>
<Step title="Run the generation command">
Run:
```bash
gorm gen -i ./path/to/interfaces -o ./path/to/output
```

- Replace `./path/to/interfaces` with the directory or specific file containing your interface definitions.
- Replace `./path/to/output` with your desired output directory.

If you omit `-o`, generated code goes to default `./g` folder.
</Step>
<Step title="Verify terminal output">
You should see messages like:
```
Generating file ./generated/query_gen.go from ./examples/query.go...
```

This confirms files are processed and generated correctly.
</Step>
<Step title="Check the output directory">
Explore your output path to confirm:
- Generated files preserve the same package structure as input.
- Files include type-safe query interface implementations and field helper structs.
</Step>
</Steps>

---

## 4. Common CLI Flags and Parameters

| Flag         | Description                                      | Default     | Required |
|--------------|------------------------------------------------|-------------|----------|
| `-i, --input`    | Input path (file or directory) containing Go interfaces and models | None        | Yes      |
| `-o, --output`   | Output directory for generated code                | `./g`       | No       |

---

## 5. Best Practices & Tips

- **Use directory as input**: Specifying a directory in `-i` recursively processes all Go files maintaining file structure in the output.
- **Keep generated output outside source tree**: To avoid clutter and accidental commits.
- **Define package-level `genconfig.Config` for configuration**: To customize output paths or apply include/exclude rules.
- **Use consistent naming and organization** in your Go source files for easier generation and debugging.

---

## 6. Troubleshooting Common Issues

<AccordionGroup title="Troubleshooting Code Generation">
<Accordion title="Error: Missing required input flag">
You must specify the `-i` flag with a valid Go file or directory path. Check you typed:

```bash
gorm gen -i ./path/to/interfaces
```

and the path exists.
</Accordion>

<Accordion title="No interfaces or structs found in input">
Ensure your input path contains Go files with properly defined interfaces and models.

- Interfaces should use SQL annotations in method comments.
- Structs must be exported types.

If custom filters are set via `genconfig.Config`, validate the include/exclude patterns.
</Accordion>

<Accordion title="Permission or file system errors writing to output directory">
Check write permissions on the output folder. The CLI creates directories recursively if needed but requires proper OS-level permissions.
</Accordion>

<Accordion title="Unexpected generated file location or name">
Confirm the output directory (`-o`) is correctly specified and that any `OutPath` set in `genconfig.Config` is consistent to avoid conflicts.
</Accordion>

<Accordion title="Unhandled Go syntax or parsing errors">
Make sure your Go source files compile correctly. Parsing comments for SQL templates fails if the file contains invalid Go code or syntax errors.
</Accordion>

</AccordionGroup>

---

## 7. Verifying Successful Generation

After generation completes:

- Check that Go files are present in the output directory.
- Inspect generated interfaces and field helper structs for method signatures matching your input annotations.
- Run your project build or tests to verify import correctness and API usability.

For further validation, consult the [Validating Generated APIs](../validating-generated-code) guide.

---

## 8. Related Documentation and Next Steps

- [Prerequisites & Requirements](../setup-installation/prerequisites-requirements) — Ensure your environment and project meet expectations.
- [Installing GORM CLI](../setup-installation/installing-cli) — How to install the CLI tool.
- [Basic Configuration & Structure](../basic-config-setup) — Organize your project for smooth generation.
- [Validating Generated APIs](../validating-generated-code) — Confirm the output is usable.
- [Common Errors & Solutions](../../troubleshooting-faq/common-errors-solutions) — Troubleshoot other common problems.

---

## 9. Summary

Running code generation with GORM CLI requires specifying your Go source input path and an optional output destination where the type-safe query APIs and helpers will be generated. Through the `gorm gen -i <path> -o <out>` command, you transform annotated interfaces and models into a robust API layer seamlessly. Keeping your project well-structured and configuring generation using the optional package-level config ensures a smooth, repeatable process.

<Tip>
Remember to always commit generated code with awareness, or better yet, incorporate code generation into your build or CI pipelines to ensure consistency.
</Tip>


---

For advanced scenarios, explore the [generation configuration best practices](../../guides/advanced-usage-patterns/generation-config-best-practices) to customize behavior beyond CLI flags.

---