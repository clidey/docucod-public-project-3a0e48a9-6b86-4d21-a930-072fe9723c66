---
title: "Using Generated Code in Your Project"
description: "Demonstrates how to consume the generated APIs in a real project. Walks through common usage patterns, including querying and writing, so you see immediate value after code generation."
---

# Using Generated Code in Your Project

This guide shows you how to smoothly incorporate the code generated by GORM CLI into your Go projects. By walking through common usage scenarios—querying data, updating records, and working with associations—you will quickly realize the power of the type-safe APIs and model-driven helpers in your everyday development workflow.

---

## 1. Importing the Generated Package

After generating code with `gorm gen`, you will have a new package containing your query interfaces and model field helpers. Import this package into your project to use the generated APIs.

```go
import (
    "context"
    "gorm.io/gorm"
    "your_project/generated" // Adjust import path to your generated folder
    "your_project/models"    // Your model package
)
```

<Tip>
Always ensure your `generated` package path matches the output directory specified during generation (`-o` flag).
</Tip>

---

## 2. Querying Data with Type-Safe APIs

The generated APIs expose interfaces that embed GORM’s base `*gorm.DB` functionality with your defined query methods, returning strongly typed results.

### Example: Fetch a User by ID

```go
func FetchUserByID(db *gorm.DB, userID int) (*models.User, error) {
    ctx := context.Background()
    user, err := generated.Query[models.User](db).GetByID(ctx, userID)
    if err != nil {
        return nil, err
    }
    return &user, nil
}
```

### Example: Filter Users by Name and Age

```go
func FindUsersByNameAge(db *gorm.DB, name string, age int) ([]models.User, error) {
    ctx := context.Background()
    users, err := generated.Query[models.User](db).FilterByNameAndAge(name, age).Find(ctx)
    if err != nil {
        return nil, err
    }
    return users, nil
}
```

<Tip>
The context parameter (`ctx context.Context`) is auto-inserted into generated method signatures if missing in your interface. Always pass a valid context.
</Tip>

---

## 3. Writing Data Using Generated Helpers

Use the generated field helpers to build expressive, type-safe update and create queries.

### Creating a New Record

```go
func CreateUser(db *gorm.DB, name string, age int) error {
    ctx := context.Background()
    user := models.User{
        Name: name,
        Age:  age,
    }
    return gorm.G[models.User](db).
        Set(
            generated.User.Name.Set(user.Name),
            generated.User.Age.Set(user.Age),
        ).
        Create(ctx)
}
```

### Updating a Record

```go
func UpdateUserAge(db *gorm.DB, userID int, newAge int) error {
    ctx := context.Background()
    return gorm.G[models.User](db).
        Where(generated.User.ID.Eq(userID)).
        Set(generated.User.Age.Set(newAge)).
        Update(ctx)
}
```

<Tip>
Use the fluent `Set()` methods with generated fields to avoid manual string SQL and minimize errors.
</Tip>

---

## 4. Working with Associations

Generated code also provides helpers for associations such as `HasMany`, `BelongsTo`, and `Many2Many`, offering type-safe operations for creating, updating, unlinking, or deleting related records.

### Example: Create a User with a Pet

```go
func CreateUserWithPet(db *gorm.DB) error {
    ctx := context.Background()
    return gorm.G[models.User](db).
        Set(
            generated.User.Name.Set("alice"),
            generated.User.Pets.Create(
                generated.Pet.Name.Set("fido"),
            ),
        ).
        Create(ctx)
}
```

### Example: Update User’s Pet Name where Pet Name is "fido"

```go
func RenamePet(db *gorm.DB, userID uint) error {
    ctx := context.Background()
    return gorm.G[models.User](db).
        Where(generated.User.ID.Eq(userID)).
        Set(
            generated.User.Pets.Where(generated.Pet.Name.Eq("fido")).
                Update(generated.Pet.Name.Set("rex")),
        ).
        Update(ctx)
}
```

### Example: Unlink or Delete Associated Records

```go
// Unlink (clear FK or remove join rows)
func UnlinkPets(db *gorm.DB, userID uint) error {
    ctx := context.Background()
    return gorm.G[models.User](db).
        Where(generated.User.ID.Eq(userID)).
        Set(generated.User.Pets.Unlink()).
        Update(ctx)
}

// Delete associated pets
func DeletePets(db *gorm.DB, userID uint) error {
    ctx := context.Background()
    return gorm.G[models.User](db).
        Where(generated.User.ID.Eq(userID)).
        Set(generated.User.Pets.Delete()).
        Update(ctx)
}
```

<Note>
Operations like `Unlink()` and `Delete()` behave differently based on association type—refer to the [Mastering Associations guide](../guides/advanced-patterns/mastering-associations) for detailed semantics.
</Note>

---

## 5. Understanding Fluent Method Chains

Generated query interfaces support chaining, allowing you to build complex queries before executing.

```go
users, err := generated.Query[models.User](db).
    FilterByNameAndAge("jinzhu", 25).
    Where(generated.User.Age.Gt(18)).
    Find(ctx)
```

The same applies to updates and deletes using the provided helpers.

<Tip>
Review method signatures in generated code for parameters and return types. The generator ensures methods are strongly typed based on your interface definitions.
</Tip>

---

## 6. Troubleshooting Common Issues

- **Missing Generated Package:** Confirm you built code after changing interfaces or models and used the correct output import path.
- **Method Not Found:** Check your interface comments for correct SQL templates; methods without valid SQL templates are omitted.
- **Context Errors:** If context is missing, ensure you pass a valid `context.Context` when calling generated methods.
- **Import Conflicts:** Clear outdated generated files before regenerating to prevent stale imports.

See [Troubleshooting Common Setup Issues](../../getting-started/configuration-and-troubleshooting/troubleshooting-common-issues) for detailed advice.

---

## 7. Next Steps

- Explore writing more advanced query interfaces with rich SQL templates.
- Customize code generation with `genconfig.Config` for mapping special field types.
- Use the generated helpers in unit tests to improve coverage and type safety.
- Dive into the [Working with Type-Safe Query APIs](../core-workflows/working-with-type-safe-queries) and [Using Model-Driven Field Helpers](../core-workflows/using-model-field-helpers) guides for deeper mastery.

---

## Additional Resources

- [Quick Start and Installation](../../getting-started/prerequisites-installation/installation)
- [Preparing Your Models and Interfaces](../../getting-started/first-run-basic-usage/prepare-code)
- [Running the Generator](../../getting-started/first-run-basic-usage/run-generator)
- [Mastering Associations](../../guides/advanced-patterns/mastering-associations)

---

With your generated code now integrated, you harness the full potential of GORM CLI: safe, discoverable, and performant interactions with your database—everyday tasks become a breeze, and your data layer more maintainable than ever.