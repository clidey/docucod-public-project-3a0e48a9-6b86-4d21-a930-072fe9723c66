---
title: "Using Your Generated APIs"
description: "Demonstrates how to import and work with the generated field helpers and query APIs in your application code. Shows quick validation steps for basic CRUD operations using the new, type-safe APIs."
---

# Using Your Generated APIs

This guide demonstrates how to import and work with the generated field helpers and query APIs from GORM CLI in your application code. You will learn how to perform basic CRUD operations quickly and with type-safety using the generated code, along with how to validate your setup by running simple queries and updates.

---

## 1. Importing Your Generated Code

After running the GORM CLI generator, your code will be output to the directory you specified (e.g., `./generated`). To begin using the generated APIs and field helpers:

1. Add the generated package to your Go module by importing it where you intend to use the generated queries and models.

```go
import (
  "context"
  "gorm.io/gorm"
  "your_project/generated" // replace with your actual generated package path
)
```

2. Also import your GORM DB instance and any dependencies as normal.

<Tip>
The exact import path depends on the `-o` (output) option you used when generating code with the CLI.
</Tip>

---

## 2. Using Generated Query APIs

The core benefit of GORM CLI is the generation of type-safe, interface-driven query APIs based on your annotated Go interfaces. Here's how to get started:

### a. Instantiate Query Interface

Use the generated constructor function for your interface, passing your `*gorm.DB` instance as the first argument.

```go
ctx := context.Background()
db := /* your initialized *gorm.DB instance */

// Instantiate api for Query[UserInfo] interface (replace UserInfo with your model type)
queryAPI := generated.Query[User](db)
```

<Tip>
If your interface is named `Query`, a function named `Query[T any](db *gorm.DB)` is generated on this package.
</Tip>

### b. Run Queries

Call the generated methods with the appropriate parameters and context.

```go
// Example: Query user by ID
user, err := queryAPI.GetByID(ctx, 123)
if err != nil {
  // handle error
}
fmt.Println("User:", user)

// Example: Filter users by dynamic column
result, err := queryAPI.FilterWithColumn(ctx, "email", "alice@example.com")
```

### c. Using Fluent Builders

For query methods that return builders (e.g., `FilterByNameAndAge`), you can chain them with GORM calls as returned.

```go
users, err := queryAPI.FilterByNameAndAge("bob", 30).Find(ctx)
```

---

## 3. Working with Generated Field Helpers

Alongside query APIs, GORM CLI generates strongly-typed field helpers for your model structs. These helpers enable you to build filters and mutations with type safety and discoverability.

### a. Access Field Helpers

Each model struct is represented as a variable with fields for each column.

```go
// For model User, generated field helpers are accessible as
idField := generated.User.ID
nameField := generated.User.Name
```

### b. Build Predicates

Use helpers to create SQL expressions in your filters and updates.

```go
// Filter users by ID equality
filter := idField.Eq(123)

// Filter users by name LIKE
nameFilter := nameField.Like("%smith%")

// Range filter on Age
ageFilter := generated.User.Age.Between(18, 65)
```

### c. Use in GORM Queries

Combine the predicates in GORM's `Where` or other clauses.

```go
var users []User
err := db.Where(filter).Find(&users).Error

// Or chain multiple conditions
err = db.Where(nameFilter).Where(ageFilter).Find(&users).Error
```

### d. Perform Updates and Creates

Use the `Set` helpers to build updates or creates.

```go
// Update user's name where ID = 123
err := db.Model(&User{}).
  Where(generated.User.ID.Eq(123)).
  Update("name", generated.User.Name.Set("alice_updated"))

// Create new user with fields set
err = db.Clauses(clause.OnConflict{DoNothing: true}).Create(&User{
  Name: "new_user",
  Age: 20,
}).Error
```

<Tip>
For batch and association operations, use methods like `CreateInBatch`, `Unlink()`, `Delete()`, and `Where()` chaining on association helpers as described in the API references.
</Tip>

---

## 4. Quick Validation of Your Generated APIs

To confirm that your generated code works as expected, run these minimal actions:

<Steps>
<Step title="Initialize DB Connection">
Make sure you have a valid GORM `*gorm.DB` connection to your database.
</Step>
<Step title="Query by ID">
Invoke `GetByID` or a simple generated query method:

```go
user, err := generated.Query[User](db).GetByID(ctx, 1)
if err != nil {
  log.Fatalf("Query failed: %v", err)
}
fmt.Printf("Fetched user: %+v", user)
```
</Step>
<Step title="Filter by Field">
Use field helpers in filters:

```go
users, err := db.Where(generated.User.Name.Like("%example%"))
  .Find(&[]User{}).Error
if err != nil {
  log.Fatalf("Filter query failed: %v", err)
}
```
</Step>
<Step title="Update a Record">
Update fields using generated setters:

```go
err = db.Model(&User{}).
  Where(generated.User.ID.Eq(1)).
  Update("name", generated.User.Name.Set("updated_name"))

if err != nil {
  log.Fatalf("Update failed: %v", err)
}
```
</Step>
</Steps>

<Check>
Successful execution of these operations confirms your generated APIs and field helpers integrate correctly with your DB.
</Check>

---

## 5. Best Practices & Tips

- **Use context consistently:** All generated query methods accept `context.Context`; pass it to control cancellations and deadlines.
- **Model synchronization:** Make sure your model structs match your database schema exactly before generation.
- **Re-generate after changes:** Every time your interfaces or models change, re-run `gorm gen` to update your APIs.
- **Leverage IDE autocomplete:** Generated code supports discoverability; rely on your IDE's code completion for fluent usage.

---

## 6. Troubleshooting Common Issues

<AccordionGroup title="Common Pitfalls When Using Generated APIs">
<Accordion title="Generated Methods Not Found in Package">
Ensure your import path matches the generated output directory and package.

Run `go mod tidy` and verify your project compiles.
</Accordion>
<Accordion title="Type Mismatches or Missing Parameters">
Verify your interface method signatures match those expected by the generator, especially the use of `context.Context`.

Check the generated code for parameter lists.
</Accordion>
<Accordion title="Database Connection Issues in Your Code">
Confirm your GORM DB instance is properly initialized and connected.

Run standalone tests on your DB connection.
</Accordion>
</AccordionGroup>

---

## 7. Next Steps & Further Reading

- Proceed to **[Generating Code with GORM CLI](getting-started/first-codegen/generating-code.md)** for details on running the generator CLI.
- Explore **[Building Queries with Generated APIs](guides/core-patterns/building-queries.md)** to master advanced querying.
- Review **[Updates, Filters, and Field Helpers](guides/core-patterns/using-field-helpers.md)** to fully leverage the generated helpers.
- Check **[Troubleshooting Common Setup Issues](getting-started/first-codegen/basic-troubleshooting.md)** if you encounter problems.

---

## References

- GORM Documentation: https://gorm.io/docs/
- GORM CLI GitHub repository: [https://github.com/go-gorm/cli](https://github.com/go-gorm/cli)

---

Using the generated APIs directly in your code unlocks the power of compile-time safety and fluent SQL operations. This guide ensures you can hit the ground running with your freshly generated code.

---