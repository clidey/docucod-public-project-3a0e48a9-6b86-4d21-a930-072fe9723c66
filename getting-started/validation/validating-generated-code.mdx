---
title: "Validating Your Generated APIs"
description: "Demonstrates how to use the generated APIs for model queries and updates. Includes quick examples to execute in your project, ensuring everything works end-to-end with your GORM integration."
---

# Validating Your Generated APIs

This guide walks you through practical examples to validate the APIs generated by GORM CLI for your models and query interfaces. You'll perform representative operations such as querying, filtering, updating, and leveraging the fluent, type-safe methods generated from your interface SQL templates and model-driven field helpers. These examples ensure your generated code integrates seamlessly with GORM and behaves as expected in real-world use.

---

## 1. Prerequisites

Before you begin validating the generated APIs, ensure you have:

- Installed the GORM CLI and generated code using your query interfaces and models.
- Imported the generated packages correctly in your project.
- A GORM `*gorm.DB` instance connected to your target database.
- Context (`context.Context`) ready for running queries.

<Tip>
Make sure your database is seeded with some sample data matching your models to observe meaningful query results.
</Tip>

## 2. Accessing Your Generated Query API

The generator creates type-safe query APIs based on your interfaces with embedded SQL templates. You access them as constructors matching your interface names with generic typing:

```go
// Assume you have a User model
queryAPI := generated.Query[models.User](db)
```

This returns the generated implementation, ready to execute your defined methods with type safety.

## 3. Running Basic Queries

### Example: GetByID
Fetch a single user record by ID.

```go
user, err := queryAPI.GetByID(ctx, 123)
if err != nil {
    log.Fatalf("failed to get user by ID: %v", err)
}
fmt.Printf("User: %+v\n", user)
```

This executes the generated SQL based on your SQL template for `GetByID`. The result is the user struct matching your model.

### Example: FilterWithColumn
Query by dynamic column and value.

```go
user, err := queryAPI.FilterWithColumn(ctx, "email", "user@example.com")
if err != nil {
    log.Fatalf("failed filter with column: %v", err)
}
fmt.Printf("User: %+v\n", user)
```

It dynamically binds the column name and query value, safely generating the right query.

## 4. Using Conditional Queries

### Example: QueryWith
Run queries with conditional SQL based on struct fields.

```go
userParam := models.User{ID: 0, Name: "alice"}
result, err := queryAPI.QueryWith(ctx, userParam)
if err != nil {
    log.Fatalf("error querying with user conditions: %v", err)
}
// result is your typed struct T
fmt.Printf("QueryWith result: %+v\n", result)
```

This leverages template DSL conditionals like `{{if}}` to generate dynamic WHERE clauses based on your method's input.

## 5. Updating Records

Example: Update user information conditionally.

```go
updateUser := models.User{Name: "bob", Age: 30}
err := queryAPI.UpdateInfo(ctx, updateUser, 123)
if err != nil {
    log.Fatalf("failed to update user info: %v", err)
}
fmt.Println("Update completed successfully")
```

The generated update respects the template logic to update only changed fields and sets computed columns like `is_adult` automatically.

## 6. Filtering with Collections

Use filter methods accepting slices to build complex OR conditions efficiently.

```go
users := []models.User{
    {Name: "alice", Age: 25, Role: "admin"},
    {Name: "bob", Age: 28, Role: "user"},
}
results, err := queryAPI.Filter(ctx, users)
if err != nil {
    log.Fatalf("filter query failed: %v", err)
}
for _, r := range results {
    fmt.Printf("Filtered user: %+v\n", r)
}
```

This demonstrates batch filtering with properly concatenated OR conditions.

## 7. Simple Where-Style Filters

Some methods operate using the generated fluent API chaining `Where` or `Filter` calls.

```go
// No result return; appends to current query
queryAPI.FilterByNameAndAge("alice", 30)
```

Use these within query chains to extend filters dynamically.

## 8. Time Range Filtering

For queries based on time ranges:

```go
start := time.Date(2023, 1, 1, 0, 0, 0, 0, time.UTC)
end := time.Now()
filteredUsers, err := queryAPI.FilterWithTime(ctx, start, end)
if err != nil {
    log.Fatalf("filter with time failed: %v", err)
}
fmt.Printf("Users filtered by time range: %d found\n", len(filteredUsers))
```

This method uses conditional SQL to generate optional WHERE clauses based on time boundaries.

## 9. Understanding and Troubleshooting Outputs

### Success Criteria
- Methods return expected data types or confirm update success.
- SQL generated matches your template's logic.
- No errors occur during query execution.

### Common Issues
- **No results returned:** Confirm the database has relevant test data.
- **SQL syntax errors:** Verify your raw SQL templates follow the DSL rules, especially around placeholders (`@param`) and conditional blocks.
- **Context missing error:** Ensure `context.Context` is passed to all method calls.

<Note>
If unexpected errors occur, consider regenerating the code and reviewing the method SQL comments for correctness.
</Note>

## 10. Next Steps

After you have validated your generated APIs:

- Explore [Using Model-Driven Field Helpers](/guides/core-workflows/field-helpers) to build expressive, type-safe filtering and updates.
- Refer to [Working with Associations](/guides/advanced-patterns/working-with-associations) to manage complex relationships effortlessly.
- For advanced queries, check out [Writing Flexible Template-Based Queries](/guides/advanced-patterns/template-based-queries).
- Visit [Troubleshooting Common Issues](/getting-started/validation/troubleshooting) if you run into errors.

---

This validation guide ensures you confidently leverage your generated GORM CLI code for robust, maintainable database operations integrated with GORM.
