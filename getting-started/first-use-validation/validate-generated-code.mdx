---
title: "Validating Generated APIs"
description: "Verify that generated query APIs and field helpers work as intended by walking through sample queries and updates. Includes sample code for using the generated API in your own project."
---

# Validating Generated APIs

Verify that your generated query APIs and field helpers operate as expected by stepping through practical examples. This guide walks you through running sample queries and update operations using the generated code, helping you ensure the APIs fit your project needs and are integrated correctly.

---

## 1. Understanding the Purpose

Once you have generated code using GORM CLI, the next critical step is to verify the generated query interfaces and field helpers work as intended. This ensures your SQL templates and struct definitions properly translate into type-safe, fluent APIs you can consume in your Go projects.

This validation focuses specifically on:

- Executing sample queries through the generated interfaces
- Using field helpers to construct filters, updates, and associations
- Confirming the generated methods compile and return expected results
- Referencing code snippets that demonstrate common patterns

> By internally testing and running example queries, you'll gain confidence your generation workflow is configured correctly and ready for production use.

---

## 2. Setting Up Your Validation Environment

Before running validations:

- Ensure you have properly generated your code using the `gorm gen` command with the correct input interfaces and output paths
- Confirm your Go project imports the generated package correctly
- Have a GORM database connection (`*gorm.DB`) configured and ready

For fresh users, follow the quick start guides on installation and generating your first code:

- [Installing GORM CLI](../../getting-started/setup-installation/cli-installation)
- [Generating Your First Code](../../getting-started/first-use-validation/generate-first-code)

---

## 3. Validating Query Interfaces

The generated query interfaces expose methods mapped from your SQL-annotated Go interfaces. Each method corresponds to a query or update operation built from SQL templates. Validate them as follows:

### Step 3.1: Import and Initialize

Import your generated package and initialize a query interface instance using your database connection.

```go
import (
  "context"
  "your_project/generated"
  "gorm.io/gorm"
)

func validateQueries(db *gorm.DB) error {
  ctx := context.Background()
  q := generated.Query[YourModel](db)

  // Your subsequent validation calls here
  return nil
}
```

### Step 3.2: Run Sample Query Methods

Call query methods with sample parameters, checking for:

- Successful execution (no errors)
- Correct number and type of return values
- Expected data returned or updated

Example for a generated method `GetByID`:

```go
user, err := q.GetByID(ctx, 123)
if err != nil {
  return fmt.Errorf("query GetByID failed: %w", err)
}
fmt.Printf("User with ID 123: %+v\n", user)
```

### Step 3.3: Exercise Filtering and Dynamic Queries

Test methods with dynamic SQL templates and filters:

```go
users, err := q.FilterByNameAndAge(ctx, "alice", 30).Find(ctx)
if err != nil {
  return fmt.Errorf("query FilterByNameAndAge failed: %w", err)
}
fmt.Printf("Users named alice aged 30: %v\n", users)
```

This confirms your conditional and parameterized SQL generation works correctly.

### Step 3.4: Validate Update Methods

Test update operations from generated methods that apply SQL SET clauses:

```go
err := q.UpdateUser(ctx, generated.User{Name: "Alice", Age: 31}, 123)
if err != nil {
  return fmt.Errorf("UpdateUser failed: %w", err)
}
```

Check that updates are applied correctly in your database.

---

## 4. Validating Field Helpers

Field helpers expose type-safe predicates and setters for your model fields. These enable crafting fluent expressions for queries and updates.

### Step 4.1: Using Predicates

Build filters using generated predicates:

```go
// Example: select users with ID=1
condition := generated.User.ID.Eq(1)
var user YourModel
err := db.Where(condition).Take(ctx, &user).Error
if err != nil {
  return fmt.Errorf("predicate query failed: %w", err)
}
```

### Step 4.2: Constructing Updates

Use setters for updates, including complex expressions:

```go
err := db.Model(&YourModel{}).
  Where(generated.User.Name.Eq("alice")).
  Update(ctx,
    generated.User.Age.Set(32),
    generated.User.IsAdult.Set(true),
  )
if err != nil {
  return fmt.Errorf("update with setters failed: %w", err)
}
```

### Step 4.3: Working with Associations

Test generated association helpers:

```go
// Create and associate pets for a user
err := db.Set(generated.User.Pets.Create(generated.Pet.Name.Set("fido"))).Create(ctx)
if err != nil {
  return fmt.Errorf("association create failed: %w", err)
}
```

Validate that the helper methods for `Create`, `Update`, `Unlink`, and `Delete` on associations behave as expected.

---

## 5. Sample Validation Code Snippet

```go
func ValidateGeneratedAPIs(db *gorm.DB) error {
  ctx := context.Background()
  q := generated.Query[User](db)

  // Validate simple query
  user, err := q.GetByID(ctx, 1)
  if err != nil {
    return err
  }
  fmt.Println("User:", user)

  // Validate filtering query
  users, err := q.FilterByNameAndAge(ctx, "alice", 25).Find(ctx)
  if err != nil {
    return err
  }
  fmt.Println("Filtered Users:", users)

  // Validate update method
  err = q.UpdateUser(ctx, User{Name: "alice_updated", Age: 26}, 1)
  if err != nil {
    return err
  }

  // Validate predicates
  var u User
  if err := db.Where(generated.User.ID.Eq(1)).Take(ctx, &u).Error; err != nil {
    return err
  }

  // Validate association create
  err = db.Set(generated.User.Pets.Create(generated.Pet.Name.Set("rex"))).Create(ctx)
  if err != nil {
    return err
  }

  return nil
}
```

Running this snippet with your generated APIs confirms that your code operates correctly end-to-end.

---

## 6. Troubleshooting Common Validation Issues

<AccordionGroup title="Common Validation Problems and How to Fix Them">
<Accordion title="Generated Methods Not Found or Not Compiling">
Ensure:
- The generation process completed successfully without errors
- Your Go module imports the correct generated package path
- Go code is refreshed/rebuilt post-generation
</Accordion>
<Accordion title="Queries Return No Data or Errors">
- Verify your database connection and data state
- Confirm that parameters passed to query methods are valid
- Check your SQL templates for logical correctness and required annotations
</Accordion>
<Accordion title="Field Helper Methods Missing or Incomplete">
- Confirm your model structs are correctly annotated and exported
- Check for filtering configurations that might exclude your structs or fields
- Regenerate code after model or config changes
</Accordion>
<Accordion title="Association Operations Fail or Behave Unexpectedly">
- Verify foreign keys and association tags in your models
- Ensure association helpers match the relation type (has one, belongs to, many2many)
- Check for correct usage of Unlink versus Delete to avoid data loss
</Accordion>
</AccordionGroup>

<Note>
Always re-run code generation after modifying your interfaces, structs, or configurations to keep the generated code in sync.
</Note>

---

## 7. Next Steps

Once validation succeeds:

- Integrate generated query APIs and field helpers into your business logic
- Explore advanced features like template-based dynamic queries and association operations
- Customize generation behavior via `genconfig.Config` as needed
- Consult related documentation to deepen your mastery:
  - [Generating Your First Code](../generate-first-code)
  - [Working with Associations: Patterns & Best Practices](../../guides/advanced-usage-patterns/advanced-association-operations)
  - [Mastering the SQL Template DSL](../../guides/advanced-usage-patterns/template-sql-dsl)

Return to your main project workflow with confidence that your generated APIs perform as expected.

---

## References

- [GORM CLI Quickstart Workflow](../../overview/features-workflows/quickstart-workflow) — Understand the end-to-end process
- [SQL Template DSL Documentation](../../guides/advanced-usage-patterns/template-sql-dsl) — Learn templating for custom queries
- [Configuring Code Generation](../../guides/advanced-usage-patterns/customizing-generation) — Tailor generation to project needs

---

This completes your guide to validating your generated query APIs and field helpers.

For help with issues encountered during validation, see the [Troubleshooting Setup Issues](../troubleshooting-common-issues) guide.

---

<Check>
Remember: validation is key to unlocking the full value of your generated code—test early and often.
</Check>
