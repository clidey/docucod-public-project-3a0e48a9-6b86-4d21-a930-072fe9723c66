---
title: "Project Configuration"
description: "Introduces the basics of project setup, including defining your Go models and interfaces, and (optionally) configuring code generation through `genconfig.Config`. Helps users bridge the gap between their domain models and GORM CLI."
---

# Project Configuration

Welcome to your first step in mastering GORM CLI. This guide introduces how to configure your Go projects to leverage GORM CLI’s powerful code generation capabilities. You'll learn how to define your domain models and query interfaces, and optionally tune code generation behavior with `genconfig.Config`. This foundational setup bridges your Go code with the GORM CLI generator, enabling type-safe and expressive database operations.

---

## 1. Understanding Project Configuration Purpose

GORM CLI translates **user-defined Go models and interfaces** into generated query APIs and field helpers. This process requires no configuration to get started, but **project-level configuration lets you customize:**

- **Output locations** for generated code
- **Which Go interfaces or structs to include or exclude**
- **Custom mappings for Go field types or field tags** to specialized SQL helpers

Think of the project configuration as your control panel to steer code generated by GORM CLI for your specific domain models.

---

## 2. Defining Your Domain Models and Query Interfaces

The generator scans the Go source files you point to and processes:

- **Structs**: Your domain models, e.g., `User`, `Account`.
- **Interfaces**: Interfaces containing methods with raw SQL templates in comments, e.g., `Query[T any]`.

Example from `examples/query.go`:

```go
package examples

type Query[T any] interface {
  // SELECT * FROM @@table WHERE id=@id
  GetByID(id int) (T, error)

  // ... other methods with SQL templates
}

// User model struct example
// type User struct {
//   ID   int
//   Name string
// }
```

The generator will produce concrete implementations of these interfaces and field helpers from structs.

---

## 3. Optional Configuration with `genconfig.Config`

To customize generation behavior, define a package-level variable of type `genconfig.Config`. This informs GORM CLI on:

- **Output directory for generated files (`OutPath`)**
- **Field type mappings:** map Go types to wrapper helpers (e.g., map `sql.NullTime{}` to `field.Time{}`)
- **Field name mappings:** map struct field tags to custom helpers
- **File-level or package-level generation scope**
- **Whitelists or blacklists for interfaces and structs**

### Example Configuration

```go
package examples

import (
  "database/sql"
  "gorm.io/cli/gorm/field"
  "gorm.io/cli/gorm/genconfig"
)

var _ = genconfig.Config{
  // Output folder for generated code
  OutPath: "examples/output",

  // Map Go standard types to special field helpers
  FieldTypeMap: map[any]any{
    sql.NullTime{}: field.Time{},
  },

  // Map custom `gen` tags to helpers
  FieldNameMap: map[string]any{
    "date": field.Time{},
    "json": JSON{},
  },

  // Specify interfaces or structs to include (optional)
  IncludeInterfaces: []any{},
}
```

In this snippet:

- `OutPath` tells the generator where to place output code relative to your project.
- `FieldTypeMap` and `FieldNameMap` instruct how field types or tags are wrapped, enhancing flexibility.

> **Tip:** You can configure the generator to include only certain interfaces or structs, or exclude deprecated ones—fine-grained control lets you optimize generation scope.

---

## 4. How the Generator Applies Configuration

When processing your source files,

- The generator looks for `genconfig.Config` definitions within your Go files.
- It applies include/exclude filters based on your config.
- It uses your field mappings for generating type-safe field helpers.
- It determines output paths per your specified `OutPath`.

Example from `examples/filters/pattern/config.go` shows filtering interfaces:

```go
package pattern

import "gorm.io/cli/gorm/genconfig"

// Generate only interfaces whose names start with "Query"
var _ = genconfig.Config{
  IncludeInterfaces: []any{"Query*"},
}
```

This lets you focus code generation on interfaces matching the pattern.

---

## 5. Practical Steps to Setup Your Project Configuration

<Steps>
<Step title="Create Your Go Models and Query Interfaces">
Define your domain structs and interfaces with raw SQL template comments in your preferred Go package.
</Step>
<Step title="(Optional) Add a `genconfig.Config` Variable">

Create a package-level variable using `genconfig.Config` to adjust generation settings like output path, type mappings, and inclusion/exclusion filters.

Example:

```go
var _ = genconfig.Config{
  OutPath: "generated",
  FieldTypeMap: map[any]any{sql.NullTime{}: field.Time{}},
  IncludeInterfaces: []any{"Query*"},
}
```
</Step>
<Step title="Run the GORM CLI Generator">

Use the CLI to run generation on your source directory:

```bash
gorm gen -i ./your_package -o ./generated
```

The CLI automatically recognizes your `genconfig.Config` settings.
</Step>
</Steps>

---

## 6. Best Practices and Tips

- **Single Config Per Package:** Place one `genconfig.Config` per package to control generation behavior precisely.
- **Use Patterns for Inclusion:** Use glob-like strings (e.g., "Query*", "User") to include/exclude groups easily.
- **Leverage Field Mappings:** Map Go types and `gen` tags for cleaner and more expressive generated code.
- **FileLevel Flag:** If `FileLevel` is true in your config, the generator applies config only to that source file, not the whole package.

<Note>
Incomplete or missing configuration will still generate code, but **you lose the ability to customize output locations and field mappings**.
</Note>

---

## 7. Troubleshooting Common Issues

<AccordionGroup title="Project Configuration Troubleshooting">
<Accordion title="The generator ignores my `genconfig.Config` variable">
Verify that your config variable:

- Has the exact type `genconfig.Config`
- Is declared at package scope (not inside a function)
- Uses typed instances (e.g., `FieldTypeMap: map[any]any{sql.NullTime{}: field.Time{}}`)
</Accordion>
<Accordion title="My output files go to unexpected folders">
Double-check your `OutPath` value in the config and CLI flags; the CLI flag `-o` overrides package config settings.
</Accordion>
<Accordion title="Cannot map custom field types or tags">
Make sure your `FieldTypeMap` and `FieldNameMap` values are typed composite literals to trigger import path discovery.
</Accordion>
</AccordionGroup>

---

## 8. Additional Resources

- [Generating Code](./generating-code) — Learn how to run the generator CLI.
- [Template-Based Query DSL](../advanced-patterns/template-sql-dsl) — Dive into the SQL template language used in your interfaces.
- [Model-Driven Field Helpers](../core-workflows/model-driven-field-helpers) — Understand the generated field helpers from your models.
- [Quick Validation](./quick-validation) — Verify your generated code works as expected.

Start your project configuration journey here to unlock type-safe, efficient data access tailored to your Go domain models.

---

For deep integration insights, see [Integration & Ecosystem Compatibility](../../overview/concepts-architecture/integration-overview) and [Core Concepts & Terminology](../../overview/concepts-architecture/core-concepts-terminology).

---

# Summary

This page introduces the foundation of GORM CLI project configuration: defining your Go models and query interfaces, and optionally configuring code generation with `genconfig.Config`. It guides you through setting output paths, type mappings, and inclusion/exclusion filters, allowing precise control over code generation and integration with your domain models. Practical examples, best practices, and troubleshooting tips ensure you set up with confidence. For continued mastery, explore linked guides on generating code, SQL templates, and model-driven helpers.