---
title: "Generate Code: Your First Run"
description: "Follow a no-nonsense sequence: add your model and interface files, run `gorm gen`, and examine the generated output. See exactly what to expect and how the process fits into your workflow."
---

# Generate Code: Your First Run

Welcome to your first code generation run with GORM CLI. This guide walks you through the exact steps to add your model and interface files, execute the `gorm gen` command, and examine the generated code artifacts. You'll gain a clear understanding of what to expect and how this fits into your broader workflow.

---

## 1. Prepare Your Input Files

GORM CLI uses two primary source inputs to produce code:

- **Model files**: Go structs that define your database schema.
- **Interface files**: Go interfaces with method comments containing SQL templates describing your query APIs.

### Organize Your Files

> Ensure your models and query interfaces are located in the same directory or package. This organization allows the generator to process the models and interfaces together for seamless code output.

For example, your project structure might look like this:

```
project/
 ├─ examples/
 │   ├─ models.go      # Your model structs
 │   └─ query.go       # Your query interfaces with SQL templates
```

### Example Interface

Here is what a sample interface with SQL template comments looks like:

```go
// In examples/query.go

type Query[T any] interface {
  // SELECT * FROM @@table WHERE id=@id
  GetByID(id int) (T, error)

  // where("name=@name AND age=@age")
  FilterByNameAndAge(name string, age int)
}
```

These comments define the SQL executed for each method. `@@table` and `@param` placeholders are resolved during code generation.


## 2. Run the Code Generator (`gorm gen`)

Once your input files are ready, use the CLI to generate your query APIs and field helpers.

### Basic Command Usage

```bash
gorm gen -i ./examples -o ./generated
```

- `-i` or `--input`: Path to the directory or Go file containing your model and interface definitions.
- `-o` or `--output`: Directory to place the generated Go files (defaults to `./g` if omitted).

### Step-by-Step

<Steps>
<Step title="Open your terminal and navigate to your project root">
Change to the root directory where your input files reside.
</Step>
<Step title="Run the generator command with input and output flags">
Copy and run:

```bash
gorm gen -i ./examples -o ./generated
```

The generator will parse your input and write the output into the specified folder.
</Step>
<Step title="Observe the CLI output">
You should see console logs listing each generated file, such as:

```
Generating file generated/query.go from examples/query.go...
```
This confirms successful parsing and file creation.
</Step>
</Steps>

### Default Behavior

If you omit the output path, the generator writes files under `./g`:

```bash
gorm gen -i ./examples
```

This directory structure preserves the relative paths from input.


## 3. What Happens Behind the Scenes?

The generator:

- Parses your Go files, extracting interface methods and associated SQL templates.
- Inspects model structs to create type-safe field helpers for filter, update, and association operations.
- Renders Go source files implementing concrete query methods based on your interfaces.
- Applies optional configuration you define in `genconfig.Config` if present.


## 4. Examine the Generated Output

After running, explore the output directory you specified.

### Typical Output Includes:

- **Query API files:** Concrete implementations of your interfaces with generated methods.
- **Field helper files:** Strongly-typed field definitions exposing predicates and update helpers.

Example generated snippet:

```go
// Query API method
func (e _QueryInterfaceImpl[T]) GetByID(ctx context.Context, id int) (T, error) {
  sql := `SELECT * FROM @@table WHERE id=@id`
  return e.Exec(ctx, sql, id)
}

// Field helper for 'Name' column
var User = struct {
  Name field.String
}{
  Name: field.String{}.WithColumn("name"),
}
```

### Validate the Output

Check that:

- Files exist in your specified output directory.
- Generated code matches your input interface methods.
- Field helpers correspond to your model structs.


## 5. How Does This Fit in Your Workflow?

Running `gorm gen` is your **gateway step** to adopting type-safe, efficient query APIs with GORM CLI. Once generated:

- Import the generated packages into your application.
- Use generated query methods for type-safe DB access.
- Leverage field helpers for expressive query/filter composition.


## 6. Tips and Best Practices

- **Keep interfaces focused**: Define clear methods with concise SQL annotations.
- **Use the template DSL fully**: Take advantage of placeholders like `@@table`, `@param`, and directives (`{{where}}`, `{{set}}`) for dynamic SQL.
- **Structure inputs cleanly**: Group related interfaces and models for easier maintenance.
- **Leverage genconfig.Config**: Customize generation behavior like output paths or field mappings for advanced needs.


## 7. Troubleshooting Your First Run

<AccordionGroup title="Common Issues">
<Accordion title="Missing Input Path Error">
Ensure you specify the `-i` flag with your input path.

```bash
gorm gen -i ./examples
```

The input flag is required and must point to valid Go source files.
</Accordion>
<Accordion title="Output Directory Not Created or Empty">
Check write permissions for the output folder. The generator creates directories as needed but requires the right OS permissions.

Also confirm your input directory contains processable Go source code.
</Accordion>
<Accordion title="No Methods Generated">
Verify your interfaces have methods with SQL template comments. Methods without SQL definitions are skipped or cause errors.

Consult your method comments to ensure valid SQL templates.
</Accordion>
</AccordionGroup>


## 8. Next Steps

Once you've successfully run your first generation:

- [Validate Generated Code](/getting-started/first-steps/validate-output) to confirm correctness.
- Explore [Optional: Configuration Setup](/getting-started/first-steps/config-setup) to customize generation.
- Dive into [Working with Type-Safe Queries](/guides/core-workflows/type-safe-queries) for practical usage.


---

By following this focused sequence—add your Go models/interfaces, run `gorm gen`, and examine your output—you unlock powerful, type-safe database interactions effortlessly.

Welcome to the exciting journey with GORM CLI.
