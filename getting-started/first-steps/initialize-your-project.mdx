---
title: "Initialize Your Project"
description: "Create minimal Go files for your models and query interfaces. Learn best practices for file organization and naming, with concise code examples for immediate use."
---

# Initialize Your Project

Welcome to the essential first step of using GORM CLI: setting up your project with minimal, clean Go files that define your data models and query interfaces. This page walks you through creating your foundational Go files, organizing your codebase efficiently, and following best practices that enable immediate, smooth code generation.

---

## 1. What You’ll Create Here

In this step, you will:

- Define your **model structs** representing database tables with clean Go structs.
- Declare **query interfaces** that use SQL templating annotations in comments to drive type-safe code generation.
- Organize your folder and file structure to keep generated code and source cleanly separated.

By the end, you will have minimal, ready-to-use Go files that power the GORM CLI generator to produce your query APIs and field helpers.

---

## 2. Setup Your Model and Query Interface Files

### Step 1: Create Your Model File

Create a file dedicated to your data models, for example `models/user.go`. Define your struct to match the database schema with exported fields:

```go
package models

import (
	"gorm.io/gorm"
	"time"
)

// User represents a user record in the users table.
type User struct {
	gorm.Model
	Name      string
	Age       int
	Email     string
	CreatedAt time.Time
}
```

> **Tip:** Use `gorm.Model` for basic ID, timestamps, and soft delete fields.

### Step 2: Define Your Query Interface

In the same package or a sibling package/file (e.g., `query.go`), define an interface that describes your intended queries with SQL templates in the method comments:

```go
package models

// Query provides type-safe query methods for User entities.
type Query[T any] interface {
	// GetByID fetches a single user by ID.
	//
	// SELECT * FROM @@table WHERE id=@id
	GetByID(id int) (T, error)

	// FilterByNameAndAge filters users by name and age.
	// where("name=@name AND age=@age")
	FilterByNameAndAge(name string, age int)
}
```

> **Note:** The `@@table` directive automatically resolves to your model’s table name.

### Step 3: Organize Your Files

A recommended layout:

```text
/your-project
 ├── models/
 │    ├── user.go
 │    └── query.go
 └── generated/  # for output (optional)
```

Keep your query interfaces and models close to minimize confusion and ease navigation.

---

## 3. Naming and File Organization Best Practices

- **Package naming:** Use clear package names like `models` or `queries`.
- **File naming:** Name files after their content clearly, e.g., `user.go` for user models.
- **Interface files:** Group interfaces logically, e.g., `query.go` or `user_queries.go`.
- **Avoid bloated files:** Keep interfaces minimal and focused; multiple interfaces can coexist.

---

## 4. Minimal Example to Start With

For quick reference, here is a minimal setup you can copy:

```go
// models/user.go
package models

import "gorm.io/gorm"

type User struct {
	gorm.Model
	Name  string
	Age   int
}

// models/query.go
package models

// Query provides typed queries with SQL annotations.
type Query[T any] interface {
	// SELECT * FROM @@table WHERE id=@id
	GetByID(id int) (T, error)

	// where("name=@name AND age=@age")
	FilterByNameAndAge(name string, age int)
}
```

---

## 5. What Happens Next?

Once these files are in place:

- Run the GORM CLI `gen` command pointing to your directory:
  
  ```bash
  gorm gen -i ./models -o ./generated
  ```

- The generator will parse your model structs and query interfaces, applying templates to create type-safe query APIs and strongly typed field helpers.

- Generated code will be output to the specified directory (`./generated` above), ready for use in your application.

---

## 6. Tips and Common Pitfalls

<AccordionGroup title="Tips and Best Practices">
<Accordion title="Keep Models Simple and Clean">
Avoid embedding complex logic in model structs. Keep them as clean representations of your data schema to enable straightforward code generation.
</Accordion>
<Accordion title="Annotate SQL Correctly in Interfaces">
Use the SQL templating DSL in comments exactly as shown (`@@table`, `@param`, `{{where}}`) to ensure correct parsing. Avoid typos or incomplete templates.
</Accordion>
<Accordion title="One Interface Per File is OK">
Splitting interfaces by domain or model improves readability and maintainability.
</Accordion>
<Accordion title="File and Package Placement Matters">
Keeping related models and interfaces within the same package helps the generator apply configuration effectively.
</Accordion>
</AccordionGroup>

<Warning>
Do not forget to use exported names (capitalized) for all your struct fields and interface methods; otherwise, the generator cannot access them.
</Warning>

---

## 7. Troubleshooting Initialization Issues

- **Generator cannot find input files:** Verify your `-i` path points to the directory containing your Go model and interface files.
- **No generated output:** Check that your interfaces have properly annotated SQL templates. The generator ignores interfaces without SQL.
- **Fields not recognized:** Ensure your model fields are exported and have valid Go types.

---

## 8. Related Documentation and Next Steps

- [Generate Type-Safe Code](../generate-code) – Learn how to run the generator and view the output.
- [Validate Your Setup](../validate-your-setup) – Confirm your environment is properly configured.
- [Basic Configuration](../../configuration-troubleshooting/basic-configuration) – Customize code generation.
- [Template-Based SQL Queries](../../advanced-usage-patterns/template-queries) – Deep dive into the templating syntax.

---

With these minimal Go files and best practices in place, you are ready to let GORM CLI generate powerful, type-safe query APIs and helpers tailored exactly to your data access needs. This foundation sets the stage for safer, more maintainable, and faster Go ORM workflows.

Happy coding!
