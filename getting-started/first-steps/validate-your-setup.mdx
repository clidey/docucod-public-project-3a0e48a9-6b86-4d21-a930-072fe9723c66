---
title: "Validate Your Setup"
description: "Quickly verify your generated code works: import, build, and invoke your new APIs. Provides basic test patterns and first-run checks to ensure everything is wired up before proceeding."
---

# Validate Your Setup

Quickly verify your generated code works by importing, building, and invoking your new APIs. This page guides you through basic test patterns and first-run checks to ensure everything is wired up correctly before proceeding further.

---

## 1. Purpose of Validation

After generating your type-safe query APIs and model-driven field helpers with the GORM CLI, validation confirms that:

- Your generated code compiles without errors.
- The API methods execute as expected against a real or test database.
- The SQL templates, generated types, and field helpers are correctly wired.

This early verification step lets you catch issues before integrating generated code deeply into your application.

---

## 2. Importing Generated Code

Once you have run the code generator (see the [Generate Type-Safe Code](../first-steps/generate-code) guide), import your generated package into a test or main Go file:

```go
import (
    "context"
    "log"

    generated "your/module/path/generated"
    "gorm.io/gorm"
)

func main() {
    ctx := context.Background()

    // Example: assuming you have a *gorm.DB instance named 'db'
    userQuery := generated.Query[User](db)

    // Now you can call generated API methods
    user, err := userQuery.GetByID(ctx, 1)
    if err != nil {
        log.Fatalf("Query failed: %v", err)
    }
    log.Printf("User: %+v", user)
}
```

> Replace `your/module/path/generated` with your actual generated package path.

---

## 3. Building the Generated Code

1. Ensure your module dependencies are up to date to resolve imports.
2. Run your build command in the Go project root.

```bash
go build ./...
```

3. Fix any compilation errors. Common issues include:
   - Missing imports due to config or package paths
   - Interface changes not matched by regeneration
   - Typos or outdated files due to cache or partial generation

---

## 4. Running First Operation Tests

Run simple tests or a dedicated main program to execute generated query methods:

1. Setup a test database (in-memory SQLite or your favorite DB) and migrate your models.
2. Write seed data to query.
3. Call generated query methods with known inputs and verify expected outputs.

### Example: Simple Test Using SQLite

```go
package main

import (
    "context"
    "log"

    "gorm.io/driver/sqlite"
    "gorm.io/gorm"

    generated "your/module/path/generated"
    "your/module/path/models"
)

func main() {
    ctx := context.Background()

    db, err := gorm.Open(sqlite.Open(":memory:"), &gorm.Config{})
    if err != nil {
        log.Fatal(err)
    }

    if err := db.AutoMigrate(&models.User{}); err != nil {
        log.Fatal(err)
    }

    // Insert a test user
    db.Create(&models.User{Name: "alice", Age: 30})

    // Query by ID
    user, err := generated.Query[models.User](db).GetByID(ctx, 1)
    if err != nil {
        log.Fatalf("Query failed: %v", err)
    }
    log.Printf("Queried user: %+v", user)
}
```

### Expected outcome:
- Query runs without error.
- The retrieved user matches the seeded data.

---

## 5. Verifying Template-Driven Queries

Your interfaces use SQL templates to generate concrete implementations. Validate each key method:

- **Basic queries** like `GetByID` to confirm simple parameter binding and result scanning.
- **Filters and conditionals** to verify dynamic SQL works correctly.
- **Updates and batch operations** to test SQL generation and execution.

Use the generated APIs exactly as your application will; attempt to trigger different SQL paths based on inputs.

---

## 6. Common Pitfalls & Tips

<Tip>
  - Always run `gorm gen` after changing your interfaces or model structs to keep generated code up to date.
  - Use small test DBs or in-memory SQLite to quickly validate without affecting production data.
  - Enable GORM's debug mode (`db = db.Debug()`) during validation to see SQL queries.
</Tip>

<Warning>
  - Missing or incorrect SQL annotations in your interfaces will cause generation errors or runtime failures.
  - Ensure context.Context is passed when required, or the generator auto-injects it.
  - Confirm configured output paths match your imports to avoid stale or mismatched generated files.
</Warning>

<Note>
  See the [Troubleshooting Common Issues](../configuration-troubleshooting/troubleshooting-common-issues) page for detailed diagnosis and fixes.
</Note>

---

## 7. Next Steps After Validation

Once your generated code builds and runs successfully with test data:

- Start integrating the generated code into your application logic.
- Review and customize your query interfaces and models for further features.
- Explore advanced patterns such as association helpers and template-based SQL in guides.

Refer to these guides for deeper learning:

- [Generate Type-Safe Code](../first-steps/generate-code)
- [Quickstart: Generating Type-Safe APIs](../../guides/getting-started-workflows/quickstart-complete-workflow)
- [Using Generated Field Helpers](../../guides/getting-started-workflows/using-field-helpers)

---

## Summary
This validation stage ensures your GORM CLI generated code compiles and performs basic query operations as intended. Thorough testing here avoids integration headaches and unlocks the full power of type-safe, fluent APIs.

---