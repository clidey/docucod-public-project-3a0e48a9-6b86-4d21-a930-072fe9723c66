---
title: "Optional: Configuration Setup"
description: "For most use cases, GORM CLI works out of the box, but advanced users can leverage configuration files to customize output paths, field mappings, and inclusion/exclusion rules. Learn how to set up and adjust `genconfig.Config` for greater control without overcomplicating your first run."
---

# Optional: Configuration Setup

GORM CLI works seamlessly out of the box for most projects, but as your needs grow, you can harness the power of the `genconfig.Config` configuration to tailor code generation to your specific requirements. This guide walks you through setting up and customizing this configuration to control output paths, customize field helper mappings, and fine-tune which interfaces and structs are included or excluded in the generated code — all without complicating your initial setup.

---

## Why Configure GORM CLI?

By default, GORM CLI scans your Go interfaces and structs and generates query APIs and field helpers with sensible defaults. However, configuration unlocks advanced control:

- **Output customization:** Write generated files to directories that fit your project structure.
- **Field mapping:** Override default type mappings to use custom field helpers (e.g., for JSON columns).
- **Selective generation:** Include or exclude interfaces and structs based on patterns or explicit types.
- **File-level scope:** Decide whether config applies broadly or to individual source files.

These options empower you to keep your codebase clean, consistent, and aligned with your architectural standards.

---

## 1. Declaring `genconfig.Config`

### Placement

Define a package-level variable of type `genconfig.Config` in the same Go package that contains the interfaces and models you want to generate for. The generator automatically discovers this during scanning.

```go
package examples

import (
    "database/sql"
    "gorm.io/cli/gorm/field"
    "gorm.io/cli/gorm/genconfig"
)

var _ = genconfig.Config{
    // Your configuration goes here
}
```


### Basic Fields Mapping

Map specific Go types or field tags to custom field helper wrappers. For example, map `sql.NullTime` to the `field.Time` helper and fields tagged with `gen:"json"` to your custom JSON helper.

```go
var _ = genconfig.Config{
    OutPath: "examples/output",
    FieldTypeMap: map[any]any{
        sql.NullTime{}: field.Time{},
    },
    FieldNameMap: map[string]any{
        "json": JSON{}, // Maps fields with `gen:"json"` tag
    },
}
```

<Info>
FieldNameMap entries take precedence over FieldTypeMap when both match the same field.
</Info>


### Output Directory Override

Set `OutPath` to redirect generated code for this package into a custom folder, keeping your source and generated code organized separately.

```go
var _ = genconfig.Config{
    OutPath: "generated_api",
}
```

If not set, GORM CLI uses the CLI `-o` flag or defaults to `./g`.


### Scope: FileLevel vs Package-level

- **FileLevel: false (default):** Config applies per package, affecting all files within.

- **FileLevel: true:** Config applies only to the current source file where declared.

Use file-level scope when needing different configurations within the same package.


## 2. Inclusion and Exclusion Filters

Fine-tune what interfaces and structs are processed via Include/Exclude lists. These accept shell-style patterns or fully qualified type literals.

```go
var _ = genconfig.Config{
    IncludeInterfaces: []any{"Query*", models.Query(nil)},
    ExcludeInterfaces: []any{"*Deprecated*"},
    IncludeStructs:    []any{"User", "Account*", models.User{}},
    ExcludeStructs:    []any{"*DTO"},
}
```

### How It Works

- If `IncludeInterfaces` or `IncludeStructs` is non-empty, only matching types are generated.
- If include lists are empty, exclusion filters remove matching types.

Patterns support:
- Wildcards: `Query*`, `*Repo`
- Typed literals: `models.User{}`, `pkg.Query(nil)`

<Tip>
Use these filters to prevent generating code for deprecated interfaces or DTOs, or to target a subset of your models for specific builds.
</Tip>


## 3. Example: Customizing for a JSON API with Selective Interfaces

```go
package examples

import (
    "database/sql"
    "gorm.io/cli/gorm/genconfig"
    "gorm.io/cli/gorm/field"
    "yourproject/models"
)

var _ = genconfig.Config{
    OutPath: "generated",
    FieldTypeMap: map[any]any{
        sql.NullTime{}: field.Time{},
    },
    FieldNameMap: map[string]any{
        "json": JSON{},
    },
    IncludeInterfaces: []any{"Query*", models.Query(nil)},
    ExcludeInterfaces: []any{"*Deprecated*"},
    IncludeStructs:    []any{"User", "Account*"},
    ExcludeStructs:    []any{"*DTO"},
}
```

This config:
- Outputs generated code in `./generated` folder
- Maps `sql.NullTime` fields and tags with `gen:"json"`
- Only includes interfaces starting with `Query` or the specific `models.Query`
- Excludes deprecated interfaces
- Restricts struct generation to `User` and any struct starting with `Account` excluding DTO types


## 4. Tips & Best Practices

- **Keep configuration minimal for beginners:** Delay complex filtering until you need it.
- **Use typed literals where possible:** Improves reliability over string patterns.
- **Place config in the same package as your models and interfaces:** Ensures automatic detection.
- **Leverage FileLevel scope cautiously:** Useful for distinct settings in multi-file packages.
- **Combine with CLI flags:** Command-line `-o` sets global output; per-package `OutPath` overrides it.


## 5. Common Pitfalls to Avoid

- Forgetting to import necessary packages in your config file (e.g., `database/sql` for mappings).
- Invalid patterns or literals in inclusion/exclusion leading to no generated code.
- Placing config variable in a package unrelated to the scanned interfaces or structs.
- Setting conflicting filters that exclude all types inadvertently.


## 6. Next Steps

Once configured:

- Run your generation command referencing interface files:

  ```bash
  gorm gen -i ./examples -o ./generated
  ```

- Verify generated code is placed and filtered as expected.

- Explore [Customizing Generation](./customizing-generation) guide for advanced options.

- Combine with [First Code Generation](../first-steps/run-first-generation) to integrate generation smoothly into your project workflow.

---

## See Also

- [Generate Code: Your First Run](/getting-started/first-steps/run-first-generation)
- [Customizing Generation with genconfig.Config](/guides/core-workflows/customizing-generation)
- [Working with Type-Safe Queries Guide](/guides/core-workflows/type-safe-queries)
- [Validate Your Installation](/getting-started/setup-basics/validation)

---

By mastering configuration, you ensure GORM CLI flexibly adapts to your unique project layouts and coding conventions — setting you on the path to highly maintainable, type-safe database access code.
