---
title: "Testing and Using Generated Code"
description: "Shows how to use the generated APIs in a sample application: running a basic query, checking type-safety, and verifying integration with your GORM project. Includes a minimal validation snippet to confirm setup success."
---

# Testing and Using Generated Code

Welcome to the critical step where your GORM CLI-generated code springs into action. This guide walks you through running concrete queries using the generated APIs, validating type safety, and ensuring seamless integration with your GORM-based Go project. By following these steps, you'll confirm your setup works as expected and unlock the full productivity benefits of GORM CLI.

---

## 1. Setting Up a Minimal Testing Environment

Before running any queries, ensure you have a properly initialized GORM `*gorm.DB` instance connected to your database. For demonstration, a simple test database setup and data seeding will verify everything operates correctly.

```go
package examples

import (
  "context"
  "testing"
  "time"

  "gorm.io/cli/gorm/examples/models"
  "gorm.io/gorm"
)

// setupTestDB initializes an in-memory or test database connection
func setupTestDB(t *testing.T) *gorm.DB {
  db, err := gorm.Open(/* your database driver & config here */)
  if err != nil {
    t.Fatalf("failed to connect database: %v", err)
  }
  // Automigrate ensures schema matches models
  if err := db.AutoMigrate(&models.User{}, &models.Account{}, &models.Pet{}, &models.Toy{}); err != nil {
    t.Fatalf("failed to automigrate: %v", err)
  }
  return db
}

// seedUsers inserts example users for query tests
func seedUsers(t *testing.T, db *gorm.DB, seeds ...models.User) []models.User {
  for _, user := range seeds {
    if err := db.Create(&user).Error; err != nil {
      t.Fatalf("failed to seed user %v: %v", user.Name, err)
    }
  }
  return seeds
}
```

This basic setup function prepares your test database and seeds a few users.

---

## 2. Running Basic Queries Using Generated APIs

GORM CLI generates type-safe query APIs accessible by calling `Query[YourModel](db)`. This returns a fluent API for your queries.

Here's how to run a typical query for a user by ID:

```go
query := Query[models.User](db)
ctx := context.Background()

user, err := query.GetByID(ctx, 123) // ID 123
if err != nil {
  // handle error
}
fmt.Printf("Got user: %+v", user)
```

### What this does:

- `Query[models.User](db)` returns the generated interface implementation for User queries.
- `GetByID(ctx, id)` uses the SQL template you defined, generating a safe SQL query.
- You get typed results without manually writing SQL or scanning rows.

---

## 3. Validating Type-Safety and Functionality

Test multiple generated query functions to verify they behave as expected.

Example snippet adapted from `examples/output/query_test.go`:

```go
t.Run("Test GetByID", func(t *testing.T) {
  query := Query[models.User](db)

  user, err := query.GetByID(context.Background(), 123)
  if err != nil {
    t.Errorf("unexpected error: %v", err)
  }
  if user.ID != 123 {
    t.Errorf("expected user id 123, got: %+v", user)
  }
})

// Filter with dynamic column example
u, err := query.FilterWithColumn(context.Background(), "role", "special")
if err != nil {
  t.Errorf("unexpected error: %v", err)
}
if u.Role != "special" {
  t.Errorf("expected role 'special', got: %+v", u)
}
```

Use these tests to confirm:

- Correct results matching your query criteria
- No panics or type mismatches
- The generated SQL runs cleanly against your database

---

## 4. Verifying Integration with Your GORM Models

Your generated field helpers augment standard GORM operations, supporting typed predicates and updates:

```go
// Using field helpers for filtering
users, err := gorm.G[models.User](db).
  Where(models.User.Age.Gt(18)).
  Find(ctx)

// Updating a user's age with type safety
err = gorm.G[models.User](db).
  Where(models.User.ID.Eq(123)).
  Set(
    models.User.Age.Set(40),
    models.User.IsAdult.Set(true),
  ).
  Update(ctx)
```

This confirms that the generated code seamlessly integrates in your common GORM workflows.

---

## 5. Sample Minimal Validation Snippet

Here is a concise snippet you can use as a sanity check in your application or test suite:

```go
package main

import (
  "context"
  "fmt"

  "gorm.io/cli/gorm/examples/models"
  "gorm.io/gorm"
)

func checkUserQuery(db *gorm.DB) error {
  query := Query[models.User](db)
  ctx := context.Background()

  user, err := query.GetByID(ctx, 1)
  if err != nil {
    return fmt.Errorf("query failed: %w", err)
  }

  if user.ID != 1 {
    return fmt.Errorf("unexpected user id: %d", user.ID)
  }

  fmt.Println("Basic query test passed for user ID=1")
  return nil
}
```

Run this after your setup to confirm that your generated queries execute without error.

---

## Troubleshooting Tips

- **Error "method not found" or compilation issues:** Verify you have run `gorm gen` to generate query code after writing your interfaces and models.
- **Queries return no data but you expect some:** Confirm your database contains seeded data matching your filters.
- **Type mismatches on generated code usage:** Re-check your Go version (1.18+ required) and regenerate code to ensure generics compatibility.
- **SQL errors on query execution:** Review your interface method SQL templates for syntax or logical issues.

If you encounter persistent issues, refer to the [Troubleshooting & Common Issues](../getting-started/first-steps/troubleshooting) guide for detailed diagnostics.

---

## Next Steps

- Explore [Writing Models and Query Interfaces](../getting-started/first-steps/write-models-interfaces) to extend your queries.
- Review [Generating Code for the First Time](../getting-started/first-steps/run-generator) to automate regeneration after model or query changes.
- Dive into [Model-Driven Field Helpers in Action](../../guides/core-workflows/field-helper-workflows) for advanced update and association management.

---

This page established your confidence in using GORM CLI generated code practically. With verified queries and working integration, youâ€™re ready to build robust, type-safe database access layers efficiently.

---

## References & Related Reading

- [Getting Started: Writing Models and Query Interfaces](../getting-started/first-steps/write-models-interfaces)
- [Running the Generator & Output Structure](../getting-started/first-steps/run-generator)
- [Using Generated Model Field Helpers](../../guides/core-workflows/field-helper-workflows)
- [Troubleshooting & Common Issues](../getting-started/first-steps/troubleshooting)
- [Overview: What is GORM CLI?](../../overview/product-intro-core/what-is-gorm-cli)

---

<Check>
Ensure your Go environment is version 1.18 or higher and your database is accessible before running tests.
</Check>

<Tip>
Integrate generated queries and field helpers early into your development workflow for rapid prototyping and enhanced type safety.
</Tip>

<Warning>
Do not manually edit generated files. Always modify the source interfaces and models, then rerun code generation.
</Warning>


---

*The examples in this guide are adapted from the official GORM CLI repository and sample code to provide a real-world practical integration experience.*
