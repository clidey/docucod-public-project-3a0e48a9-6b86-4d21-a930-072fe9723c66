---
title: "Validating and Using Generated APIs"
description: "Confirm that your first code generation was successful by running sample queries and field operations. Ensure your application can leverage GORM CLI outputs with simple tests or example usage."
---

# Validating and Using Generated APIs

Confirm that your first code generation was successful by running sample queries and field operations. This guide will walk you through validating generated query interfaces and model-driven field helpers, helping you confidently integrate GORM CLI outputs into your Go application.

---

## 1. Verify Generated Code Location and Structure

After running the CLI command (e.g., `gorm gen -i ./examples -o ./generated`), check the output directory for generated files corresponding to your interfaces and models. The generated files typically include:

- Query interface implementations (e.g., `query.go`)
- Model-based field helper structs (e.g., `user_fields.go`)

Ensure these files exist, as this confirms successful code generation.

<Tip>
If you donâ€™t see generated files, verify your input path and check for any configuration that might include/exclude certain interfaces or models.
</Tip>

## 2. Run Sample Queries Using Generated Interfaces

Use the generated query API to perform basic fetch operations and validate type-safe SQL generation.

### Example: Query a User by ID

```go
import (
    "context"
    "fmt"
    "gorm.io/cli/gorm/examples/models"
    "gorm.io/cli/gorm/generated"
    "gorm.io/gorm"
)

func validateGetByID(db *gorm.DB, userID int) error {
    ctx := context.Background()

    query := generated.Query[models.User](db)
    user, err := query.GetByID(ctx, userID)
    if err != nil {
        return fmt.Errorf("failed to get user: %w", err)
    }

    fmt.Printf("User retrieved: %+v\n", user)
    if user.ID != uint(userID) {
        return fmt.Errorf("expected user ID %d but got %d", userID, user.ID)
    }
    return nil
}
```

### Outcome
- The call to `GetByID` executes a type-safe query using the generated method
- The returned result is a fully populated `User` struct
- Any mismatches or errors indicate problems in code generation or database connectivity

<Tip>
Ensure your database contains a user with the tested ID for the query to succeed.
</Tip>

## 3. Use Generated Field Helpers for Condition Building

Generate strongly typed field helpers enable writing expressive predicates safely.

### Example: Query Users with Age and Name Filters

```go
import (
    "context"
    "fmt"
    "gorm.io/cli/gorm/generated"
    "gorm.io/gorm"
)

func validateFilterByNameAndAge(db *gorm.DB, name string, age int) error {
    ctx := context.Background()

    query := generated.Query[models.User](db)

    // Compose query with generated field helpers
    users, err := query.FilterByNameAndAge(ctx, name, age)
    if err != nil {
        return fmt.Errorf("failed filtering users: %w", err)
    }

    fmt.Printf("Users matching filter: %d\n", len(users))
    for _, u := range users {
        if u.Name != name || u.Age != age {
            return fmt.Errorf("unexpected user found: %+v", u)
        }
    }

    return nil
}
```

### Outcome
- The `FilterByNameAndAge` method binds parameters safely
- Results verify strong typing and proper SQL generation

## 4. Validate Update Operations Through Generated APIs

You can test update methods that apply partial updates and conditions.

### Example: Update User Info

```go
func validateUpdateInfo(db *gorm.DB, id int) error {
    ctx := context.Background()
    query := generated.Query[models.User](db)

    userUpdate := models.User{
        Name:  "UpdatedName",
        Age:   35,
        IsAdult: true,
    }

    if err := query.UpdateInfo(ctx, userUpdate, id); err != nil {
        return fmt.Errorf("update failed: %w", err)
    }

    // Verify update
    var updated models.User
    if err := db.WithContext(ctx).First(&updated, id).Error; err != nil {
        return fmt.Errorf("cannot load updated user: %w", err)
    }

    if updated.Name != "UpdatedName" || updated.Age != 35 || !updated.IsAdult {
        return fmt.Errorf("update verification failed, got: %+v", updated)
    }

    return nil
}
```

## 5. Using Field Helpers with GORM's Query Builder

You can leverage generated fields directly with GORM queries for custom filters.

```go
func findAdultUsers(db *gorm.DB) ([]models.User, error) {
    var users []models.User

    // Compose conditions using generated field helpers
    err := gorm.G[models.User](db).
        Where(generated.User.Age.Gt(18)).
        Where(generated.User.IsAdult.Eq(true)).
        Find(context.Background(), &users)

    return users, err
}
```

This approach showcases fluent, discoverable APIs that reduce boilerplate.

## 6. Common Troubleshooting Tips

<AccordionGroup title="Troubleshooting Validation Issues">
<Accordion title="Generated Code Not Found or Outdated">
- Verify CLI was run with the correct `-i` (input) and `-o` (output) paths.
- Remove stale generated files and regenerate.
- Confirm your interfaces and models are under the input path.
</Accordion>
<Accordion title="Compilation Errors in Generated Code">
- Check for any invalid Go syntax in your interfaces or models.
- Ensure Go version 1.18+ is used as generics are required.
- Validate that you have no include/exclude filters ignoring needed types.
</Accordion>
<Accordion title="Errors Running Sample Queries">
- Confirm your database is accessible and contains test data.
- Check for schema mismatches between your models and actual tables.
- Use GORM logging to inspect generated SQL and error details.
</Accordion>
</AccordionGroup>

## 7. Next Steps

- Follow [Your First Code Generation](./your-first-generation) to deepen understanding of generation patterns.
- Explore [Generating Field Helpers from Models](./model-driven-field-helpers) to enhance your data filtering and association updates.
- Review [Template-based Query APIs](./template-based-query-apis) to take advantage of flexible SQL templating.

---

## Summary
This guide verified your initial GORM CLI code generation by running sample queries, using generated field helpers in searches and updates, and integrating results with GORM's native query builder. You learned practical validation steps to confirm a successful setup and how to leverage generated APIs immediately. Troubleshooting aids help recover from common pitfalls.


---

## Additional References
- [Installing GORM CLI](../getting-started/setup-installation/installing-cli) - How to install and set up the CLI tool.
- [Basic Configuration](../getting-started/first-steps/initial-configuration) - Customize generation parameters.
- [Working with Associations](../guides/real-world-patterns/working-with-associations) - Manage database relations with generated helpers.
- Official GORM Documentation: https://gorm.io/docs/

---