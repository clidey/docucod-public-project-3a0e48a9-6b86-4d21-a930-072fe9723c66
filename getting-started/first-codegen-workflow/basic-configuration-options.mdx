---
title: "Basic Configuration Options"
description: "Introduction to optional configuration using genconfig.Config for customizing output paths, field mappings, inclusion/exclusion rules, and file-level controls."
---

# Basic Configuration Options

Customize the GORM CLI code generation by using the optional `genconfig.Config` struct. This configuration lets you tailor output directories, map Go types to custom field helpers, filter what interfaces and structs are included or excluded, and control generation scope at the file or package level.

This page introduces the essential configuration options, explains how to define them in your code, and provides practical examples that fit naturally into your GORM CLI workflow.

---

## Why Configure?

By default, GORM CLI uses conventional settings suited for most projects. However, when you need:

- Custom output paths for generated files,
- To override how certain Go types map to field helpers,
- To selectively generate code only for specific interfaces or structs,
- To apply settings at per-file or whole-package levels,

then `genconfig.Config` offers powerful controls for these situations.

This improves maintainability, integration consistency, and aligns generated code with your project conventions.

---

## Defining Your Configuration

### Where to Declare

Place a package-level variable of type `genconfig.Config` in the Go package where your models and query interfaces reside. The generator automatically detects and applies it during code generation.

### Minimal Example

```go
package examples

import (
    "database/sql"
    "gorm.io/cli/gorm/field"
    "gorm.io/cli/gorm/genconfig"
)

var _ = genconfig.Config{
    OutPath: "examples/output", // Custom output folder for generated files
    FieldTypeMap: map[any]any{
        sql.NullTime{}: field.Time{}, // Use field.Time helper for sql.NullTime.
    },
    FieldNameMap: map[string]any{
        "date": field.Time{}, // Map fields tagged with `gen:"date"` to field.Time.
    },
}
```

### How It Works

- The generator reads your Go package files.
- It finds your `genconfig.Config` declaration.
- Your settings override the default behavior selectively for that package.

---

## Configuration Options Explained

| Option             | Description                                                                                                                                                     | Example Values                                                                           |
|--------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------|
| `OutPath`          | Overrides the CLI `-o` output directory for generated files in that package (or subtree, if `FileLevel` is false).                                               | `"generated/code"`                                                                      |
| `FieldTypeMap`     | Maps Go type instances to custom field helpers to control the generated field helper for those types.                                                          | `map[any]any{sql.NullTime{}: field.Time{}}`                                              |
| `FieldNameMap`     | Maps Go struct field tags (`gen:"name"`) to typed field helpers. Overrides `FieldTypeMap` for tagged fields.                                                  | `map[string]any{"json": JSON{}}`                                                      |
| `FileLevel`        | When `true`, applies only to the single file declaring the config. Defaults to `false` (applies to whole package).                                              | `true`                                                                                   |
| `IncludeInterfaces`| Optional whitelist patterns or type selectors for interfaces to generate. If non-empty, only matching interfaces are processed, ignoring excludes.              | `[]any{"Query*", models.Query(nil)}`                                                   |
| `ExcludeInterfaces`| Optional blacklist patterns or selectors for interfaces to exclude from generation, applied after includes.                                                     | `[]any{"*Deprecated*"}`                                                                |
| `IncludeStructs`   | Optional whitelist patterns or type literals to generate field helpers only for those structs.                                                                  | `[]any{"User", "Account*", models.User{}}`                                           |
| `ExcludeStructs`   | Optional blacklist patterns or type literals to exclude from field helper generation, applied after include filtering.                                          | `[]any{"*DTO"}`                                                                        |

### Pattern Matching

- Patterns support shell-style wildcards (`*`, `?`).
- Type selectors can be specified using empty type conversions like `models.Query(nil)` or type literals like `models.User{}`.

---

## Step-by-Step: Using Basic Configuration

<Steps>
<Step title="Step 1: Create or Open a Package File">
Locate the Go package containing your model structs and SQL-annotated query interfaces.
</Step>
<Step title="Step 2: Import Required Packages">

Add imports for `genconfig` and any field helpers you want to use with your mappings:

```go
import (
    "database/sql"
    "gorm.io/cli/gorm/field"
    "gorm.io/cli/gorm/genconfig"
)
```
</Step>
<Step title="Step 3: Declare the Configuration Variable">
Declare a package-level variable with your customization settings.

Example:

```go
var _ = genconfig.Config{
    OutPath: "generated",
    FieldTypeMap: map[any]any{
        sql.NullTime{}: field.Time{},
    },
    FieldNameMap: map[string]any{
        "json": JSON{},
    },
    IncludeInterfaces: []any{"Query*"},
    ExcludeStructs: []any{"*DTO"},
}
```

This example sets a custom output directory, maps `sql.NullTime` to `field.Time`, applies a custom `JSON` helper for fields tagged with `gen:"json"`, includes only interfaces starting with `Query`, and excludes any struct ending with `DTO`.
</Step>
<Step title="Step 4: Annotate Your Models (Optional for FieldNameMap)">
If using `FieldNameMap`, annotate your struct fields with the appropriate `gen:"tag"` tags.

Example:

```go
type User struct {
    ID      uint
    Profile string `gen:"json"`
}
```
</Step>
<Step title="Step 5: Run the Code Generator">
Invoke `gorm gen` CLI with your package or files as input.

Example command:

```bash
gorm gen -i ./examples -o ./generated
```

The generator will pick up your `genconfig.Config` settings and apply them to customize generated code accordingly.
</Step>
</Steps>

---

## Practical Examples

### Example 1: JSON Field Helper

Configure the generator to use a custom `JSON` field helper for `gen:"json"` tags.

```go
package examples

import "gorm.io/cli/gorm/genconfig"

var _ = genconfig.Config{
    OutPath: "examples/output",
    FieldNameMap: map[string]any{
        "json": JSON{},
    },
}
```

Your model:

```go
type User struct {
    Profile string `gen:"json"`
}
```

The generated code will use the `JSON` helper for the `Profile` field.

### Example 2: Selective Interface Inclusion

Only generate query code for interfaces matching `Query*` prefix.

```go
package pattern

import "gorm.io/cli/gorm/genconfig"

var _ = genconfig.Config{
    IncludeInterfaces: []any{"Query*"},
}
```

This avoids generating code for unrelated or deprecated interfaces.

### Example 3: File-Level vs Package-Level Configuration

Use `FileLevel: true` to restrict config effects to just the declaring file.

```go
var _ = genconfig.Config{
    OutPath: "output/special",
    FileLevel: true,
    ExcludeInterfaces: []any{"I3"},
}
```

This is useful in mixed directories where different files require distinct codegen rules.

---

## Best Practices

- **Use `OutPath` for organized outputs:** Keep generated code separate from source files.
- **Leverage `FieldTypeMap` and `FieldNameMap` for consistent field helpers:** Avoid manual type assertions by mapping Go types and tags.
- **Whitelist with `IncludeInterfaces` and `IncludeStructs` for focused generation:** Generates only relevant code, speeding builds.
- **Combine with exclude lists for fine control.**
- **Set `FileLevel` when you want to localize config effects to single files, especially in multi-package repos.**

---

## Common Pitfalls & Troubleshooting

<AccordionGroup title="Troubleshooting Basic Configuration">
<Accordion title="Generated code doesn't reflect my configuration changes">
- **Cause:** `genconfig.Config` not declared at package level or file is not scanned.
- **Fix:** Ensure the config variable is declared globally in the package of your models/interfaces.
- Confirm your input path to `gorm gen -i` includes the directory containing the config.
</Accordion>
<Accordion title="Output directory ignored or defaults to CLI flag">
- **Cause:** Config `OutPath` set but overridden by CLI `-o` flag or `FileLevel` mismatches.
- **Fix:** Avoid conflicting output settings; if `FileLevel` is false (default), config applies to the whole package subtree.
</Accordion>
<Accordion title="Field helpers for custom types not applied">
- **Cause:** Mismatch between mapped Go type and actual field type, or missing import.
- **Fix:** Verify the exact Go type instance (including pointer and package) when mapping.
- Use `FieldNameMap` when tagging fields explicitly.
</Accordion>
<Accordion title="Interfaces or structs not generated as expected">
- **Cause:** Inclusion or exclusion lists filtering out items unexpectedly.
- **Fix:** Check your include/exclude patterns carefully; inclusion lists take priority over exclusion.
- Test with empty lists to confirm.
</Accordion>
</AccordionGroup>

---

## Summary

Using `genconfig.Config` opens flexible, package-level customization of your generated GORM CLI code. It allows you to:

- Control where files generate,
- Assign custom field helpers based on Go types or struct tags,
- Include or exclude specific interfaces and structs through pattern matching,
- Scope configurations to files or entire packages.

By embedding this configuration in your Go code, you keep code generation inline with your project's structure and conventions.


---

## Related Documentation

- [Preparing Models & Query Interfaces](https://your-docs-domain/getting-started/first-codegen-workflow/prepare-models-interfaces) — How to prepare code that works with configuration
- [Running the Code Generator](https://your-docs-domain/getting-started/first-codegen-workflow/generate-code) — How to invoke generation including config recognition
- [Validation & Troubleshooting](https://your-docs-domain/getting-started/first-codegen-workflow/validation-troubleshooting) — Debugging generation and configuration issues
- [Using the Generated APIs](https://your-docs-domain/getting-started/first-codegen-workflow/using-generated-code) — How configuration affects usage of generated code
- [Custom Field Helpers and JSON Mapping](https://your-docs-domain/guides/advanced-patterns/custom-fields) — Advanced examples for field helper customization

---

For the official code examples, configuration samples, and in-depth usages, see the [GORM CLI GitHub repository](https://github.com/go-gorm/cli).

If you want to explore package-level setup or more complex filtering, check `examples/filters/` in the repository.

---

## Additional Tips

- Always keep your `genconfig.Config` variable named anonymously (`var _ = genconfig.Config{}`) to ensure it is used but does not pollute the package API.
- When mapping custom types for fields, ensure you use typed instances, for example `sql.NullTime{}` as key, and `field.Time{}` as value.
- Configuration scanning supports multiple config instances across your package tree, merged with priority based on path specificity.
- Use pattern matching (`*`, prefixes) wisely to target precisely the types you want to include or exclude.

---

This guide empowers you to master GORM CLI’s basic configuration, making your generated code predictable, organized, and adapted to your unique project needs.

<Check>
Remember: No configuration is required to get started, but configuring your code generation unlocks advanced control and customization.
</Check>
