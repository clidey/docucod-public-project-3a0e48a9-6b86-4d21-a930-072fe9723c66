---
title: "Using the Generated APIs"
description: "How to use your newly generated APIs in real Go code, including integrating query methods and field helpers with GORM. Shows working examples for CRUD operations."
---

# Using the Generated APIs

This guide walks you through how to use the APIs generated by GORM CLI in your Go projects. You will learn how to integrate query methods defined via SQL templates and use the model-driven field helpers alongside GORM for fluent, type-safe CRUD operations. Working examples accompany each step, helping you confidently employ your generated code in real applications.

---

## 1. Understanding the Generated APIs

The GORM CLI generates two main code artifacts from your Go interfaces and models:

- **Type-safe query APIs**: Concrete implementations of your interfaces embedding SQL templates, offering methods that return typed results or support fluent query building.
- **Field helpers**: Strongly typed field predicates and association helpers generated from your model structs, allowing expressive filters, updates, and association operations.

These work together with `gorm.io/gorm` to give you compile-time safety and discoverability when performing database operations.

<Check>
Before proceeding, ensure you have run the generator correctly via:

```bash
gorm gen -i ./your/source/path -o ./generated
```

and imported the generated package into your project.
</Check>

---

## 2. Using Query Methods

Query interfaces you define in Go with SQL templates generate concrete implementations exposing typed query methods. These methods either:

- Return data directly, e.g., `(T, error)`, by executing raw SQL;
- Return interface chains for further query building.

### Example: Calling a Generated Query Method

Suppose you have the following interface:

```go
// Query[T any] interface with SQL template methods
// SELECT * FROM @@table WHERE id=@id
GetByID(id int) (T, error)
```

You can invoke it in your Go code as:

```go
import (
  "context"
  "your_project/generated"
  "gorm.io/gorm"
)

func findUserByID(ctx context.Context, db *gorm.DB, id int) {
  user, err := generated.Query[User](db).GetByID(ctx, id)
  if err != nil {
    // handle error
  }
  fmt.Println(user)
}
```

Here `generated.Query[User](db)` returns the generated implementation for your interface specialized on `User`.

### Working With Query Methods That Chain

Some methods are designed to build queries further. For example:

```go
// FilterByNameAndAge(name string, age int)
```

Returns an interface allowing chaining more GORM expressions or calling `.Find(ctx)`.

```go
users, err := generated.Query[User](db).
  FilterByNameAndAge("jinzhu", 25).
  Find(ctx)
```

This pattern lets you combine generated SQL snippets with GORM's fluent API.

---

## 3. Using Field Helpers with GORM

From your model structs, GORM CLI generates type-safe field helpers that simplify creating query predicates and setting values.

These helpers correspond to your model fields and provide intuitive methods like `.Eq()`, `.Like()`, `.Set()`, `.Incr()`, and others.

### Filtering with Field Predicates

To find users older than 18:

```go
users, err := gorm.G[User](db).
  Where(generated.User.Age.Gt(18)).
  Find(ctx)
```

Field helpers generate well-typed expressions for query conditions.

### Updates and Creations Using Setters

You can set field values when creating or updating records:

```go
// Create a new user
err := gorm.G[User](db).
  Set(
    generated.User.Name.Set("alice"),
    generated.User.Age.Set(25),
    generated.User.IsAdult.Set(true),
  ).
  Create(ctx)

// Update a user with id=1
err = gorm.G[User](db).
  Where(generated.User.ID.Eq(1)).
  Set(
    generated.User.Name.Set("bob"),
    generated.User.Age.Incr(1),
  ).
  Update(ctx)
```

This approach eliminates error-prone manual query construction.

---

## 4. Handling Associations

Associations (has one, has many, belongs to, many-to-many) in your models generate special helpers under your model's generated variable (e.g., `generated.User.Pets`).

These helpers support operations such as:

- `Create(...)` — create and link new associated records
- `CreateInBatch(...)` — batch creation
- `Update(...)` — update associated records
- `Unlink()` — remove association links
- `Delete()` — delete associated records/join rows

### Example: Creating a Parent with an Associated Child

```go
err := gorm.G[User](db).
  Set(
    generated.User.Name.Set("alice"),
    generated.User.Pets.Create(generated.Pet.Name.Set("fido")),
  ).
  Create(ctx)
```

### Example: Updating an Associated Record with Condition

```go
err := gorm.G[User](db).
  Where(generated.User.ID.Eq(1)).
  Set(
    generated.User.Pets.Where(generated.Pet.Name.Eq("fido")).
      Update(generated.Pet.Name.Set("rex")),
  ).
  Update(ctx)
```

### Unlinking or Deleting Associations

You can remove associations without deleting the parent or child explicitly:

```go
gorm.G[User](db).
  Where(generated.User.ID.Eq(1)).
  Set(generated.User.Pets.Unlink()).
  Update(ctx)

// Or deleting associated records
gorm.G[User](db).
  Where(generated.User.ID.Eq(1)).
  Set(generated.User.Pets.Delete()).
  Update(ctx)
```

<Note>
Association operations respect relationship types semantics: `Unlink` may clear foreign keys or remove join rows, `Delete` removes associated rows or join rows depending on association type.
</Note>

---

## 5. Putting It All Together: CRUD Examples

### Create

```go
err := gorm.G[User](db).
  Set(
    generated.User.Name.Set("alice"),
    generated.User.Age.Set(0),
    generated.User.IsAdult.Set(false),
    generated.User.Role.Set("active"),
  ).
  Create(ctx)
```

### Read (Query by ID)

```go
user, err := generated.Query[User](db).GetByID(ctx, 123)
```

### Update

```go
err := generated.Query[User](db).UpdateInfo(ctx, models.User{Name: "jinzhu", Age: 20}, 1)
```

or

```go
gorm.G[User](db).
  Where(generated.User.ID.Eq(1)).
  Set(
    generated.User.Name.Set("bob"),
    generated.User.Age.Incr(1),
  ).
  Update(ctx)
```

### Delete

Handle deletion via GORM as usual; generated code supports filters and associations.

---

## 6. Tips, Pitfalls, and Best Practices

- **Always check errors** returned by generated methods to catch issues early.
- Generated APIs automatically inject `context.Context` if omitted in your interface method signatures.
- Use field helpers for predicates and updates to avoid SQL injection and runtime errors.
- When working with associations, understand the semantics of `Unlink` vs `Delete` for your relation type.
- To customize output or exclude certain interfaces/structs, adjust your `genconfig.Config` accordingly.

<Warning>
Do not modify generated code directly. Regenerate when your interfaces or models change to keep APIs in sync.
</Warning>

---

## 7. Troubleshooting

<AccordionGroup title="Common Issues Using Generated APIs">
<Accordion title="Generated Method Not Found">
- Ensure you ran the generator after adding new methods.
- Confirm your interface's methods have valid SQL templates in comments.
- Check your import path when referencing the generated package.
</Accordion>
<Accordion title="Compilation Errors Due to Missing Context Parameter">
- The generator auto-adds `context.Context` if absent; use generated methods accordingly.
- Avoid redefining methods with incompatible signatures.
</Accordion>
<Accordion title="Association Operations Have No Effect">
- Verify your model’s GORM tags and association definitions.
- Understand `Unlink` vs `Delete` semantics.
- Check that association helpers are generated properly by inspecting generated code.
</Accordion>
</AccordionGroup>

---

## 8. Next Steps

- Explore the [Preparing Models & Query Interfaces](../prepare-models-interfaces.md) page to refine your definitions.
- Review [Basic Configuration Options](../basic-configuration-options.md) to learn how to customize generation.
- Consult the [Validation & Troubleshooting](../validation-troubleshooting.md) guide for debugging generation issues.
- Dig deeper into association helpers with the [Working with Associations](../../guides/advanced-patterns/association-helpers.md) guide.

---

For more examples and advanced usage, see the [GORM CLI README](https://github.com/go-gorm/cli#readme).

---

**Happy coding with type-safe, fluent GORM-driven data access!**