---
title: "Defining Models & Query Interfaces"
description: "Quickly scaffold Go model structs and query interfaces using real examples. Learn best practices for struct and interface organization to ensure the generator produces optimal, type-safe APIs tailored to your domain."
---

# Defining Models & Query Interfaces

Welcome to the essential first step in your GORM CLI journey! In this guide, you'll learn how to structure your Go model structs and define your query interfaces to harness GORM CLI’s powerful type-safe code generation. By following real-world examples and best practices, you'll set the foundation for generating efficient, discoverable, and maintainable query APIs that fit your domain perfectly.

---

## 1. Understanding Your Objective

Your primary goal on this page is to define **domain models** as Go structs and write **query interfaces** with embedded SQL templates. These serve as blueprints from which GORM CLI generates two key pieces of code:

- **Model-driven field helpers** for filters, setters, and association operations.
- **Interface-driven, type-safe query APIs** for your data access layer.

This dual approach provides compile-time guarantees and improves your development experience with fluent, discoverable APIs tailored to your application.

---

## 2. Defining Your Models

### 2.1 Start with Simple Structs

Write your application data entities as Go structs using idiomatic Go and GORM conventions:

```go
package models

import (
  "time"
  "gorm.io/gorm"
)

type User struct {
  gorm.Model
  Name      string
  Age       int
  Email     string
  CreatedAt time.Time
}
```

> Each field represents a table column; embedded `gorm.Model` includes ID and timestamps.

### 2.2 Use GORM Field Tags for Column Customization

When necessary, you can customize column names, indexes, or types using struct tags:

```go
type Product struct {
  ID      uint      `gorm:"primaryKey"`
  Name    string    `gorm:"size:255;not null"
  Price   float64   `gorm:"type:decimal(10,2)"
  CreatedAt time.Time
}
```

### 2.3 Model Associations for Rich Relationships

GORM CLI detects associations from your models and generates helpers accordingly:

- `has one`
- `has many`
- `belongs to`
- `many2many`

Example:

```go
type User struct {
  ID       uint
  Pets     []Pet           // has many
  Company  Company          // belongs to
  Languages []Language `gorm:"many2many:user_languages"`
}
```

> These associations generate strongly typed helpers for easy CRUD and relation operations.

### 2.4 Annotate Fields for Custom Helpers

Use struct tags like `gen:"json"` to apply custom field helper types (e.g., JSON operations):

```go

// In your model
Profile string `gen:"json"`
```

Then configure the generator to recognize `json` fields:

```go
var _ = genconfig.Config{
  FieldNameMap: map[string]any{
    "json": JSON{},
  },
}
```

---

## 3. Writing Query Interfaces

### 3.1 Purpose and Structure

Your query interfaces define methods representing SQL operations using embedded SQL templates in method comments. These interfaces are parameterized generics:

```go
// Query interface for User entity

type Query[T any] interface {
  // SELECT * FROM @@table WHERE id=@id
  GetByID(id int) (T, error)

  // where("name=@name AND age=@age")
  FilterByNameAndAge(name string, age int)
}
```

- Methods end with a return type of `(T, error)` or `(error)` depending on operation.
- Templates support dynamic placeholders like `@@table` and named parameters (e.g., `@id`).

### 3.2 Using the SQL Template DSL

Leverage built-in directives:

| Directive   | Use Case                         | Example                                |
|-------------|---------------------------------|--------------------------------------|
| `@@table`   | Resolves to model's DB table    | `SELECT * FROM @@table WHERE id=@id`  |
| `@@column`  | Used for dynamic column names   | `WHERE @@column=@value`               |
| `@param`    | Binds method params to SQL      | `WHERE name=@name`                    |
| `{{where}}` | Conditional WHERE clause builder| `{{where}} age > 18 {{end}}`          |
| `{{set}}`   | Conditional UPDATE SET clause   | `{{set}} name=@name {{end}}`          |
| `{{if}}`/`{{else}}` | Conditional expressions    | `{{if age > 0}} AND age=@age {{end}}`|
| `{{for}}`   | Loop over collections           | `{{for _, item := range items}} ...` |

### 3.3 Writing Flexible Queries

Use conditionals and loops in comments to express dynamic filters:

```go
//
// SELECT * FROM @@table
// {{where}}
//   {{if user.Name != ""}} name=@user.Name {{end}}
//   {{if user.Age > 0}} AND age=@user.Age {{end}}
// {{end}}
SearchUsers(user User) ([]T, error)
```

### 3.4 Method Signatures and Context

- If your method lacks `context.Context`, the generator automatically prefixes `ctx context.Context` in the implementation for cancellation and deadlines.

### 3.5 Return Values

- Methods returning data must have two returns: `(T, error)`.
- Methods performing operations like updates may return only `error`.

---

## 4. Organizing Your Code

### 4.1 File Placement

Place your model structs and query interfaces in the **same package or directory** to allow the generator to find and process them together:

```shell
/myapp
  /models
    user.go       # model declarations
    query.go      # query interfaces
```

### 4.2 Generating Code from Multiple Sources

You can define multiple query interfaces or structs across your project and combine them with generation configuration.

### 4.3 Configuration

Use an optional `genconfig.Config` struct within the same package to control output directory, include/exclude filters, and custom mapping:

```go
package examples
import (
  "gorm.io/cli/gorm/genconfig"
  "gorm.io/cli/gorm/field"
  "database/sql"
)

var _ = genconfig.Config{
  OutPath: "examples/output",
  FieldTypeMap: map[any]any{
    sql.NullTime{}: field.Time{},
  },
  FieldNameMap: map[string]any{
    "json": JSON{},
  },
  IncludeInterfaces: []any{"Query*"},
}
```

> This concentrates generation to your targeted structs/interfaces and applies custom helpers.

---

## 5. Practical Example

Follow this workflow to define a User model and a basic query interface:

```go
// models/user.go
package models

import "gorm.io/gorm"

type User struct {
  gorm.Model
  Name string
  Age  int
}


// examples/query.go
package examples

// Query interface uses generics and SQL templates

type Query[T any] interface {
  // SELECT * FROM @@table WHERE id=@id
  GetByID(id int) (T, error)

  // where("name=@name AND age=@age")
  FilterByNameAndAge(name string, age int)
}
```

Generator command:

```bash
gorm gen -i ./examples -o ./generated
```

Your generated code provides fluent APIs such as:

```go
u, err := generated.Query[models.User](db).GetByID(ctx, 123)
users, err := generated.Query[models.User](db).FilterByNameAndAge("jinzhu", 30).Find(ctx)
```

---

## 6. Best Practices & Tips

- **Keep models and query interfaces close**: This simplifies generation and keeps related code organized.
- **Use clear method names**: Reflect intent in your interface for easier maintenance and discovery.
- **Leverage the SQL template DSL**: Use conditional clauses, loops, and placeholders to write flexible queries.
- **Annotate for custom helpers**: Use tags like `gen:"json"` for special field support.
- **Apply configuration wisely**: Include or exclude interfaces/structs to keep generation focused and fast.

---

## 7. Common Pitfalls

<AccordionGroup title="Common Issues When Defining Models & Interfaces">
<Accordion title="Missing Return Types or Incorrect Signatures">
Ensure methods that return data always include an error as the last return value. For single return methods, it must be `error`. For two returns, the second must be `error`. Otherwise, generation will fail.
</Accordion>
<Accordion title="Template Syntax Errors in Comments">
Incorrect or malformed SQL template DSL in method comments can cause generation errors. Verify directives and placeholders match examples.
</Accordion>
<Accordion title="Model and Interface Location Mismatch">
Keep your models and interfaces in the same package/directory or configure the generator `OutPath` and `IncludeInterfaces` correctly.
</Accordion>
<Accordion title="Forgetting to Add Context in Method Signatures">
While the generator prepends `context.Context` automatically, explicitly including `context.Context` in method signatures offers clarity.
</Accordion>
</AccordionGroup>

---

## 8. Next Steps

- Proceed to [Generating Code](/getting-started/your-first-code-generation/generating-code) to learn running the generator with your defined models and interfaces.
- Explore [Using the Generated APIs](/guides/core-workflows/using-generated-apis) to integrate generated code into your application.
- Review [Configuration Setup](/getting-started/installation-and-setup/configuration-setup) to fine-tune generator behavior.

---

## 9. References & Resources

- [GORM CLI Official GitHub](https://github.com/go-gorm/cli) for source, examples, and issues
- [SQL Template DSL Guide](/guides/advanced-usage/template-dsl-guide) for advanced query writing
- [Field Helpers and Associations](/guides/core-workflows/field-helper-basics)
- [Working with Associations](/guides/core-workflows/association-guides)

---

Start strong by clearly defining your models and queries — this unlocks the full power of GORM CLI’s type-safe generation for robust and efficient Go data layers.

Happy coding!
