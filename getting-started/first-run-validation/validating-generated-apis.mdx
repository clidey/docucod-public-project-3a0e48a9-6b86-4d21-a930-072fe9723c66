---
title: "Validating Generated APIs"
description: "Quickly verify your generated APIs by running example queries and updates. Learn to check for proper type-safety, discoverability in your IDE, and correctness through minimal code snippets. Page includes first test command to ensure your setup works."
---

# Validating Generated APIs

Quickly verify your generated APIs by running example queries and updates. This guide helps you check for proper type-safety, discoverability in your IDE, and correctness through minimal code snippets. It also covers your first test command to ensure your setup works smoothly.

---

## 1. Overview

After generating your type-safe APIs using GORM CLI, the next critical step is validation. This ensures your generated code correctly maps your interfaces and models, integrates cleanly with GORM, and behaves as expected in real queries and updates.

This page guides you through:

- Executing first test query calls with generated APIs
- Verifying type-safety and SQL correctness
- Understanding minimal example snippets for common operations
- Running a recommended test command

The goal is a fast onboarding flow that ensures your code generation result is immediately usable and aligns perfectly with your expectations.

---

## 2. Prerequisites

Before validating your generated APIs:

- **Code generation completed successfully.** Please follow the [Generating Your First Code](./generating-code) instructions to generate code from your Go interfaces and structs.
- **Generated package successfully imported.** Your Go project should import the generated code package (e.g., `generated` or configured `OutPath`).
- **GORM DB instance initialized.** You have an active `*gorm.DB` connected to your database.

<Tip>
If you haven’t run code generation yet, errors or unexpected API shapes during validation will likely indicate generation issues. Complete generation first.
</Tip>

---

## 3. Running Your First Test Queries

This step uses minimal code snippets to check your generated APIs.

### 3.1. Import the Generated Package

```go
import (
  "context"
  "fmt"

  "gorm.io/gorm"
  "path/to/your/generated" // adjust import path
)
```


### 3.2. Set Up Your DB and Context

```go
ctx := context.Background()
db := initializeYourGormDB() // your existing GORM DB setup
```


### 3.3. Run a Sample Query Using Generated Query API

Assuming you generated for interface `Query[T]` with a method `GetByID(int) (T, error)`, here is a minimal usage:

```go
user, err := generated.Query[models.User](db).GetByID(ctx, 123)
if err != nil {
  fmt.Println("Query failed:", err)
  return
}
fmt.Printf("User: %+v\n", user)
```

This call validates:

- The generated method exists and has the expected signature
- SQL executes correctly with proper parameterization
- Returned struct matches your model


### 3.4. Try an Update Operation Example

If your interface includes an UPDATE method like `UpdateInfo(user models.User, id int) error`, test it:

```go
updateUser := models.User{
  Name: "Updated Name",
  Age:  30,
}
err = generated.Query[models.User](db).UpdateInfo(ctx, updateUser, 123)
if err != nil {
  fmt.Println("Update failed:", err)
  return
}
fmt.Println("Update succeeded")
```


## 4. Understanding Success Criteria

You have successfully validated your generated APIs if:

- No compile-time errors related to method calls or types appear
- Calls execute without SQL syntax errors or runtime exceptions
- Returned data matches expected model fields
- Updates affect the database rows as intended

<Tip>
Enable IDE auto-completion and inspect the generated method signatures for confidence in discoverability and type safety.
</Tip>


## 5. Minimal Example of a Complete Test Function

Below is a simple test function you can place in your project to verify your generated APIs quickly:

```go
func TestGeneratedQueryAPI(t *testing.T) {
  ctx := context.Background()
  db := initializeYourGormDB() // Replace this with your DB setup
  q := generated.Query[models.User](db)

  user, err := q.GetByID(ctx, 1)
  if err != nil {
    t.Fatalf("GetByID failed: %v", err)
  }
  if user.ID != 1 {
    t.Errorf("Expected user ID 1, got %d", user.ID)
  }

  err = q.UpdateInfo(ctx, models.User{Name: "Tester"}, 1)
  if err != nil {
    t.Fatalf("UpdateInfo failed: %v", err)
  }
}
```

Run this test with `go test`. Success means your generation and database mapping are correctly wired.


## 6. Running the Built-In Generator Test Command

For a built-in lightweight validation step on your environment, you can run the automated test provided within the generator’s codebase:

```bash
go test -v ./internal/gen -run TestGeneratorWithQueryInterface
```

This test:

- Parses example query interfaces
- Generates code
- Compares generated files against golden output
- Validates Go syntax correctness

<Tip>
Running this test is a strong way to verify your generation process works correctly on your machine before custom runs.
</Tip>

---

## 7. Tips and Best Practices

- **Use context.Context**: Your generated methods automatically inject `ctx` if missing; always provide it.
- **Validate with real data**: Run queries against an actual test database reflecting your schema.
- **Check IDE autocomplete**: Generated APIs should be discoverable in your IDE, reflecting your interfaces.
- **Incrementally test**: Start testing one method at a time to isolate issues easily.


## 8. Troubleshooting Common Issues

<AccordionGroup title="Common Validation Issues and Solutions">
<Accordion title="No Methods Found or Wrong Signatures">
Check that your Go interfaces have correct method signatures and SQL template comments as per the [Writing Query Interfaces](./generating-code#writing-query-interfaces) guide. Also, verify your generation command input points to the correct files.
</Accordion>
<Accordion title="Generated Code Not Importable">
Ensure the output directory (`-o` flag) is correctly referenced in your project imports. Run `go mod tidy` and rebuild your project.
</Accordion>
<Accordion title="SQL Execution Errors During Query">
Review your SQL template syntax in the interface comments. Remember that placeholders like `@param` must match method parameters. Consult the SQL Template DSL examples for correctness.
</Accordion>
<Accordion title="Database Connection Issues">
Confirm your GORM setup and database connectivity. The generated code depends on a functional `*gorm.DB` instance.
</Accordion>
</AccordionGroup>

---

## 9. Next Steps

- Explore more in-depth SQL template examples and advanced query features in [Building Template-Based Query APIs](../../guides/core-workflows/template-based-queries).
- Learn to customize your generation with filters and configuration in [Customizing Generation with genconfig](../../guides/advanced-usage/customizing-generation).
- Deep dive into field helpers and associations for complex models in related guides.

---

## References

- [Generating Your First Code](./generating-code): How to write interfaces and generate code.
- [Troubleshooting Common Issues](./troubleshooting-common-issues): Fix setup and generation problems.
- [SQL Template DSL Fundamentals](../../gorm-cli-concepts/extensibility-integration/template-dsl-concepts): Learn the template language syntax.


---

## Summary
This guide empowers you to confidently verify your generated GORM CLI APIs by running straightforward query and update examples, checking for type-safety, and verifying integration with your database. It includes the recommended test command to ensure your generation pipeline works perfectly.

---

# Code References

For detailed generator internals and test validations, see:

- Generator test validating output and syntax: [`internal/gen/generator_test.go`](https://github.com/go-gorm/cli/blob/main/internal/gen/generator_test.go)
- Example query interfaces with templated SQL docs: [`examples/query.go`](https://github.com/go-gorm/cli/blob/main/examples/query.go)
- CLI generator command entry: [`internal/gen/gen.go`](https://github.com/go-gorm/cli/blob/main/internal/gen/gen.go)


---

## Example

```go
package main

import (
  "context"
  "fmt"

  "gorm.io/driver/sqlite"
  "gorm.io/gorm"

  "your/module/generated"
  "your/module/models"
)

func main() {
  ctx := context.Background()

  db, err := gorm.Open(sqlite.Open("test.db"), &gorm.Config{})
  if err != nil {
    panic(err)
  }

  user, err := generated.Query[models.User](db).GetByID(ctx, 1)
  if err != nil {
    fmt.Println("Error fetching user:", err)
    return
  }

  fmt.Printf("Fetched user: %+v\n", user)
}
```

This snippet confirms your generated API methods are functional and your environment is correctly set up.