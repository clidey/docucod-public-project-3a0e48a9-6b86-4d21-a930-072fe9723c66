---
title: "Generating Your First Code"
description: "Follow a hands-on workflow: write a query interface, model struct, and run the GORM code generator. See typical command-line patterns and what to expect as output (structure, placement, and naming conventions)."
---

# Generating Your First Code with GORM CLI

This guide walks you through generating your first type-safe query code using GORM CLI. The workflow involves writing a query interface with SQL templates, defining your model structs, and running the GORM code generator command. You'll learn the expected command-line usage patterns and understand where and how the generated code files will be placed, including naming expectations.

---

## 1. Write a Query Interface with SQL Templates

Your query interface drives the generation of type-safe query methods. Define an interface with methods annotated by SQL templates in comments. These templates use GORM CLI's DSL placeholders to map Go method parameters to SQL parameters.

**Example:**

```go
package examples

import (
	"database/sql"
	"time"
	
	"gorm.io/cli/gorm/examples/models"
	"gorm.io/cli/gorm/field"
)

type Query[T any] interface {
	// SELECT * FROM @@table WHERE id=@id
	GetByID(id int) (T, error)

	// SELECT * FROM @@table WHERE @@column=@value
	FilterWithColumn(column string, value string) (T, error)

	// SELECT * FROM @@table
	// {{if user.ID > 0}}
	//     WHERE id=@user.ID
	// {{else if user.Name != ""}}
	//     WHERE name=@user.Name
	// {{end}}
	QueryWith(user models.User) (T, error)

	// UPDATE @@table
	//  {{set}}
	//    {{if user.Name != ""}} name=@user.Name, {{end}}
	//    {{if user.Age > 0}} age=@user.Age, {{end}}
	//    {{if user.Age >= 18}} is_adult=1 {{else}} is_adult=0 {{end}}
	//  {{end}}
	// WHERE id=@id
	UpdateInfo(user models.User, id int) error

	// Additional methods with templated queries...
}
```

> These comments define the SQL logic, using placeholders such as `@@table`, `@param`, `{{if}}`, and `{{set}}` directives.


## 2. Define Your Model Structs

Your data models should be defined as Go structs in the same package or directory. The generator uses these to create strongly typed field helpers.

**Example:**

```go
package models

import "time"

type User struct {
	ID        uint
	Name      string
	Age       int
	CreatedAt time.Time
}
```

> Properly structuring your models with exported fields is key for accurate field helper generation.


## 3. Run the GORM CLI Generator Command

With your interface and model defined, run the GORM CLI `gen` command to generate the code.

### Typical CLI Command Pattern

```bash
gorm gen -i ./examples -o ./generated
```

- `-i` or `--input`: Path to your input Go file or directory (containing interfaces and model structs).
- `-o` or `--output`: Directory where the generated files will be placed.

### What Happens?

- The generator parses your interfaces and structs.
- It reads SQL templates from comments.
- Generates type-safe Go implementations with fluent API methods.
- Creates field helper variables for model fields.


## 4. Understand the Output Structure and Naming

Generated code files mirror your input directory structure beneath the output folder:

```
./generated/examples/query.go
./generated/examples/models.go
```

- File names match input files (e.g., `query.go` and `models.go`).
- Generated code has a header comment warning to not edit manually.
- Generated interfaces and methods provide methods matching your query interface.

> The output preserves package names to enable seamless import and usage.


## 5. Verify and Use the Generated APIs

Once generated:

- Import your generated package(s).
- Use the generated query objects and field helpers directly with your existing GORM DB instance.

**Example Usage:**

```go
// SELECT * FROM users WHERE id = 123
user, err := generated.Query[models.User](db).GetByID(ctx, 123)

// SELECT * FROM users WHERE name='jinzhu' AND age = 25
users, err := generated.Query[models.User](db).FilterByNameAndAge(ctx, "jinzhu", 25)

// UPDATE users SET name='jinzhu', age=20, is_adult=1 WHERE id=1
err := generated.Query[models.User](db).UpdateInfo(ctx, models.User{Name: "jinzhu", Age: 20}, 1)
```


## 6. Practical Tips and Best Practices

- **Consistent File Layout:** Keep interfaces and model structs logically organized in the same folder or package for easier config and generation.
- **Use genconfig for Customization:** You can place a package-level `genconfig.Config` to control output paths, field helper mappings, and inclusion/exclusion rules.
- **Context Parameter:** If your method signatures omit `ctx context.Context`, the generator will add it for you automatically.
- **SQL Template DSL:** Master the templating DSL to write clean and flexible query methods.


## 7. Common Pitfalls to Avoid

- Missing required return `error` in query methods will cause generation errors.
- Unclosed or malformed SQL template directives (e.g., missing `{{end}}`) will fail parsing.
- Forgetting to run the generator after changes will cause your code to be out-of-date.
- Incorrect import paths or package inconsistencies in your input files may cause generation or build failures.


## 8. Troubleshooting Generation Errors

If you encounter issues:

- Verify your interface method signatures match expected return types (see example).
- Check your SQL template comments for correct syntax and balanced directives.
- Confirm your input paths point to valid Go files with the correct package and struct definitions.
- Run `gorm gen -h` to see CLI usage and flags.
- Consult the "Troubleshooting Common Issues" guide for detailed solutions.


## 9. Next Steps: After Your First Code Generation

- Test the generated APIs extensively with your database.
- Explore customizing generation with `genconfig.Config` to match your project conventions.
- Study the generated code to understand how queries and field helpers are implemented.
- Leverage association helpers for more advanced model relationships.


---

### Additional Resources

- [Installation Guide](../getting-started/setup-prerequisites-installation/installation)
- [Initial Configuration](../getting-started/setup-prerequisites-installation/initial-configuration)
- [Validating Generated APIs](../getting-started/first-run-validation/validating-generated-apis)
- [Troubleshooting Common Issues](../getting-started/first-run-validation/troubleshooting-common-issues)
- [Understanding the Generated Code](../../guides/getting-started/understanding-generated-code)


---

By following this workflow, you enable your Go projects with robust, type-safe, and maintainable database access methods tailored by your own SQL requirements and data models.


<Check>
Ensure you have Go 1.18+ installed and your environment configured for your project before starting generation.
</Check>

<Warning>
Always backup or version-control your generated code directories to avoid accidental loss or overwrite.
</Warning>

<AccordionGroup title="Common CLI Command Examples">
<Accordion title="Generate code from a directory with default output">
```bash
gorm gen -i ./examples
```
</Accordion>
<Accordion title="Generate code specifying output directory">
```bash
gorm gen -i ./examples -o ./generated
```
</Accordion>
<Accordion title="Generate code from a single file">
```bash
gorm gen -i ./examples/query.go -o ./generated
```
</Accordion>
<Accordion title="Force overwrite existing generated files">
Currently, the command overwrites files silently. Ensure no conflicting manual edits before regenerating.
</Accordion>
</AccordionGroup>