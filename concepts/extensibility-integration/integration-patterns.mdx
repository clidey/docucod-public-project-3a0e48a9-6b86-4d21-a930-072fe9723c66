---
title: "Patterns for Integrating with GORM and Databases"
description: "Get a concise guide to integrating generated code with plain GORM, handling differences across MySQL, SQLite, and Postgres, and adapting output for multi-database projects."
---

# Patterns for Integrating with GORM and Databases

Learn how to seamlessly integrate the code generated by GORM CLI with plain GORM usage, adapt to the specific nuances of MySQL, SQLite, and Postgres, and manage projects supporting multiple databases. This guide offers practical patterns to align generated query APIs and model-driven helpers with your real-world database workflows, ensuring smooth adoption and efficient multi-dialect support.

---

## Introduction

GORM CLI generates strongly typed query APIs and model-driven field helpers based on your Go interfaces and model structs. While these generated components are designed to work out-of-the-box with GORM, each database dialect (MySQL, SQLite, Postgres) presents unique considerations that affect how you integrate and adapt the generated code.

This page focuses exclusively on practical patterns for integrating the generated code with:

- Plain GORM usage in your Go projects
- Dialect-specific behaviors and SQL variations
- Multi-database project architecture

By the end, you will wield actionable strategies to ensure your generated code consistently delivers expected results in diverse environments.

---

## Using Generated Code with Plain GORM

The generated query APIs and model-driven field helpers are designed as ergonomic extensions to plain GORM workflows, enhancing type safety and reducing boilerplate:

- **Query Interfaces:** These are Go interfaces with SQL templates embedded in comments. The generator produces fluent implementations that invoke GORM internally, exposing methods that map directly to SQL operations.

- **Field Helpers:** Generated structs expose strongly typed field predicates and setters (e.g., `.Eq()`, `.Set()`, `.Like()`) that integrate perfectly with GORM's querying and updating mechanisms.

### Typical Integration Flow

1. **Import the Generated Packages:** After generation, import your generated code packages (usually located under your specified output directory). For example:

    ```go
    import "yourapp/generated"
    ```

2. **Initialize Query Interfaces:** Construct query interface instances by passing a `*gorm.DB` instance:

    ```go
    query := generated.Query[models.User](db)
    ```

3. **Use Queries and Field Helpers:** Compose type-safe query calls using generated methods and helpers:

    ```go
    user, err := query.GetByID(ctx, 123)

    users, err := query.FilterByNameAndAge("jinzhu", 25).Find(ctx)

    err = query.UpdateInfo(ctx, models.User{Name: "jinzhu", Age: 20}, 1)

    // Using field helpers with plain GORM
    err = gorm.G[models.User](db).
      Where(generated.User.Name.Eq("alice")).
      Set(generated.User.Age.Set(30)).
      Update(ctx)
    ```

> This integration leverages GORM's native capabilities, augmented by the added type safety and expressiveness of the generated code.

### Benefits of this Pattern

- Clean separation of concerns: generated code solely focuses on query composition;
- Reuse of GORM's mature runtime ecosystem including connection pooling, caching, hooks;
- Enhanced discoverability and compile-time guarantees for field references.

---

## Handling Dialect Differences: MySQL, SQLite, and Postgres

Though GORM abstracts many database differences, certain SQL functions and JSON operations differ notably across dialects. GORM CLI-generated code respects these differences by enabling you to customize field helpers and SQL templates.

### JSON Fields as an Example

The `JSON` field helper illustrates how to adapt SQL generation per database dialect:

```go
func (e jsonEqualExpr) Build(builder clause.Builder) {
  if stmt, ok := builder.(*gorm.Statement); ok {
    switch stmt.Dialector.Name() {
    case "mysql":
      clause.Expr{SQL: "JSON_EXTRACT(?, ?) = CAST(? AS JSON)", Vars: []any{e.col, e.path, string(v)}}.Build(builder)
    case "sqlite":
      clause.Expr{SQL: "json_valid(?) AND json_extract(?, ?) = ?", Vars: []any{e.col, e.col, e.path, e.val}}.Build(builder)
    default: // postgres
      clause.Expr{SQL: "jsonb_extract_path_text(?, ?) = ?", Vars: []any{e.col, e.path[2:], e.val}}.Build(builder)
    }
  }
}
```

This pattern ensures calls like `generated.User.Profile.Equal("$.vip", true)` compile to dialect-appropriate SQL.

### Strategies for Dialect-Specific Adaptation

- **Configuration-Based Custom Helpers:** Use `genconfig.Config` to map struct tags and Go types to dialect-aware custom field helpers.

- **SQL Template Directives:** Leverage conditional SQL templating (`{{if}}`, `{{else}}`) in interface comments to embed dialect-specific clauses.

- **Runtime Dialect Detection:** Write helper methods that inspect `gorm.Statement.Dialector.Name()` to generate dialect-aware expressions.

- **Testing Across Dialects:** Maintain tests for all target databases to catch incompatibilities early.

### Tips for SQL Template Dialect Handling

- Use explicit, clear SQL templates with placeholders like `@@table`, `@param` for portability.
- Avoid vendor-specific SQL unless wrapped in dialect conditionals.
- When complex, consider custom helpers for heavy-lifting logic.

---

## Adapting Generated Output for Multi-Database Projects

Projects targeting multiple database backends require careful integration strategies to handle schema and query variations without duplicating large amounts of code.

### Common Scenarios

- Supporting dev/test environments with SQLite, production with MySQL/Postgres.
- Migrating between databases over time.
- Offering user-configurable database engines.

### Recommended Patterns

#### 1. Separate Configuration Packages

Maintain a `genconfig.Config` package per dialect, setting specialized mappings and output paths:

```go
// mysql/config.go
var _ = genconfig.Config{
  OutPath: "generated/mysql",
  FieldNameMap: map[string]any{
    "json": MySQLJSONHelper{},
  },
}

// postgres/config.go
var _ = genconfig.Config{
  OutPath: "generated/postgres",
  FieldNameMap: map[string]any{
    "json": PostgresJSONHelper{},
  },
}
```

Generate code separately for each dialect:

```bash
gorm gen -i ./mysql/config.go -o ./generated/mysql
orm gen -i ./postgres/config.go -o ./generated/postgres
```

Then at runtime, select the appropriate generated package by build tag or configuration.

#### 2. Conditional Compilation

Employ Go build tags to selectively include generated code per target dialect.

#### 3. Compose Shared and Dialect-Specific Code

- Generate core queries and helpers once in a shared package.
- Extend or override dialect-specific helpers with embedding or interfaces.

For instance, common fields use default field helpers, while JSON-related fields use dialect-customized implementations.

#### 4. Use Runtime Dialect Aware Helpers

Design custom field helpers that adjust behavior based on `gorm.Statement.Dialector.Name()` as in the JSON example above, reducing code duplication.

### Best Practices

- Maintain consistent naming conventions for generated packages per dialect.
- Document dialect-specific variations clearly alongside generated code.
- Keep your SQL templates dialect-neutral where possible to maximize reuse.
- Regularly run integration tests against all supported databases.

---

## Troubleshooting Common Integration Scenarios

<AccordionGroup title="Troubleshooting Integration" >
<Accordion title="Generated Code Fails to Compile After Updates">
Verify your package imports correctly reference the generated output directory configured via `OutPath`. Run the generation command again after any interface or model changes to keep the code in sync.
</Accordion>
<Accordion title="Divergent SQL Generated for Different Databases">
Confirm your custom field helpers or SQL templates use dialect-aware logic. Utilize `stmt.Dialector.Name()` in field helper methods to conditionally generate SQL code.
</Accordion>
<Accordion title="Runtime Query Errors in Multi-DB Setup">
Check that the appropriate generated package for the current dialect is compiled and imported. Avoid mixing code generated for different dialects at runtime.
</Accordion>
<Accordion title="JSON Fields Not Querying Correctly">
Validate your JSON helper's SQL syntax against each database's JSON function syntax. Adjust your `FieldNameMap` configuration to bind the field tag (e.g., `gen:"json"`) to your dialect-aware JSON field helper.
</Accordion>
</AccordionGroup>

---

## Summary

Integrating generated GORM CLI code with plain GORM usage ensures you gain type safety and fluent APIs without losing flexibility. Adapting for MySQL, SQLite, and Postgres means writing dialect-aware helpers and SQL templates, especially for complex types like JSON. Multi-database projects benefit from clear separation of generated code per dialect, conditional compilation strategies, and runtime dialect detection.

Apply these patterns to accelerate your adoption, avoid common pitfalls, and maintain clean, maintainable database access layers.

---

## References & Further Reading

- [Interface-Driven Query APIs: Template-Based SQL Queries](/guides/advanced-usage-patterns/template-queries)
- [Model-Driven Field Helpers & Custom Field Mapping](/concepts/core-architecture/model-field-helpers)
- [Customizing Code Generation with `genconfig.Config`](/guides/advanced-usage-patterns/customizing-generation)
- [Using Generated Field Helpers with GORM](/guides/getting-started-workflows/using-field-helpers)
- [Managing Associations and Relationships](/guides/advanced-usage-patterns/working-with-associations)

---

For visual learners, you can also explore the [Architecture Overview](/concepts/core-architecture/architecture-overview) to understand where these integration patterns fit within the overall generation lifecycle.
