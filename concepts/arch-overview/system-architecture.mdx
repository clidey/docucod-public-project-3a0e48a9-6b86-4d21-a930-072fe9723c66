---
title: "System Architecture"
description: "Gain a visual and narrative overview of GORM CLI’s architecture—the interplay between the command-line tool, code generators, and your Go project. Understand how interfaces, models, and configuration interact with the generator to produce type-safe APIs and field helpers."
---

# System Architecture

Understand how GORM CLI orchestrates code generation to empower your Go projects with type-safe query APIs and expressive model-driven field helpers. This architecture overview reveals the interactions between your source code, configuration, the command-line interface, and internal generators, culminating in fluent, compile-time validated code that integrates seamlessly with GORM.

---

## 1. Inputs: Your Interfaces, Models, and Configuration

### 1.1 Go Interfaces with SQL Templates
You start by defining Go interfaces that encapsulate your raw SQL queries or commands within specially formatted method comments. These annotated interfaces form the blueprint for generating type-safe, fluent query APIs.

Example:
```go
// Query[T any] interface {
//   // SELECT * FROM @@table WHERE id=@id
//   GetByID(id int) (T, error)
// }
```

### 1.2 Go Struct Models
Your Go structs represent database models used for field helper generation. They allow the generator to produce strongly typed, composable predicates, setters, and association operations.

### 1.3 Configuration via `genconfig.Config`
Declare package-level configuration variables to customize generation behavior:
- Control output directories
- Map Go types or struct tags to custom field helpers
- Include or exclude specific interfaces or structs

Example:
```go
var _ = genconfig.Config{
  OutPath: "generated",
  FieldTypeMap: map[any]any{
    sql.NullTime{}: field.Time{},
  },
  IncludeInterfaces: []any{"Query*"},
}
```

---

## 2. Command-Line Interaction: The `gorm gen` Command

This CLI command is your gateway to code generation. Using `gorm gen`, you specify:
- `-i`: Path to your Go source files or directories containing SQL-annotated interfaces
- `-o`: Output directory for generated code

Example usage:
```bash
gorm gen -i ./examples -o ./generated
```

The CLI invokes the internal generator which processes your code samples, configurations, and templates.

---

## 3. Internal Generator: Parsing, Processing, and Producing Code

At the core resides the `Generator` module, responsible for:

### 3.1 Parsing Go Source
- **AST Traversal**: Parses Go files' abstract syntax trees, extracting information about imports, interfaces, methods, and structs.
- **Interface Extraction**: Identifies methods and their associated SQL comments.
- **Struct Analysis**: Gathers model struct fields and details for field helper generation.

### 3.2 Applying Configuration
- Filters interfaces and structs based on inclusion/exclusion rules from `genconfig.Config`.
- Adapts output paths and field/type mappings accordingly.

### 3.3 Template Rendering
- Uses Go templates to generate:
  - Typed interfaces with generated method implementations reflecting your SQL templates
  - Fluent field helper structs/functions with predicate and association APIs

### 3.4 Formatting and Output
- Writes generated Go source to the designated output folder, preserving directory structure
- Runs Go imports processor for clean, idiomatic source code

### 3.5 Feedback
- Prints progress messages to guide you during generation
- Provides detailed error messages if parsing or rendering fails

---

## 4. Generated Artifacts: Safe, Fluent, Discoverable APIs

### 4.1 Query API Types
Each interface method produces:
- A concrete implementation with injected `context.Context` if missing
- Methods that compile SQL templates into GORM expressions
- Return values aligned with declared method signatures

### 4.2 Field Helpers
- Typed field helpers aligned with your model structs
- Support for predicates, setters, ordering, and predicates on associations
- Association helpers for has-one, has-many, belongs-to, many-to-many relations

Example usage:
```go
// Query by ID with type safety
user, err := generated.Query[User](db).GetByID(ctx, 123)

// Compose predicates
users, err := gorm.G[User](db).
  Where(generated.User.Age.Gt(18)).
  Find(ctx)
```

---

## 5. Integration Flow Diagram

```mermaid
flowchart TD

  subgraph "User Workspace"
    SRC["Source Files: Interfaces & Models"]
    CFG["Config: genconfig.Config"]
  end

  subgraph "GORM CLI Tool"
    CLI["Command Line Interface (gorm gen)"]
    GEN["Generator Module"]
    TPL["Templates & Code Production"]
    FS["File System: Writing Generated Files"]
  end

  subgraph "Output"
    GENERATED["Generated Code: Query APIs & Field Helpers"]
  end

  SRC --> CLI
  CFG --> GEN
  CLI --> GEN
  GEN --> TPL
  TPL --> FS
  FS --> GENERATED

  GENERATED -->|Imported by| USER_APP["Your Go Application Code"]

  classDef userStroke fill:#bbf,stroke:#228,stroke-width:2px;
  SRC,CFG,USER_APP userStroke

  %% Annotations
  note right of CLI
    Initiates generation
    with user parameters
  end

  note left of GEN
    Parses AST, applies configs,
    processes SQL templates
  end

  note right of GENERATED
    Ready-to-use,
    type-safe code
  end

```

---

## 6. Practical Tips and Best Practices

- **Define clear SQL Templates**: Ensure your interface methods have concise, valid SQL in comments with correct parameter bindings.
- **Leverage Configuration**: Use `genconfig.Config` to filter generation targets and map custom types to generated helpers.
- **Maintain Directory Layout**: Place interfaces and models logically to preserve output structure.
- **Inspect Generated Code**: Review and integrate generated code to understand fluent APIs.
- **Incremental Generation**: Re-run `gorm gen` as your project evolves to keep generated code up to date.

---

## 7. Troubleshooting Common Issues

- **Missing `input` flag or invalid path**: The CLI requires a valid path to interface files.
- **Parsing Errors**: Syntax errors in Go source or invalid annotations halt generation; fix errors and retry.
- **Empty Output**: Verify inclusion/exclusion filters and that interfaces/structs are correctly annotated.
- **Import Path Issues**: Ensure your Go modules and imports are correctly configured for full path resolution.

---

## Further Learning and Next Steps

- Explore [Defining Models and Query Interfaces](../getting-started/first-code-generation/defining-models-and-interfaces) to write effective interfaces
- Use [Running the Code Generator](../getting-started/first-code-generation/running-gorm-cli-gen) for step-by-step commands
- Dive into [Using Model-Driven Field Helpers](../guides/core-workflows/field-helper-generation) for fluent query construction

---

This architecture guide is your foundation for mastering GORM CLI’s capabilities in transforming your Go source into high productivity, type-safe database access layers.