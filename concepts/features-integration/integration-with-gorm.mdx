---
title: "Integration with GORM ORM"
description: "Explore how generated code seamlessly integrates with GORM and typical Go database workflows. See how users invoke, compose, and extend generated queries and field helpers within their data access layers."
---

# Integration with GORM ORM

GORM CLI enhances your Go data access layers by generating type-safe, interface-driven query APIs and model-based field helpers that seamlessly integrate with the mainstream GORM ORM framework. This page explores how generated code is invoked, composed, and extended within typical GORM workflows, empowering you to write expressive and safe database queries and updates with minimal boilerplate.

---

## Why Integration Matters

GORM is the de facto ORM in Go for relational databases, prized for its simplicity and extensibility. GORM CLI builds directly on this foundation by:

- **Leveraging GORM’s core types and APIs** to provide fluent, type-safe query builders.
- **Augmenting your data models** with generated field and association helpers, enabling compile-time safety in filters, updates, and relations.
- **Aligning with GORM idioms** so your existing knowledge of GORM translates immediately to generated code usage.

Together, this integration sharpens developer productivity and reduces runtime errors by catching common query bugs at compile time.

---

## Invoking Generated Query APIs

After running the GORM CLI generator on your SQL-annotated Go interfaces and model structs, you get generated packages with strongly typed query interfaces.

### Basic Usage Pattern

You start with obtaining a generated interface instance using:

```go
u, err := generated.Query[User](db).GetByID(ctx, 123)
```

Here:

- `generated.Query[User](db)` returns an instance of the generated query interface for type `User` bound to GORM’s `*gorm.DB`.
- Calling `.GetByID(ctx, 123)` executes the compiled SQL method with type safety.

This pattern embraces GORM’s `*gorm.DB` connection and context-aware API, fitting naturally in your existing GORM-powered repositories.

### Chained Query Composition

Generated query methods that build on predicates (like filters) chain seamlessly into GORM’s fluent API:

```go
users, err := generated.Query[User](db).
  FilterByNameAndAge("jinzhu", 25).
  Find(ctx)
```

This composes a query with type-safe predicates and executes it within your Go application context.

<Tip>
The generated query interfaces always include context injection (`ctx context.Context`), so your queries are goroutine-safe and support deadlines, cancellation, and tracing.
</Tip>

---

## Using Generated Field Helpers Within GORM Queries

GORM CLI generates a `generated` package containing field helpers for each model field based on your struct definitions. These helpers provide fluent predicates and update setters tightly coupled to your database schema.

### Building Filters

Field helpers empower you to build expressive query filters:

```go
// Query users older than 18
users, err := gorm.G[User](db).
  Where(generated.User.Age.Gt(18)).
  Find(ctx)
```

Common predicates supported include: `Eq()`, `Gt()`, `Lt()`, `Between()`, `Like()`, and `IsNull()`. These guarantee type correctness and SQL safety.

### Performing Updates

Setters correspond to fields for update operations:

```go
err := gorm.G[User](db).
  Where(generated.User.Name.Eq("alice")).
  Set(generated.User.Age.Incr(1), generated.User.IsAdult.Set(true)).
  Update(ctx)
```

This grants succinct, atomic update semantics while preventing accidental SQL injection or type mismatches.

### Creating Records

Create new entity with values assigned through setters:

```go
err := gorm.G[User](db).
  Set(generated.User.Name.Set("bob"), generated.User.Age.Set(20)).
  Create(ctx)
```

You gain compile-time validation over which fields can be set and their types.

<Warning>
Avoid mixing raw SQL strings with generated predicates to fully leverage type safety and avoid errors.
</Warning>

---

## Managing Associations With Generated Helpers

GORM CLI recognizes model associations (`has one`, `has many`, `belongs to`, `many2many`, `polymorphic`) and generates corresponding association helpers on the model struct.

### Association Operations

You can:

- **Create:** Create and link new associated records
- **Update:** Modify associated rows with conditions
- **Unlink:** Remove foreign key relationships without deleting data
- **Delete:** Remove associated rows or join table rows for many-to-many
- **Batch Create:** Create linked records in batch

Example:

```go
// Create user and one pet (has many)
gorm.G[User](db).
  Set(
    generated.User.Name.Set("alice"),
    generated.User.Pets.Create(generated.Pet.Name.Set("fido")),
  ).
  Create(ctx)
```

### Understanding Semantics By Association Type

- `belongs to`: Unlink sets parent FK NULL; Delete removes parent-associated rows.
- `has one` / `has many`: Unlink sets child FK NULL; Delete removes child rows.
- `many2many`: Unlink/Delete remove join table rows only.

This intelligence ensures your updates respect data integrity as per your domain model.

---

## Extending and Customizing Queries

The generated APIs support:

- **SQL Template DSL:** Write raw SQL with placeholders in Go interface comments that compile into type-safe methods.
- **Context Auto-Injection:** Keep concurrency-friendly and traceable database access flows.
- **Advanced Filtering:** Parameterized filters with dynamic conditions.

You can combine generated queries and field helpers to compose complex queries without manually writing SQL.

---

## Typical Usage Flow

<Steps>
<Step title="Define Models and Query Interfaces">
- Write your GORM model structs normally.
- Define Go interfaces with SQL template comments capturing your queries.
</Step>
<Step title="Generate Code with GORM CLI">
- Run `gorm gen -i <input_file> -o <output_path>`.
- The tool generates query interfaces and field helpers.
</Step>
<Step title="Invoke Generated Queries in Code">
- Import the generated package.
- Use `generated.Query[Model]` for type-safe queries.
- Use `gorm.G[Model]` with field helpers to compose filters and updates.
</Step>
<Step title="Manage Associations">
- Use generated association helpers on models for relation operations.
</Step>
</Steps>

---

## Troubleshooting Integration Issues

<Tip>
Common pitfalls include forgotten context parameters, mixing raw SQL with generated helpers, or misconfigured project paths preventing code generation. Refer to the Troubleshooting Your First Run guide for detailed steps.
</Tip>

- Validate your `*gorm.DB` and `context.Context` are properly passed.
- Ensure generated packages are imported correctly and up to date.
- Confirm model structs correctly define associations with GORM tags.

---

## Summary

GORM CLI augments your existing GORM ORM workflows with generated, type-safe query APIs and field/association helpers. You invoke generated interface methods for SQL templates, then use field helpers to compose expressive, type-checked predicates and updates, all while respecting your Go codebase’s idioms. This integration delivers robust, efficient, and maintainable data access with compile-time guarantees.

---

## See Also

- [Generating Type-Safe Query APIs](/guides/core-workflows/generating-type-safe-queries)
- [Using Field Helpers and Building Filters](/guides/core-workflows/field-helpers-and-filters)
- [Working with Associations](/guides/advanced-patterns/working-with-associations)
- [Template DSL & Query Specification](/concepts/architecture-dataflow/template-dsl)
- [Customizing Code Generation](/guides/advanced-patterns/customizing-generation-output)
- [Troubleshooting Your First Run](/getting-started/first-steps-with-gorm-cli/troubleshooting-first-run)

---