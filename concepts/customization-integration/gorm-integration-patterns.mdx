---
title: "Integration with GORM and Go Generics"
description: "See how GORM CLI-generated APIs work fluently with GORM's native query builder, leveraging Go 1.18+ generics for ergonomic, strongly typed database access. Learn about patterns for smooth adoption into existing projects."
---

# Integration with GORM and Go Generics

Understand how GORM CLI-generated APIs integrate smoothly with GORM's native query builder, leveraging Go 1.18+ generics to provide ergonomic, type-safe, and fluent database access. This guide bridges your generated query interfaces and model-driven field helpers with GORM's idiomatic usage patterns to maximize productivity and safety.

---

## Introduction

GORM CLI generates **type-safe query APIs** from Go interfaces annotated with SQL templates along with **model-driven field helpers**. These APIs harness the power of Go 1.18+ **generics** to deliver compile-time safety and fluent method chaining, and are designed to work hand-in-hand with the standard GORM `gorm.DB` query builder.

This integration pattern enables you to:

- Use your existing `*gorm.DB` instances without extra wrappers.
- Compose generated predicates and conditions dynamically and expressively.
- Use generated query interfaces both for standard CRUD operations and complex SQL templating.
- Leverage strong typing and IDE auto-completion across your entire data access layer.


## How Generated APIs Leverage Go Generics

The generated query methods and model fields are generic over your model type `T`, offering:

- **Strong typing**: Your database operations return your model struct directly without casting.
- **Flexible composition**: Methods can accept and return query builders or interfaces generic on the same model.
- **Code reuse**: One generic interface can work for any struct type, reducing boilerplate.

### Example: Generic Query Interface

```go
func QueryUser[T any](db *gorm.DB, opts ...clause.Expression) _QueryUserInterface[T] {
    return _QueryUserImpl[T]{
        Interface: gorm.G[T](db, opts...),
    }
}
```

- This factory function returns a generic query interface bound to the specified model `T` (for example, `User`).
- It internally wraps a generic GORM query builder `gorm.G[T](db, opts...)`.
- Your code calls typed methods on the returned interface, with parameters and results strongly typed to `T`.


## Fluent, Type-Safe Query Composition

GORM CLI-generated APIs emphasize fluent, discoverable method chains familiar to GORM users, but with added compile-time safety.

- Generated interfaces embed `gorm.Interface[T]` that supports common query methods like `.Where()`, `.Find()`, `.Count()`.
- Custom methods decorated with SQL templates add domain-specific queries returning typed results.
- Model-driven field helpers generate predicate methods for building conditions (`Eq()`, `Lt()`, `In()`, etc.) on your struct fields.

### Example Usage

```go
// Using generated type-safe query API for User
u, err := generated.Query[User](db).GetByID(ctx, 123)  // returns (User, error)

// Composing a filtered query with predicates
users, err := gorm.G[User](db).
    Where(generated.User.Age.Gt(18)).
    Where(generated.User.Name.Like("%john%")).
    Find(ctx)
```


## How the Generated Code Integrates with `gorm.DB`

1. **Accepts a standard `*gorm.DB`**:
   - Your application’s established database connection, transaction, or context-specific `*gorm.DB` is passed directly.
   - No additional wrapping or conversion is required.

2. **Works with GORM's core fluent API**:
   - The generated query interfaces embed `gorm.Interface[T]`, allowing `.Where()`, `.Order()`, `.Limit()`, `.Find()`, and custom extensions.

3. **Returns strongly typed results and errors**:
   - Standard GORM methods return concrete model structs, minimizing casting and runtime errors.

4. **Supports SQL template bindings**:
   - Methods with raw SQL templates generate custom query implementations, seamlessly called via the generic API.


## Patterns for Easy Adoption in Existing Projects

### Step 1: Define Your Models and Query Interfaces

Declare your Go structs and annotate SQL templates on interface methods.

```go
// models/user.go
package models

type User struct {
    ID   uint
    Name string
    Age  int
}

// query.go
package query

type Query[T any] interface {
    // SELECT * FROM @@table WHERE id = @id
    GetByID(id int) (T, error)

    // where(name=@name)
    FilterByName(name string)
}
```

### Step 2: Generate the Code

Run the generator with your interfaces input path:

```bash
gorm gen -i ./query -o ./generated
```

### Step 3: Use Generated APIs Alongside GORM

```go
import "generated"

func example(db *gorm.DB, ctx context.Context) error {
    // Get user by ID (typed method)
    user, err := generated.Query[models.User](db).GetByID(ctx, 123)
    if err != nil {
        return err
    }

    // Compose a query with generated predicates
    var adults []models.User
    err = gorm.G[models.User](db).
        Where(generated.User.Age.Gt(18)).
        Find(ctx, &adults)
    return err
}
```

### Step 4: Combine Generated and Custom GORM Queries

You retain full flexibility to use native GORM APIs and expressions alongside generated code.


## Best Practices and Tips

- **Always pass your app’s `*gorm.DB`** to generated APIs to maintain transaction context and settings.
- Use model-driven **field helpers** (generated) to construct expressive, reusable predicates.
- Provide `context.Context` explicitly to generated methods for cancellation and tracing.
- Take advantage of generated **SQL template methods** for complex or optimized queries.
- Use config (`genconfig.Config`) to adjust generation output paths, custom types, and mappings.


## Common Pitfalls & Troubleshooting

| Pitfall                        | Solution                                                      |
|-------------------------------|---------------------------------------------------------------|
| Missing `context.Context` param in interface method          | Generator injects `ctx` automatically if omitted—provide it explicitly for clarity|
| Generated files not in GOPATH or go module                     | Ensure output path matches module structure; configure `OutPath` in `genconfig.Config`|
| Type mismatches in SQL template annotations                   | Verify interface method signatures align with annotated parameters in SQL templates|
| No generated methods found after running `gorm gen`           | Confirm interfaces include SQL annotations and generator flags (`-i`) target correct paths|


## Summary

GORM CLI's integration with GORM and Go 1.18 generics provides a powerful, type-safe, and idiomatic query and update experience for Go developers. By bridging generated interfaces and helpers directly with `*gorm.DB`, it enables smooth, fluent database access that scales from simple CRUD to complex, template-driven queries—all with strong compile-time guarantees.

Explore related documentation to expand your expertise in code generation workflows, field helper patterns, association handling, and template DSL mastery.


---

## Additional Resources

- [Type-safe Query API Generation](https://example.com/concepts/data-modeling-safety/type-safe-apis)
- [Field Helpers and Associations](https://example.com/concepts/data-modeling-safety/field-helper-logic)
- [Mastering the SQL Template DSL](https://example.com/guides/real-world-examples/template-sql-dsl)
- [Working With Generated APIs in Your Project](https://example.com/guides/getting-started/using-generated-apis)
- [Configuring the Generator](https://example.com/concepts/customization-integration/generator-config-concept)

---

## Diagram: Flow of Generated API Usage with `*gorm.DB`

```mermaid
flowchart TD

    DB[*gorm.DB Instance] -->|Pass db| GenAPI[Generated Query API for T]
    GenAPI -->|Embeds| GormGorm[gorm.G[T](db)]
    GenAPI -->|Custom Query Methods| SQLTemplate[SQL Template Implementations]
    GormGorm -->|Fluent Methods| FluentQuery[Fluent Query Builder]
    FluentQuery -->|Executes| DB
    SQLTemplate -->|Executes| DB

    subgraph "Application Code"
      DB
      GenAPI
      FluentQuery
      SQLTemplate
    end

    classDef dbClass fill:#bbdefb,stroke:#1e88e5,stroke-width:2px
    class DB dbClass

    classDef apiClass fill:#c8e6c9,stroke:#388e3c,stroke-width:2px
    class GenAPI,FluentQuery,SQLTemplate apiClass
```
