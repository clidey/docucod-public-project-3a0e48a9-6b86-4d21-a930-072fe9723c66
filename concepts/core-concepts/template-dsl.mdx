---
title: "SQL Template DSL"
description: "Master the concise DSL used in query interface templates: understand placeholder syntax (`@@table`, `@@column`, `@param`), conditional (`{{if}}`), iterative (`{{for}}`), and macro replacement patterns. Learn how this DSL grants both flexibility and type safety."
---

# SQL Template DSL

Master the concise domain-specific language (DSL) used within GORM CLI's query interface templates. This guide empowers you to write powerful, type-safe SQL queries by understanding and effectively applying placeholders, conditional logic, iteration, and macro replacement patterns available in interface method comments.

---

## Why Use the SQL Template DSL?

GORM CLI transforms annotated Go interfaces with embedded SQL templates into type-safe, fluent query methods. The DSL enables:

- **Placeholder binding** for safe and dynamic parameter insertion.
- **Conditional SQL fragments** to include or exclude clauses based on input.
- **Iteration** over collections to compose complex WHERE or SET clauses.
- **Macro replacement** for dynamic table and column names.

Together, these features provide flexible, maintainable query code generation while preserving compile-time safety.

---

## Core Placeholder Syntax

| Placeholder  | Description                                  | Example Usage                              |
|--------------|----------------------------------------------|--------------------------------------------|
| `@@table`    | Inserts the model's actual database table name | `SELECT * FROM @@table WHERE id=@id`      |
| `@@column`   | Inserts a dynamic column name bound to parameter | `WHERE @@column=@value`                     |
| `@param`     | Binds a Go method parameter (or struct field) as a SQL parameter | `WHERE name=@user.Name`                     |

### Details

- **`@@table`** resolves to the underlying table name defined by the model struct, ensuring you don't hardcode table names.
- **`@@column`** lets you create dynamic column filters or updates by passing a column name parameter.
- **`@param`** corresponds to method parameters or fields; the generator maps these parameters safely into the query to prevent SQL injection.


### Example

```sql
-- Annotated in Go interface comment
SELECT * FROM @@table WHERE id=@id AND status=@status
```

This will generate a parameterized query that binds the `id` and `status` inputs safely.

---

## Conditional Blocks: `{{if}}`, `{{else if}}`, `{{else}}`, `{{end}}`

Conditional directives allow including SQL fragments only when certain conditions in method parameters or struct fields are met.

### Syntax

```go
{{if condition}}
  SQL fragment
{{else if condition}}
  SQL fragment
{{else}}
  SQL fragment
{{end}}
```

- Conditions support any valid Go boolean expression against input parameters.
- Supports multiple `else if` branches and an optional `else` fallback.


### Example

```sql
SELECT * FROM @@table
{{where}}
  {{if user.ID > 0}}
    id=@user.ID
  {{else if user.Name != ""}}
    name=@user.Name
  {{end}}
{{end}}
```

This generates a WHERE clause filtered by either `ID` or `Name` depending on which parameter is set.

---

## Iteration Blocks: `{{for}}` ... `{{end}}`

Allows looping over collections passed as method parameters (e.g., slices) to build repeated SQL conditions.

### Syntax

```go
{{for _, item := range collection}}
  SQL fragment using @item.Field
{{end}}
```

The iteration variable (`item`) lets you access fields within each element.


### Example

```sql
SELECT * FROM @@table
{{where}}
  {{for _, tag := range tags}}
    {{if tag != ""}} tags LIKE concat('%',@tag,'%') OR {{end}}
  {{end}}
{{end}}
```

This builds a WHERE clause with multiple OR conditions for each non-empty tag.

---

## Clause Directives: `{{where}}` and `{{set}}`

These specialized blocks help generate syntactically correct SQL **WHERE** and **SET** clauses, handling necessary trimming and formatting.

### `{{where}}`

- Wraps conditions inside a valid `WHERE` clause.
- Automatically trims leading/trailing `AND` or `OR` connectors.

### `{{set}}`

- Wraps expressions inside `SET` clause for `UPDATE` statements.
- Removes trailing commas and excess whitespace.

### Example

```sql
UPDATE @@table
{{set}}
  {{if user.Name != ""}} name=@user.Name, {{end}}
  {{if user.Age > 0}} age=@user.Age, {{end}}
{{end}}
WHERE id=@id
```

This generates an `UPDATE` statement with only the set fields that have non-zero values.

---

## Combining DSL Features: Realistic Example

```sql
-- Retrieve records filtered by multiple dynamic criteria
SELECT * FROM @@table
{{where}}
  {{if user.Name != ""}} name=@user.Name {{end}}
  {{if user.Age > 0}} AND age=@user.Age {{end}}
  {{for _, tag := range tags}}
    {{if tag != ""}} OR tags LIKE concat('%',@tag,'%') {{end}}
  {{end}}
{{end}}
```

This template uses `@@table`, conditional `if`s, and iteration via `for` for flexible searching.

---

## Key Usage Notes

- Placeholders like `@@table` and `@@column` must be accompanied by the correct method parameters.
- Use escaped `\@` to include literal '@' characters in SQL, preventing them from being interpreted as parameters.
- Conditions are evaluated as strict Go expressions — leverage Go syntax and types.
- Always close blocks with their corresponding `{{end}}`. Unclosed or mismatched blocks cause generation errors.

---

## Step-by-Step: Defining a Template Query Method

<Steps>
<Step title="Write the Go interface method">
Declare the method with parameters and expected return type.
Example:

```go
type Query[T any] interface {
  // SELECT * FROM @@table WHERE id=@id
  GetByID(id int) (T, error)
}
```
</Step>
<Step title="Add the SQL template comment">
Write the corresponding SQL & DSL in the method comment.

Use placeholders and directives as needed:

```sql
// SELECT * FROM @@table WHERE id=@id
```
</Step>
<Step title="Generate code">
Run the GORM CLI generator pointing to your interface:

```bash
gorm gen -i ./path/to/interfaces -o ./generated
```
</Step>
<Step title="Use the generated API">
Call your type-safe method in Go with parameters:

```go
user, err := generated.Query[User](db).GetByID(ctx, 123)
```

The generated code safely binds parameters and executes the query.
</Step>
</Steps>

---

## Common Pitfalls & Troubleshooting

<AccordionGroup title="Troubleshooting SQL Template DSL Issues">
<Accordion title="Unclosed or mismatched {{if}}/{{for}} blocks">
Always ensure every `{{if}}` or `{{for}}` is properly closed with `{{end}}`. The generator will error if blocks are unbalanced.
</Accordion>
<Accordion title="Parameters not recognized or bound">
Verify the parameter referenced (e.g., `@user.Name`) matches a method parameter or struct field exactly.

Use the fully qualified name as defined in your Go interface to avoid mismatch.
</Accordion>
<Accordion title="Literal '@' characters in SQL">
If you want a literal '@' inside your SQL (not a parameter), escape it with a backslash: `\@name`.
This prevents it from being treated as a placeholder.
</Accordion>
<Accordion title="Incorrect use of @@table or @@column placeholders">
`@@table` and `@@column` are replaced with database-safe table or column names.
They cannot be used arbitrarily; ensure your models and interfaces define these correctly.
</Accordion>
<Accordion title="Logic errors in conditional expressions">
DSL conditions use Go syntax. For example, string comparison needs `!= ""` (empty string).
Avoid type mismatches or unsupported expressions.
</Accordion>
</AccordionGroup>

---

## Summary Table of Supported DSL Constructs

| Directive     | Purpose                         | Description                                  |
|---------------|---------------------------------|----------------------------------------------|
| `@@table`     | Table name macro                | Inserts the model’s table name                |
| `@@column`    | Column name macro               | Inserts a dynamic column name parameter       |
| `@param`      | SQL parameter placeholder       | Binds method arguments to query parameters   |
| `{{if}}`      | Conditional block                | Includes SQL fragment if Go expression true   |
| `{{else if}}` | Else-if conditional             | Alternative conditional branch                 |
| `{{else}}`    | Else conditional                | Fallback conditional branch                    |
| `{{for}}`     | Loop over collection            | Iterates over slices or arrays                 |
| `{{where}}`   | Conditional WHERE clause wrapper | Generates WHERE clause if inner conditions apply |
| `{{set}}`     | Conditional SET clause wrapper   | Generates SET clause for UPDATE dynamically    |
| `{{end}}`     | Block end                      | Closes conditional, loop, where, or set blocks|

---

## Elegant DSL enables Flexible, Safe Queries

By mastering this DSL, you can express complex, dynamic SQL queries concisely and with tight compiler integration. It shields you from crafting error-prone string concatenations, while delivering expressiveness to cover common and advanced querying needs.

---

## Related Resources

- [Query Interfaces & SQL Templates](https://gorm.io/docs/concepts#query-interfaces)
- [Using the Generated APIs in Real Projects](https://gorm.io/docs/guides/core-workflows/using-generated-apis.html)
- [Customizing Generation with genconfig.Config](https://gorm.io/docs/guides/advanced-features-patterns/customizing-generation-config.html)
- [Troubleshooting & Validation](https://gorm.io/docs/getting-started/troubleshooting-validation/validate-setup.html)

---

## Frequently Referenced Example

```go
// Example interface with embedded SQL template
// Selects users conditionally by ID or Name
//
// SELECT * FROM @@table
// {{where}}
//   {{if user.ID > 0}}
//     id=@user.ID
//   {{else if user.Name != ""}}
//     name=@user.Name
//   {{end}}
// {{end}}
QueryWith(user models.User) (T, error)
```

The generator parses this template, applies the substitutions, and emits safe, runnable query methods ready to use.
