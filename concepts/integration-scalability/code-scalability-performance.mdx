---
title: "Scalability & Performance Considerations"
description: "Learn core best practices for using generated helpers and queries in high-throughput or growing projects. Examine compile-time efficiencies, potential bottlenecks in large codebases, and strategies for keeping generated code maintainable as models and interfaces evolve."
---

# Scalability & Performance Considerations

Efficient and maintainable generated code is essential as your project scales and handles increased load. This guide focuses on practical best practices and strategies to maximize the performance and manageability of GORM CLI-generated helpers and query APIs in growing or high-throughput Go projects using GORM.

---

## 1. Understanding Compile-Time Efficiency

GORM CLI’s core value lies in generating **type-safe, fluent, and discoverable query and field helper APIs**. This maximizes compile-time assurance and reduces runtime surprises, but as codebases grow, keeping compile times manageable requires attention.

- **Generated Files Are Auto-Partitioned by Input Files:** GORM CLI preserves the source directory structure when generating code, generating one output file per input Go file. This prevents a single large output file from slowing builds.

- **Incremental Regeneration:** Modify only query interfaces or model structs relevant to your change before regenerating, limiting code churn and avoiding unnecessary recompilation.

- **Selective Generation via Configuration:** Use the `genconfig.Config` options:
  - `IncludeInterfaces` and `ExcludeInterfaces` to target or skip specific query interfaces.
  - `IncludeStructs` and `ExcludeStructs` to control which models and associated helpers are generated.
  This drastically reduces output size and compile dependencies in large projects.

> **Tip:** Use selective generation during development iterations to speed up compile cycles when working on isolated modules.

---

## 2. Managing Large Codebases and Generated Output

As the number of models and query interfaces grows, generated files can expand both in number and length. Maintaining clarity and minimizing compilation overhead requires organizational best practices.

- **Organize your model structs and query interfaces logically:** Keep related models and interfaces in the same package or directory to optimize package-level generation and imports.

- **Use File-Level Configuration Scoping:** Set `FileLevel: true` in `genconfig.Config` to apply configuration such as filtering or custom field mappings only to individual files instead of the entire package, granting fine-grained control.

- **Modularize Your Project:** Split large domain models or services into smaller packages. This benefits GORM CLI's generation scope and your codebase’s compilation and dependency graph.

- **Monitor Generated File Sizes:** The output files for interfaces include both the generated query method implementations and the accompanying field helpers. If a single input file includes many interfaces or models, consider splitting it into smaller files.

- **Avoid Excessive Use of Wildcard Filters:** Broad `Include*` patterns may lead to unintended growth. Instead, prefer explicit or narrowly defined interface and struct names.

---

## 3. Performance Considerations During Runtime

Generated code enables type-safe query construction and execution but does not change the underlying database interaction performance directly. Still, efficient usage patterns reduce overhead.

- **Reuse Query Builders:** Generated query API calls return chainable builder interfaces (`e.g. Query[T]Interface[T]`), allowing you to append conditions, limits, and orders dynamically before execution with minimal overhead.

- **Minimize Repeated Generation at Runtime:** Avoid regenerating field helper references or query interfaces inside hot loops. Instantiate query interfaces once per request or service rather than repeatedly.

- **Leverage Field Helpers for Predicate Optimization:** Use field helpers’ predicate builders (e.g., `.Eq()`, `.Like()`, `.Between()`) to build expressive but concise filters, avoiding hand-written or raw SQL concatenations that risk injection or inefficiencies.

- **Batch Updates and Inserts:** Use `.CreateInBatch()` association helpers and batch updates when handling multiple entities to reduce round trips and improve transaction performance.

- **Profile Database Queries:** Always profile your SQL generated by field and query helpers to ensure indexes and joins are optimized by your database engine.


---

## 4. Best Practices for Maintaining Maintainable Generated Code

Generated sources become part of your repository and code review process. Applying best practices keeps them sustainable.

- **Separate Generated Code:** Use the default or configured output directory (e.g., `./g` or configured `OutPath`) to isolate generated code, so your tooling ignores or treats it differently if needed.

- **Automate Generation in CI/CD:** Integrate `gorm gen` in your build pipeline to ensure generated sources are always up to date.

- **Review Generated Code Regularly:** Occasionally review generated code for unexpected growth or regressions, especially after changes to query interfaces or model structs.

- **Use Descriptive Interface and Method Names:** Clear naming in your query interfaces helps generate intuitive method names that together with field helpers improve code discoverability.

- **Leverage Configuration to Customize:** Use mapping and filtering options in `genconfig.Config` to tailor the output exactly to your project’s evolving needs, minimizing clutter.

- **Document Non-Standard Field Helpers:** If you introduce custom field helpers (e.g., JSON), ensure team members understand how to use them for consistent queries and updates.

---

## 5. Common Pitfalls and How to Avoid Them

- **Generating all interfaces and structs indiscriminately:** This leads to heavy outputs and longer compile times. Instead, use `Include*`/`Exclude*` lists.

- **Mixing unrelated interfaces/models in the same file:** Leads to monolithic output files. Split logically.

- **Overusing complex template SQL in interfaces:** Complex templates may slow generation and complicate debugging. Favor simpler templates or helper methods.

- **Assuming generated code caches SQL:** GORM CLI generates type-safe methods but GORM itself may recompile some internal query plans. Use prepared statements or GORM-specific optimizations as needed.

- **Ignoring error handling in generated API usage:** Always check errors from generated methods; silent failures can obscure performance issues or bugs.

- **Overriding field helper mappings carelessly:** Mapping field types incorrectly can produce wrong query semantics.

---

## 6. Example: Using Configuration to Control Growth

```go
package example

import "gorm.io/cli/gorm/genconfig"

var _ = genconfig.Config{
  OutPath: "examples/output",          // Redirect generated files
  FileLevel: false,                   // Apply filters at package level

  IncludeInterfaces: []any{"Query*"}, // Only generate interfaces starting with "Query"
  ExcludeStructs: []any{"*DTO"},    // Exclude DTO structs (e.g., projections)
  
  FieldNameMap: map[string]any{
    "json": JSON{},                  // Use custom JSON helper for "json" fields
  },
}
```

This keeps output scoped, skips unwanted model helpers, and maps field helpers for specialized use.

---

## 7. Visualizing the Scalability Workflow

```mermaid
flowchart TD

  subgraph Generation_and_Compilation
    UserWrites["User writes interfaces and models"] --> GORMCLI["GORM CLI Generator runs (gorm gen)"]
    GORMCLI --> GeneratedCode["Generates Query APIs + Field Helpers"]
    GeneratedCode --> GoBuild["Go Compiler compiles generated files + user code"]
  end

  subgraph Runtime
    GoApp["Go application at runtime"] --> GeneratedAPIs["Uses generated query APIs and helpers"]
    GeneratedAPIs --> DB["Database executes SQL queries"]
  end

  GORMCLI -. Filters with genconfig.Config .-> GeneratedCode
  UserWrites -. Organizes files, interfaces, models .-> GORMCLI

  style Generation_and_Compilation fill:#e3f6f5,stroke:#008080,stroke-width:2px
  style Runtime fill:#f3f0f0,stroke:#800000,stroke-width:2px

```

This flowchart highlights how generation scope and organization impact compile-time and runtime efficiency.

---

## 8. Troubleshooting Tips

- **Slow builds after generation:** Audit your `genconfig.Config` filters to limit generated interfaces and structs.

- **Unexpected missing generated methods or helpers:** Check inclusion and exclusion patterns, and verify file-level `FileLevel` setting.

- **Generated files not updated after changes:** Ensure regeneration command runs in correct directory with right `-i` (input) and `-o` (output) flags.

- **Confusing method signatures or missing context parameter:** Remember the generator auto-injects `context.Context` if absent; review interface method captures.

- **Excessive imports or unused helper code:** Consider code cleanup and reorganizing your interface/models to minimize unnecessary imports.

---

By following these guidelines and practices, you will maintain high-performance, scalable, and maintainable code generated by GORM CLI that supports your project’s growth.

For continuous mastery, examine related guides on [generation configuration](https://gorm.io/cli/guides/advanced-usage/generation-configuration), [core concepts](https://gorm.io/cli/concepts/architecture-core-principles/query-api-concept), and [integration patterns](https://gorm.io/cli/concepts/integration-scalability/gorm-integration-patterns).