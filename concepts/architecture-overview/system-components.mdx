---
title: "Core System Components"
description: "Gain an overview of the main components that power GORM CLI, including the CLI entrypoint, the generators, template engine, and configuration hooks. Learn how user interfaces, models, and configuration converge to drive the code generation lifecycle."
---

# Core System Components

Gain a comprehensive understanding of the fundamental building blocks that power GORM CLI. This guide unpacks the main components—including the CLI entrypoint, code generators, the template engine, and configuration hooks—and illustrates how user interfaces, model definitions, and configuration settings converge to orchestrate the entire code generation lifecycle.

---

## 1. The CLI Entrypoint

The journey begins with the GORM CLI executable, the primary entrypoint that developers invoke to kick off code generation. When you run the CLI command, it:

- Parses input Go source files or directories containing model structs and query interfaces.
- Applies the user’s configuration settings to filter which interfaces and structs to process.
- Orchestrates the generation pipeline that creates strongly-typed query APIs and field helpers.

This entrypoint is designed for simplicity and efficiency, abstracting the underlying complexity and delivering a smooth developer experience.

### User Flow Example

```bash
gorm gen --path ./models --out ./generated
```

- User specifies input path and output directory.
- CLI loads source files.
- Configurations are discovered and applied.
- Code is generated and saved.


---

## 2. Code Generators: Interfaces and Models

Code generation in GORM CLI pivots around two primary artifacts extracted from the source code:

### 2.1 Interface Generators

- **What:** The CLI extracts Go interface types annotated with SQL templates in comments.
- **Purpose:** From these, GORM CLI generates **type-safe query APIs** — methods that enable fluent, compile-time-checked database queries.
- **How it works:**
  - It parses method signatures and embedded SQL in interface comments.
  - Translates SQL template directives into Go code that interacts with GORM.
  - Generates method bodies supporting query building, execution, and result mapping.

### 2.2 Model Generators

- **What:** Structs representing database models with their fields and tags.
- **Purpose:** From these models, the CLI creates **field helpers**—strongly typed constructs representing columns.
- **How it works:**
  - It inspects struct fields, including embedded anonymous structs.
  - Maps Go types and tags to field helper types.
  - Supports customization via configuration mappings for custom types (e.g., JSON, sql.NullTime).

### Practical Value

Generated APIs and helpers dramatically reduce manual boilerplate, prevent runtime errors, and boost developer productivity while preserving GORM’s flexibility.

---

## 3. Template Engine

At the heart of the CLI’s query API generation lies the **SQL template engine**, which interprets SQL embedded as Go interface method comments.

### Core Features

- Processes directives like `@@table`, `@@column` for table and column substitutions.
- Supports control flow constructs such as `{{if}}`, `{{else}}`, `{{for}}` to build dynamic SQL.
- Enables expression of complex predicates, conditional updates, batch operations, and more.

### How This Benefits Users

- Allows writing declarative SQL patterns close to the model structure.
- Integrates seamlessly with Go’s type system making queries fluent and safe.
- Users need not write raw SQL in application code; instead, they define interfaces with embedded templates.

---

## 4. Configuration Hooks

GORM CLI’s behavior is highly customizable via **configuration hooks** declared as global vars of type `genconfig.Config`.

### Key Configuration Areas

- **Inclusion/Exclusion Filters:** Scope which interfaces and structs are processed by name patterns or specific types.
- **Output Directories:** Customize where generated code files are placed, supporting monorepos and package flexibility.
- **Field Mapping:** Map Go or SQL types to specific field helper implementations or custom types.
- **File-Level vs Directory-Level Scoping:** Control configuration inheritance across directory trees for granular setup.

### Example Configuration (Pattern Filter)
```go
package pattern

import "gorm.io/cli/gorm/genconfig"

// Include only interfaces whose names start with "Query"
var _ = genconfig.Config{
	IncludeInterfaces: []any{"Query*"},
}
```

### Configuration Application Flow

- The CLI detects `genconfig.Config` declarations across input files.
- Applies configuration filters and mappings progressively based on directory structure and file.
- Enables combining multiple configs for nuanced generation criteria.

---

## 5. Convergence of Components: The Code Generation Lifecycle

The lifecycle merges these components into a coherent process:

1. **Input collection:** CLI reads Go files, discovering interfaces and models.
2. **Config processing:** Filters and settings are applied from config hooks.
3. **AST analysis:** Extract interfaces, struct fields, embedded structs, and tagging.
4. **Template rendering:** SQL templates in interface methods are parsed and compiled.
5. **Code emission:** Generates Go source files containing type-safe query methods and field helpers.
6. **Output organisation:** Writes output respecting configured directories and package paths.

This entire flow enables developers to focus on their domain logic and data modeling while the CLI produces optimized, safe, and maintainable data access code.

---

## 6. Troubleshooting Common Challenges

### Missing Generated Methods or Types
- Verify inclusion/exclusion filters in config to ensure your interfaces and structs are selected.
- Make sure model types are exported and properly tagged where needed.

### Unexpected Output Location
- Check the `OutPath` setting in your configuration hooks.
- Inspect directory-level configurations for overrides.

### SQL Template Parsing Errors
- Ensure clean and properly indented interface method comments.
- Use supported template directives exactly as documented.

### Type Mismatches in Generated Helpers
- Confirm FieldTypeMap and FieldNameMap are correctly mapping your custom types.
- Use supported Go versions (1.18+) and updated GORM versions.

---

## 7. How This Page Fits Into the Larger Documentation

This Concepts guide complements detailed practical and configuration documentation:

- For hands-on generation examples, see **Your First Code Generation** and **Using the Generated APIs** guides.
- To understand the overall system architecture and data flow, consult the **System Architecture (with Diagram)** page.
- For deep dives into configuration options, refer to **Advanced Generation Settings** and **Customizing Generation with Config**.

Together, these documents empower you to master GORM CLI’s capabilities from foundational understanding to advanced customization.

---

## Diagram: High-Level Component Interaction

```mermaid
flowchart TD

  CLI["GORM CLI Entrypoint"] -->|Processes| SourceFiles["Go Source Files (Models, Interfaces)"]

  SourceFiles --> Parser["AST Parser & Analyzer"]
  Parser --> ConfigLoader["Configuration Loader & Filter"]

  ConfigLoader --> Generator["Code Generator"]
  Generator --> TemplateEngine["SQL Template Engine"]
  TemplateEngine --> Generator

  Generator --> Output["Generated Go Code"]

  Output --> Developer["Go Projects / Developers"]

  subgraph Config
    ConfigLoader
  end

  subgraph Core
    Parser
    Generator
    TemplateEngine
  end

  classDef entrypoint fill:#1E90FF,stroke:#000,color:#fff;
  class CLI entrypoint;

  classDef component fill:#90EE90,stroke:#000,color:#000;
  class Parser,ConfigLoader,Generator,TemplateEngine component;

  classDef output fill:#FFD700,stroke:#000,color:#000;
  class Output output;

  class Developer fill:#FFA07A,stroke:#000,color:#000;
```

---

## Additional Learning Resources

- [Your First Code Generation](https://gorm.io/concepts/guides/getting-started/your-first-generation)
- [Understanding the Code Generation Workflow](https://gorm.io/concepts/guides/getting-started/understanding-the-workflow)
- [Advanced Configuration Settings](https://gorm.io/concepts/getting-started/first-run-configuration/advanced-configuration)
- [Mastering the SQL Template DSL](https://gorm.io/concepts/guides/real-world-examples/template-sql-dsl)

---

By mastering these core components, you unlock the full power of GORM CLI, enabling faster development, safer queries, and highly customizable code generation tailored to your project's needs.
