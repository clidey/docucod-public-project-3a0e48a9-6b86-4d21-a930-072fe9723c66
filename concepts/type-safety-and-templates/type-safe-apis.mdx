---
title: "Type-Safe Query & Update APIs"
description: "Examine GORM CLI's approach to combining Go interfaces, method signatures, and generics to generate type-safe builders. Learn how compile-time checking extends to custom queries, filters, and even association operations."
---

# Type-Safe Query & Update APIs

Explore how GORM CLI leverages Go interfaces, generic types, and method annotations to generate powerful, type-safe query and update builders. This approach guarantees compile-time validation of custom queries, filters, and association operations, ensuring safe and efficient database access.

---

## Introduction

GORM CLI transforms user-defined Go interfaces annotated with SQL templates into fluent, type-safe APIs for querying and updating databases. By combining Go generics with method signatures, the generated code enforces correctness at compile time while providing a discoverable and readable API surface.

This page focuses exclusively on this facet: how GORM CLI processes query interfaces and generates type-safe builder APIs that incorporate custom SQL templates, conditional filters, and association-aware updates.

---

## Defining Query Interfaces with SQL Templates

At the heart of type-safe API generation are Go interfaces with generic type parameters describing the target model.

### How It Works

- **Generic Interfaces:** Users declare interfaces like `Query[T any]` where `T` represents the model struct.
- **Method Signatures:** Methods define the input parameters and the expected result types, typically returning `T`, slices of `T`, or errors.
- **Embedded SQL Templates:** Each method includes a comment block with annotated SQL or template DSL, specifying the underlying query or update semantics.

Example:

```go
// Query interface with generic type parameter T
// SQL comments define the query template

type Query[T any] interface {
  // SELECT * FROM @@table WHERE id=@id AND name = "@name"
  GetByID(id int) (T, error)

  // SELECT * FROM @@table WHERE @@column=@value
  FilterWithColumn(column string, value string) (T, error)

  // UPDATE @@table
  // {{set}}
  //   {{if user.Name != ""}} name=@user.Name, {{end}}
  //   {{if user.Age > 0}} age=@user.Age, {{end}}
  //   {{if user.Age >= 18}} is_adult=1 {{else}} is_adult=0 {{end}}
  // {{end}}
  // WHERE id=@id
  UpdateInfo(user models.User, id int) error
}
```

### Template DSL Highlights

- `@@table`: Resolves to the database table name for the model.
- `@@column`: Placeholder for dynamic column names.
- `@param`: Binds Go method parameters to SQL parameters.
- `{{where}}...{{end}}`, `{{set}}...{{end}}`: Conditional clauses that render only if conditions match.
- `{{if}}`, `{{for}}`: Control structures for dynamic SQL generation.

---

## Generated API Surface

From these interfaces, GORM CLI produces concrete implementations equipped with:

- **Compile-Time Checked Queries:** The generated methods accept strongly typed parameters matching the interface signature.
- **Fluent Builders:** Methods return interfaces or concrete types enabling method chaining and further query refinement.
- **Automatic Context Injection:** If `context.Context` is missing in method signatures, it is automatically prepended for async-safe calls.

### Example Usage of Generated APIs

```go
// Fetch a single user by id
user, err := generated.Query[User](db).GetByID(ctx, 123)

// Filter users by name and age
users, err := generated.Query[User](db).
  FilterByNameAndAge("jinzhu", 25).
  Find(ctx)

// Update user information
err := generated.Query[User](db).
  UpdateInfo(ctx, User{Name: "jinzhu", Age: 20}, 1)
```

In each case, parameters and return values are statically checked, preventing runtime SQL errors and type mismatches.

---

## Advanced Query Construction

The template-based DSL permits the construction of dynamic, conditional SQL statements that adapt depending on parameter values.

### Conditional WHERE Clauses

Using `{{where}}` combined with `{{if}}` and `{{for}}`, users define flexible filters that generate clauses only when needed.

Example:

```sql
SELECT * FROM @@table
{{where}}
  {{if !start.IsZero()}}
    created_at > @start
  {{end}}
  {{if !end.IsZero()}}
    AND created_at < @end
  {{end}}
{{end}}
```

This results in SQL only applying date filters if the corresponding Go `time.Time` values are set.

### Dynamic Updates with `{{set}}`

For update operations, the `{{set}}...{{end}}` block dynamically constructs the SET clause, including only fields with non-zero or non-empty values.

This allows partial updates without writing multiple methods or manual SQL string concatenation.

---

## Internals of Method Generation

Each method corresponds to Go code generated by parsing the SQL templates:

- **SQL Template Parsing:** Templates are rendered into SQL snippets with parameter placeholders.
- **Parameter Binding:** Method parameters map directly to SQL parameters, preserving safety and correctness.
- **Return Types:** Methods returning data produce code that executes `Raw` queries and scans into model structs.
- **Chaining Support:** Methods that represent incremental filters chain calls like `.Where()` or `.Select()` returning the interface for further refinement.

Users don’t need to manage the internal details; they interact only with the generated fluent API.

---

## Benefits of This Approach

- **Compile-Time Safety:** Type errors in queries surface during compilation rather than at runtime.
- **Less Boilerplate:** Developers write concise interfaces instead of verbose repository code.
- **Dynamic Yet Type-Safe:** Complex SQL with conditional logic is expressible without sacrificing static verification.
- **Custom Queries & Updates:** Beyond basic CRUD, sophisticated filters and update logic are expressible via templates.

---

## Common User Workflow

1. **Define Generic Interfaces:** Declare interfaces with SQL annotation comments representing queries.
2. **Generate Code:** Run `gorm gen -i ./path/to/interfaces -o ./generated` to produce typed implementations.
3. **Use Generated APIs:** Import the generated package and consume fluent, type-safe query/update methods.
4. **Iterate & Extend:** Modify interfaces to add more methods or sophisticated SQL templates as needed.

---

## Troubleshooting and Tips

- **Ensure Proper SQL Annotation:** Each method must have valid SQL or template DSL in its doc comments to generate code.
- **Return Value Rules:** Methods that execute queries must return a data type and an `error`; update methods return `error` only.
- **Context Parameter:** If your interface methods lack a `context.Context` parameter, the generator automatically inserts it.
- **Test Templates Early:** Use unit tests or sample generation runs to verify template expansions and resulting SQL.
- **Naming Conventions:** Follow consistent naming for interfaces and methods to leverage include/exclude filters in config.

---

## Diagram: Generating Type-Safe APIs from Interfaces

```mermaid
flowchart TD

  subgraph UserCode[User-Defined Code]
    QueryInterface["Generic interface Query[T any] with SQL templates"]
  end

  subgraph CodeGenerator["GORM CLI Code Generator"]
    ParseAST["Parse Go source & extract interfaces"]
    ApplyConfig["Apply genconfig.Config filters & mappings"]
    RenderTemplates["Process SQL template comments"]
    GenerateCode["Generate type-safe API implementations"]
  end

  subgraph GeneratedCode[Generated Output]
    API[
      "Type-safe Query & Update API Methods\n- Methods: GetByID, FilterByNameAndAge, UpdateInfo, etc."
    ]
  end

  QueryInterface --> ParseAST --> ApplyConfig --> RenderTemplates --> GenerateCode --> API

  API -->|imported by user| UserApp["User app code · Use fluent APIs"]

  %% Styling
  classDef user fill:#ddf, stroke:#00f, stroke-width:2px
  classDef gen fill:#ffd, stroke:#fa0, stroke-width:2px
  classDef output fill:#dfd, stroke:#080, stroke-width:2px

  class UserCode user
  class CodeGenerator gen
  class GeneratedCode output
```

---

## Summary

GORM CLI's type-safe query and update API generation empowers Go developers to define expressive, strongly typed data access methods via generic interfaces and annotated SQL templates. This approach moves runtime errors into the compile phase while offering flexibility through conditional templating.

For mastering this feature, focus on learning the template DSL syntax, crafting well-typed interfaces, and iteratively generating code to suit your application's querying and updating needs.

---

## See Also

- [SQL Template DSL & Parameter Binding](/concepts/type-safety-and-templates/sql-template-dsl) — Learn the full syntax of GORM CLI's templating language.
- [Model-Driven Field Helpers](/guides/getting-started/model-driven-field-helpers) — Understand how model structs generate useful field predicate helpers for queries.
- [Managing Associations](/guides/real-world-usage-patterns/working-with-associations) — See how association updates are type-safe and supported.
- [Generation Configuration](/concepts/configuration-and-customization/generation-configuration) — Customize code generation via config files.

---

## Helpful Tips

- Always keep your query interfaces minimal but descriptive — one method, one responsibility.
- Leverage the `{{where}}` and `{{set}}` DSL constructs to make queries dynamic and safe.
- Use explicit return signatures with error as the last parameter for clarity.
- Run `gorm gen` after interface updates to regenerate API code.
- Review generated code to verify output matches intent and optimize queries if needed.

---

## References

- Source code location: See [`internal/gen/gen.go`](https://github.com/go-gorm/cli/blob/main/internal/gen/gen.go) for command and generation config.
- Example queries with templates: [`examples/query.go`](https://github.com/go-gorm/cli/blob/main/examples/query.go)
- SQL template test coverage: [`internal/gen/sqlparser_test.go`](https://github.com/go-gorm/cli/blob/main/internal/gen/sqlparser_test.go)



