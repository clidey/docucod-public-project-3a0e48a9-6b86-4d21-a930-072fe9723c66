---
title: "Model-Driven Field Helpers"
description: "Learn how GORM CLI analyzes struct fields to generate field helpers for filters, updates, and associations. This page introduces the supported types, handling for custom mappings, and how the result supports expressive query-building in application code."
---

# Model-Driven Field Helpers

GORM CLI transforms your Go model structs into powerful, type-safe field helpers that dramatically simplify building queries, updates, and association operations with GORM. This page guides you through how GORM CLI analyzes struct fields to generate these helpers, the supported field types, handling of custom mappings, and how you can leverage the results to write expressive, maintainable, and safe database interactions.

---

## Understanding Field Helpers

Field helpers in GORM CLI represent your model's struct fields as strongly typed, compile-time checked constructs. They wrap basic fields like integers, strings, and booleans with helper types that provide expressive predicate constructors, setter methods, and association operations for relation fields.

These helpers turn what used to be error-prone string column names and raw SQL fragments into discoverable, fluent API calls that integrate seamlessly with GORM's query builder.

### Why Use Model-Driven Field Helpers?
- **Type Safety**: Avoid typos in column names and mismatched types.
- **Discoverability**: Intellisense/autocomplete assists in writing queries.
- **Expressiveness**: Quickly build predicates for filters, updates, and association operations.
- **Maintainability**: Changes in model fields automatically reflect in generated helpers.

---

## Supported Field Types

GORM CLI intelligently generates field helpers for a wide range of Go types based on field definitions in your structs. It supports:

### Basic Field Types
- Primitive types such as `int`, `float64`, `string`, `bool`.
- `time.Time` and other common time types.
- `[]byte` for binary data.
- Named types implementing accepted interfaces such as:
  - `database/sql.Scanner`
  - `database/sql/driver.Valuer`
  - `gorm.io/gorm.Valuer`
  - `gorm.io/gorm/schema.SerializerInterface`

These fields map to concrete helper types such as `field.Number[int]`, `field.String`, `field.Bool`, and `field.Time`, which expose common predicates like `.Eq(value)`, `.Like(pattern)`, `.Between(low, high)`, `.IsNull()`, and update helpers like `.Set(value)`, `.Incr(amount)`.

### Association Fields
GORM CLI detects association fields (belonging to relations like has one, has many, belongs to, many-to-many) and creates specialized helpers:
- `field.Struct[T]` for single-entity associations (e.g., `Account` or `Company`)
- `field.Slice[T]` for multi-entity associations (e.g., slices like `Pets []*Pet` or `Languages []Language`)

These association helpers provide rich semantics for creating, updating, unlinking, and deleting related records safely and idiomatically.

### Custom Field Helpers
You can define and map custom field helpers for special use cases such as JSON columns or specialized serialization. Use configuration to instruct the generator to produce these custom helpers:

```go
var _ = genconfig.Config{
    FieldNameMap: map[string]any{
        "json": JSON{}, // fields tagged `gen:"json"` get this helper
    },
}
```

This mechanism lets you tailor behavior when default basic types aren’t enough, like generating JSON-aware predicates optimized per database dialect.

---

## How GORM CLI Generates Field Helpers

1. **Parsing your model structs**: The CLI inspects your Go structs recursively, including embedded structs, generating a unified list of fields.
2. **Determining field types**: For each field, it matches the Go type against supported types or configured mappings.
3. **Naming columns**: It derives the database column name using GORM naming conventions or explicit `gorm:"column"` tags.
4. **Creating field values**: It generates a helper instance for each field exposing methods for building filters and updates.

This process is automatic and respects configuration overrides for included/excluded structs or fields.

---

## Generated Field Helpers in Practice

Here’s an example model and how its generated field helpers appear in code:

```go
// Example model struct
package models

type User struct {
    ID        uint
    Name      string
    Age       int
    Score     sql.NullInt64
    Profile   string `gen:"json"`
}
```

Generated helpers:

```go
var User = struct {
    ID      field.Number[uint]
    Name    field.String
    Age     field.Number[int]
    Score   field.Field[sql.NullInt64]
    Profile examples.JSON // Custom JSON helper
}{
    ID:      field.Number[uint]{}.WithColumn("id"),
    Name:    field.String{}.WithColumn("name"),
    Age:     field.Number[int]{}.WithColumn("age"),
    Score:   field.Field[sql.NullInt64]{}.WithColumn("score"),
    Profile: examples.JSON{}.WithColumn("profile"),
}
```

This enables queries like:

```go
// Find users older than 20
result, err := gorm.G[User](db).Where(User.Age.Gt(20)).Find(ctx)

// Update score and mark profile as JSON flag
gorm.G[User](db).
    Where(User.ID.Eq(1)).
    Set(
        User.Score.Set(sql.NullInt64{Int64: 100, Valid: true}),
        User.Profile.Equal("$.vip", true),
    ).
    Update(ctx)
```

---

## Handling Associations

Association fields become helpers of type `field.Struct[T]` or `field.Slice[T]` that provide methods for relational operations:

- **Create:** Create and link one or more related records.
- **Update:** Update related records based on conditions.
- **Unlink:** Remove association links without deleting records.
- **Delete:** Delete associated records or join table rows.
- **CreateInBatch:** Batch create and link multiple records.

For example, a user with pets: 

```go
gorm.G[User](db).
    Set(
        User.Name.Set("alice"),
        User.Pets.Create(generated.Pet.Name.Set("fido")),
    ).
    Create(ctx)
```

These helpers wrap and enforce correct foreign key semantics based on the association type (belongs to, has many, many-to-many).

---

## Custom Mapping via Configuration

You can customize generation to map specific Go types or struct tags to particular field helpers to fine-tune query expressions:

```go
var _ = genconfig.Config{
    OutPath: "examples/output",
    FieldTypeMap: map[any]any{
        sql.NullTime{}: field.Time{}, // map sql.NullTime to time helper
    },
    FieldNameMap: map[string]any{
        "json": JSON{}, // map fields tagged gen:"json" to JSON helper
    },
}
```

This flexibility allows advanced users to integrate specialized helpers for columns like JSON, arrays, or domain-specific types.

---

## Best Practices and Tips

- **Keep your models clean:** Well-structured models with clear field typing help generate optimal helpers.
- **Use configuration for edge cases:** Customize only when default mappings don't meet your needs.
- **Leverage association helpers:** Avoid manual join logic by using generated association operations.
- **Validate generated code:** After generation, import and compile to confirm correctness.

---

## Troubleshooting Common Issues

<AccordionGroup title="Common Issues When Using Field Helpers">
<Accordion title="Field Helper Not Generated for New Field">
Ensure your struct field is exported and the type is supported or correctly mapped in your configuration.
</Accordion>
<Accordion title="Column Name Does Not Match Database">
Use `gorm:"column:name"` tags on struct fields to explicitly specify the DB column name.
</Accordion>
<Accordion title="Custom Field Helper Not Working">
Verify that your custom helper type implements the necessary methods and is properly referenced in `FieldNameMap` or `FieldTypeMap`.
</Accordion>
<Accordion title="Association Operations Fail at Runtime">
Check that your association helpers correspond to the proper association type, and ensure foreign keys exist and are correctly configured in your database schema.
</Accordion>
</AccordionGroup>

---

## Summary

Model-driven field helpers created by GORM CLI enhance code expressivity, safety, and maintainability by generating typed, discoverable wrappers around your struct fields. They empower rich predicate building, safe updates, and powerful association management, all automatically aligned with your Go models and database schema.

By understanding supported types, leveraging custom mappings, and embracing generated helpers for associations, you unlock a significantly more productive and reliable ORM experience.

---

## Related Documentation

- [Using Generated Field Helpers](/guides/getting-started-workflows/using-field-helpers): Practical workflows and examples using generated helpers.
- [Supported Field Types and Predicates](/concepts/data-modeling/field-types-and-predicates): Deep dive into supported types and predicate functions.
- [Managing Associations and Relationships](/guides/advanced-usage-patterns/working-with-associations): Working effectively with generated association helpers.
- [Customizing Code Generation with Config](/concepts/extensibility-integration/generation-config): Configuration options for advanced customization.
- [Core Concepts & Terminology](/overview/concepts-architecture-flow/core-concepts-terminology): Foundational concepts contextualizing field helpers.

---

For your practical next steps, try running the generator on your models, inspect the generated field helpers, and explore writing queries and updates using these strongly typed constructs to harness full type safety and clarity in your ORM layer.